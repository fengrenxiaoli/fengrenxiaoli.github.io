<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据校验码]]></title>
    <url>%2Fpost%2Fa55639d7.html</url>
    <content type="text"><![CDATA[数据在计算机系统内形成、存取和传送过程中，可能会因为某种原因而产生错误，如将0误传为1等。为减少和避免这类错误，一方面需要从电路、电源、布线等硬件方面采取措施，提高计算机硬件本身的抗干扰能力和可靠性；另一方面可以在数据编码上采取检错纠错的措施，即采用某种编码方法，使得机器能够发现、定位乃至纠正错误。 具有检测某些错误或带有自动纠正错误能力的数据编码称为数据校验码。数据校验码的实现原理是在正常编码中加入一些冗余位，即在正常编码组中加入一些非法编码，当合法数据编码出现某些错误时，就成为非法编码，因此就可以通过检测编码是否合法来达到自动发现、定位乃至改正错误的目的。在数据校验码的设计中，需要根据编码的码距合理地安排非法编码的数量和编码规则。 错误纠正编码的现代发展在1947年由理查德·卫斯里·汉明带来，即海明码/汉明码。 海明距离：一组编码中任何两个编码之间代码不同的位数，换句话说，就是将一个编码变换成另外一个编码所需要替换的字符个数。（在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。 ————维基百科）码距：在一组编码中任何两个编码之间最小的距离 例如编码0011与0001，仅有一位不同，称其海明距离为1。如果采用四位二进制编码表示16种状态，因为从0000到1111这16种编码都用到了，所以这组编码的码距为1。也就是说，在这组编码中任何一个状态的四位码中的一位几位出错，都会变成另一个合法编码，所以这组编码没有查错和纠错能力。但是，如果采用四位二进制表示8个状态，例如只将其中的8种编码0000、0011、0101、0110、1001、1010、1100、1111用作合法编码，而将另外8种编码作为非法编码，此时这组编码的码距为2，即从一个合法编码改为另一个合法编码需要修改2位。如果在数据传输过程中，任何一个合法编码有一位发生了错误，就会出现非法编码。例如编码0000的任意一位发生错形成的编码都不是合法编码，因此系统只要检查编码的合法性，就可以发现错误。 校验码通常是在正常编码的基础上按特别规定增加一些附加的校验位形成的，即通过增大编码的码距来实现检查和纠正错误的目的。一般来说，合理地增加校验位、增大码距，就能提高校验码发现错误的能力。如上所述，要检查1位错误，编码的码距需要1+1=2。而要检查e位错，编码的码距需要e+1，因为对于这样的编码，一个码字e位出错就无法将一个合法编码变为另外一个合法编码。类似地，如果出错的位置能够确定，将出错位的内容取反，就能够自动纠正错误。而要纠正t位错，编码的码距需要2t+1。这是因为当码距达到2t+1时，即使合法编码中有t位出错，它与原合法编码的编码距离还是比与其他任何合法码字的编码距离要小，这样就可以惟一地确定它的合法编码，即可以自动纠正错误。 例如，考虑下面只有四个合法编码0000000000、0000011111、1111100000、1111111111的编码组。可以看出这个编码组的码距为5，意味着它能纠两位错。如果在数据传输过程中，接收方接收到一个编码0000000111，就能够知道原来的正确编码应0000011111（必须假定不出现两位以上的错误）。当然，如果错了3位，即0000000000变成了0000000111就无法确定0000000000出现了错误，还0000011111出现错误，因而无法纠正错误，即码距为5时，只能够纠两位错由此可见校验位越多，码距越大，编码的检错和纠错能力越强。设码距为d，码距与校验码的检错和纠错能力的关系是:d≥e+1，可检验e个错d≥2t+1，可纠正t个错d≥e+t+1，且e&gt;t，可检验e个错并能纠正t个错 由于数据校验码所使用的二进制位数比常数据编码要多，所以在使用过程中，将增加数据存储的容量或数据传送的数量。因此在确定与使用数据校验码的时候，必须考虑在不过多增加硬件开销的情况下，尽可能发现或改正更多的错误。常用的数据校验码有奇偶校验码、海明校验码和循环冗余校验码 奇偶校验码PCC奇偶校验码是一种最简单、最常用的校验码。奇偶校验码广泛用于主存的读写校验或 ASCII码字符传送过程中的检查。奇偶校验码的最小码距是2 组成奇偶校验码的基本方法是：在n位有效信息位上增加一个二进制位作为校验位P，构成n+1位的奇偶校验码。校验位P的位置可以在有效信息位的最高位之前，也可以在有效信息位的最低位之后。奇偶校验码可分为奇校验和偶校验 奇校验（Odd）：使n+1位的奇偶校验码中1的个数为奇数偶校验（Even）：使n+1位的奇偶校验码中1的个数为偶数 采用奇偶校验的编码在传输过程中需要进行奇偶校验，以判断信息传输是否出错，如果接收方接收到一奇校验码中1的个数为偶数，或接收到一偶校验码中1的个数为奇数，则表示接收到的编码中有一位出错 奇偶校验码只能发现一位或奇数位个错误，而无法现偶数位个错误，而且即使发现奇数位个错误也无法确定出错的位置，因而无法自动纠正错误。由于现代计算机可靠性比较高，出错概率很低，而出错时只有一位出错的概率比多位出错的概率高得多，因此用奇偶校验检测一位出错，能够满足一般可靠性的要求。在CPU与主存的信息传送过程中，奇偶校验被广泛应用。 海明校验码如前所述，合理地增加校验位、增大码距，能够提高校验码发现错误的能力。因此如果在奇偶校验的基础上，增加校验位的位数，构成多组奇偶校验，就能够发现更多位的错误并可自动纠正错误。这就是海明校验码的实质所在。 海明校验码是 Richard Hamming 于1950年提出来的。它的实现原理是:在数据编码中加入几个校验位，并把数据的每一个二进制位分配在几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验组的值发生变化，这样不但可以发现出错，还能指出是哪一位出错，为自动纠错提供了依据。那么海明校验码究竟应该设置多少个校验位呢？ 设有效信息位的位数为n，校验位的位数为k，则组成的海明校验码共长n+k位校验时，需进行k组奇偶校验，将每组的奇偶校验结果组合，可以组成一个k位的二进制数，共能够表示2种状态。在这些状态中，必有一个状态表示所有奇偶校验都是正确的，用于判定所有信息均正确无误，剩下的（2^k-1）种状态可以用来判定出错代码的位置。因为海明校验码共长n+k位，所以校验位的位数k与有效信息位的位数n应满足关系：2^k-1≥n+k 如果出错代码的位置能够确定，将出错位的内容取反，就能够自动纠正错误，因此，满足上式的海明校验码能够检测出一位错误并且能自动纠正一位错误。 扩展的海明校验码的编码方式是:在检一纠一错的海明校验码的基础上，增加一个校验位P0，构成长度为n+k+1的编码。P0的取值是使长度为n+k+1的编码中1的个数为偶数（偶校验）或奇数（奇校验） 循环冗余校验码CRC目前在磁介质存储器与主机之间的信息传输、计算机之间的通信以及网络通信等采用串行传送方式的领域中，广泛采用循环冗余校验码（ Cyclic Redundancy Check，CRC）。循环冗余校验码是在n位有效信息位后拼接k位校验位构成的，它通过除法运算来建立有效信息和校验位之间的约定关系，是一种具有很强检错纠错能力的校验码。 CRC的编码思想 模2运算 CRC码的编码方法 CRC码的校验 多项式 参考： wiki-错误检测与纠正 《计算机组成原理》,张功萱,P53-P65 《计算机组成原理》,唐朔飞,P100 最通俗的CRC校验原理剖析]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java判断输入是否为数字，若不是数字，则重新输入]]></title>
    <url>%2Fpost%2F2b4d69da.html</url>
    <content type="text"><![CDATA[Java判断输入是否为数字，若不是数字，则重新输入 第一开始使用while true实现，但是会导致无限循环，原因是输入流缓存没有被清空，scanner.nextInt()得到的值还是上次进入catch中的值，所以需要使用scanner.nextLine();或scanner.next();换行。123456789101112Scanner scanner = new Scanner(System.in);while(true)&#123; System.out.println(&quot;输入ID&quot;); try&#123; int playerId = scanner.nextInt(); break; &#125;catch (InputMismatchException e)&#123; System.out.println(&quot;请输入整数类型的ID&quot;); continue; &#125;&#125; 类似的比如：12345678910int j=0;Scanner input=new Scanner(System.in);while(true)&#123; if(input.hasNextInt())&#123; j=input.nextInt(); break; &#125;else&#123; System.out.println(&quot;请输入整数类型的ID&quot;); &#125;&#125; 正确的做法：12345678910111213Scanner scanner = new Scanner(System.in);while(true)&#123; System.out.println(&quot;输入ID&quot;); try&#123; int playerId = scanner.nextInt(); break; &#125;catch (InputMismatchException e)&#123; System.out.println(&quot;请输入整数类型的ID&quot;); scanner.nextLine(); continue; &#125;&#125; 12345678int playerId = 0;Scanner scanner = new Scanner(System.in);System.out.println(&quot;输入ID&quot;);while(!scanner.hasNextInt())&#123; scanner.next(); System.out.println(&quot;请输入整数类型的ID&quot;);&#125;playerId = scanner.nextInt(); 参考： 关于JAVA的Scanner（System.in）循环输入的一些问题与解决]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO]]></title>
    <url>%2Fpost%2Fb4224212.html</url>
    <content type="text"><![CDATA[文件编码如果直接复制文本内容会自动转换编码ANSI并不是某一种特定的字符编码，而是在不同的系统中，ANSI表示不同的编码。比如在中文系统中使用gbk 当你的字节序列是某种编码时，这个时候想把字节序列变成字符串，也需要用这种编码方式，否则会出现乱码文本文件本身可以是任意编码的字节序列，但在utf-8下创建的文本文件只能识别为utf-8的编码，复制文件到其他编码环境下会识别为乱码，复制文本内容会自动转换 在.java文件中指定的各种编码格式，无论指定成哪种格式，最后在编译成.class时统统经过了 unicode 编码转换成双字节 12345678910111213141516171819202122232425262728293031323334353637383940414243String s = &quot;你好word&quot;;//Linux默认使用utf-8，locale命令查看//IDE使用utf-8//在UTF-8编码中，英文字符占一个字节，中文字符占用3个字节。byte[] bytes = s.getBytes();for(byte b :bytes)&#123; //默认使用十进制 //System.out.print(b+&quot; &quot;); //把字节转换成了int以16进制的方式显示，并去掉前24位（byte只占8位，转换为int，变为32位 System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);&#125;System.out.println();byte[] bytes1 = s.getBytes(&quot;utf-8&quot;);System.out.print(&quot;utf-8:\t\t&quot;);for(byte b :bytes1)&#123; System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);&#125;System.out.println();//gbk中，英文字符占用一个字节，中文占用两个字节byte[] bytes2 = s.getBytes(&quot;gbk&quot;);System.out.print(&quot;gbk:\t\t&quot;);for(byte b :bytes2)&#123; System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);&#125;System.out.println();//utf-16be中，英文字符占用两个字节，中文占用两个字节byte[] bytes3 = s.getBytes(&quot;utf-16be&quot;);System.out.print(&quot;utf-16be:\t&quot;);for(byte b :bytes3)&#123; System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);&#125;System.out.println();// 当你的字节序列是某种编码时，这个时候想把字节序列变成字符串// 也需要用这种编码方式，否则会出现乱码String string1 = new String(bytes3);System.out.println(string1);String string2 = new String(bytes3,&quot;utf-16be&quot;);System.out.println(string2); File类java.io.File类用于表示文件或目录的信息（名称、大小等），不能用于文件内容的访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051File file = new File(&quot;/home/lee/Downloads/Temple&quot;);//分隔符System.out.println(File.separator);System.out.println(File.separatorChar);//判断文件或目录是否存在System.out.println(file.exists());if(!file.exists())&#123; //创建文件，包括所有必需但不存在的父目录 file.mkdirs(); //创建文件 //file.mkdir();&#125;else&#123; //删除文件 file.delete();&#125;//是否是一个目录，如果是目录返回true，如果不是目录或者目录不存在返回的是falseSystem.out.println(file.isDirectory());//是否是一个文件，如果是文件返回true，如果不是文件或者文件不存在返回的是falseSystem.out.println(file.isFile());File file1 = new File(&quot;/home/lee/Downloads/log1.txt&quot;);//File file1 = new File(&quot;/home/lee/Downloads/&quot;,&quot;log1.txt&quot;)if(!file1.exists())&#123; try &#123; //创建文件 file1.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;System.out.println(file);//file.toString的内容//文件或目录名System.out.println(file.getName());System.out.println(file1.getName());System.out.println(file.getPath());System.out.println(file.getAbsolutePath());System.out.println(file.getAbsoluteFile());System.out.println(file.getParentFile());System.out.println(file.getParent());System.out.println(file1.getPath()); //路径名字符串，包括文件名System.out.println(file1.getAbsolutePath());//绝对路径名，返回类型为FileSystem.out.println(file1.getAbsoluteFile());//绝对路径名，返回类型为String//返回父目录的路径System.out.println(file1.getParentFile()); //返回值为FileSystem.out.println(file1.getParent()); //返回值为String 12345678910111213141516171819202122232425/** * 遍历目录，包括子目录 */public static void listDirectory(File file) throws IOException, IllegalAccessException &#123; if(!file.exists())&#123; throw new IllegalAccessException(&quot;目录&quot;+file+&quot;不存在&quot;); &#125; if(!file.isDirectory())&#123; throw new IllegalAccessException(file+&quot;不是目录&quot;); &#125; //下列两个方法都是列出路径名表示的目录中的文件和目录，但返回值不同 String[] strings = file.list(); File[] files = file.listFiles(); if(files != null &amp; files.length != 0)&#123; for(File f:files)&#123; if(f.isDirectory())&#123; listDirectory(f); &#125;else&#123; System.out.println(f.getPath()); &#125; &#125; &#125;&#125; RandomAccessFile类RandomAccessFile类提供对文件内容的访问，既可以读文件，也可以写文件。支持随机访问文件，可以访问文件的任意位置。 在硬盘上的文件是以 byte byte byte形式存储的，是数据的集合 RandomAccessFile打开文件有两种模式：rw（读写），r（只读） 文件指针，打开文件时指针在开头 pointer = 0； 写方法：raf.write(int)只写一个字节（后8位），同时指针指向下一个位置，准备再次写入 读方法：int b = raf.read()—&gt;读一个字节 文件读写完成以后一定要关闭raf.close() 不存在追加，如果需要追加，将位置定位到文件末尾，使用long fileLen = raf.length(); raf.seek(fileLen); IO流IO流分为输入流、输出流，又分为字节流、字符流 字节流InputStream和OutputStream是抽象类 InputStream：抽象了应用程序读取数据的方式 OutputStream：抽象了应用程序写出数据的方式 EOF = End 读到-1就读到结尾 输入流基本方法int b = in.read();读取一个字节无符号填充到int低八位，如果已到达文件末尾，则返回 -1。in.read(byte[] buf)读取数据填充到字节数组bufin.read(byte[] buf,int start, int size);读取数据到字节数组buf从buf的start位置开始存放size长度的数据 输出流基本方法out.write(int b)写出一个byte到流，b的低8位out.write(byte[] buf)将buf字节数组都写到流out.write(byte[] buf, int start,int size)字节数组buf从start位置开始写size长度的字节到流 FileInputStream类InputStream的子类，具体实现了在文件上读取数据 123456789101112131415161718192021222324252627282930313233343536373839/*** 读取指定文件内容，按照16进制输出到控制台* 并且每输出10个byte换行* 一个字节一个字节读取文件内容*/public static void printHex(String filename) throws IOException &#123; FileInputStream fis = new FileInputStream(filename); int b; int i = 0; while((b=fis.read()) != -1)&#123; System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;); i++; if(i% 10 == 0)&#123; System.out.println(); &#125; &#125;&#125;/*** 读取指定文件内容，按照16进制输出到控制台* 并且每输出10个byte换行* 一次性读取20 * 1024个字节读取文件内容*/public static void printHex1(String filename) throws FileNotFoundException,IOException &#123; FileInputStream fis = new FileInputStream(filename); byte[] bytes = new byte[20 * 1024]; int b=0; int j = 0; while((b = fis.read(bytes,0,bytes.length)) != -1)&#123; for(int i =0;i&lt;bytes.length;i++)&#123; System.out.print(Integer.toHexString(bytes[i] &amp; 0xff)+&quot; &quot;); j++; if(j%10 == 0)&#123; System.out.println(); &#125; &#125; &#125;&#125; 字符流对象的序列化和反序列化 ANSI是什么编码？ 字符编码Unicode、UTF-8和ANSI 遇到乱码不怕不怕啦——计算机字符编码详尽讲解 java io系列26之 RandomAccessFile Java RandomAccessFile用法]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程]]></title>
    <url>%2Fpost%2Fc2ca7a91.html</url>
    <content type="text"><![CDATA[利用Java多线程可以简化模型，编写强大的代码，但也可能会因为考虑不周而面临bug 进程是程序的执行过程，持有资源（共享内存，共享文件）和线程，是线程的载体线程是系统中最小的执行单元，同一进程中有多个线程，线程共享进程的资源 线程的交互分为互斥和同步]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2Fpost%2Fadc18de0.html</url>
    <content type="text"><![CDATA[Class类的使用除了基本的数据类型、静态成员不是对象，万事万物皆对象，而基本的数据类型可封装为包装类。类是java.lang.Class类的实例对象，任何一个类都是Class的实例对象。 类的实例化表示方法：123456789101112131415161718Food food = new Food();//第一种Class c1 = food.getClass();//第二种，任何一个都有一个隐含的静态成员classClass c2 = Food.class;//第三种Class c3 = null;try &#123; c3 = Class.forName(&quot;com.Reflectest.Food&quot;); //需要加上类的包名&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125;//c1、c2、c3表示Food类的类类型（class type）//一个类只可能是Class类的一个实例对象System.out.println(c1 == c2);//trueSystem.out.println(c2 == c3);//true c1、c2、c3表示Food类的类类型（class type）一个类只可能是Class类的一个实例对象 通过类类型实例化对象123Food food1 = (Food) c1.newInstance();//注意异常//返回值为Object类型，需要转换 基本数据类型、包装类、void关键字等都存在类类型1234567891011Class cl1 = int.class;Class cl2 = String.class;Class cl3 = void.class;Class cl4 = Double.class;Class cl5 = double.class;//cl4和cl5不一样System.out.println(cl1.getName()); //intSystem.out.println(cl2.getName()); //java.lang.StringSystem.out.println(cl3.getName()); //voidSystem.out.println(cl4.getName()); //java.lang.DoubleSystem.out.println(cl5.getName()); //double 动态加载类编译时刻加载类是静态加载类，运行时刻加载类是动态加载类 new创建对象：是静态加载类，在编译时刻就需要加载所有的可能使用到的类。有一个类有问题（如不存在），都不能通过编译，会报错。 Class.forName(&quot;类的全称&quot;);不仅代表了类的类型，还代表了动态加载类。Class.forName()通过动态加载类，用到一个类时，才进行加载。动态加载类，编译时不会出错，只有运行时可能出错 12345678910111213/** * 静态加载类 * 如果Word类和Excel类不存在，则编译的时候会报错，IDE直接报错 */public class Office&#123; public static void main(String[] args)&#123; Word word = new Word(); word.start(); Excel excel = new Excel(); excel.start(); &#125;&#125; 1234567891011121314/** * 动态加载类 * 编译时不会抛出异常 */public class OfficeBetter&#123; public static void main(String[] args) &#123; try &#123; Class cl = Class.forName(args[0]); Excel e = (Excel)cl.newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 功能性的类尽量使用动态加载，并对新添的类实现功能性接口（标准），这样就不用重新编译1234567891011121314151617181920212223242526272829public interface OfficeAble &#123; public void start();&#125;public class Word implements OfficeAble &#123; @Override public void start() &#123; System.out.println(&quot;Word&quot;); &#125;&#125;public class Excel implements OfficeAble &#123; @Override public void start() &#123; System.out.println(&quot;Excel&quot;); &#125;&#125;public class OfficeBetter&#123; public static void main(String[] args) &#123; try &#123; Class cl = Class.forName(args[0]); OfficeAble oa = (OfficeAble) cl.newInstance(); oa.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取类的信息通过反射可以获取类的方法、属性、构造函数、包等信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class MethodClass &#123; public static void main(String[] args)&#123; Animal animal = new Animal(); MethodClass.printClassMethodMessage(animal); MethodClass.printClassFieldMessage(animal); MethodClass.printClassConstructorMessage(animal); Integer i = 1; MethodClass.printClassMethodMessage(i); MethodClass.printClassFieldMessage(i); MethodClass.printClassConstructorMessage(i); String s = &quot;Hello&quot;; MethodClass.printClassMethodMessage(s); MethodClass.printClassFieldMessage(s); MethodClass.printClassConstructorMessage(s); &#125; /** * 获取类的方法信息 * 通过反射获取类的方法名称、返回值类型、参数列表 * 所有方法都是java.lang.reflect.Method类的对象 * 一个成员方法就是一个Method对象 */ public static void printClassMethodMessage(Object obj)&#123; //获取obj对象的类类型 Class cl = obj.getClass(); //获取类的名称，包含包名 System.out.println(&quot;类的名称，包含包名:\t&quot;+cl.getName()); //获取类的名称，不包含包名 System.out.println(&quot;类的名称，不包含包名:\t&quot;+cl.getSimpleName()); //获取所有public的方法，包括继承来的 Method[] ms = cl.getMethods(); //获取该类所有自己声明的方法，不论访问权限 Method[] ms1 = cl.getDeclaredMethods(); System.out.println(&quot;Method类的方法:&quot;); for (Method m:ms1) &#123; //获取方法的返回值类型的类类型（int.clss\String.class，而不是int\String） Class returnType = m.getReturnType(); System.out.print(returnType.getSimpleName()+&quot;\t&quot;); //获取方法的名称 System.out.print(m.getName()+&quot;\t&quot;); //获取参数类型（和返回值一样，得到的都是类类型） Class[] paramTypes = m.getParameterTypes(); for(Class c:paramTypes)&#123; System.out.print(c.getSimpleName()+&quot;,&quot;); &#125; System.out.println(); &#125; System.out.println(); &#125; /** * 获取类的成员变量信息 * 通过反射获取类的属性名称、属性类型 * 成员变量是java.lang.reflect.Field的对象 */ public static void printClassFieldMessage(Object obj)&#123; Class cl = obj.getClass(); //获取所有public的成员变量信息，包括继承 Field[] fields = cl.getFields(); //获取该类所有自己声明的成员变量信息，不论访问权限 Field[] fields1 = cl.getDeclaredFields(); for(Field field:fields)&#123; //得到成员变量类型的类类型（int.clss\String.class） Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+&quot;\t&quot;+fieldName); &#125; System.out.println(); &#125; /** * 获取类的构造方法信息 * 通过反射获取构造函数的名称、参数列表 * 构造函数是java.lang.Constructor类的对象 */ public static void printClassConstructorMessage(Object obj)&#123; Class cl = obj.getClass(); //获得所有公有构造方法信息，包括继承 Constructor[] constructors = cl.getConstructors(); //获取自己声明的构造方法，不论访问权限 Constructor[] constructors1 = cl.getDeclaredConstructors(); for(Constructor constructor:constructors1)&#123; //获取构造函数的名称 String constructorName = constructor.getName(); System.out.print(constructorName + &quot; &quot;); //获取构造函数的参数 Class[] parameterTypes = constructor.getParameterTypes(); for(Class parameterType:parameterTypes)&#123; System.out.print(parameterType.getSimpleName()+&quot;,&quot;); &#125; System.out.println(); &#125; System.out.println(); &#125;&#125; 方法的反射通过方法的反射调用方法 1234567891011121314151617181920212223242526272829303132333435363738public class ClassDemo5 &#123; public static void main(String[] args)&#123; A a = new A(); Class cl = a.getClass(); try &#123; //无参无返回值 //1. 获取方法，也可以使用getDeclaredMethod() Method m1 = cl.getMethod(&quot;print&quot;); //Method m1 = cl.getDeclaredMethod(&quot;print&quot;); //2. 调用方法，method.invok(对象,参数列表); 以下两种方式效果一样 m1.invoke(a); a.print(); //有参有返回值 //参数列表为可变参数，使用以下两种方式均可 Method m2 = cl.getMethod(&quot;add&quot;,new Class[]&#123;int.class,int.class&#125;); //Method m1 = cl.getMethod(&quot;add&quot;,int.class,int.class); //参数列表为可变参数，使用以下两种方式均可 //方法如果没有返回值则返回null，有返回值则返回具体的返回值，需要类型转换 int i = (int)m2.invoke(a,1,2); //int i = (int)m2.invoke(a,new Object[]&#123;1,2&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A&#123; public void print()&#123; System.out.println(&quot;hello&quot;); &#125; public int add(int a,int b)&#123; int c = a+b; System.out.println(c); return c; &#125;&#125; 通过反射了解集合泛型的本质Java中集合的泛型是防止错误输入的，只在编译阶段有效，如果绕开编译就无效了 123456789101112131415161718192021222324public class ClassDemo6 &#123; public static void main(String[] args)&#123; //list1可以添加任意类型，list2只能添加String类型 ArrayList list1 = new ArrayList(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); //反射的操作过都是编译之后的操作 //c1 == c2 返回true说明编译之后集合的泛型是去泛型化的 Class c1 = list1.getClass(); Class c2 = list2.getClass(); System.out.println(c1 == c2); //true //Java中集合的泛型是防止错误输入的，只在编译阶段有效，如果绕开编译就无效了 //验证：通过方法的反射绕过编译 Method m = null; try &#123; m = c2.getMethod(&quot;add&quot;,Object.class); m.invoke(list2,100); System.out.println(list2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-06-Java与二进制]]></title>
    <url>%2Fpost%2F6e78d28e.html</url>
    <content type="text"><![CDATA[关于二进制参考【Linux】Linux 计算机基础 进制转换12345678910111213141516//十进制转为其他进制Integer.toBinaryString(112)//二进制Integer.toHexString(112)//十六进制Integer.toOctalString(112)//八进制//其他进制转为十进制Integer.parseInt(&quot;110101&quot;,2)Integer.parseInt(&quot;F6889&quot;,16)Integer.parseInt(&quot;76541&quot;,8)//其他进制转为十进制Integer.valueOf(&quot;110101&quot;,2)Integer.valueOf(&quot;F6889&quot;,16)Integer.valueOf(&quot;76541&quot;,8) Java数据类型和字节的转换在平时的Java开发中，进制转换和位操作用的不多，但是在跨平台中用的较多，比如文件读写、数据通信 如果Java客户端和Java服务器通信，可以使用序列和反序列serializable，而如果Java客户端和C服务器通信则需要转换为字节 Java的基本数据类型包括： int数据类型：byte(8bit,-128~127)、short(16bit)、int(32bit)、long(64bit) float数据类型：单精度(32bit,float)、双精度(64bit,double) boolean数据类型(true、false) char数据类型：unicode字符 16位 基本数据类型和字节的转换 小端法(LIttle-Endian)：低位字节排放在内存的低地址端即该值的起始地址，高位字节排放在内存的高地址端大端法(Big-Endian)：高位字节排放在内存的底地址端即该值的起始地址，低位字节排放在内存的高地址端 12345678910111213141516171819202122232425262728293031323334353637383940/*** int 转 字节数组* @param x* @return*/public static byte[] int2byte(int x)&#123; byte[] bytes = new byte[4]; //int型长度为4个字节 for(int i = 0;i&lt;bytes.length;i++)&#123; bytes[i] = (byte)((x&gt;&gt;i*8) &amp; 0xff); &#125; return bytes;&#125;/*** long 转 字节数组* @param x* @return*/public static byte[] long2byte(long x)&#123; byte[] bytes = new byte[8]; //long型长度为8个字节 for(int i = 0;i&lt;bytes.length;i++)&#123; bytes[i] = (byte)((x&gt;&gt;i*8) &amp; 0xff); &#125; return bytes;&#125;/*** 字节数组 转 int* @param bytes* @return*/public static int byte2int(byte[] bytes)&#123; int result = 0; for(int i=0;i&lt;bytes.length;i++)&#123; result += (bytes[i] &amp; 0xff) &lt;&lt; i*8; &#125; return result;&#125; 字符串和字节的转换123456789101112//字符串转字节数组String s = &quot;hello&quot;;byte[] bs = s.getBytes();for(int i =0;i&lt;bs.length;i++)&#123; System.out.println(bs[i]);&#125;//字节数组转字符串String ss = new String(bs);String sss = new String(bs,encode);//encode指编码方式，比如 gb2312 utf-8System.out.println(ss);]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2Fpost%2F4509351.html</url>
    <content type="text"><![CDATA[Java集合框架：Collection接口，Map接口，Collections工具类，Comparable接口，Comparator接口 集合Java中的集合类是一种工具类，用于存储任意数量的具有共同属性的对象 集合的作用： 在类的内部，对数据进行组织 简单而快速的搜索大数量的条目 有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素 有的集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型 集合和数组的区别： 数组的长度固定，集合长度可变 数组只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象 Collection(接口) List(接口)（特点：有序，可重复） ArrayList（实现类） LinkedList（实现类） Query(接口)（特点：有序，可重复） LinkedList（实现类） Set(接口)（特点：无序，不可重复） HashSet（实现类）Map(接口)（特点：Entry(Key,Value) – 键值对：)注：Entry是Map的内部类 HashMap（实现类） Collection接口是List、Set和Queue接口的父接口，定义了可用于操作List、Set和Queue的方法————增删改查 ListList是元素有序并且可以重复的集合，被称为序列List可以精确的控制每个元素的插入位置，或删除某个位置元素 ArrayList(数组列表)是List的一个重要实现类，底层是由数组实现的 list.add(对象)把一个对象添加到另一个集合的队尾位置list.add(index, 对象) 把一个集合添加到另一个集合的指定位置list.addAll(集合对象) 把一个集合添加到另一个集合的队尾位置list.addAll(index, 集合对象) 把一个集合添加到另一个集合的指定位置Arrays.asList(数组) 把一个数组转换成List集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class Course &#123; public String id; public String name; public Course()&#123;&#125; public Course(String id, String name) &#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return &quot;Course&#123;&quot; + &quot;id=&apos;&quot; + id + &apos;\&apos;&apos; + &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Course course = (Course) o; return Objects.equals(name, course.name); &#125;&#125;/** * 模拟学生选课功能 * 1. 添加课程 * 2. 删除课程 * 3. 查看所选课程 * 4. 修改所选选课程 */public class ListTest &#123; public List coursesList; public ListTest()&#123; this.coursesList = new ArrayList(); //List是接口，所以在构造方法中不能直接实例化，而通过ArrayList()实例化 &#125; /** * 添加课程 */ public void courseAdd()&#123; Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;); Course course2 = new Course(&quot;2&quot;,&quot;离散数学&quot;); Course course3 = new Course(&quot;3&quot;,&quot;高等数学&quot;); Course course4 = new Course(&quot;4&quot;,&quot;计算机组成原理&quot;); Course course5 = new Course(&quot;5&quot;,&quot;计算机网络&quot;); Course course6 = new Course(&quot;6&quot;,&quot;大学英语&quot;); coursesList.add(course1); coursesList.add(course1); //支持重复数据 //coursesList.add(2,course2); //会报异常IndexOutOfBoundsException: Index: 2, Size: 1 coursesList.add(1,course2); Course[] courses1 = &#123;course3,course4&#125;; coursesList.addAll(Arrays.asList(courses1)); Course[] courses2 = &#123;course5,course6&#125;; coursesList.addAll(2,Arrays.asList(courses2)); &#125; /** * 遍历课程 */ public void coursesGetAll()&#123; for(int i = 0;i&lt;coursesList.size();i++)&#123; Course course = (Course) coursesList.get(i); //get()方法获得的对象是Object类型，需要转换 System.out.println(course); &#125; System.out.println(&quot;-----------------&quot;); //foreach遍历方法 for(Object object : coursesList)&#123; System.out.println((Course)object); &#125; System.out.println(&quot;-----------------&quot;); //迭代器遍历 Iterator iterator = coursesList.iterator(); while(iterator.hasNext())&#123; System.out.println((Course)iterator.next()); &#125; System.out.println(&quot;-----------------&quot;); &#125; /** * 修改课程 */ public void courseSet()&#123; Course course = new Course(&quot;7&quot;,&quot;Java web&quot;); coursesList.set(0,course); &#125; /** * 删除课程 */ public void courseRemove()&#123; coursesList.remove(coursesList.get(1)); coursesList.remove(2); Course[] courses = &#123;(Course) coursesList.get(3),(Course) coursesList.get(4)&#125;; coursesList.removeAll(Arrays.asList(courses)); &#125; /** * 索引课程位置 * indexOf()方法返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。 */ public int courseIndex(Course course)&#123; return coursesList.indexOf(course); &#125; /** * 判断课程是否存在 */ public boolean courseContain(Course course)&#123; /** * ArrayList中contains() 如果此列表中包含指定的元素，则返回 true。 * 更确切地讲，当且仅当此列表包含至少一个满足 (o==null ? e==null : o.equals(e)) 的元素 e 时，则返回 true。 * 因此比较的是o.equals(e)，这是比较两个对象内在地址是否相同 * 这里只需要比较课程的名称是否相同，重写Course类的equals方法 */ return this.coursesList.contains(course); &#125; public static void main(String[] args)&#123; ListTest listTest = new ListTest(); listTest.courseAdd(); listTest.coursesGetAll();// listTest.courseRemove();// listTest.coursesGetAll(); listTest.courseSet(); listTest.coursesGetAll(); Course course = (Course)listTest.coursesList.get(0); System.out.println(listTest.courseContain(course)); Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;); //重写Course类的equal方法前为false，重写后为true System.out.println(listTest.courseContain(course1)); System.out.println(listTest.courseIndex(course1)); &#125;&#125; 集合中的元素可以是任意类型的对象，如果把某个对象放入集合，则会忽略它的类型，而把它当做Object对象处理。泛型则规定了某个集合只可以存放特定类型的对象，会在编译期间进行类型检查比如上例中的List未规定泛型，则coursesList除了可以添加Course对象外，还可以添加String类型等其他类型，而且在取出其中的元素时，需要进行类型转换 用泛型改进上例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ListGenericTest &#123; public List&lt;Course&gt; courseList; public ListGenericTest()&#123; this.courseList = new ArrayList&lt;Course&gt;(); &#125; public void courseAdd()&#123; Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;); Course course2 = new Course(&quot;2&quot;,&quot;离散数学&quot;); Course course3 = new Course(&quot;3&quot;,&quot;高等数学&quot;); Course course4 = new Course(&quot;4&quot;,&quot;计算机组成原理&quot;); Course course5 = new Course(&quot;5&quot;,&quot;计算机网络&quot;); Course course6 = new Course(&quot;6&quot;,&quot;大学英语&quot;); courseList.add(course1); courseList.add(course1); courseList.add(1,course2); Course[] courses1 = &#123;course3,course4&#125;; courseList.addAll(Arrays.asList(courses1)); Course[] courses2 = &#123;course5,course6&#125;; courseList.addAll(2,Arrays.asList(courses2)); &#125; public void coursesGetAll()&#123; for(Course course:courseList)&#123; System.out.println(course); &#125; System.out.println(&quot;-----------------------&quot;); &#125; /** * 修改课程 */ public void courseSet()&#123; Course course = new Course(&quot;7&quot;,&quot;Java web&quot;); courseList.set(0,course); &#125; public void courseRemove()&#123; courseList.remove(courseList.get(1)); courseList.remove(2); Course[] courses = &#123;courseList.get(3),courseList.get(4)&#125;; courseList.removeAll(Arrays.asList(courses)); &#125; public static void main(String[] args)&#123; ListGenericTest listTest = new ListGenericTest(); listTest.courseAdd(); listTest.coursesGetAll(); listTest.courseRemove(); listTest.coursesGetAll(); listTest.courseSet(); listTest.coursesGetAll(); &#125;&#125; 泛型不还可以接受泛型类的子类型1234567public class ChildCourse extends Course &#123;&#125;public void childCourseAdd()&#123; ChildCourse childCourse = new ChildCourse(); courseList.add(childCourse);&#125; 泛型集合中的限定类型不能使用基本数据类型，可以通过包装类使用基本数据类型1List&lt;Integer&gt; lists = new ArrayList&lt;&gt;(); SetSet是元素无序并且不可以重复的集合，被称为集 HashSet(哈希集)是Set的一个重要实现类。 Set没有像List中set()方法一样就修改，因为List是有序的，可以指定位置，而Set是无序的。 查询遍历时，Set不能用get()方法去获取，因为无序没有指定索引ID，但可以使用foreach和iterator来遍历，但是每次遍历出来可能顺序都不一样，还是因为无序造成的。 Set中的size(),add(),addAll(),remove(),removeAll()与List类似。 Set还可以添加null，new HashSet&lt;&gt;().add(null); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Student &#123; public String id; public String name; public Set&lt;Course&gt; courses; public Student(String id, String name) &#123; this.id = id; this.name = name; this.courses = new HashSet&lt;&gt;();//初始化集合 &#125;&#125;public class SetTest2 &#123; public static void main(String[] args)&#123; Student student = new Student(&quot;1&quot;,&quot;小明&quot;); Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;); Course course2 = new Course(&quot;2&quot;,&quot;离散数学&quot;); Course course3 = new Course(&quot;3&quot;,&quot;高等数学&quot;); //增加课程 student.courses.add(course1); List&lt;Course&gt; courseList = new ArrayList&lt;&gt;(); courseList.add(course2); courseList.add(course3); student.courses.addAll(courseList); //遍历课程 //不能使用get方法遍历，因为Set是无序的 for(Course course:student.courses)&#123; System.out.println(course); &#125; //移除课程 student.courses.remove(course3); for(Course course:student.courses)&#123; System.out.println(course); &#125; //判断Set中是否包含课程 //使用contains方法 System.out.println(student.courses.contains(course1));//true Course course4 = new Course(&quot;1&quot;,&quot;数据结构&quot;); //返回false，HashSet类的contain方法，需要比较hashcode方法和equals方法 //重写hashcode方法和equals方法后，才为true System.out.println(student.courses.contains(course4)); &#125;&#125; Map Map接口提供了一种映射关系，其中的元素是键值对（key-value）的形式存储的，能够实现根据Key快速查找value。Key-value可以是任何对象，是以Entry类型的对象实例存在的。2.Key是不可以重复的，Value是可以重复的。Key-value都可以为null，不过只能有一个key是null。3.map支持泛型，Map4.每个键最多只能映射到一个值5.Map接口提供了分别返回key值集合（keySet()）、value值集合（values()）以及Entry（键值对）集合（entrySet() ）的方法 HashMap是Map的一个实现类，基于哈希表实现，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。 Key值和value值都可以为null，但是一个HashMap只能有一个key值为null的映射（key值不可重复） HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。 如果需要同步，可以用Collections.synchronizedMap(HashMap map)方法使HashMap具有同步的能力。 Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空； HashMap中的Entry对象是无序排列的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * 通过Map&lt;String,Student&gt;进行学生信息管理，其中key为学生ID，value为学生对象 * 对集合中的学生信息进行增、删、改、查操作 */public class MapTest &#123; public Map&lt;String,Student&gt; studentMap; public MapTest()&#123; this.studentMap = new HashMap&lt;&gt;(); &#125; /** * 增加学生信息 * @param student */ public void studentAdd(Student student)&#123; Student student1 = studentMap.get(student.id); if(student1 != null)&#123; System.out.println(&quot;学生id已存在&quot;); return ; &#125; studentMap.put(student.id,student); &#125; /** * 查找学生信息 * @param id * @return */ public Student studentGet(String id)&#123; Student student = studentMap.get(id); if(student != null)&#123; return student; &#125;else &#123; return null; &#125; &#125; /** * 遍历学生信息 * @return */// public Map&lt;String,Student&gt; studentGetAll()&#123;// return this.studentMap;// &#125; public void studentGetAll()&#123; Set&lt;Map.Entry&lt;String,Student&gt;&gt; entrySet = studentMap.entrySet(); for(Map.Entry&lt;String,Student&gt; entry:entrySet)&#123; System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue()); &#125; &#125; /** * 修改学生信息 * @param student */ public void studentModify(Student student)&#123; Student student1 = this.studentGet(student.id); if(student1 == null)&#123; System.out.println(&quot;学生id不存在&quot;); return; &#125; studentMap.put(student.id,student); &#125; /** * 测试Map中是否包含某个key或者value值 * 在Map中，用containsKey方法，来判断是否包含某个key值 * 在Map中，用containsValue方法，来判断是否包含某个Value值，需要重写equals方法和hashCode方法 * @param id * @return */ public void studentContainsById(String id)&#123; if(studentMap.containsKey(id))&#123; System.out.println(&quot;该学生存在&quot;); &#125;else&#123; System.out.println(&quot;该学生不存在&quot;); &#125; &#125; //注意，Map的值为Student类 public void studentContainsByName(String name)&#123; if(studentMap.containsValue(new Student(null,name)))&#123; System.out.println(&quot;该学生存在&quot;); &#125;else&#123; System.out.println(&quot;该学生不存在&quot;); &#125; &#125; /** * 删除学生信息 * @param id */ public void studentDelete(String id)&#123; Student student1 = this.studentGet(id); if(student1 == null)&#123; System.out.println(&quot;学生id不存在&quot;); return; &#125; studentMap.remove(id); &#125; public static void main(String[] args)&#123; MapTest mapTest = new MapTest(); mapTest.studentAdd(new Student(&quot;1&quot;,&quot;John&quot;)); mapTest.studentAdd(new Student(&quot;2&quot;,&quot;John&quot;)); mapTest.studentAdd(new Student(&quot;3&quot;,&quot;Mei&quot;)); mapTest.studentGetAll(); System.out.println(mapTest.studentGet(&quot;3&quot;)); System.out.println(mapTest.studentGet(&quot;5&quot;)); Student student = new Student(&quot;2&quot;,&quot;Halen&quot;); mapTest.studentModify(student); Student student1 = new Student(&quot;5&quot;,&quot;Halen&quot;); mapTest.studentModify(student1); mapTest.studentGetAll(); mapTest.studentDelete(&quot;1&quot;); mapTest.studentGetAll(); mapTest.studentDelete(&quot;4&quot;); System.out.println(); mapTest.studentGetAll(); mapTest.studentContainsById(&quot;1&quot;); mapTest.studentContainsById(&quot;2&quot;); mapTest.studentContainsByName(&quot;Mei&quot;); mapTest.studentContainsByName(&quot;Halen&quot;); &#125;&#125; contains方法contains方法用于判断集合中是否包含某个值 不论是List中的 contains 方法，Set中的 contains 方法，以及Map中的 containsKey 和containsValue ，都是遍历寻找第一个匹配的项，因为使用的是equals 方法，所以比较的是对象的引用是否相同，即是否是同一个对象，需要重写类的equals 方法，另外Set的contains 方法和Map中的 containsValue 需要重写 hashCode 方法 Conllections工具类java.util.Collections工具类是Java集合框架中用来操作集合对象的工具类 排序根据元素的自然顺序对指定列表按升序进行排序。列表中的所有元素都必须实现 Comparable 接口。 两个接口都可以使用泛型 Comparable接口定义了默认的比较规则实现该接口表示：这个类的实例可以比较大小，可以进行自然排序 实现 Comparable 接口必须实现 compareTo 方法，该方法比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 Comparator接口—–比较工具接口定义了临时的比较规则 其实现类需要实现 compare()方法，该方法比较用来排序的两个参数。根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class Student implements Comparable&lt;Student&gt;&#123; public String id; public String name; public Set&lt;Course&gt; courses; public Student(String id, String name) &#123; this.id = id; this.name = name; this.courses = new HashSet&lt;&gt;();//初始化集合 &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&apos;&quot; + id + &apos;\&apos;&apos; + &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125; @Override public int compareTo(Student o) &#123; return this.id.compareTo(o.id); &#125;&#125;public class StudentComparator implements Comparator&lt;Student&gt; &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.name.compareTo(o2.name); &#125;&#125;public class CollectionsTest &#123; /** * 通过Collections.sort()方法对Integer泛型的List进行排序 */ public static void IntegerSort()&#123; List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); for(int i=0; i&lt;10;i++)&#123; integerList.add((int)(Math.random()*100)); &#125; for(Integer i :integerList)&#123; System.out.print(i+&quot;\t&quot;); &#125; System.out.println(); Collections.sort(integerList); for(Integer i :integerList)&#123; System.out.print(i+&quot;\t&quot;); &#125; &#125; /** * 对String泛型的List进行排序 * 字符串的排列顺序为 1.0-9 2.A-Z 3.a-z */ public static void StringSort()&#123; List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); for(int i=0;i&lt;5;i++)&#123; stringList.add(randomString1(10)); &#125; for(String s :stringList)&#123; System.out.print(s+&quot;\t&quot;); &#125; System.out.println(); Collections.sort(stringList); for(String s :stringList)&#123; System.out.print(s+&quot;\t&quot;); &#125; &#125; /** * 创建给定长度的随机字符串 * @param i * @return */ public static String randomString(int i)&#123; String s = &quot;&quot;; short start = &apos;0&apos;; short end = &apos;z&apos; + 1; while (s.length() != i) &#123; char c = (char) (Math.random() * (end - start) + start); if (Character.isDigit(c) || Character.isLetter(c)) &#123; s += c; &#125; &#125; return s; &#125; /** * 创建给定长度以内的随机字符串 * 每条字符串的长度为i以内的随机整数 * 每条字符串的每个字符都为随机生成的字符，字符可以重复 * @param i * @return */ public static String randomString1(int i)&#123; String s = &quot;&quot;; short start = &apos;0&apos;; short end = &apos;z&apos; + 1; //避免字符串长度为0 int x = (int)(Math.random()*(i-1)+1); while (s.length() != x) &#123; char c = (char) (Math.random() * (end - start) + start); if (Character.isDigit(c) || Character.isLetter(c)) &#123; s += c; &#125; &#125; return s; &#125; /** * 实现Comparatable接口，根据字符串id比较 */ public static void StudentSort()&#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); studentList.add(new Student(&quot;3&quot;,&quot;Halen&quot;)); studentList.add(new Student(&quot;2&quot;,&quot;John&quot;)); studentList.add(new Student(&quot;1&quot;,&quot;JJ&quot;)); for(Student s:studentList)&#123; System.out.print(s); &#125; System.out.println(); Collections.sort(studentList); for(Student s:studentList)&#123; System.out.print(s); &#125; &#125; /** * 实现Comparator接口，根据名字比较 */ public static void StudentSort2()&#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); studentList.add(new Student(&quot;3&quot;,&quot;Halen&quot;)); studentList.add(new Student(&quot;2&quot;,&quot;John&quot;)); studentList.add(new Student(&quot;1&quot;,&quot;JJ&quot;)); for(Student s:studentList)&#123; System.out.print(s); &#125; System.out.println(); Collections.sort(studentList,new StudentComparator()); for(Student s:studentList)&#123; System.out.print(s); &#125; &#125; public static void main(String[] args)&#123; CollectionsTest.IntegerSort(); System.out.println(); CollectionsTest.StringSort(); System.out.println(); CollectionsTest.StudentSort(); System.out.println(); CollectionsTest.StudentSort2(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 文件系统]]></title>
    <url>%2Fpost%2Ff525ac74.html</url>
    <content type="text"><![CDATA[linux中一切皆文件。目录为目录文件。普通文件用来保存数据，目录文件用来保存文件文件系统：Windows里面是这样的：C:\Program files\office11\word\word.exeLinux里面是这样的：/etc/sysconfig/network-scripts/ifcfg-eth0 文件有两类数据：元数据：metadata 元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode…)等等。数据：data 数据是指普通文件中的实际数据。 1、文件名严格区分字符大小写；file1, File1, FILE1是不同的文件；2、文件名可使用除/以外的任意字符，不建议使用特殊字符； /: 表示根目录，也用做路径分隔符；3、文件名长度最长不能超过255个字符；4、所以.开头的文件，均为隐藏文件； LSB: Linux Standard Base Linux标准库]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to use Github]]></title>
    <url>%2Fpost%2F68d6df4b.html</url>
    <content type="text"><![CDATA[在写这篇文章的时候，Github已经被Microsoft收购，不过依然会使用Github，因为觉得对自己的影响不大。 最近重新学习Git发觉自己其实对Github了解甚少，star了不少，但是从来没有好好看过，我觉得学习一定要发挥自己的主动性，不能光收藏，还要尽可能提出issues、甚至代码，当前我最应该克服的是懒，破除嫌麻烦的这种思想，如果自己都懒，都嫌麻烦，如何去解决麻烦。 回到正题，Github是一个git版本库托管商，里面有各种开源项目。本篇文章尝试写清楚从Github的入门使用到参与开源项目的一般方法。 官网：https://github.com/ 账户的配置如何注册账户就不介绍了 SSH访问配置SSH是为了能够在本地电脑上访问Github，识别出你推送的提交确实是你推送的，而不是别人冒充的 具体如何做，其实在【Hexo】使用Hexo搭建github博客里面有过介绍，那篇文章是为了制作Github Pages，这里不再说明git的安装和配置，那么只有一行命令 1ssh-keygen -t rsa -f ~/.ssh/id_rsa_github 该命令会在本地电脑（Linux）的~/.ssh下创建公钥和私钥，将公钥(id_rsa_github.pub)中的内容拷贝到github帐号Settings&gt;SSH and GPG keys中 此外还有头像的配置（Profile）、邮箱的配置（Emails）、两步验证（Security）等全部都在Settings里。 创建项目仓库创建项目仓库 首页 &gt; New repository如果勾选 Initialize this repository with a README，会创建一个README.md文件， 可以将本地已存在的项目上传到仓库123456git initgit remote add origin git@github.com:fengrenxiaoli/GitTest.gitgit add .git commit -m &quot;upload&quot;git push -u origin master# 第一次push需要-u参数，关联本地master和远程master，以后不用加-u 也可以将Github上的项目复制到本地1git clone git@github.com:fengrenxiaoli/GitTest.git Github协作流程 从 master 分支中创建一个新分支 创建，编辑，重命名，移动或删除文件 将这个分支推送到 GitHub 上 创建一个合并请求（Pull Request） 讨论，根据实际情况继续修改 项目的拥有者合并或关闭你的合并请求 给队友添加写权限到项目的 Settings 页面，点击 collaborator 选项，输入框中输入相应的用户名使用户具有写权限。 Fork项目副本对于大多数情况，参于开发者并不会被直接赋予写权限，开发者需要先Fork一份项目到自己的用户名下。 创建一个新分支开新分支一定要在刚刚更新过的 master 的基础上开。分支的名字应该是描述性的（如refactor-authentication，user-content-cache-key，make-retina-avatars），越清楚越好 123456git pullgit checkout -b &lt;branch-name&gt;vim &lt;file-name&gt;git add &lt;file-name&gt;git commit -m &quot;some commit&quot;git push origin &lt;branch-name&gt; 发起Pull Request修改项目后，在Github上点击 Compare &amp; pull request，选择需要进行对比的分支，填写描述信息，需要图片可以直接拖进去，也可以点击selecting them Pull Request会启动关于提交的讨论 如果需要新的改动，直接在分支上修改，然后同步即可在pull request页面看到 合并拥有写权限的人可以点击 Merge Pull Request合并之后可以删除分支 快速 Pull Request如果只是修改很小的一点，没有必要使用上述流程，直接在Github网页上点击编辑，然后选择Create a new branch for this commit and start a pull request... issueshttps://guides.github.com/features/issues/Issue 中一般是放一些临时性的讨论(报Bug、提新需求等)，最终是要被关掉的。如果 Issue 里面有一些精华的内容，可以拷贝出来贴到 wiki 中，方便大家查阅。 打开项目页面，点击issues，点击New issue新建的issue会有一个编号，类似于# 1issue支持MarkDown语法 代码高亮使用三个反引号 123\`\`\`jsalert(&quot;hello worold&quot;)\`\`\` 快速引用MarkDown中使用&gt;作为引用如果你想回答具体某个问题，可以用鼠标选中那段话，然后，敲 r 。这样这段话就自动出现在你的评论框中了。 拉别人进来讨论如果你在评论框中输入@happypeter那么不管我是不是你当然项目的参与者，我都会收到通知来进来参加讨论 引用issue在评论框中输入#会提示相应的issue。如果我在当前 Issue#10 的评论框中写 #20 就可以自动链接到 Issue#20 了。同时 Issue#20 那边也会显示出 Issue#10 。这种指向和关联的功能在实用中是非常重要的 用版本留言关闭 Issue点击Close issue按钮可以关闭issue 引用emoji输入:,会提示输入emoji 1:dancer: Github Pageshttps://pages.github.com/ Github Pages可以用于写博客，也可以用于制作项目网站，对应的网址是http://username.github.io/repository 里程碑用于发布版本Github项目页，点击release&gt;Draft a new release，创建标签，填入字段 参考： Understanding the GitHub Flow http://gitbeijing.com/ Hello World Git 游戏通关流程]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用方法]]></title>
    <url>%2Fpost%2Fab888b92.html</url>
    <content type="text"><![CDATA[版本控制系统集中式版本控制系统（Centralized Version Control Systems,简称 CVCS）：have a single server that contains all the versioned files, and a number of clients that check out files from that central place. 集中式版本控制系统的缺点是中央服务器的单点故障。 分布式版本控制系统（Distributed Version Control System,简称 DVCS）：clients don’t just check out the latest snapshot of the files; rather, they fully mirror the repository, including its full history. 分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 集中式版本控制：CVS、SVN、ClearCase、VSS分布式版本控制：Git、BitKeeper、Mercurial、Bazaar git和其他版本控制工具存储数据的方式不同： 其他版本控制工具存储一组文件以及基于这些文件随时间推移产生的差异 git存储更像快照，对当时的全部文件制作一个快照并保存这个快照的索引，如果没有修改则只保留一个指向之前存储文件的链接 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息SVN 中可以修改文件，但是无法向数据库提交修改 Git 中所有数据在存储前都计算校验和，然后以校验和来引用，校验和由 40 个十六进制字符组成，通过SHA1计算得出。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git的作用 备份文件 记录历史 回到过去 多端共享 团队协作 安装Git12sudo apt install gitsudo yum install git 帮助信息123git help &lt;verb&gt;git &lt;verb&gt; --helpman git &lt;verb&gt; 配置1git config 配置文件 /etc/gitconfig，系统配置，git config --system ~/.gitconfig 或 ~/.config/git/config，当前用户，git config --global 项目目录下的.git/config，当前仓库 当前仓库会覆盖当前用户配置，当前用户配置会覆盖系统配置 用户信息12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 全局配置只需设置一次当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置 列出所有配置1git config --list 配置别名1234567891011git config --global alias.st status# git stgit config --global alias.co checkout# git cogit config --global alias.ci commit# git cigit config --global alias.br branch# git brgit config --global alias.last &apos;log -1 HEAD&apos;# git last 最后一次提交 初始化在现有目录中初始化仓库12cd &lt;dir-name&gt;git init 克隆现有的仓库12345git clone git@github.com:fengrenxiaoli/GitTest.git# 在当前目录下创建一个 GitTest 目录，并在 GitTest 目录下创建 .git 文件夹git clone git@github.com:fengrenxiaoli/GitTest.git mylibgit# 在当前目录下创建一个 mylibgit 目录，并在 mylibgit 目录下创建 .git 文件夹 检查当前文件状态1git status tracked：已跟踪，那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区untracked：未跟踪，其他文件，使用git add &lt;file-name&gt;变为跟踪状态 三种状态和三个工作区域 状态 工作区域 命令 已修改modifed Workspace 已暂存staged Stage/Index git add &lt;file-name&gt; 已提交commited Local Repository/.git目录 git commit git add既可以用该命令开始跟踪新文件，也可以把已跟踪的文件放到暂存区 查看修改12345678910git diffgit diff readme.txt# 查看修改之后还没有暂存起来的修改内容(git add前)# 工作区(workspace)和暂存区(stage)的比较git diff HEAD --readme.txtgit diff --cached# 查看已暂存的将要添加到下次提交里的内容(git add后)# 暂存区(stage)和分支(master)的比较 添加和提交12345678910111213141516git add .git add readme.txt# 实际上是把文件修改添加到暂存区git commit# 提交更改，实际上是把暂存区的所有内容提交到当前分支# 会启动默认的编辑器输入注释信息# 没有git add但是已经修改的内容不会提交git commit -m &quot;增加文件&quot;# 直接声明注释信息git commit -m -a &apos;增加文件&apos;# git add + git commitgit commit --amend# 更改一次提交 忽略特殊文件忽略某些文件时，需要编写.gitignore.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理参考模版：https://github.com/github/gitignore 文件 .gitignore 的格式规范如下：• 所有空行或者以 # 开头的行都会被 Git 忽略。• 可以使用标准的 glob 模式（通配符模式）匹配。• 以 / 开头防止递归。• 以 / 结尾表示目录。• 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。 查看提交历史1234567891011121314151617181920212223242526272829303132333435363738git log# 查看提交历史，以便确定要回退到哪个版本，时间从最近到最远# 列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明git log -p# 显示每次提交的内容差异，可以用于代码审查git log -2# 最近再次提交git log --since=2.weeks# 最近两周提交git log --author=&quot;John&quot;# 指定作者（负责修改的人）git log --grep=&quot;关键字&quot;# 搜索提交信息中的关键字git log --author=&quot;John&quot; --grep=&quot;关键字&quot; --all-match# --all-match 同时匹配git log -S &quot;key&quot;# 仅显示添加或移除了某个关键字的提交git log -- path# 指定路径，放在最后git log --stat# 包含简略的统计信息git log --pretty=oneline# 指定显示格式，oneline表示单选显示，其他包括short\full\fullergit log --format=&quot;%h - %an - %ar - %s&quot;# 指定显示格式，具体选项，参考git log --help，或参考Pro-gitgit log --format=&apos;%h %s&apos; --graph# 图形化显示分支、合并历史git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \ --before=&quot;2008-11-01&quot; --no-merges -- t/# 2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件 撤消操作12345678910111213141516171819202122232425262728git checkout -- &lt;fiel-name&gt;# 未git add，回退到文件修改之前（丢弃工作区的修改），还原成上次提交时的样子# 对文件做的任何修改都会消失git reset # 默认为HEAD，索引会回滚到最后一次提交# 如果用--hard选项，工作目录也同样回滚git reset -- &lt;file-name&gt;# 撤销最后一次git addgit reset HEAD &lt;file-name&gt;# 已经git add（添加到了暂存区），需要回退未 git add 之前git reset HEAD &lt;file-name&gt;git checkout -- &lt;fiel-name&gt;# 已经git add（添加到了暂存区），还未git commit，需要回退到文件修改之前（丢弃工作区的修改）git reset --hard HEAD^# 已经git commit，还未git push，想要撤销本次提交，回退到上个版本git log# 查看提交历史，以便确定要回退到哪个版本git relog# 查看命令历史，以便确定要回到未来的哪个版本git reset --hard 1094adb# 回退到指定的commit id，commit id可以只写前几位 如果用–hard选项，那么工作目录也更新，如果用–soft选项，那么都不变 删除文件123456789101112rm readem.txtgit rm readme.txt# 未提交到暂存区域# 可以用git add代替git rm -f readme.txt# 删除已经添加到暂存区域的文件 git rm --cached readme.txt# 让文件保存在磁盘，但是禁止git继续跟踪# 适用于忘记添加 .gitignore 文件时 如果误删除了文件且没有git add，需要撤消1git checkout -- test.txt 远程仓库查看远程仓库1234567git remote# 列出指定的每一个远程服务器的简写git remote -v# 列出所有远程服务器的简写与其对应的 URLgit remote show &lt;remote-name&gt;# 远程仓库详细信息 origin是远程仓库的默认名字 添加远程库123git remote add &lt;remote-name&gt; &lt;url&gt;git remote add origin git@github.com:michaelliao/learngit.git# 可以使用默认名 origin ，也可以使用自定义的名字 从远程库克隆1git clone git@github.com:michaelliao/gitskills.git Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支 从远程仓库中抓取与拉取12345678910git fetch &lt;remote-name&gt;git fetch origin# 抓取克隆(或上一次抓取)后新推送的所有分支数据# 即远程仓库中有但本地没有的数据# 不会自动合并或修改你当前的工作。必须手动将其合并入你的工作git pull# 有一个分支设置为跟踪一个远程分支# 从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支 推送到远程仓库12345678910git push &lt;remote-name&gt; &lt;branch-name&gt;git push origin master# 要求对远程仓库有写入权限# 如果别人先推送到上游然后你再推送到上游，你的推送就会被拒绝# 必须先将他们的工作拉取下来（git pull）并将其合并（git merge）进你的工作后才能推送git push -u origin master# 如果本地分支没有关联远程分支，需要加上-u进行关联，以后就不需要了git push -u origin featureB:featureB 远程仓库的重命名1git remote rename origin hexo 远程仓库的删除1git remote rm origin 一个本地库关联多个远程库1234567git remote rm origin# 先删除已关联的名为origin的远程库git remote add github git@github.com:michaelliao/learngit.gitgit remote add gitee git@gitee.com:liaoxuefeng/learngit.git# 关联远程库，远程库的名称叫github、gitee 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。 查看标签123456789git tag# 查看所有标签git tag -l &apos;v1.8.5*&apos;# 查看特定标签git show &lt;tag-name&gt;git show v1.4# 某个标签的详细信息 创建标签轻量标签只是特定提交的引用123git master# 切换到相应分支git tag v1.4-lw 附注标签存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard (GPG)签名与验证 1git tag -a v1.4 -m &apos;some message&apos; -a 表示是附注标签-m 表示存储在标签中的信息 后期打标签12git tag -a v0.9 f52c633# 针对某一commit id打标签 推送标签推送标签到远程服务器12345git push &lt;remote-name&gt; &lt;tag-name&gt;git push origin v1.5git push origin --tags# 把所有不在远程仓库服务器上的标签全部传送到远程服务器 1234567891011git tag -d v0.1# 删除一个本地标签git push origin v1.0# 推送某个标签到远程git push origin --tags# 一次性推送全部尚未推送到远程的本地标签git tag -d v0.9git push origin :refs/tags/v0.9# 删除推送到远程的标签 分支管理Git的分支，本质上仅仅是指向提交对象的可变指针master：Git的默认分支名HEAD是一个指针，指向当前所在的本地分支一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上 创建分支123456789101112git branch testing# 只是为你创建一个可以移动的新的指针，不会自动切换git branch -b testing # 创建并切换分支git log --oneline --decorate # 查看各个分支当前所指的对象# master和dev指向同一对象git branch develop master # 从master分支上新建develop分支 分支切换123git checkout testing# 已经存在的分支# HEAD 指向 testing 分支 在 testing 分支提交文件之后的变化 切换回 master 分支后的变化，工作目录的内容会变成 master 最全后一次提交的情况 在 master 分支提交文件 查看分支123456789101112131415git log --oneline --decorate# 查看各个分支当前所指的对象git log --oneline --decorate --graph --all# 查看分叉历史git branch# 列出所有分支，* 表示当前分支git branch -v# 每一个分支的最后一次提交git branch --merged# 看哪些分支已经合并到当前分支git branch --no-merged# 查看所有包含未合并工作的分支，无法使用 -d 选项删除，可以使用 -D 选项强制删除 合并分支12345678910111213141516171819git commit -a -m &quot;...&quot;# 先提交# 三方合并git checkout master# 切换回需要合并到的分支 git merge hotfix# 合并分支到当前分支# 直接把 master 指向 hotfix 的当前提交，就完成了合并# 分支合并可能会遇到冲突，需要手动解决并提交git status# 查看冲突vim &lt;conflict-file-name&gt;git add &lt;conflict-file-name&gt;git commit -m &quot;....&quot;# 不需要再次 merge fast-forward：没有需要解决的冲突，直接将 HEAD 指向分支 一次合并提交：三方合并，你的开发历史从一个更早的地方开始分叉开来 non-fast-forward：存在需要解决的冲突，需要先拉取到本地并进行合并才能推送 删除分支删除不再需要的分支12git branch -d hotfix# 删除 hotfix 分支就是把 hotfix 指针给删掉 分支开发工作流长期分支在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中比如只在 master 分支上保留完全稳定的代码 特性分支短期分支，它被用来实现单一特性或其相关工作 Bug分支每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 假定需要在master分支上修复，就从master创建临时分支12345678910111213141516git stash# 保存现场工作git checkout mastergit checkout -b issue-101git add readme.txt git commit -m &quot;fix bug 101&quot;git checkout mastergit merge --no-ff -m &quot;merged bug fix 101&quot; issue-101git checkout dev# 切换到之前的工作分支git stash list# 列出保存的工作现场git stash pop# 恢复的同时把stash内容也删了 Feature分支添加一个新功能123456git checkout -b feature-vulcan# 原来在dev分支git add vulcan.pygit commit -m &quot;add feature vulcan&quot;git checkout dev 12git branch -D feature-vulcan# 强行删除分支，未合并之前删除使用 远程分支之前的分支操作都是在本地执行的。 远程跟踪分支是远程分支状态的引用。以 (remote)/(branch) 形式命名，比如 origin/master 表示远程的master分支 12git fetch origin# 更新本地数据 推送12345git push origin serverfix# 推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支git push origin serverfix:awesomebranch# 本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支 其他协作者通过 git fetch origin 会下载新的分支，但不能修改12345git merge origin/serverfix# 合并分支git checkout -b serverfix origin/serverifx# 跟踪远程分支，这样本地可以修改 serverfix 分支 跟踪分支跟踪分支是与远程分支有直接关系的本地分支当克隆一个仓库时,它通常会自动地创建一个跟踪 origin/master 的 master 分支 123456789101112git checkout -b &lt;branch&gt; &lt;remote-branch&gt;git checkout -b sf origin/serverfix# 本地分支名和远程分支名不同git branch -u orgin/serverfix# 创建分支，跟踪远程分支git fetch --allgit branch -vv# 查看设置的所有跟踪分支，需要先更新# 可以确定本地分支与远程分支是否是领先（ahead）、落后（ahead）或是都有（说明远程有其他提交，本地也有提交） 拉取12git pull# 更新本地仓库至最新改动并尝试合并 也就是 git fetch 和 git merge，建议显示使用 git fetch 和 git merge 删除远程分支1git push origin --delete &lt;remote-branch&gt; 变基变基是另一种合并方式不要对在你的仓库外有副本的分支执行变基 变基使得提交历史更加整洁，提交历史是一条直线没有分叉 首先找到这两个分支(即当前分支 experiment、变基操作的目标基底分支 master)的最近共同祖先 C2,然后对比当前分支相对于该祖先的历次提交,提取相应的修改并存为临时文件,然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用 123456789git checkout experimentgit rebase mastergit checkout master git merge experimentgit rebase &lt;basebranch&gt; &lt;topicbranch&gt;git rebase master servergit checkout mastergit merge server 解决冲突不同的分支各自都分别有新的提交，当进行合并时就会发生冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件 修改文件中的冲突后可以再次提交 用git log --graph命令可以看到分支合并图产品 git有个最佳实践，master是主分支，用来做正式发布版之后的保留历史，其他分支包括dev用来做正常开发，多个feature用来做某些特性功能，release用来做发布版历史，每次发布都是用release打包，hotfix用来做发布版之后的一些及时迭代修复bug的工作。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并1git merge --no-ff -m &quot;merge with no-ff&quot; dev 多人协作12345678910111213git push origin mastergit push origin dev# 推送分支git clone git@github.com:michaelliao/learngit.gitgit branch# 默认是master分支git checkout -b dev origin/dev# 创建dev分支git pullgit branch --set-upstream-to=origin/dev dev# 解决冲突 工作流私有小型团队有一两个其他开发者的私有项目 私有管理团队独立小组的工作只能被特定的工程师整合,主仓库的master 分支只能被那些工程师更新 假设 John 与 Jessica 在一个特性上工作,同时 Jessica 与 Josie 在第二个特性上工作 git flow master分支，即主分支。任何项目都必须有个这个分支。对项目进行tag或发布版本等操作，都必须在该分支上进行。 develop分支，即开发分支，从master分支上检出。团队成员一般不会直接更改该分支，而是分别从该分支检出自己的feature分支，开发完成后将feature分支上的改动merge回develop分支。同时release分支由此分支检出。 release分支，即发布分支，从develop分支上检出。该分支用作发版前的测试，可进行简单的bug修复。如果bug修复比较复杂，可merge回develop分支后由其他分支进行bug修复。此分支测试完成后，需要同时merge到master和develop分支上。 feature分支，即功能分支，从develop分支上检出。团队成员中每个人都维护一个自己的feature分支，并进行开发工作，开发完成后将此分支merge回develop分支。此分支一般用来开发新功能或进行项目维护等。 fix分支，即补丁分支，由develop分支检出，用作bug修复，bug修复完成需merge回develop分支，并将其删除。所以该分支属于临时性分支。 hotfix分支，即热补丁分支。和fix分支的区别在于，该分支由master分支检出，进行线上版本的bug修复，修复完成后merge回master分支，并merge到develop分支上，merge完成后也可以将其删除，也属于临时性分支。 参考： git-flow 备忘清单 Git 在团队中的最佳实践–如何正确使用Git Flow 大话 Git 工作流 图文详解如何利用Git+Github进行团队协作开发 深入理解学习Git工作流（git-workflow-tutorial） Learn Version Control with Git 搭建Git服务器以下方式为通过ssh协议搭建的Git服务器，添加了公钥的用户可以进行读写操作 1.安装git1sudo apt install git 2.创建用户123456cat /etc/shellswhich git-shellsudo vim /etc/shells# 添加git-shell的位置，git-shell可以禁止使用ssh登录shellsudo adduser git -s /usr/bin/git-shell 3.管理公钥收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个人多可以用Gitosis来管理公钥 注意权限123456789su gitcdmkdir .sshchmod 700 .sshtouch .ssh/authorized_keyschmod 600 .ssh/authorized_keyscat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keyscat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys 4.初始化Git仓库选定一个目录作为Git仓库123456cd /opt/gitmkdir project.gitcd project.gitgit init --barechown -R git:git project.git 需要有一个人推送第一个版本123456cd myprojectgit initgit add .git commit -m &apos;initial commit&apos;git remote add origin git@gitserver:/opt/git/project.gitgit push origin master 5.克隆远程仓库在各自的电脑上克隆远程仓库1git clone git@server:/srv/sample.git Git不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 还有其他方式，比如适合快速只读访问的Git守护进程，既可以进行授权访问又可以进行无授权访问的Smart HTTP，使用GitWeb搭建网页展示，参考Pro-git 利用工具提升工作效率，而不是去学习工具本身 多用客户端和工具，少用命令行，除非在linux服务器上直接开发 每次提交前，diff自己的代码，以免提交错误的代码 下班回家前，整理好自己的工作区 并行的项目，使用分支开发 遇到冲突时，搞明白冲突的原因，千万不要随意丢弃别人的代码 参考： 比较全面的 Git 学习资料整理 http://www.cylong.com/blog/2016/09/26/git-svn/ http://rogerdudler.github.io/git-guide/ https://guides.github.com/activities/hello-world/ 分布式和集中式版本控制工具-svn,git,mercurial Git在工作中的小总结 图解Git]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2Fpost%2Ff7ede91d.html</url>
    <content type="text"><![CDATA[基础JVM JRE JDKJVM：Java Virtual MachineJDK：Java Development Kit（Java开发工具包）JRE：Java Runtime Environment（Java运行环境） java文件执行过程 源代码文件 .java 编译器编译 字节码文件 .class 解释器解释 执行 跨平台通过JVM实现 JRE包含JVM，JDK包含JRE 环境变量JAVA_HOME 配置JDK安装路径，通常Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。PATH 配置JDK命令文件的位置CLASSPATH 配置类库文件的位置 Java 关键字区分大小写 标识符标识符就是用于给 Java 程序中变量、类、方法等命名的符号。类名、变量名、方法名等都是标识符使用标识符时，需要遵守几条规则： 标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。 标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Myvoid 可以 标识符是严格区分大小写的。 所以涅，一定要分清楚 imooc 和 IMooc 是两个不同的标识符哦！ 标识符的命名最好能反映出其作用，做到见名知意。 变量在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。 变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge2.变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName 保存“学生姓名”信息 基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址String 是一种常见的引用数据类型，用来表示字符串。char使用两个字节，使用单引号括起来 Java 中的变量需要先声明后使用 变量使用时，可以声明变量的同时进行初始化，也可以先声明后赋值 变量中每次只能赋一个值，但可以修改多次 main 方法中定义的变量必须先赋值，然后才能输出 虽然语法中没有提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患，譬如后期跨平台操作时出现乱码等等 自动类型转换 目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型 目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以了 强制类型转换1(数据类型)数值 数值上并未进行四舍五入，而是直接将小数位截断。强制类型转换可能会造成数据的丢失 常量它的值被设定后，在程序运行过程中不允许改变1final 常量名 = 值; 常量名一般使用大写字符 注释一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。 Java 中注释有三种类型：单行注释、多行注释、文档注释文档注释以/**开头,以*/结尾多行注释以/*开头,以/结尾单行注释以/开头,行未结尾 通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。1javadoc -d doc Demo03.java 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息：123456@author 标明开发该类模块的作者@version 标明该类模块的版本@see 参考转向，也就是相关主题@param 对方法中某参数的说明@return 对方法返回值的说明@exception 对方法可能抛出的异常进行说明 运算符Java 语言中常用的运算符可分为如下几种： 算术运算符 赋值运算符 比较运算符 逻辑运算符 条件运算符 ++出现在左边,先执行自增,然后赋值++出现在右边,先赋值,后执行自增 12double ave = 24/4;System.out.println(ave); 结果是6.0 比较的结果是一个布尔值（ true 或 false ） &gt;、&lt; 、 &gt;= 、 &lt;=只支持左右两边操作数是数值类型 == 、 != 两边的操作数既可以是数值类型，也可以是引用类型 equals()用于判断字符串的内容是否相同,相同返回true,反之false “短路”现象譬如：( one &gt; two ) &amp;&amp; ( one &lt; three ) 中，如果能确定左边 one &gt; two 运行结果为 false , 则系统就认为已经没有必要执行右侧的 one &lt; three 啦。 同理，在( one &gt; two ) || ( one &lt; three ) 中，如果能确定左边表达式的运行结果为 true , 则系统也同样会认为已经没有必要再进行右侧的 one &lt; three 的执行啦！ 1布尔表达式 ？ 表达式1 ：表达式2 如果布尔表达式的值为 true ，则返回 表达式1 的值，否则返回 表达式2 的值 流程控制语句if语句123if (score&gt;90)&#123; System.out.println(&quot;哟&quot;);&#125; 12345if (score&gt;90)&#123; System.out.println(&quot;哟&quot;);&#125;else&#123; System.out.println(&quot;噢&quot;);&#125; 1234567if (score&gt;90)&#123; System.out.println(&quot;哟&quot;);&#125;else if (score &gt;70)&#123; System.out.println(&quot;噢&quot;);&#125;else&#123; System.out.println(&quot;喵&quot;);&#125; 123456789if (score&gt;90)&#123; if (sex.equals(&quot;&quot;))&#123; System.out.println(&quot;哟&quot;); &#125;else &#123; System.out.println(&quot;噢&quot;); &#125;&#125;else&#123; System.out.println(&quot;喵&quot;);&#125; switch语句1234567891011121314int num =1;switch(num)&#123; case 1: System.out.println(&quot;1&quot;); break; case 2: System.out.println(&quot;2&quot;); break; case 3: System.out.println(&quot;3&quot;); break; default: System.out.println(&quot;default&quot;);&#125; 执行过程：当 switch 后表达式的值和 case 语句后的值相同时，从该位置开始向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。 switch 后面小括号中表达式的值必须是整型或字符型 case 后面的值可以是常量数值，如 1、2；也可以是一个常量表达式，如 2+2 ；但不能是变量或带有变量的表达式，如 a * 2 case 匹配后，执行匹配块里的程序代码，如果没有遇见 break 会继续执行下一个的 case 块的内容，直到遇到 break 语句或者 switch 语句块结束 default 块可以出现在任意位置，也可以省略 可以把功能相同的 case 语句合并起来 123case 1:case 2: System.out.println(&quot;&quot;); while先判断，后执行12345int i=1;while(i &lt;=1000)&#123; System.out.println(&quot;嗯&quot;); i++;&#125; do…while先执行，后判断保证循环至少被执行一次 12345int i=1;do&#123; System.out.println(&quot;哦&quot;); i++&#125;while (i&lt;=1000); for123for(int i=0;i&lt;=1000;i++)&#123; System.out.println(&quot;咦&quot;);&#125; for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略。 省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作 省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象 省略“循环变量变化”，可以在循环体中进行循环变量的变化 for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值 循环条件部分可以使用逻辑运算符组合的表达式，表示复杂判断条件，但一定注意运算的优先级 break break 语句退出指定的循环，直接执行循环后面的代码。 continue跳过循环体中剩余的语句执行下一次循环 多重循环 java.util.Scanner类 ，输入1234import java.util.Scanner;Scanner scanner = new Scanner(System.in);System.out.println(&quot;Please input score:&quot;);int score = scanner.nextInt(); System.out.println 换行输出System.out.print 不换行输出 数组1234567891011121314151617181920212223242526272829# 声明int[] scores;double height[];# 分配空间scores = new int[5];height = new double[5];int[] scores = new int[5];# 赋值scores[0] = 89;scores[1] = 79;int[] scores = &#123;87,89&#125;;# 造价于 int[] scores = new int[]&#123;87,89&#125;;# 取值scores[1]# 长度scores.lenght;# 遍历for(int i =0;i&lt;scores.length;i++)&#123; System.out.println(scores[i]);&#125;for(int score:scores)&#123; System.out.println(score);&#125; 数组中的元素都可以通过下标来访问，下标从 0 开始。数组下标的范围是 0 至 数组长度-1，如果越界访问，就会报错。 ArraysArrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等 12345678import java.util.Arrays;Arrays.sort(scores);# 正序排列# 改变原数组Arrays.toString(scores);# 将数组转换为字符串，多个元素之间使用逗号和空格隔开 二维数组123456789101112131415# 声明int[][] nums = new int[2][3];# 赋值nums[0][0] = 12;# 取值nums[1][1];# 遍历for(int i = 0; i&lt; nums.length; i++)&#123; for(int j =0; j&lt;nums[i].length; j++)&#123; System.out.println(nums[i][j]); &#125;&#125; 方法定义方法123访问修饰符 返回值类型 方法名(参数列表)&#123; 方法体&#125; 访问修饰符：方法允许被访问的权限范围， 可以是 public、protected、private 甚至可以省略 返回值类型：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。方法的返回值最多只能有一个，不能返回多个值 方法名：定义的方法的名字，必须使用合法的标识符 参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。定义方法时的参数称为形参，目的是用来定义方法需要传入的参数的个数和类型；把调用方法时的参数称为实参，是传递给方法真正被处理的值。调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应。多个参数间以逗号分隔 方法体放在一对大括号中，实现特定的操作 方法名主要在调用这个方法时使用，需要注意命名的规范，一般采用第一个单词首字母小写，其它单词首字母大写的形式 调用方法1对象名.方法名(); 重载如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载 当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。 判断方法重载的依据： 必须是在同一个类中 方法名相同 方法参数的个数、顺序或类型. 与方法的修饰符或返回值没有关系 类和对象类类是对象的类型具有相同属性和方法的一组对象的集合 属性：对象具有的各种特征方法：对象执行的操作 所有Java程序都以类class为组织单元 定义类的方法： 定义类名 编写类的属性 编写类的方法 对象使用对象的步骤 创建对象类名 对象名 = new 构造方法(); 使用对象对象名.属性;对象名.方法(); 成员变量和局部变量成员变量：即类的属性局部变量：类的方法中定义的变量 成员变量和局部变量的区别 作用域不同：局部变量的作用域仅限于定义它的方法，成员变量的作用域在整个类内部都是可见的。 初始值不同：java会给成员变量一个初始值，java不会给局部变脸赋予初始值。 在同一个方法中，不允许有同名局部变量；在不同的方法中，可以有同名局部变量。 两类变量同名时，局部变量具有更高的优先级（就近原则）。 构造方法构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且没有返回值 构造方法的语法格式:123public 类名(参数)&#123;//初始化代码&#125; public后面没有返回值类型，构造方法名与类名相同，括号内可以指定参数 构造方法分为无参构造方法和有参构造方法。有参构造方法的目的就是初始化对象中成员变量的值。通过无参或者有参的构造方法都可以创建对象，但是后者不但可以创建对象而且可以给对象中的实例变量赋初值 使用new+构造方法创建一个新的对象，当我们创建对象的时候,其实我们执行的是构造方法 当没有指定构造方法时，系统会自动添加无参的构造方法，可以自定义无参的构造方法 当有指定构造方法时，无论是有参无参的构造方法，都不会自动添加无参的构造方法 构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法 构造方法不但可以给对象的属性赋值，还可以通过条件判断保证给对象的属性赋一个合理的值 static关键字静态变量Java 中被 static 修饰的变量称为静态变量或类变量。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。 使用 static 可以修饰变量、方法和代码块。 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收 静态方法使用 static 修饰方法，称为静态方法或类方法。 main 方法就是静态方法。 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。 静态数据块Java 中可以通过初始化块进行数据赋值123456public class HelloWorld&#123; String name; &#123; name = &quot;John&quot;; &#125;&#125; 在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。 程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。 面向对象的三大特性：封装、继承、多态 封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。 好处：只能通过规定的方法访问数据；隐藏类的实例细节，方便修改和实现。 封装实现方法： 修改属性可见性，设为private。 创建getter\setter方法，用于属性的读写。 在getter\setter中加入属性控制语句(对属性值的合法性进行判断)。 包packege，包名间可以用点来区别文件夹且要放在java程序的第一行包名间用.隔开 包的作用：1.管理java文件2.管理同名文件冲突加上不同的包来区分相同文件名的类例如：音乐类——MyClassMusic12com.imooc.music.MyClassMusiccom.imooc.movie.MyClassMusic 系统中的包java.lang.(类) 放置java语言基础类java.util.(类)放置java语言工具类java.io.(类)包含输入输出相关功能的类 包的使用 可以使用import关键字，在某个文件使用其他文件中的类。import com.imooc.music.MyClass java中，包的命名规范是全小写字母拼写 使用的时候不但可以加载某个包下的所有文件com.imooc.*。也可以加载某个具体子包下的所有文件com.imooc.music.* 访问修饰符修饰属性和方法的访问范围 this关键字this关键字代表当前对象this.属性 操作当前对象的属性this.方法 调用当前对象的方法 封装对象的属性的时候，经常会使用this关键字 内部类内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。 内部类作用： 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 内部类的方法可以直接访问外部类的所有数据，包括私有的数据 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类分类 成员内部类 静态内部类 方法内部类 匿名内部类 成员内部类内部类中最常见的就是成员内部类，也称为普通内部类。 12345678910111213141516public class Outer&#123; private int a = 99; public class Inner&#123; int b = 2; public void test()&#123; System.out.println(&quot;外部类中的变量a：&quot;+a); System.out.println(&quot;内部类中的变量b：&quot;+b); &#125; &#125; public static void main(String[] args)&#123; Outer outer = new Outer(); Inner i = outer.new Inner(); i.test(); &#125;&#125; Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等。 Inner 类中定义的 test() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a。 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( ); 编译上面的程序后，会发现产生了两个 .class 文件，成员内部类的 .class 文件总是这样命名：外部类名$内部类名.class 外部类是不能直接使用内部类的成员和方法 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字（名字不相同的变量或方法可以直接访问）。 静态内部类静态内部类是 static 修饰的内部类，这种内部类的特点是： 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 1234567891011121314151617public class SOuter&#123; private int a = 99; static int b = 1; int c = 3; public static class SInner&#123; int b = 2; public void test()&#123; System.out.println(&quot;访问外部类的私有成员a：&quot;+new SOuter().a); System.out.println(&quot;访问外部类的静态成员b：&quot;+SOuter.b); System.out.println(&quot;访问外部类的非静态成员c：&quot;+ new SOuter().c); &#125; &#125; public static void main(String[] args)&#123; SInner si = new SInner(); si.test(); &#125;&#125; 方法内部类方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。 1234567891011121314151617181920public class MOuter&#123; public void show()&#123; final int a = 25; int b = 13; class MInner&#123; int c = 2; public void print()&#123; System.out.println(&quot;访问外部类的方法中的常量a：&quot;+a); System.out.println(&quot;访问外部类中的变量b：&quot;+b); System.out.println(&quot;访问内部类中的变量c：&quot;+c); &#125; &#125; MInner mi = new MInner(); mi.print(); &#125; public static void main(String[] args)&#123; MOuter mo = new MOuter(); mo.show(); &#125;&#125; 继承继承是类与类的一种关系；Java中的继承是单继承，只有一个父类。 继承的好处： 子类拥有父类的所有属性和方法。(private修饰的属性和方法无法继承) 代码可复用 语法规则123class 子类 extends 父类&#123; ……&#125; 方法的重写如果子类对继承父类的方法不满意，是可以重写父类继承的方法的，当调用方法时会优先调用子类的方法。 语法规则 返回值类型 方法名 参数类型及个数都要与父类继承的方法相同，才叫方法的重写。 重写方法的规则： 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。如果在子类中写了一个只有返回类型不同的函数，将不是重写，且会报错 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private） 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。 重载的规则： 必须具有不同的参数列表。 可以有不责骂的返回类型，只要参数列表不同就可以了。 可以有不同的访问修饰符。 可以抛出不同的异常。 重写与重载的区别在于： 重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。 用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般. 重写是除了函数体其他必须完全相同，如果参数不同则是重载，如果参数相同而返回类型不同则会报错 继承的初始化顺序 初始化父类再初始化子类。2.先执行初始化对象中属性，再执行构造方法中的初始化。 综合以上两点，顺序为：父类属性初始化—》父类构造方法—》子类属性初始化—》子类构造方法。 在一个不存在继承的类中：初始化static变量—》执行static初始化快—》初始化普通成员变量(如果有赋值语句)—》执行普通初始化块—》构造方法 在一个存在继承的类中：初始化父类static成员变量—》运行父类static初始化块—》初始化子类static成员变量—》运行子类static初始化块—》初始化父类实例成员变量(如果有赋值语句)—》执行父类普通初始化块—》父类构造方法—》初始化子类实例成员变量(如果有赋值语句)及普通初始化块—》子类构造方法。 注意：其中变量初始化(赋值)和初始化块的执行与相关语句在源码中的放置顺序一致，不过变量声明会最先执行 final关键字final关键字表示“最终的”，即不可修改。 final可以修饰类、方法、属性和变量 修饰类：不允许被继承 修饰方法：不允许被重写 修饰属性：则该属性不会进行隐式初始化（不会自动初始化），需要手动初始化或者在构造方法中初始化 （但二者只能选一，即只能初始化一次后便不能更改） 修饰变量，只能在声明的时候赋一次值，成为常量。 （static final 会使其成为全局常量） super关键字super关键字在对象内部使用，代表父类对象 访问父类的属性super.age 访问父类方法super.eat(); 调用父类的构造方法super([参数]); 调用父类的构造方法需要注意：1.子类的构造过程中必须调用其父类的构造方法2.如果子类的构造方法没有显式调用父类的构造方法，则系统会默认调用父类的无参构造方法。3.如果显示的调用构造方法，必须在子类的构造方法的第一行，super()。4.如果子类的构造方法中既没有显示调用父类的构造方法，父类又没有无参的构造方法，则编译就会报错 Object类Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类，且Object类中的方法适用于所有子类 toString()方法在Object类中的toString()方法返回对象的哈希code码(对象地址字符串) 如果我们在代码里面直接输出一个对象System.out.println(new TelePhone);，会输出这个对象在内存中的地址，我们把它称为哈希码，哈希码是通过哈希算法生成的一个字符串用来唯一区分对象的 可以通过重写toString()方法表示出对象的属性 getClass()方法getClass()可以得到一个类对象，当我们new的时候得到的是一个类的对象，如果对象调用getClass()方法我们得到的是类对象，类对象描述的是类的代码信息(类的代码信息:这个类有哪些属性\它是什么类型\变量名是什么\它有哪些方法\方法名是什么\方法里面的代码是什么；而类的对象关注的是对象的属性值的信息或者说这个对象的数据信息) equals方法Object类中的equals()用于比较对象的引用是否指向同一块内存地址（对象实例化时，即给对象分配内存空间） 在比较引用对象是否相同时，==比较对象是否相等和equals一样于比较对象的引用是否指向同一块内存地址（对象实例化时，即给对象分配内存空间） 在比较引用对象是否相同时，==比较对象是否相等和equals一样 使用方法如：dog.equals(dog2); 如果是两个对象，但想判断两个对象的属性是否相同，则重写equals()方法（ecplise和Intellij都提供了自动生成重写equals方法的功能，equals() and hascode()） 1234567891011@Overridepublic boolean equals(Object o) &#123; //地址是否相同，即是否为同一对象 if (this == o) return true; //对象是否为空，getClass()可以得到类对象，判断类的属性是否一样 if (o == null || getClass() != o.getClass()) return false; Telephone telephone = (Telephone) o; return Float.compare(telephone.cpu, cpu) == 0 &amp;&amp; Float.compare(telephone.screen, screen) == 0 &amp;&amp; Float.compare(telephone.mem, mem) == 0;&#125; 多态多态指的是对象的多种形态主要分为引用多态、方法多态继承是多态的实现基础 引用多态 父类引用可以指向本类对象 Animal obj1 = new Animal(); 父类引用可以指向子类对象 Animal obj2 = new Dog();但是我们不能用子类的引用指向父类对象 Dog obj3 = new Animal();//错 方法多态 父类创建本类对象时，调用的方法为本类方法 父类创建子类对象时候，调用的方法为子类重写的方法或者父类的方法 不能父类引用调用子类自己的方法 123456789Animal obj1 = new Animal();Animal obj2 = new Dog();Animal obj3 = new Cat();obj1.eat();//Animal的方法obj2.eat();//Dog重写的方法obj3.eat();//Cat没有重写，使用继承自Animal中的方法obj2.watchDoor();//不能父类引用调用子类自己的方法 引用类型转换 向上类型转换（隐式/自动类型转换），小类型到大类型的转换 向下类型转换（强制类型转换），大类型到小类型的转换（存在风险，溢出） instanceof运算符，用来解决引用对象的类型，避免类型转换的安全性问题 12345678910111213141516Dog dog=new Dog();Animal animal=dog;//正确，自动类型提升，向上类型转换Dog dog1=(Dog)animal;//向下类型转换Cat cat=(Cat)animal;/*编译时不会出错（按Cat类型进行编译），但运行时会报错，因为它开辟的是Dog类型的空间，而（无法将引用类型进行转换）无法将dog对象转换成Cat类型，并且此方法对程序的安全性有影响。此时应该利用instanceof和if语句结合使用，进行验证，以保证程序的安全性*/if(animal instanceof Cat)&#123; //判断animal类中是否包含Cat类型的元素，若包含则进行转换，instanceof返回值为布尔类型 Cat cat=(Cat)animal;&#125;else&#123;System.out.println(&quot;无法进行类型转换&quot;);&#125; 抽象类抽象类钱使用abstract关键字修饰，则该类为抽象类。 应用场景 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性 作用限制规定子类必须实现某些方法，但不关注实现细节 使用规则 abstract定义抽象类 abstract定义抽象方法，只有声明，不需要实现，没有方法体 包含抽象方法的类是抽象类 抽象类中可以包含普通的方法，也可以没有抽象方法 抽象类不能直接创建，可以使用引用变量 只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。 1234public abstract class Shape &#123; public abstract float circuit();//周长 public abstract float area();//面积&#125; 接口定义接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。 类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。 语法和类定义不同，定义接口不再使用class关键字，而是使用interface关键字。 12345[修饰符] [abstract] interface 接口名 [extends 父接口1，父接口2...]&#123; 零个到多个常量定义... 零个到多个抽象方法的定义...(抽象方法的abstract会自动加)&#125; 接口就是用来被继承、被实现的，修饰符一般建议用public，注意:不能使用private和protected修饰接口接口中的属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上接口中的方法只能是抽象方法，即使定义时不添加public abstract修饰符，系统也会自动加上 一个类可以实现一个或多和接口，实现接口使用implements关键字。java中一个类只能继承一个父类，可以通过实现多个接口作补充 继承父类实现接口的语法：123[修饰符] class 类名 extends 父类 implements 接口1，接口2……&#123;类体部分//如果继承的是抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法&#125; 如果要继承父类，继承父类必须在实现接口之前接口命名时通常首字母为I，以区分类名 实现实现时可以利用接口的引用指向实现了接口的对象，调用其方法1234IPlayGame ip1 = new Psp();IPlayGame ip2 = new SmartPhone();ip1.playGame();//Psp和SmartPhone都是实现了IPlayGame接口的playGame方法 配合匿名内部类使用接口的使用还经常与匿名内部类配合匿名内部类就是没有名字的内部类，多用于关注实现而不关注实现类的名称 语法格式：123456IPlayGame ip=new IPlayGame()&#123; public void playGame()&#123; System.out.print(&quot;匿名内部类实现接口的方式……&quot;); &#125;&#125;;ip.playGame(); 即通过创建接口的对象，直接写出实现的方法，再调用此方法注意结尾的逗号 还可以直接创建并调用方法，如：12345new IPlayGame()&#123; public void playGame()&#123; System.out.println(&quot;……&quot;); &#125;&#125;.playGame(); 项目分析 数据模型分析 业务模型分析 显示和流程分析 数据模型分析将现实世界的事与物的主要特征 –分析–抽象–&gt; 信息系统数据存取的数据结构以及约束信息，数据结构的组成：操作（方法）、属性 业务模型分析在设计应用程序前，应该明确该应用必须执行哪些任务。 分析业务需求量是应用程序开发中最重要的步骤之一。 确认业务需求的目的在于创建一个能同时满足零售商和消费者需要的解决方案。 显示和流程分析 显示：用户可以看到的信息提示界面 流程：显示信息的执行过程和步骤 异常阻止当前方法或作用域正常运行 异常处理的作用Java异常体系结构所有异常都继承于Throwable类，其下有两大子类： Error类：错误，如虚拟机错误(VirtualMachineError)、线程死锁(ThreadDeath)。会使程序崩溃 Exception类：异常，编码、环境、用户输入等问题 Exception类其子类主要有： 非检查异常(运行时异常RuntimeException)，由java虚拟机自动捕获 检查异常CheckException，需要手动添加捕获和处理语句，包括文件异常IOException、SQL异常SQLException等 捕获异常try-catch（多catch块）-finally try块：负责捕获异常，一旦try中发现异常，程序的控制权将被移交给catch块中的异常处理程序。【try语句块不可以独立存在，必须与 catch 或者 finally 块同存】 catch块：如何处理？比如发出警告：提示、检查配置、网络连接，记录错误等。执行完catch块之后程序跳出catch块，继续执行后面的代码。·编写catch块的注意事项：多个catch块处理的异常类，要按照先catch子类后catch父类的处理方式，因为会【就近处理】异常（由上自下）。 finally：最终执行的代码，用于关闭和释放资源等，无论是否出现异常，finally块中代码都会执行 多重异常处理代码块顺序问题：先子类再父类（顺序不对也会提醒错误），finally语句块处理最终将要执行的代码 当try和catch中有return时，finally仍然会执行，顺序如下1）有错误情况下如果finally块中有return语句，try语句 -&gt; catch -&gt; finally -&gt; finally.return如果finally块中没有return语句，try语句 -&gt; catch -&gt; finally -&gt; catch.return2）无错误情况下如果finally{}块中有return语句，try语句 -&gt; finally -&gt; finally.return如果finally{}块中没有return语句，try语句 -&gt; finally -&gt; try.return 12345678910111213141516171819202122public class TryCatchTest &#123; public static void main(String[] args)&#123; TryCatchTest tct = new TryCatchTest(); int x = tct.test(); System.out.println(x); &#125; public int test()&#123; try&#123; System.out.println(&quot;try&quot;); throw new Exception(&quot;xxx&quot;); //return 999; &#125;catch (Exception e)&#123; System.out.println(&quot;catch&quot;); return -1; //-1为抛出异常的习惯写法 &#125; finally &#123; System.out.println(&quot;finally&quot;); &#125; &#125;&#125; 如果方法中try,catch,finally中没有return语句，则会调用这三个语句块之外的return结果e.printStackTrace()可以输出异常信息 抛出异常1.throws的异常列表可以是抛出一条异常，也可以是抛出多条异常，每个类型的异常中间用逗号隔开2.方法体中调用会抛出异常的方法或者是先抛出一个异常：用throw new Exception()，throw写在方法体里，表示“抛出异常”这个动作3.如果某个方法调用了抛出异常的方法，那么必须添加try... catch语句去尝试捕获这种异常，或者添加声明，将异常抛出给更上一层的调用者进行处理 1234public void 方法名（参数列表）throws 异常列表&#123; //调用会抛出异常的方法或者： throw new Exception();&#125; 自定义异常当实际应用中需要用到Java中没有的异常，就需要自定义异常自定义异常需要继承于Java类库中意思相近的异常，或者直接继承Exception1class 自定义异常类 extends 异常类型｛｝ 1234public class DrunkException extends Exception &#123; public DrunkException()&#123;&#125; public DrunkException(String message)&#123;super(message);&#125;&#125; 异常链异常链指将捕获的异常包装进一个新的异常中，在新异常里添加原始的异常，并重新抛出的异常处理方式。原异常被保存为新异常的一个属性（比如cause）。这个想法是指一个方法应该抛出定义在相同的抽象层次上的异常，但不会丢弃更低层次的信息。 一个方法应该抛出定义在相同的抽象层次上的异常，（将所有捕获到的异常包装为新的异常类，即定义在相同的抽象层次上抛出）但不会丢弃更低层次的信息。 1234567891011121314151617181920212223242526272829303132public class chainTest &#123; /** * @param args * Test1抛出喝大了异常 * Test2调用test1捕获了喝大了异常，并且包装成运行时异常，继续抛出 * main方法中调用test2尝试捕获test2方法抛出的异常 */ public static void main(String[] args) &#123; try&#123; chainTest ct=new chainTest(); ct.Test2();&#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public void Test1()throws DrunkException&#123; throw new DrunkException(&quot;喝车别开酒&quot;); &#125; public void Test2()&#123; try&#123; Test1(); &#125;catch( DrunkException e)&#123; RuntimeException rte=new RuntimeException(e); //运行时异常，是所有java虚拟机正常操作期间可以被抛出异常的父类 //rte.initCause(e); //一种对异常的一种包装技巧。initCause()的作用是保存原始的异常，当想要知道底层发生了什么异常的时候调用getCause()就能获得原始异常。 e.printStackTrace(); throw rte; &#125; &#125;&#125; 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常 对于不确定的代码，也可以加上try-catch，处理潜在的异常 尽量去处理异常，切记只是简单的调用printStackTrace（）去打印 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句块去释放占用的资源 字符串String字符串被作为 String 类型的对象处理。 String 类位于 java.lang 包中。默认情况下，该包被自动导入所有的程序。1234String s1 = &quot;jj&quot;;//s1存放了到字符串对象的引用String s2 = new String();String s3 = new String(&quot;jj&quot;); String 对象创建后则不能被修改，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不同。 一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder 每次 new 一个字符串就是产生一个新的对象，即便两个字符串的内容相同，使用 ==比较时也为 ”false” ,如果只需比较内容是否相同，应使用 equals()方法 字符串中字符的索引从0开始，范围为 0 到 str.length()-1 使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1 使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符 1234567891011121314151617String str = &quot;学习 JAVA 编程&quot;;System.out.println(&quot;字符串长度：&quot;+str.length());char c = &apos;编&apos;;System.out.println(&quot;字符串‘编’的位置：&quot;+str.indexOf(c));System.out.println(&quot;子字符串Java的位置：&quot;+str.indexOf(&quot;JAVA&quot;));System.out.println(&quot;子字符串imooc的位置：&quot;+str.indexOf(&quot;java&quot;));String[] arr = str.split(&quot; &quot;);System.out.println(&quot;按空格拆分成数组：&quot;+Arrays.toString(arr));System.out.println(&quot;获取位置[3，7)之间的子字符串：&quot;+str.substring(3,7));System.out.println(&quot;转换为小写：&quot;+str.toLowerCase());System.out.println(&quot;获取索引位置为3的字符：&quot;+str.charAt(3));System.out.print(&quot;将字符串转换为byte数组：&quot;);byte[] bytes = str.getBytes();for(int i=0;i&lt;bytes.length;i++)&#123; System.out.print(&quot;bytes&quot;+i+&quot;:&quot;+bytes[i] + &quot; &quot;); &#125; 123456789字符串长度：10字符串‘编’的位置：8子字符串Java的位置：3子字符串imooc的位置：-1按空格拆分成数组：[学习, JAVA, 编程]获取位置[3，7)之间的子字符串：JAVA转换为小写：学习 java 编程获取索引位置为3的字符：J将字符串转换为byte数组：bytes0:-27 bytes1:-83 bytes2:-90 bytes3:-28 bytes4:-71 bytes5:-96 bytes6:32 bytes7:74 bytes8:65 bytes9:86 bytes10:65 bytes11:32 bytes12:-25 bytes13:-68 bytes14:-106 bytes15:-25 bytes16:-88 bytes17:-117 1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，1 个英文字符存储需要 1 个字节。字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过 127，如果超过就会溢出，以负数的形式显示。 ==” 和 equals() 有什么区别: ==: 判断两个字符串在内存中首地址是否相同，即判断是否是同一个字符串对象 equals(): 比较存储在两个字符串对象中的内容是否一致 比较字符用== StringBuilder类String 类具有是不可变性，多个字符串进行拼接了以后产生一个新的临时变量并指向一个新的对象或新的地址。使用 StringBuilder 或 StringBuffer 就可以避免这个问题。 StringBuilder 和StringBuffer ，它们基本相似，不同之处，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。 12StringBuilder str1 = new StringBuilder();StringBuilder str2 = new StringBuilder(&quot;imooc&quot;); 在需要频繁对字符串进行修改操作时使用 StringBuilder 的效率比 String 要高 常用类包装类为了让基本数据类型也具备对象的特性， Java 为每个基本数据类型都提供了一个包装类，这样我们就可以像操作对象那样来操作基本数据类型。 基本类型 对应的包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 包装类主要提供了两大类方法： 将本类型和其他基本类型进行转换的方法 将字符串和本类型及包装类互相转换的方法 Integer类123int i = 2;Integer m = new Integer(8);Integer n = new Integer(&quot;8&quot;); 常用方法 | 返回值 | 方法名 | 解释 || byte | byteValue() | 将该Integer转为byte类型 || double | doubleValue() | 转为double类型 || float | floatValue | 转为float类型 || int | intValue() | 转为int类型 || long | longValue() | 转为long类型 || static int | parseInt(String s) | 将字符串转换为int类型 || String | toString | 转为字符串类型 || static Integer | valueOf(String s) | 将字符串转换为Integer类型 | 基本类型和包装类之间的转换装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱123int i = 10Integer x = new Integer(i);//手动装箱Integer y = i;//自动装箱 拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱 123Integer j = new Integer(8);int m = j.intValue(); //手动拆箱int n = j; //自动拆箱 基本类型和字符串之间的转换基本类型转换为字符串有三种方法： 使用包装类的 toString() 方法 使用String类的 valueOf() 方法 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串1234int c = 10;String str1 = Integer.toString(c);String str2 = String.valueOf(c);String str3 = c + &quot;&quot;; 将字符串转换成基本类型有两种方法: 调用包装类的 parseXxx 静态方法 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱 123String str = &quot;8&quot;;int a = Integer.parseInt(str);int b = Integer.valueOf(str); Date 类java.util 包中 1234Date d = new Date();System.out.println(d);// 默认输出当前时间// Thu Jul 05 11:39:09 CST 2018 java.text 包中的 SimpleDateFormat 类可以对日期时间进行格式化 1234567891011//使用 format() 方法将日期转换为指定格式的文本Date d1 = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String today = sdf.format(d1);System.out.println(today);//使用 parse() 方法将文本转换为日期String day = &quot;2014年02月14日 10:30:25&quot;;SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);Date date = sdf1.parse(day);System.out.println(&quot;当前时间&quot;+date); 调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行异常处理 使用 Date 类时需要导入 java.util 包，使用 SimpleDateFormat 时需要导入 java.text 包 Calendar 类Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用 Calendar 类进行时间和日期的处理。 java.util.Calendar类是一个抽象类，可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance(); 1234567891011Calendar c = Calendar.getInstance();int year = c.get(Calendar.YEAR);int month = c.get(Calendar.MONTH) + 1; //0表示1月份int day = c.get(Calendar.DAY_OF_MONTH);int hour = c.get(Calendar.HOUR);int minute = c.get(Calendar.MINUTE);int second = c.get(Calendar.SECOND);System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日 &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second);Date d = c.getTime(); //Calendar 和 Date 的转换Long time = c.getTimeInMillis(); //获取此 Calendar 的时间值，以毫秒为单位 Math 类Math 类位于 java.lang 包中，包含用于执行基本数学运算的方法， Math 类的所有方法都是静态方法，所以使用该类中的方法时，可以直接使用类名.方法名， 不需要导入包 12int y = (int)(Math.random()*99);# 产生[0,99)之间的随机整数]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试]]></title>
    <url>%2Fpost%2F7a8ab919.html</url>
    <content type="text"><![CDATA[软件测试概要定义 软件测试是对程序能够按预期运行建立起一种信心 ——Bill Hetzel,1973 测试是为发现错误而执行程序的过程 ——Myers,1979 使用人工或自动的手段来运行或测量软件系统的过程，以检测软件系统是否满足规定的要求，并找出与预期定义之间的差异。 ——IOS/IEC/IEEE 29119 对象软件测试覆盖整个软件研发过程 软件需求 概要设计 详细设计 源代码 可运行程序 可运行环境 历史 五大要素及两大目标要素： 质量(最为核心) 人员(决定因素) 技术(实现手段)【测试技术，方法，测试工具】 资源【测试所需的硬件，网络环境，测试生命周期，测试时间】 流程(测试标准)【测试计划，测试执行，报告】 目标 提升测试覆盖率 测试效率 遵循原则 测试显示软件的存在，但不能证明系统不存在缺陷 穷极测试是不可能的，应设定及时终止的条件（无穷无尽的测试是不可能的，需很大代价；无论怎样测试，我们不可能发现软件的所有缺陷） 测试应该尽早进行 缺陷具备群集特性（发现越多错误的模块，越应该集中关注，可能该模块的编程人员的水平较低） 测试的杀虫剂悖论（用相同的用例多次测试时发现不了bug的，应该更新测试方法和用例） 测试的二八原则（80%的时间测试20%的重要模块） 测试活动依赖于测试背景（针对不同的软件的测试方法是不同的，比如电信软件看中性能、大批量；银行看中安全性） 术语杀虫剂悖论（The Pesticide Paradox）用来描述这样一种现象，即你对软件进行越多的测试，那么该软件对你的测试就越具有免疫力。同样的事情发生在对昆虫使用杀虫剂上。如果你持续使用同样的杀虫剂，这些昆虫最终将建立起抵抗力，杀虫剂将不再发挥作用。为了克服“杀虫剂悖论”，软件测试人员必须不断地编写新的不同的测试来检验程序的不同部分从而找出更多的bug。让其他的人来测试你的程序将有助于打破“杀虫剂悖论”。 分类]]></content>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nmap使用]]></title>
    <url>%2Fpost%2F30bf2354.html</url>
    <content type="text"><![CDATA[Nmap(Network Mapper)是一款用于网络发现（Network Discovery）和安全审计（Security Audting）的安全工具，采用C++语言编写，常用于端口扫描。Nmap软件包带有一个名为GUI的包zenmap，使用Python编写。 安装nmap1sudo apt-get install nmap 使用最简单的形式是只传递地址或域名：123nmap scanme.nmap.orgnmap 74.207.244.221nmap 192.168.1.200 端口状态扫描结果中显示的商品状态 状态 说明 open 开放，探测报文到达了端口，端口有响应：我有应用程序监听 - SYN/ACK closed 关闭，探测报文到达了端口，端口有响应：我没应用程序监听 - RST (复位) filtered 被屏蔽，探测报文到不了端口，石沉大海 unfiltered 没有被屏蔽，还需要确认，探测报文到达了端口，没响应了 open &#124; filtered 开放或屏蔽，有可能报文过滤器丢弃了探测报文（filtered），或丢弃了端口的响应报文 (open)(原理请往下看 -sN，-sF，-sX)UDP，IP 协议， FIN，Null，和 Xmas 扫描可能把端口归入此类 closed &#124; unfiltered 关闭或屏蔽，IPID+1，但是 closed 和 unfiltered 都可能导致只 + 1，所以就不确定了。只可能出现在 IP ID Idle 扫描中（看下端口 TCP 空闲扫描的原理就知道为什么了） 扫描类型 参数 说明 -sT TCP 连接扫描，会在目标主机中记录大量的链接请求和错误信息 -sS SYN 扫描，隐蔽扫描，不创建完整连接，只完成三次握手前两次，很少有系统记入日志，默认使用，需要 root(admin) 权限 -sP Ping 扫描，默认使用，只有能 Ping 得通才会继续扫描 -P0 扫描之前不需要 Ping，用于绕过防火墙禁 Ping 功能 -sA 高级的扫描方式，用来穿过防火墙的规则集 -sV 服务的详细信息 -sU UDP 扫描，扫描主机开启的 UDP 的服务，速度慢，结果不可靠 -sX -sN 秘密的 FIN 数据包扫描，圣诞树 (Xmas Tree) 和空模式，针对 Unix 和 Linux 主机，系统要求遵循 TCP RFC 文档 扫描参数 参数 说明 -v 显示扫描过程，推荐使用 -h 帮助文档 -p 指定端口号，如 [1-65535],[22,135,1433,3306,] 等格式 -O 探测操作系统，存在误报 -A 全面系统监测，使用脚本检测，扫描等 -T4 针对 TCP 端口禁止动态扫描延迟超过 10ms -iL 批量扫描，读取主机列表，如 [-iL C:\ip.txt] -F 快速扫描 -V 确定指定端口对应的服务信息 -eclude 排除IP，多个IP用逗号分隔 -p 指定端口，多个端口用逗号分隔 扫描案例1234567891011121314151617181920212223242526272829303132# 扫描 C 段（局域网）存活主机nmap -sP www.XXX.com/24nmap -sP 192.168.1.*# 主机发现，通过ICMP ECHO扫描子网中的在线主机nmap -v -sn -PE 192.168.1.1/24nmap -v -sn -PE 192.168.1.1-5# 指定商品扫描nmap -v -p 135 192.168.1.1-5# 扫描指定 IP 开放端口号# -p-为全端口扫描，和[1-65535]一样，建议使用，不使用默认Nmap认为危险的100个端口号nmap -sS -p- -v 192.168.1.100# 扫描指定 IP 所开端口及对应的服务nmap -sV -v 192.168.1.100# 探测主机操作系统以及硬件信息，扫描准确度以百分比显示，未必准确nmap -O www.XXX.com# 穿透防火墙扫描nmap -P0 www.XXX.com# 全面探测，-A 包含 OS 探测，版本探测，脚本扫描，traceroutenmap -A www.XXX.com# 使用脚本扫描，脚本放在Nmap安装目录script下，官网可查各个脚本功能nmap --script=&quot;脚本名称&quot; www.XXX.com# 如在局域网上扫找 Conficker 蠕虫病毒nmap -PN -T4 -p139,445 -n -v --script=smb-check-vulns --script-args safe=1 192.168.0.1-254 补充： https://github.com/erasin/notes/blob/master/linux/safe/nmap.md https://nmap.org/book/history-future.html https://blog.csdn.net/emaste_r/article/details/17840465 http://os.chinaunix.net/a2006/0619/956/000000956765.shtml https://zhuanlan.zhihu.com/p/26676508 https://wiki.archlinux.org/index.php/Nmap]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看IP使用情况]]></title>
    <url>%2Fpost%2F62edaad4.html</url>
    <content type="text"><![CDATA[12sudo apt install fpingfping -g -c 1 192.168.1.0/24 1nmap -nsP 192.168.1.1-254]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Cisco Packet Tracer]]></title>
    <url>%2Fpost%2F5aea5c58.html</url>
    <content type="text"><![CDATA[下载https://www.netacad.com/courses/packet-tracer 注册下载 安装将压缩文件解压缩到一个文件夹并打开一个终端。使用sudo权限运行install.sh并按照说明进行安装安装的默认路径是/opt/pt 运行在终端中键入packettracer来运行如果没有反应，运行/opt/pt/bin/PacketTracer7会提示缺少库文件，安装相应库文件后再次运行 配置调整终端字体点击选项（options），点击首选项（Preferences），然后点击字体（Font），选CLI右侧就有大小的选择了。 参考： http://www.christospanoudis.com/how-to-install-packet-tracer-7-1-in-linux-and-resolve-any-dependency-issues/ https://linux.cn/article-5576-1.html]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 网络层]]></title>
    <url>%2Fpost%2F5149561d.html</url>
    <content type="text"><![CDATA[TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，则将数据包丢弃。ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的，traceroute正是因为有了TTL才能正常工作]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包工具tcpdump、wireshark]]></title>
    <url>%2Fpost%2F8a478097.html</url>
    <content type="text"><![CDATA[在Linux下，当我们需要抓取网络数据包分析时，通常是使用工具tcpdump。但是，有时我们需要将抓取的数据包保存在一个文件中，已备以后分析。而tcpdump保存的文件是二进制文件，使用cat 和vim 都无法打开查看。此时我们采取的措施是，下载到本地使用wireshark界面网络分析工具进行网络包分析。 tcpdump需要管理员权限1234567891011121314151617181920212223242526272829303132tcpdump host www.baidu.comtcpdump host www.baidu.com and port 80tcpdump host www.baidu.com -w out.cap# 经过eth1tcpdump -i eth1 host 192.168.1.1# 指定源地址，抓取主机发送的所有数据tcpdump -i eth1 src host 192.168.1.1# 指定目的地址，抓取主机接收的所有数据tcpdump -i eth1 dst host 192.168.1.1# 经过eth1tcpdump -i eth1 port 25# 指定源端口tcpdump -i eth1 src port 25# 指定目的端口tcpdump -i eth1 dst port 25tcpdump -c100tcpdump host 10.37.63.255 and (10.37.63.61 or 10.37.63.95)tcpdump host 10.37.63.255 and !10.37.63.61# host 主机地址，后面可以带具体的IP或者地址# port 端口号# -w 保存到文件# -r 读取保存的文件# src源地址# dst目标地址# -c 指定捕获的报文数量# -i 指定接口 ifconfig -a查看有哪些接口 wiresharkwireshark是一个图形化的工具 补充： https://linuxwiki.github.io/NetTools/tcpdump.html https://wizardforcel.gitbooks.io/network-basic/content/16.html https://www.jianshu.com/p/8d9accf1d2f1 https://www.wireshark.org/docs/wsug_html_chunked/index.html https://wizardforcel.gitbooks.io/wireshark-manual/content/1.html http://blog.51cto.com/zhaoyuqiang/1575315]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程]]></title>
    <url>%2Fpost%2Fd317e8c4.html</url>
    <content type="text"><![CDATA[网络通信是两台计算机上的两个进程之间的通信]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 数据链路层]]></title>
    <url>%2Fpost%2F2f41be1.html</url>
    <content type="text"><![CDATA[其实本文中数据链路层讲了两部分，一部分是针对广域网的PPP，另一部分是针对局域网（以太网）的CSMA/CD 基本概念信道类型数据链路层使用的信道主要有以下两种类型点对点信道。这种信道使用 一对一 的点对点通信方式。用于广域网，使用PPP协议广播信道。这种信道使用 一对多 的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。用于局域网，使用CSMA/CD协议 链路和数据链路链路 (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。（物理层） 数据链路 (data link) 除了物理线路外，还必须有 通信协议 来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。（链路+协议） 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 数据链路层的三个基本问题封装成帧封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。帧=帧头+帧尾+物理层地址+校验值 透明传输如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地 “找到帧的边界”。 解决方法：字节填充 (byte stuffing) 或字符填充 (character stuffing)。 发送端的数据链路层在数据中出现控制字符 SOH 或EOT的前面插入一个转义字符ESC (其十六进制编码是 1B)。 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前插入一个转义字符，当接收端收到连续的两个转义字符时，就删除其中前面的一个 之所以称为透明传输，是因为插入转义和删除转义是无法感受到的 差错控制在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER (Bit Error Rate)。 误码率与信噪比有很大关系为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施如果发现错误并不进行纠错而直接丢弃，目标发现没有接收到会要求重发，这是传输层的事情 循环冗余检验 CRCCRC是差错检测中最常见的方法 在发送端，先把数据划分为组。假定每组 k 个比特。假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。冗余码的计算举例加法没有进位，减法没有借位，等同于异或运算余数的位数等于n，不足补零 FCS在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法 检验接收端对收到的每一帧进行CRC检验若得出的余数R=0，则判定这个帧没有差错，就接受若余数R不等于0,则判定这个帧有差错，就丢弃 特点这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错除数P越大，检错能力越强只要经过严格的挑选，并使用位数足够多的除数P，那么出现检测不到的差错的概率就很小 仅用循环冗余检验CRC差错检测技术只能做到无差错接受，”无差错接受” 是指：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。要做到“可靠传输”（即发送什么就收到什么）就必须加上确认和重传机制 在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。 点对点信道的数据链路层——PPP协议PPP协议 点对点协议 Point-to-Point Protocal用于点到点通信现在全世界使用得最多的数据链路层协议用户使用拨号电话线接入因特网时，一般都是使用PPP协议 使用场合用户通过拨号连入ISP（电信、联通），点对点的。ISP给用户分配IP地址。PPP协议作用于之间，为用户和ISP提供规则：在连上网线的基础上还需要遵守拨号和利用IP地址才能上网的规则。PPP能够计费，能够显示上网时间和上网流量等等 PPP 协议满足的需求： 简单——这是首要的要求，对帧不需要纠错，不需要流量控制，在接收方收到帧后用CRC检测，正确接收，错误就丢弃 封装成帧：从PPP协议的帧格式可以看出PPP协议封装成帧。在数据链路层以帧为单位进行传输 透明性：为了防止信息部分出现帧定界序列7E，而使网络误以为帧结束 差错检测：能够利用CRC进行差错检测 多种网络层协议：能够支持多种高层协议的运行，比如IP协议等 多种类型链路：支持在光线等不同物理链路 检测连接状态：当拨号密码错误、连接错误时，PPP协议会提示错误信息 最大传送单元：一般要传输的数据不能超过1500个字节 网络层地址协商：拨号成功后，PPP协议能给用户分配网络层的IP地址 数据压缩协商：比如要传0000000011111111，16个比特。经过压缩算法后，只需要告诉对方要传8个0，8个1。接收方收到后再根据算法将16个0，16个1解压成0000000011111111。这样能够节省带宽 PPP 协议不需要的功能： 纠错 流量控制 序号 多点线路 半双工或单工链路 PPP 协议的组成： 数据链路层协议（HDLC）可以用于异步串行或同步串行方法 链路控制协议 LCP (Link Control Protocol)建立并维护数据链路连接，身份验证，流量统计 网络控制协议 NCP (Network Control Protocol)允许在点到点连接上使用多种网络层协议 如果拨号身份验证成功了，则LCP负责建立数据链路，当LCP建立好了链路后，那么NCP就可以通了，NCP就分配一个IP给我们上网 PPP 协议的帧格式： 标志字段F=0x7E(符号0x表示后面的字符是用十六进制表示，十六进制的7E用二进制表示是01111110) 地址字段A只置为0xFF。地址字段实际上并不起作用 控制字段C通常置为0x03 PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。 PPP有一个2字节的协议字段用来表示信息字段的内容类型 0x0021：PPP帧的信息字段是IP数据段 0xC021：PPP链路控制数据 0x8021：网络控制数据 0xC023：安全性认证PAP 0xC025：LQR oxC223：安全性认证CHAP PPP 协议的透明传输问题：当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。字节填充以字节为单位，应用于异步网络中 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E) 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D) 若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 零比特填充以比特为单位，应用于同步网络中在同步网络中传的比特流，所以不一定是8的倍数了。需要解决比特流的透明传输PPP 协议用在SONET/SDH链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。 在发送端，只要发现有 5 个连续 1，则立即填入一个 0。 接收端对帧中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除。 PPP 协议不提供序号和确认的可靠传输。原因： 在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。 在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。 帧检验序列 FCS 字段可保证无差错接受。 PPP 协议的工作状态 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。 PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。 PPP 是一种验证方式，验证成功后会分配给用户一个 IP 地址。PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。 广播信道的数据链路层——CSMA/CD协议局域网的拓扑 星型拓扑结构：每个结点都由一条单独的通信线路与中心结点连结 优点：结构简单、容易实现、便于管理，连接点的故障容易监测和排除 缺点：中心结点出现故障会导致网络的瘫痪 环形拓扑结构：各结点通过通信线路组成闭合回路，环中数据只能单向传输 优点：结构简单、容易实现，适合使用光纤，传输距离远，传输延迟确定 缺点：任意结点出现故障都会造成网络瘫痪，另外故障诊断也较困难 总线拓扑结构：是将网络中的所有设备通过相应的硬件接口直接连接到公共总线上，结点之间按广播方式通信，一个结点发出的信息，总线上的其它结点均可 “收听” 到 优点：结构简单、布线容易、可靠性较高，易于扩充，是局域网常采用的拓扑结构 缺点：所有的数据都需经过总线传送，出故障诊断较为困难 树型拓扑结构：一种层次结构，结点按层次连结，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换 优点：连结简单，维护方便，适用于汇集信息的应用要求 缺点：资源共亨能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行 局域网最主要的特点网络为一个单位所拥有，且地理范围和站点数目均有限 局域网的优点 具有广播功能，从一个站点可佷方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变 提高了系统的可靠性、可用性和生存性 局域网中的冲突域与广播域最初的以太网是将许多计算机都连接到一根总线上，当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（有电源的器件） 总线上的每一个工作的计算机都能检测到B发送的数据信号由于只有计算机D的地址（mac地址）与数据帧首部写入的地址一致，因此只有D才接收这个数据帧其他所有的计算机（A，C和E）都检测到一是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来具有广播特性的总线上实现了一对一的通信 广播域： 一台计算机发送数据，连接在总线上的所有计算机都能收到数据，所有的计算机在同一个广播域中。冲突域： 当一台计算机发送数据时，总线被占用，此时所有连接在总线上的其他计算机都不能再发送数据了。所有的计算机又处于同一个冲突域中。 局域网各终端共享通信媒体（线路介质）的方法 静态划分信道 频分复用 时分复用 波分复用 码分复用 动态媒体接入控制（多点接入） 随机接入：用户想什么时候在线路上发送数据就什么时候发，什么都不用管。如果恰好有多个用户同时刻发送，则在线路上发生碰撞，需要 CSMA/CD 协议协调（主要被以太网采用）这是以太网最需要解决的问题。 受控接入，如多点线路探询（polling），或轮询（目前已不被采用） 静态划分的主要问题是增加新的计算机不方便，需要重新分配信道 CSMD/CD 载波监听多点接入/碰撞检测CSMA/CD 表示Carrier Sense Multiple Access with Collision Detection 多点接入 表示许多计算机以多点接入的方式连接在一根总线上。载波监听 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么 “载波”。因此， “载波监听” 就是用电子技术检测总线上有没有其他计算机发送的数据信号。碰撞检测 就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。检测到碰撞后在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 载波监听后仍然出现碰撞的可能电磁波在总线上的有限传播速率的影响当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A 向 B 发出的信息，要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。 CSMA/C的D重要特性使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）每个站在发送数据之后的一小段时间内，存在遭遇碰撞的可能性。所以不能保证在一定时间内一定能把数据发送出去。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率（因为碰撞会降低效率） 可以看出，如果A到B之间的线路越长（传播时延τ受传播媒介长度影响），那么接受到碰撞信息的时间也会越长，所以CSMA/CD协议适合用在线路较短的局域网和以太网中。这也是局域网范围受限的原因之一。 争用期A能收到碰撞的最长时间为，当数据到达B后，B刚好发送数据，在主机B上发生了碰撞。最先发送数据帧的站，在发送数据帧后至多经过时间 2τ就可知道发送的数据帧是否遭受了碰撞。如果这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 以太网的争用期以太网的端到端往返时延2τ称为争用期，或碰撞窗口。通常，取 51.2 ms 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节未发生冲突，则后续的数据就不会发生冲突。 最短有效帧长如果发生冲突，就一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。 强化碰撞当发送数据的站一旦发现发生了碰撞时： 立即停止发送数据； 再继续发送若干比特的人为干扰信号 (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。 二进制指数类型退避算法发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。尽量避免再次发生碰撞 确定基本退避时间，一般是取为争用期 2t。定义参数 k，k = Min[重传次数n, 10]从整数集合[0,1,…, (2的K次方-1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 以太网以太网两个标准 DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。 IEEE 的 802.3 标准。 DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。说白了： 以太网就是局域网。严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网 10M以太网使用CSMA/CD协议 以太网与数据链路层的两个子层为了使数据链路层能更好地适应多种局域网标准，802 委员会就将局域网的数据链路层拆成两个子层： 逻辑链路控制 LLC (Logical Link Control)子层 媒体接入控制 MAC (Medium Access Control)子层 与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的。 由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了，即现在LLC子层几乎不提了。 很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。 以太网提供的服务以太网提供的服务是不可靠的交付，即尽最大努力的交付。当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由传输层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 如图所示，PC1发送数据给PC0，在以太网上，ＲＡ接收到有差错的数据帧时就直接丢弃。如果PC0的高层（网络层以上）发现数据在途中丢失了，就会要求PC1重新发送一份。 传统以太网的拓扑——使用集线器的星形拓扑结构传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。不用电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(hub) 。 需要注意的是： 现在中间的可靠设备一般不用集线器了，现在组网去市场花个便宜的钱都是用交换机组网的。 100m以内 集线器（hub）集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。集线器很像一个多接口的转发器，工作在物理层。 集线器是傻瓜式的，它没有智能作用，看不见什么信号。只知道机械的传输，也不管目的地址什么的，反正就是有信号就传。 接在工作站网卡上的8根双脚线有两根是发送数据的，有两根是接收数据的。A发送数据数据到集线器后，B和C都能收到，C发送数据到集线器后，A和B也能收到。发送者自己是收不到自己发出去的数据的。 需要注意的是： 这是早期的集线器，在芯片电路还没有出来之前的，集线器里面都是线连接的。现在的集线器都是芯片电路板了。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。 以太网速度标准10BASE-T（10Mb/s）的通信距离稍短，每个站到集线器的距离不超过 100 m。这种 10 Mb/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。 其他：100Base-FX(百兆快速以太网，使用光纤)、100Base-T和100Base-T4…. 10：10M/sBASE：基带信号T：双绞线FX：光纤 以太网信道利用率因为每个站点发送数据时可能产生碰撞的可能，所以此时的信道不会被利用，所以利用率就会变低。 以太网的信道被占用的情况：我们知道争用期长度为 2τ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。如果帧长为 L (bit)，数据发送速率为 C (b/s)，因而帧的发送时间为 L/C = T0 (s)。 一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过τ时间使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。 要提高以太网的信道利用率，就必须减小τ 与 T0 之比。在以太网中定义了参数 a，它是以太网单程端到端时延τ与帧的发送时间 T0 之比： a=τ/T0 a→0 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。 a并不是信道利用率，只是为了描述信道利用率的一个参数而已从式子可以得出，要想a变小，则τ尽量变小，而T0尽量要大。当数据率C一定时，T0=L（帧长）/C 。所以以太网的帧长L尽量要长些，这样T0会增大，a会变小。当然也不能太长，太长后信道利用率过高会引起信道延迟成倍增加（ 信道利用率越高，数据线路上拥堵的可能性就越大，当高到一定程度后，会增加数据在线路上的延时）。同时，以太网的连线的长度尽量短些，这样端到端的传播时间τ会变小，a会减小。当然也不能太短，太长后信道利用率过高会引起信道延迟成倍增加。 信道利用率的最大值在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。 发送一帧占用线路的时间是 T0 +τ，而帧本身的发送时间是 T0。于是我们可计算出理想情况下的极限信道利用率 Smax为： MAC地址在局域网中，硬件地址又称为物理地址，或 MAC 地址。 （48位地址） 802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。 其实我们教材中说的地址并不是很确切，但是我们习惯将这种 48 位的“名字”称为“地址”，所以本书也采用这种习惯用法。 IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即高位 24 位)。 地址字段中的后三个字节(即低位 24 位)由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址。 一个地址块可以生成224个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是EUI-48。 “MAC地址”实际上就是适配器地址或适配器标识符EUI-48。在出厂前就烧录在了我们的网卡中。 如果在一个局域网内（同一个交换机连接下）有相同的MAC地址，则会引起冲突，导致一方不能正常上网。我们说MAC地址是刻在网卡适配器中的，是不可以更改的，但是我们可以指定一个MAC地址，让计算机应用指定的MAC地址，而不用网卡上固定的MAC地址。windows修改mac地址方法：本地连接—更改适配器设置—本地连接属性—配置—-高级—网络地址（本地管理的地址） 适配器检查 MAC 地址适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。 “发往本站的帧”包括以下三种帧： 单播(unicast)帧（一对一） 广播(broadcast)帧（一对全体）（源mac地址：FF:FF:FF:FF:FF:FF） 多播(multicast)帧（一对多） MAC帧格式常用的以太网MAC帧格式有两种标准 ： DIX Ethernet V2 标准 IEEE 的 802.3 标准 最常用的 MAC 帧是以太网 V2 的格式。 MAC帧V2 格式最小长度64字节（最短有效帧长，参考争用期）-18字节的首部和尾部（6+6+2+4）=数据字段的最小长度为了达到比特同步在传输媒体上实际传送的要比 MAC 帧还多 8 个字节 无效的 MAC 帧当适配器收到MAC帧后，会检查是否是有效的MAC帧。 帧的长度不是整数个字节； 用收到的帧检验序列 FCS 查出有差错； 数据字段的长度不在 46 ~ 1500 字节之间。 有效的 MAC 帧长度为 64 ~ 1518 字节之间。 对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 帧间最小间隔帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 9.6 μs × 10Mb/s = 96bit 扩展以太网扩展可以在物理层上也可在链路层上，但从网络层看依然是一个局域网。以太网主机之间的距离不能太远（10BASE-T规定200米） 在物理层扩展局域网主机使用光纤和一对光纤调制解调器连接到集线器用多个集线器可连成更大的局域网 优点使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。扩大了局域网覆盖的地理范围。（使用光纤可以扩大到几千米）数量增加 缺点碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。三个碰撞域连起来后，最大吞吐率仍然是一个系的最大吞吐率。因为其中任何一台主机通信，其他主机都不能通信。 在数据链路层扩展局域网在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。 网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。 网桥的内部结构网桥具有多个接口每个接口连接一个网段 若网桥从接口1收到从主机1向主机5的帧，则把帧发到接口2转发出去。若网桥从接口1收到从主机2发到主机3的帧，则丢弃。因为主机2和3位于同一桥段，不用转发。 使用网桥带来的好处过滤通信量，增大吞吐率。扩大了物理范围。主机数量提高了可靠性。只影响个别网段可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。 网桥使各网段成为 隔离开的碰撞域 使用网桥带来的缺点存储转发增加了时延。存储、查表、碰撞检测在MAC 子层并没有流量控制功能。 网桥的缓存可能溢出，帧丢失。网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。路由器可以阻断网络风暴 网桥和集线器（或转发器）不同集线器在转发帧时，不对传输媒体进行检测。网桥在转发帧之前必须执行 CSMA/CD 算法。若在发送过程中出现碰撞，就必须停止发送和进行退避。 透明网桥目前使用得最多的网桥是透明网桥(transparent bridge)。“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。透明网桥是一种即插即用设备，其标准是 IEEE 802.1D。 自学习算法网桥使用自学习算法处理收到的帧和建立转发表，网桥并不是一开始就知道所连接网络的所有mac地址的，而是通过自学习算法建立转发表 若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A。 网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。 在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面 在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。 如果一个接口有多个mac说明，这个接口连接的是网桥或者交换机 网桥在转发表中登记以下三个信息网桥转发表中的信息：地址、接口和帧进入该网桥的时间。 这是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。 网桥的自学习和转发帧的步骤归纳网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。如有，则按转发表中给出的接口进行转发。如没有，则通过所有其他接口（但进入网桥的接口除外）进行转发。若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。 透明网桥使用了生成树算法这是为了避免产生转发的帧在网络中不断地兜圈子 互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。 为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。 多接口网桥——以太网交换机1990 年问世的交换式集线器(switching hub)，可明显地提高局域网的性能。交换式集线器常称为以太网交换机(switch)或第二层交换机（表明此交换机工作在数据链路层）。以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，可见交换机工作在数据链路层。 以太网交换机的特点以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。 独占传输媒体的带宽对于普通 10 Mb/s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽(10 Mb/s)的 N 分之一。使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 对接口的交换机的总容量为 N×10 Mb/s。这正是交换机的最大优点。 对于普通共享式HUB 若N个用户 总带宽：10Mb/s 每个用户占有平均带宽= 10M/N 以太网交换机的交换方式存储转发方式把整个数据帧先缓存后再进行处理。直通 (cut-through) 方式接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。 虚拟局域网虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。在缺省配置的情况下，交换机的所有端口属于同一 VLAN。连接在不同交换机上的、属于同一 VLAN 的数据帧必须通过 Trunk 链路传输。 高速以太网速率达到或超过 100 Mbit/s 的以太网称为高速以太网。100BASE-T 以太网又称为快速以太网 (Fast Ethernet)。 可在全双工方式下工作而无冲突发生。在全双工方式下工作时，不使用 CSMA/CD 协议。MAC 帧格式仍然是 802.3 标准规定的。保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 m。帧间时间间隔从原来的 9.6 μs 改为现在的 0.96 μs。 吉比特以太网允许在 1 Gbit/s 下全双工和半双工两种方式工作。使用 IEEE 802.3 协议规定的帧格式。在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。 http://blog.51cto.com/zhaoyuqiang/1575315]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-物理层]]></title>
    <url>%2Fpost%2Fb709c2f1.html</url>
    <content type="text"><![CDATA[物理层的基本概念物理层解决如何在连接各种计算机的 传输媒体（光纤、无线等）上传输 数据比特流，而不是指具体的传输媒体物理层的主要任务描述为：确定传输媒体的接口的一些特性，即： 机械特性：例如接口形状，大小，引线数目 电气特性：例如规定电压范围（-5V到+5V） 功能特性：例如规定-5V表示0，+5V表示1 过程特性：也称为规程特性，规定建立连接时各个相关部件的工作步骤 数据通信的基础知识数据通信模型广域网：公共电话网局域网：通过交换机直接使用数字比特流 数据通信不只包括计算机通信，也包括电视、电话、传真等通信方式 通信的目的是传送消息 数据data：运送消息的实体 信号signal：数据的电气或电磁表现 模拟信号：代表消息的参数的取值是连续的 数字信号：代表消息的参数的聚会是离散的 码元code：在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元(在波形中单个0和1就代表码元)，在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度，1码元可以携带nbit的信息量 右图表示一码元可以携带3bit的信息，可以通过不同的电压表示 信道信道一般表示向一个方向传送信息的媒体（A到B是一条，B到A是一条），所以平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互，电视、收音机 双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送（当然也不能同时接收），对讲机 双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息 基带信号和带通信号、调制 基带信号/baseband/基本频带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号 带通信号/band pass：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道） 基带信号传播衰减太严重，这就是为什么需要带通信号的原因，带通信号能够在空气中传播较远的范围 由于在传输距离较近时，基带信号的衰减不大，信号内容不会发生变化，当在较近范围内传输时计算机网络会采用基带传输方式。如从计算机到监视器、打印机等外设的信号就是基带信号 把基带信号调制为带通信号的常见方式有三种： 调幅（AM）：载波的振幅随基带数字信号而变化 调频（FM）：载波的频率随基带数字信号而变化 调相（PM）：载波的初始相位随基带数字信号而变化 常用编码 单极性不归零码：只使用一个电压值，用高电平表示1，没电压表示0 双极性不归零码：用正电平和负电平分别表示二进制数据的1和0，正负幅值相等 单极性归零码（RZ）：即是高电平和零电平分别表示二进制码1和0，而且在发送码1时高电平在整个码元期间T只持续一段时间t，其余时间返回零电平 双极性归零码：正负零三个电平，信号本身携带同步信号 曼彻斯特编码 差分曼彻斯特编码 单极性和双极性：区别在于0用没电压表示还量用负电平表示归零和不归零：每一bit结束时是否归零，不归零这种方式无法区分到底是0还是没有信号 曼彻斯特编码 采样两次是指每bit开始一次，结束一次，比较开始和结束是从高电平转低电平还是从低电平转高电平 差分曼彻斯特编码注意，看的是bit与bit之间是否有跳变，不是bit内 信道极限容量有失真，但可以识别 失真大，无法识别 奈氏准则1924年，奈奎斯特（Nyquist)就推导出了著名的奈氏准则，他给出了在 假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。在任何信道中，码元传输的速率是有上限的，否则就会出现 码间串扰的问题，使接收端对码元的识别成为不可能。如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰。 香农理论在奈氏准则的基础上，香农用信息论的理论推导出了 带宽受限且有 噪声干扰的信道的极限、无差错的信息传输速率。 信道的极限信息传输速率C可表达为：C=W lg(1+S/N)/lg2 b/s W为信道的带宽（以Hz为单位） S为信道内所传信号的平均功率 N为信道内部的高斯噪声功率 S/N为信噪比 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输 若信道带宽 W 或信噪比S/N没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率C也就没有上限 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少 物理层下面的传输媒体导向传输媒体导向传输媒体中，电磁波沿着固体媒体传播 双绞线 屏蔽双绞线STP：屏蔽网线，优点屏蔽性好，抗干扰能力强。缺点价格昂贵，与UTP相比，直径较大，更重以及不易安装 无屏蔽双绞线UTP：非屏蔽网线，优点是价格便宜，直径较小，易安装。缺点是抗干扰能力较弱 同轴电缆 50Ω 同轴电缆用于数字传输，由于多用于基带传输，也叫基带同轴电缆 75Ω 同轴电缆用于模拟传输，即宽带同轴电缆 光缆 双绞线LAN网络中最常见的数据传输铜介质是双绞线。铜介质优点是可以非常好的传导电信号，缺点是易受外界干扰而产生畸形和信号衰减，导致长距离传输过程中能量损失。为解决上述不足，提高数据传输稳定性，IEEE制定了LAN线缆标准，主要有两种：屏蔽双绞线(STP)和非屏蔽双绞线(UTP)。 所谓双绞线，实际上是将线缆中细铜缆成对出现。之所以这样设计，原因是在数据传输过程中，电线中电流流过时产生电磁场，干扰线缆中其它细铜缆。为解决这个问题，将电缆中细铜线 两两配对，使得传输过程中两两配对的细铜缆产生的 电磁场互相抵消，减少串扰。 随着UTP单位长度中的双绞次数的增多，抗干扰能力也得到加强,是目前使用最广泛的双绞线，而STP因需要接地，安装不易反而没有得到大范围应用。在实际工作中可以察看双绞线的双绞频率判断双绞线的伪劣。 双绞线线缆引脚顺序双绞线要正常稳定工作，需要在两端将细铜缆按一定的顺序接在连接器中。双绞线使用的连接器标准是 RJ-45连接器。要理解线缆的引脚顺序本质，实际上需要理解硬件设备接收发送电信号的规则： 以太网设备使用一对铜细缆来传输数据 以太网设备使用一对铜细缆来接收数据 以太网设备不能使用同一对铜细缆来同时传输和接收数据。 结论：在以太网中，以太网设备需要使用两对细铜缆分别用来进行数据的接收和发送。 理解了以上规则后，我们再来了解下不同的硬件设备用于发送和接收数据的工作规则： 网卡NIC：1、2引脚发送数据，3、6引脚接收数据 集线器：3、6引脚发送数据，1，2引脚接收数据 交换机：3、6引脚发送数据，1，2引脚接收数据 网桥：3、6引脚发送数据，1，2引脚接收数据 路由器：1，2引脚发送数据，3，6引脚接收数据 了解了不同硬件设备的接收发送信号的引脚编号后，再看来直通线和交叉线的使用场景就会清晰很多。 以最常见的PC机与交换机通信为例 PC机网卡发送信号给交换机，对于NIC端是发送数据，NIC的发送引脚是1，2引脚，对于交换机是接收数据，参照上述规则，交换机接收数据使用的是1，2引脚。 交换机发送信号到PC机网卡，对于交换机是发送数据，使用3，6引脚，对于NIC端是接收数据，同样使用3，6引脚。 所以PC机与交换机通过网线相连，用于通信的线缆1、2、3、6引脚两端顺序保持一致，简称直通线。同理，PC机与集线器、网桥相连，也使用直通线。 结论：互相通信的网络设备使用的传输引脚规则一致时，使用交叉线互相通信的网络设备使用的传输引脚规则不同时，使用直通线 TIA/EIA-586A与TIA/EIA-586B引脚顺序从上述双绞线线缆引脚顺序的描述中，可以看出两台设备要能正常通信，只需要根据具体设备发送和接收数据的工作规则来排列正确的引脚次序。比如说PC机与交换机通信，只要将网线两端的引脚顺序保持一致就可以，那么可以通信的引脚顺序组合有：8765432*1种可能性。为避免不同人员随意性的引脚顺序排列，TIA/EIA制定了两个网线引脚顺序标准，分别是TIA/EIA-586A与TIA/EIA-586B，强制要求所有的网线引脚顺序必须遵循以上两种标准之一。 TIA/EIA-586A引脚顺序：1-绿白 2-绿 3-橙白 4-蓝 5-蓝白 6-橙 7棕白 8棕TIA/EIA-586B引脚顺序：1-橙白 2-橙 3-绿白 4-蓝 5-蓝白 6-绿 7棕白 8棕 观察586A和586B引脚顺序，实质上就是 1，2引脚和3，6引脚互换了位置，其它位置的引脚保持不变。1、2、3、6是10M和100M网线使用的线路，1000M使用全部8根线 根据标准的586A和586B标准，再来明确一下直通线和交叉线的定义： 直通线：两端使用相同引脚顺序，同时使用586A标准或同时使用586B标准。用于不同类的网络设备连接，如电脑与交换机、交换机与路由器等。 交叉线：两端使用不同的引脚顺序，一端使用586A顺序，一端使用586B顺序，主要用于同类网络设备的连接，如交换机与交换机、电脑与电脑等。 当前大部分网络设备、网络终端的网线接口均支持 自动翻转功能。 光纤 非导向传输媒体非导向传输媒体就是指 自由空间，其中的电磁波传输被称为无线传输无线传输所使用的频段很广短波通信主要是靠电离层的反射，但短波信道的通信质量较差微波在空间主要是直线传播 地面微波接力通信 卫星通信 物理层设备———集线器工作范围：它在网络中只起信号放大和重发作用，其目的是扩大网络的传输范围，而 不具备信号的定向传送能力（不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点）最大传输距离：100m集线器是一个大的冲突域（带宽共用） 信道复用技术 频分复用FDM Frequency Division Multiplexing用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带频分复用的所有用户在同样的时间占用不同的频率 时分利用TDM Time Division Multiplexing时分复用是将时间划分为一段段等长的时分复用帧（TDM帧），每一个时分复用的用户在每个TDM帧中占用固定序号的时隙每个用户所占用的时隙是周期性（其周期性就是TDM帧的长度对应的时间）TDM信号也称为等时（isochronous)信号 时分复用的所有用户是在不同的时间占用同样的频带宽度 统计时分复用STDM Statistic TDM时分复用可能会造成线路资源的浪费使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的，所以出现了统计时分复用 波分复用WDM Wavelength Division Multiplexing波分复用就是光的频分复用 数字传输系统脉冲编码调制PCM最初是为了在电话局之间的中继线上传送多路的电话。由于历史的原因，PCM有两个互一兼容的标准，即北美24路PCM（简称为T1）和欧洲的30路PCM（简称为E1）。我国采用的是欧洲的E1标准。E1的速率是 2.048Mb/s，而T1的速率是 1.544Mb/s当需要有更高的数据率时，可采用复用的方法 PCM 是要把声音从 模拟转换成数字信号的一种技术，他的原理简单地说就是利用一个固定的频率对模拟信号进行采样，采样后的信号在波形上看就像一串连续的幅值不一的脉冲，把这些脉冲的幅值按一定的精度进行量化，这些量化后的数值被连续地输出、传输、处理或记录到存储介质中，所有这些组成了数字音频的产生过程。 电话的采样采样频率通常为8000次/s，量化精度是 8bit（每一个波形/码元用8位二进制表示）8000×8 = 64Kb/sPCM产生的数字信号称为 数字基带信号 参考： https://blog.csdn.net/hanmengaidudu/article/details/78854264 https://baike.baidu.com/item/PCM/1568054 宽带接入技术究其本质，没有太多区别，它们都是接入网络（Access Network），先认证用户合法，分配 IP 地址等上网必备的参数，将用户电脑接入互联网 Internet。运营商在将用户接入网络的同时，启动用户流量统计/用户在线时长统计，以生成用户账单，用户掏钱。 但由于采用的传输介质（physical media）大不同，有模拟电话线、数字铜线、光纤，以及成帧方式的不同，有 PPP，PPPoE +PPP，IPoE，在上网速率上体现出数量级的差别，从模拟电话线 56Kbps，ISDN 144Kbps，ADSL 512Kbps-10Mbps，FTTH 2-1000Mbps。 拨号上网模拟线电话拨号使用电话线，用户可以在自己的电脑上安装一个内置（插在电脑 PCI 插槽）modem，或外置（插在 RS-232 接口）modem官方的名字：调制解调器，民间的名字：猫！它负责将电脑的数字信号转换为可以在电话线上传输的模拟信号。在局端，也有对应的 modem，再将模拟信号转换为数字信号。 数字线电话拨号 ISDN此为数字线，所以不需要模数转换的 modem，提供 B +2D 接入方式，即一条 16Kbps 信令通道 B，两条各 64 Kbps 数据通道 D，可以一条线路打电话，同时另一条上网；也可以两条 D 通道都用于上网，即 64 + 64=128 Kbps 的上网带宽。 xDSL方式xDSL：用数字技术对现有的模拟电话用户线进行改造。标准模拟电话信号的频带限制在300～3400Hz的范围内，但用户线本身实际可通过的信号频率超过1MHz。xDSL就把0～4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱给用户上网使用。 DSL：数字用户线路 ADSL：不对称数字用户线路 VDSL：甚高比特率数字用户线路 R-ADSL：速率适应数字用户线 IDSL：ISDN DSL HDSL：高速数字用户线 SDSL：单线用户数字线 中间还是一根电话线，你这头是一个ADSL宽带猫，运营商机房那头是对应的宽带设备。 ADSL的特点 上行和下行带宽做成不对称的 ADSL在用户线的两端各安装一个ADSL调制解调器 我国目前采用的方案是离散多间调DMT（Discrete Multi-Tone）调制技术 DMT技术DMT调制技术采用频分复用的方法，把40kHz以上一直到1.1MHz的高端频谱划分为许多的子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道每个子信道占据4kHz带宽，并使用不同的载波（即不同的音调）进行数字调制，这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据 Serial/parallel converter 串/并行转换 HFC光纤同轴混合网，Hybrid Fiber Coax HFC网是在目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。HFC网除可传送CATV外，还提供电话、数据和其他宽带交互型业务。现有的CATV网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而HFC网则需要对CATV进行改造。 HFC的主要特点： HFC网的主干线路采用光纤。HFC网将原CATV网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。在模拟光纤中采用光的振幅调制AM，这比使用数字光纤更为经济。模拟光纤从头端连接到光纤结点（fiber node），即光分配结点OND（Optical Distribution Node）。在光纤结点光信号被转换为电信号，在光纤结点以下就是同轴电缆。 HFC网具有比CATV网更宽的频谱，且具有双向传输功能 每个家庭要安装一个用户接口盒 HFC的优点具有很宽的频带能够利用已经有相当大的覆盖面的有线电视网 FTTxFTTx（光纤到……），这里字母x可代表不同意思 光纤到家FTTH（Fiber To The Home）：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法（155Mb/s） 光纤到大楼FTTB（Fiber To The Building）：光纤进入大楼后就接入交换机，然后用电缆或双绞线分配到各用户 光纤到路边FTTC（Fiber To The Curb）：从路边到各用户可使用星形结构双绞线作为传输媒体（155Mb/s） 参考： http://blog.51cto.com/alligator/910667 http://www.admin10000.com/document/3946.html https://www.zhihu.com/question/48988005]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络性能指标]]></title>
    <url>%2Fpost%2Fda722289.html</url>
    <content type="text"><![CDATA[速率连接在计算机网络上的主机在 数字信道 上传送 数据位数 的速率，也称为 data rate 或 bit rate单位：b/s、kb/s、Mb/s、Gb/s 注意两点： 速率是指一个信道 计算的是bit，而不是byte，实际网速多用K/s、M/s都是计算byte，而我们说的带宽有100M指的是bit，故而实际网速是带宽除以8 带宽数据通信领域中，数字信道所能传送的最高数据率，单位是b/s、kb/s、Mb/s、Gb/s所有信道传输和的最大值 吞吐量在单位时间内通过某个网络的数据量，单位是b/s、kb/s、Mb/s、Gb/s单位时间内所有信道传输的和 时延又叫延迟。时延是指一个报文或分组从一个网络的一端传送到另一个端所需要的时间。它包括了发送时延，传播时延，处理时延，排队时延。主要时延是发送时延和传播时延 发送时延：数据块长度(bit)/信道带宽(b/s)。主机或路由器发送数据帧所需要的时间，也就是从发送数据的第一个比特算起，到该帧的最后一个比特发送（到网线上）完毕所需的时间。发送时延也称为传输时延。 传播时延：数据在网络上传输开始到接收端完全接收数据结束。电磁波在信道中传播一定的距离需要花费的时间 处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，就这产生了处理时延。 排队时延：分组在经过网络传输时，会经过许多路由器。分组在进入路由器之前要先在输入队列中排队等待处理（因为可能无法一次处理完成）。在路由器确定了转发接口后，还要在输出队列中排队等待转发（因为可能无法一次发送完成）。这就产生了排队时延。 带宽决定了发送时延，带宽越大，时延越低，但是不能无限增大，数据太密集后，可能无法识别高电压和低电压，也就无法识别数据，这时就要考虑传播介质，传播介质决定传播时延，铜介质因为信号太密集就无法识别，而光纤可以 时延带宽积时延带宽积 = 带宽×传播时延 往返时间 RTT Round-Trip Time从发送方发送数据开始，到发送方收到接收方确认ping命令查看的时间就是往返时间 利用率信道利用率：有数据通过时间/(有+无)数据通过时间网络利用率：信道利用率加权平均值]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gns3使用]]></title>
    <url>%2Fpost%2F1f37d955.html</url>
    <content type="text"><![CDATA[官网：https://gns3.com/ ubuntu下安装gns3123sudo add-apt-repository ppa:gns3/ppasudo apt-get updatesudo apt-get install gns3-gui]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python播放视频]]></title>
    <url>%2Fpost%2Ffb7a8e23.html</url>
    <content type="text"><![CDATA[安装opencv1pip install opencv-python 如果使用以下方式安装，则安装opencv2，只能在python2.7下使用1sudo apt-get install python-opencv 导入123&gt;&gt;&gt; import cv2&gt;&gt;&gt; cv2.__version__&apos;3.4.1&apos; 播放视频这样只有声音12345678910111213141516import pygletimport oswindow=pyglet.window.Window(caption=&apos;my player&apos;)player=pyglet.media.Player()source=pyglet.media.load(&apos;./sound/movie.flv&apos;,streaming=False)player.play()@window.eventdef on_draw(): window.clear() player.get_texture().blit(0,0)pyglet.app.run()]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python变量和常量]]></title>
    <url>%2Fpost%2F7f049186.html</url>
    <content type="text"><![CDATA[变量命名 第一个字符必须是字母表中的字母(大写ASCII字符或小写ASCII字符或Unicode字符)或下划线(_)。 标识符的其它部分可以由字符(大写 ASCII 字符或小写 ASCII 字符或 Unicode字符)、下划线(_)、数字(0~9)组成。 标识符名称区分大小写 实际上是把变量b指向变量a所指向的数据1234567891011&gt;&gt;&gt; a=&apos;ABC&apos;&gt;&gt;&gt; print(a)ABC&gt;&gt;&gt; b=a&gt;&gt;&gt; print(b)ABC&gt;&gt;&gt; a=&apos;XYZ&apos;&gt;&gt;&gt; print(a)XYZ&gt;&gt;&gt; print(b)ABC 常量通常用全部大写的变量名表示常量，但无法保证不会被改变，本质还是变量 1PI = 3.14159265359]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2Fpost%2F8d4b7ae1.html</url>
    <content type="text"><![CDATA[以下为哈尔滨理工大学的计算机组成原理笔记使用的教材是唐朔飞的《计算机组成原理》 总述内容 基本部件的结构和组织方式 基本运算的操作原理 基本部件和单元的设计思想 教材 唐朔飞. 计算机组成原理（第2版）.高等教育出版社 David A.Patterson. John L.Hennessy. Computer Organization &amp; Design: A Hardware/Software Interface(计算机组成与设计：硬件/软件接口) David Harris, Sarah Harris. Digital Design and Computer Architecture. Morgan Kaufmann, 2007(数字设计和计算机系结构) 结构 概论计算机系统简介计算机的软硬件计算机系统 硬件：计算机的实体 软件：由具有各类特殊功能的信息程序组成 系统软件：管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行，包括标准程序库、语言处理程序、操作系统、服务程序、数据库管理系统、网络软件 应用软件：用户根据任务需要所编制的各种程序 计算机组成原理主要是讲硬件 计算机系统的层次结构应对系统复杂性的方法 抽象 层次化（Hierachy）：将被设计的系统划分为多个模块或子模块 模块化（Modularity）：有明确定义 （well-defined）的功能和接口 规则性（regularity）：模块更容易被重用 M0和M1都是实际机器，M2（操作系统）以上都是虚拟机。硬件主要研究M0和M1，软件主要研究M2以上计算机组成原理主要研究微指令层和机器语言层， 翻译程序将高级语言程序翻译成机器语言程序的软件称为翻译程序。 编译程序：将用户编写的高级语言程序（源程序）的全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序。只要源程序不变，就无须再次进行翻译。 解释程序：将源程序的一条语句翻译成对应于机器语言的一条语句，并且立即执行这条语句，接着翻译源程序的下一条语句，并执行这条语句，如此重复直至完成源程序的全部翻译任务。翻译一次执行一次，即使下一次重复执行该语句时，也必重新翻译。 每一条机器指令翻译成一组微指令，即构成一个微程序 计算机组成和计算机体系结构计算机体系结构描述程序员所见到的计算机系统的属性，概念性的结构与功能特性，包括指令系统、数据类型、寻址技术、I/O机理计算机组成描述如何实现计算机体系结构所体现的属性，即具体指令的实现 计算机体系结构规定了软件和硬件的接口，哪些功能应该由软件实现，哪些由硬件实现计算机组成则是根据体系结构规定的硬件实现的要求，使用哪些元件，什么样的物理结构来实现也就是说，体系结构像指挥官，告诉组成去实现哪些指令所以，从另一个角度，也就是程序员的角度来思考，就是体系结构是面向程序员的，他可以使用什么样的指令进行编程，来实现想要的功能，体系结构向上屏蔽了硬件实现细节，比如说实现寄存器0与寄存器1的数值相加，程序员知道这台机器提供了这样的指令，直接用来编程即可，具体是使用什么样的元件，什么样的连接，并不关心，只要有这样的功能就好了，这样的抽象，很大程度上屏蔽了复杂性；计算机组成则更多的是面向硬件工程师，要考虑采用什么样的元件来实现，如何提升效率，还要考虑电气特性等等 计算机的基本组成冯·诺依曼计算机的特点 计算机由运算器、存储器、处理器、输入设备和输出设备五大部件组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据均用二进制表示 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用于表示操作数在存储器中的位置 存储程序，指令在存储器内按顺序存放 以运算器为中心 哈佛结构是将数据和指令分开存储的结构 运算器：算术运算、逻辑运算控制器：指挥程序运行存储器：存放数据和程序输入设备：将信息转换成机器能识别的形式输出设备：将结果转换成人们熟悉的形式 寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。 运算器是瓶颈，改进：以存储器为中心的结构 现代计算机结构 计算机的工作过程 1.主存储器（内存）包括存储体和2个寄存器 存储体M包括多个存储单元，每个存储单元包括多个存储元件，每个存储元件存储一位二进制1或0存储单元存放的一串二进制代码称为存储字，这串二进制代码的长度称为存储字长每个存储单元都有一个编号，称为存储单元的地址号主存的工作方式就是按存储单元的地址号来实现对存储字各位的写入和读出，这种存取方式称为按地址存取方式，简称访存 寄存器： MAR：Memory Address Register，存储器地址寄存器，存放地址，其位数对应存储单元的个数，反映了能存多少个地址 MDR：Memory Data Register，存储器数据寄存器，存放数据，其位数与存储字长相等，反映了能存多在的数据 2.运算器包括3个寄存器和一个算术逻辑单元 算术逻辑单元，Arithmetic Logic Unit，ALU，算术逻辑运算 寄存器包括ACC累加器，MQ乘商寄存器，X操作数寄存器 3.控制器 控制器用于解释指令，并保证指令的按序执行。解释指令的过程包括取指过程、分析过程、执行过程 控制器包括程序计数器PC、指令寄存器IR、控制单元CU PC：取指，存放当前欲执行指令的地址，具有计数功能(PC)+1-&gt;PC，即自动形成下一条指令的地址 IR：分析，存放当前欲执行的指令，OP(IR)指操作码，Ad(IR)指地址码 CU：执行指令 一条指令在主机上的完成过程 PC存放程序的首地址，控制器将PC中的地址送至主存的MAR MAR读取存储体中的地址 将存储体中读到的内容送入MDR MDR将内容送到IR CU分析IR的操作码，当前操作码为取数指令 CU控制IR的地址码送入MAR MAR读取存储体中的地址 将存储体中读到的内容送入MDR MDR将数据送入ACC累加器 程序在主机上是如何执行的 计算机硬件的主要技术指标机器字长CPU一次能处理数据的位数，与 CPU 中的寄存器位数有关机器字长，指令字长和存储字长可以相等也可以不等。 运算速度 主频/时钟频率：CPU内部晶振的频率，常用单位为MHz，它反映了CPU的基本工作节拍 时钟周期：主频的倒数，t =1/ f 机器周期：一个机器周期包含若干个时钟周期，m*t 核数,每个核支持的线程数 吉普森法，每条指令的加权平均执行时间，根据计算百分比方法的不同分为静态（直接计算百分比）和动态（实际运行计算百分比）方法 CPI，平均每条指令的平均时钟周期个数，m*n 指令周期：执行一条指令所需要的时间，一般包含若干个机器周期，指令周期 = mtn = CPI×机器周期 MIPS：每秒执行百万条指令数， MIPS = 1/（CPI×时钟周期）= 主频/CPI FLOPS 每秒浮点运算次数，PFLOPS、MFLOPS 题： 若某处理器的时钟频率为500MHz，每4个时钟周期组成一个机器周期，执行一条指令需要3个机器周期，则该处理器的一个机器周期 8 ns，平均执行速度为 42 MIPS 解析如下：时钟周期T等于主频的倒数，即T=1/500MHz=1/（0.5×10的9次方Hz）=2 ns，机器周期等于4个时钟周期即=4T=4×2 ns=8 ns，每条指令的时钟周期数CPI=3×4=12，则平均速度为：f/（CPI×10的6次方）=（500×10的6次方）/（12×10的6次 方）=500/12=41.6≈42MIPS.计算主频的倒数时要注意把主频的MHz换算成Hz即500后面加6个0=500×10的6次方=0.5×10的9次方，1/10的9次方 Hz=1ns 每条指令的时钟周期数CPI=3×4=12，执行一条指令需要3个机器周期数，一个机器周期包含4个时钟周期，所以CPI=3×4=12，这里计算 的都是周期的个数，和具体的时间ns纳秒没有关系，若带上具体的时间，一个时钟周期T=2ns，一个机器周期就是2×4=8ns，执行一条指令需要三个机 器周期得出执行一条指令需要的具体时间为3×8=24ns，执行每条指令的需要的时钟周期数CPI换句话说就是把执行每条指令需要的时间24ns换算成时 钟周期个数表示，为多少个时钟周期个数?时钟周期是最基本的时间操作单位，500MHz主频的处理器一个时钟周期为2ns，24ns等于多少个时钟周期？24/2=12个时钟周期，即那一句：“每条指令的时钟周期数CPI=12”。 存储容量存放二进制信息的总位数 &lt;!– 1. 主存容量 存储单元个数 × 存储字长，2^MAR × MDR 位 字节数：2^13b= 1KB，2^21b= 256KB，1B = 2^3b 辅存容量，用字节数来表示，80GB（1GB = 2^30B） –&gt; 硬件结构计算机硬件系统由中央处理器、存储器、I/O系统以及连接它们的系统总线组成 总线计算机系统五大部件之间的互边连方式包括： 分散连接：各部件之间使用单独的连线，不利于扩展设备 总线连接：将各部件连到一组公共信息传输线上 总线的基本概念总线是连接各个部件的信息传输线，是各个部件共享的传输介质在某一时刻只允许一个部件向总线发送信息 总线的分类按照连接部件的不同，分为 片内总线：芯片内部的总线（片外总线不叫片外总线），CPU芯片内部、寄存器之间、寄存器与ALU之间 系统总线：CPU、主存、I/O设备之间的信息传输线，按系统总线传输信息的不同分为： 数据总线：双向 与机器字长、存储字长有关（小于等于） 地址总线：单向，由CPU输出 与存储地址、 I/O地址有关 控制总线：用来发出各种控制信号的传输线，从CPU输出（存储器读、存储器写、总线允许、中断确认）或输入（中断请求、总线请求） 通信总线：用于计算机系统之间或计算机系统与其他系统(如控制仪表、移动通信等)之间的通信，按传输方式分为 串行通信总线：数据在单条1位宽的传输线上，一位一位地按顺序分时传送。适用于远距离传送 并行通信总线：数据在多条并行1位宽的传输线上同时由源传送到目的地。。适用于近距离传送 并行传输因为互相干扰，所以传输距离短 串行传输和并行传输的优缺点： 串行传输 优点：使用的数据线少，在远距离通信中可以节约通信成本。 缺点：因为每次只能传输一位数据，所以传输速度比较低。 并行传输 优点：因为可以多位数据一起传输，所以传输速度很快。 缺点：内存有多少位，就要用多少数据线，所以需要大量的数据线，成本很高。 总线特性 机械特性：尺寸、形状、管脚数 及 排列顺序 电气特性：传输方向和有效的电平范围 功能特性：每根传输线的功能，地址、数据、控制 时间特性：信号的时序关系，总线中的任一根线在什么时间内有效 性能指标 总线宽度：数据总线的根数，总线能同时传送的二进制数据的位数，总线宽度越宽，每秒钟数据传输率越大，总线的带宽越宽。 标准传输率/总线带宽：单位时间内总线上传送的数据量，每秒传输的最大字节数(MBps，兆字节每秒)，总线的带宽＝总线的工作频率×总线宽度/8 时钟同步/异步：同步（总线上的数据与时钟同步工作）、不同步（不同步包括异步） 总线复用：一条信号线上分时传送两种信号，地址线与数据线复用，可以减少总线中信号线的数量、引脚的数量 信号线数：地址总线、数据总线和控制总线的总和 总线控制方式：突发、自动、仲裁、逻辑、计数 其他指标：负载能力 总线的工作频率总线的工作时钟频率以MHz为单位，工作频率越高，总线工作速度越快，总线带宽越宽。 总线标准系统与各模块、模块与模块之间的一个互连的标准界面 总线结构总线结构的改进总是按照解决瓶颈、功能分离、区分高速和低速的思路递进 单总线结构所有的设备都连接在一条系统总线上I/O设备和主存交换信息不必经过cup，减轻cpu负担CPU和主存之间交互需要经过总线，加大总线负担更容易发生冲突，需要设置总线判优逻辑，影响整机的工作效率 双总线结构将速度较低的I/O设备从单总线上分离出来通道是一个具有特殊功能的处理器，由通道对I/O统一管理 以CPU为中心，发出存储总线和I/O总线，分别连接主存和I/O设备。CPU和主存之间交互频繁单有单独总线，提高效率I/O设备与主存交换信息时仍然要占用CPU，影响CPU的工作效率 在单总线基础上加一条CPU和主存之间的总线。或者说面向CPU双总线结构基础上在主存连接到了I/O总线CPU和主存之间可以直接交换信息。I/O和主存之间交换信息也不用经过CPU。 三总线结构将速率不同的I/O设备进行分类 任一时刻只能使用一种总线 四总线结构将速度更快的接口从扩展总线接口分离 举例 总线控制使用总线需要解决两个问题，判优控制（总线同一时刻只允许一个部件发送信息）和通信问题（保证传输的正确性） 总线判优控制通过总线判优控制获得总线使用权，只有获得总线使用权的主设备才能开始传送数据 总线上所连接的各类设备按其对总线有无控制功能可分为主设备和从设备 主设备(模块) 对总线有控制权，发出总线请求 从设备(模块) 响应从主设备发来的总线命令 总线判优控制分为 集中式 链式查询：3根用于总线控制 计数器定时查询：计数器可以定义为0、上次执行的接口、或者某个k，优先级根据计数器的初始值设定，大致用log2(n)根线 独立请求：每一台设备均有一对总线请求线BR和总线同意线BG，2n根线，排队器设定优先级 分布式 总线通信控制解决通信双方协调配合问题 总线传输周期： 申请分配阶段 主模块申请，总线判优决定 寻址阶段 主模块向从模块 给出地址和命令 传数阶段 主模块和从模块交换数据 结束阶段 主模块撤消有关信息 总线通信的四种方式 同步通信：由统一时标控制数据传送，一般用于总线长度较短、各部件存取时间比较一致的场合 异步通信：采用应答方式，没有公共时钟标准，分为不互锁、半互锁和全互锁 不互锁：主模块不必等待接到从模块的回答信号，从模块不必等待接到主模块的回答信号 半互锁：主模块必须待接到从模块的回答信号后再撤销其请求信号，从模块不必等待接到主模块的回答信号 全互锁：主模块必须待接到从模块的回答信号后再撤销其请求信号，从模块必须待接到主模块的回答信号后再撤销其请求信号 半同步通信：同步（发送方用系统时钟前沿发信号，接收方用系统时钟后沿判断、识别）、异步（允许不同速度的模块和谐工作）结合，增加一条 “等待”响应信号WAIT 分离式通信：充分挖掘系统总线每个瞬间的潜力，总线上所有模块都可以成为主模块 一个总线传输周期(以输入数据为例) 主模块发地址、命令 占用总线 从模块准备数据 不占用总线 总线空闲 从模块向主模块发数据 占用总线 分离式通信改进一个总线传输周期，各模块准备数据时，不占用总线 子周期1：主模块申请占用总线，使用完后即放弃总线的使用权 子周期2：从模块申请占用总线，将各种信息送至总线上 分离式通信特点 各模块有权申请占用总线 采用同步方式通信，不等对方回答（同步通信主模块不用等待从模块是否得到响应，可以缩短各个设备的数据传送时间，实现高速度、大容量的数据传送。） 各模块准备数据时，不占用总线 总线被占用时，无空闲充分提高了总线的有效占用 存储器存储器的分类按存储介质分类 半导体存储器 双极性（TTL）半导体存储器、MOS半导体存储器 易失 磁表面存储器 磁盘、磁带、磁鼓 非易失 磁芯存储器 硬磁材料、环状元件 非易失 光盘存储器 激光、磁光材料 非易失 按存取方式分类 存取时间与物理地址无关(随机访问) 随机存储器RAM 在程序的执行过程中可读、可写，分为静态RAM和动态RAM 只读存储器ROM 在程序的执行过程中 只 读 存取时间与物理地址有关(串行访问) 顺序存取存储器 磁带 直接存取存储器 磁盘 按在计算机中的作用分类 主存储器：可以直接和CPU交换信息 辅助存储器：存放当前暂时不用的程序和数据 缓冲存储器：用在两个速度不同的部件之中 存储器的层次结构存储器有3个主要性能指标：速度、容量和每位价格不只CPU中有寄存器，IO设备也会有 为了实现高速度、大容量和低价格，所以需要存储器的层次结构存储系统层次结构主要体现在缓存-主存和主存-辅存这两个存储层次 缓存-主存解决CPU和主存速度不匹配的问题，由硬件自动完成（只使用硬件是为了提高速度），使用实地址/物理地址（主存的实际地址） 主存-辅存解决存储系统的容量问题，由硬件和操作系统共同完成，使用虚地址/逻辑地址（虚拟存储器，主存+辅存），逻辑地址转物理地址由硬件和操作系统完成 局部性原理: CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。顺序局部性：在典型程序中，除小部分转移类指令外，大部分指令是顺序进行的。即程序的地址访问流有很强的时序相关性，根据这一原理，多级存储器体系把主存储器中访问概率最高的内容存放在Cache中，当CPU需要读取数据时就首先在Cache中查找是否有所需内容，如果有则直接从Cache中读取；若没有再从主存中读取，然后同时送往Cache和CPU，主辅亦是。故可以按对所使用的指令和数据的急迫和频繁程度，将其存入容量、速度、价格不同的存储器中，增加了时间优化的命中率，取得更高的性能价格比访问模式与最近已发生的访问模式相似。 主存储器概述主存的基本组成存储体、MAR、MDR驱动器、译码器和读写电路都在存储芯片上，MAR和MDR在CPU芯片上 主存与CPU之间的联系 主存中存储单元地址的分配参考https://blog.csdn.net/lishuhuakai/article/details/8934540 主存的技术指标 存储容量：主存存放二进制代码的总位/字节数 存储速度 存取时间：存储器的访问时间，启动一次存储器操作到完成该操作所需的全部时间 读出时间： 写入时间 存取周期 连续两次独立的存储器操作(读或写)所需的最小间隔时间，通常存取时间要比存取周期要短 读周期 写周期 存储器的带宽：单位时间内存储器存取的信息量，位/秒、字节/秒 半导体存储芯片半导体存储芯片的基本结构半导体存储芯片包括存储矩阵、译码驱动电路和读/写电路译码驱动电路用于将地址转换为选择信号存储芯片通过地址总线、数据总线和控制总线与外部连接地址线和数据线的位数共同反映存储芯片的容量控制线包括读写控制线和片选线（芯片选择线）半导体存储器由许多芯片组成，片选线用来选择芯片 半导体存储芯片的译码驱动方式 线选法：只能用于小容量，需要 2^地址线 个存储单元，如果地址线为20则需要1M个选择线 重合法：如果地址线为20则需要64根选择线 为什么在内存中数据需要对齐存储 平台原因(移植原因) 不是所有的硬件平台都能访问任意地址上的任意数据的； 某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 性能原因 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 随机存取存储器(RAM)静态RAM，SRAM使用触发器工作原理存储信息 动态RAM，DRAM使用电容存储电荷存储信息 刷新因为动态RAM使用电容存储电荷方式存储信息，电荷会消失，需要刷新，每次刷新都是刷新一行，每2ms都必须对所有行进行一次刷新刷新的过程实际上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程 集中刷新：集中一段时间，死区 分散刷新：分散到每个存取周期 异步刷新：结合集中刷新和分散刷新 只读存储器(ROM) 掩模ROM/MROM：在厂家就写好了内容，行列选择线交叉处有MOS管为1，行列选择线交叉处无MOS管为0 PROM：一次性编程，熔丝断为0，熔丝未断为1 EPROM：多次性编程，使用紫外线全部擦洗 EEPROM：多次性编程，电可擦写、局部擦写、全部擦写 Flash Memory (闪速型存储器) 存储器与 CPU 的连接存储容量的扩展 位扩展：增加存储字长，需要片选信号一致 字扩展：增加存储字的数量，将新增的地址线作为片选信号 同时扩展 存储器与CPU的连接 地址线的连接：CPU地址线的低位与存储芯片的地址线相连，高位用于扩展 数据线的连接 读/写命令线的连接：一般可直接相连，高电平为读，低电平为写 片选线的连接：片选有效信号与CPU的MREQ（访存控制信号，低电平有效，高电平表示CPU访问IO）有关， 合理选择存储芯片：存储芯片类型（ROM用于存放系统程序、标准子程序和各类常数，RAM用于存放用户数据）和数量（连线方便） 存储器的校验存储器的校验是为了能及时发现错误并及时纠正错误。 编码的检测能力和纠错能力与任意两组合法代码之间二进制位的最少差异数有关。 编码的最小码距d与纠错能力的关系：码距 1 检错位数 0 纠错位数 0码距 2 检错位数 1 纠错位数 0码距 3 检错位数 1 纠错位数 1码距 4 检错位数 2 纠错位数 1码距 5 检错位数 2 纠错位数 2检错位数=码距/2，取整数纠错位数=检错位数(-1)，如果码距/2余数为0，则减1，否则不减 存储器的校验使用汉明码校验，请参考数据校验码 提高访存速度的措施调整缓冲存储器辅助存储器输入输出系统中央处理器CPU控制单元CU]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python数据类型]]></title>
    <url>%2Fpost%2F9f07ae5c.html</url>
    <content type="text"><![CDATA[数据类型 整数：-1，100，0，0xff00（十六进制整数） 浮点数：1.23，-9.01，1.23e9，1.23-5 字符串：&#39;12c&#39;，&quot;ab&quot;，&quot;I&#39;m OK&quot;，&#39;I\&#39;m OK&#39; 布尔值：True，False（首字母大写） 空值：None 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的），而浮点数运算则可能会有四舍五入的误差。 转义字符：\n，\\，\t，\&#39;，\&quot; 用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义 用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容 1234&gt;&gt;&gt; print(r&apos;&apos;&apos;hello,\n... world&apos;&apos;&apos;)hello,\nworld and，or，not1234567891011121314&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1&gt;2True 数据类型转换1234567891011121314&gt;&gt;&gt; s=&apos;123&apos;&gt;&gt;&gt; s&apos;123&apos;&gt;&gt;&gt; int(s)123&gt;&gt;&gt; a=123&gt;&gt;&gt; a123&gt;&gt;&gt; str(a)&apos;123&apos;&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(&apos;&apos;)False]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python输入输出及基础]]></title>
    <url>%2Fpost%2F32cf0123.html</url>
    <content type="text"><![CDATA[输出自动添加空格 123456&gt;&gt;&gt;print(&apos;hello world&apos;)hello world&gt;&gt;&gt;print(&apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;)The quick brown fox jumps over the lazy dog&gt;&gt;&gt;print(&apos;1024 * 768 =&apos;,1024*768)1024 * 768 = 786432 输入12&gt;&gt;&gt;name=input(&apos;please input your name:&apos;)&gt;&gt;&gt;print(&apos;name:&apos;,name) 采用缩进方式当语句以冒号:结尾时，缩进的语句视为代码块Python程序是大小写敏感的使用4个空格的缩进以#开头的语句是注释]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编码]]></title>
    <url>%2Fpost%2Fd6d2cac9.html</url>
    <content type="text"><![CDATA[编码 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节12345678910&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; ord(&apos;中&apos;)20013&gt;&gt;&gt; chr(66)&apos;B&apos;&gt;&gt;&gt; chr(25991)&apos;文&apos;&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;&apos;中文&apos; str和bytes12x=b&apos;ABC&apos;y=&apos;ABC&apos; y是str，x是bytes，内容显示一样，但bytes每个字符都只占用一个字节 Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes(各个平台的编码不一定都相同，socket 传递的数据都是bytes类型的，避免乱码) Python 3 不会以任意隐式的方式混用str和bytes Bytes 对象是由单个字节作为基本元素（8 位，取值范围 0-255）组成的序列，为不可变对象。 Bytes对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。我们可以通过调用bytes() 类（没错，它是类，不是函数）生成bytes实例，其值形式为b&#39;xxxxx&#39;，其中&#39;xxxxx&#39;为一至多个转义的十六进制字符串（单个 x 的形式为：\xHH，其中 \x 为小写的十六进制转义字符，HH 为二位十六进制数）组成的序列，每个十六进制数代表一个字节（八位二进制数，取值范围 0-255），对于同一个字符串如果采用不同的编码方式生成 bytes 对象，就会形成不同的值 str编码为指定的bytes12345678&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)b&apos;ABC&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf8&apos;)b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\x##显示。 bytes编码为str12345678&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)&apos;ABC&apos;&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf8&apos;)&apos;中文&apos;&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;ascii&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 0: ordinal not in range(128) len函数12345678&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;)2&gt;&gt;&gt; len(b&apos;abc&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf8&apos;)) 6 文件编码12#!/usr/bin/env python# encoding=utf-8 第一行会告诉系统使用的python路径，不建议使用#!/usr/bin/python，灵活性降低 1234import syssys.getdefaultencoding()&apos;utf-8&apos; 格式化1234567891011&gt;&gt;&gt; &apos;Hello,%s&apos;%&apos;world&apos;&apos;Hello,world&apos;&gt;&gt;&gt; &apos;Hi,%s,you have $%d.&apos;%(&apos;Michael&apos;,10000)&apos;Hi,Michael,you have $10000.&apos;&gt;&gt;&gt; print(&apos;$%2d-$%02d&apos; % (3,1))$ 3-$01&gt;&gt;&gt; print(&apos;%.2f&apos; % 3.1415926)3.14&gt;&gt;&gt; &apos;growth rate:%d %%&apos; % 7&apos;growth rate:7 %&apos; %d 整数%f 浮点数%s 字符串%x 十六进制整数 如果不太确定应该用什么，%s永远起作用 format()12&gt;&gt;&gt; &apos;Hello,&#123;0&#125;,成绩提升了&#123;1:.1f&#125;&apos;.format(&apos;小明&apos;,17.125)&apos;Hello,小明,成绩提升了17.1&apos; 参考： http://www.ituring.com.cn/article/1116 https://www.kancloud.cn/lanyulei/python/357700 https://segmentfault.com/a/1190000004450876]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Anaconda]]></title>
    <url>%2Fpost%2F634c672f.html</url>
    <content type="text"><![CDATA[Anaconda 是一种Python语言的包管理工具，用于进行大规模数据处理, 预测分析, 和科学计算, 致力于简化包的管理和部署。 Anaconda使用软件包管理系统Conda进行包管理。 实际上我使用Anaconda是为了避免Python2和Python3的冲突，我既想使用Python3又不想改变Python2原来的东西 官网：https://anaconda.org/ 安装下载：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/选择对应的Python版本和系统进行下载安装 12bash Anaconda3-5.2.0-Linux-x86_64.shconda upgrade --all 安装包管理列出已经安装的包：pip list或conda list安装新包：pip install 包名或conda install 包名更新包： conda update package_name升级所有包：conda upgrade --all卸载包：conda remove package_names搜索包：conda search search_term 管理环境安装nb_conda，用于notebook自动关联nb_conda的环境conda install cb_conda创建环境：conda create -n env_name package_names[=ver]指定Python版本：conda create -n py3 python=3.6可以切换不同的Python版本使用环境：activate env_name离开环境：deactivate导出环境设置：conda env export &gt; environmentName.yaml 或 pip freeze &gt; environmentName.txt导入环境设置：conda env update -f=/path/environmentName.yaml 或 pip install -r /path/environmentName.txt导出和导入可以用于共享环境，在 GitHub 上共享代码时，最好同样创建环境文件并将其包括在代码库中。这能让其他人更轻松地安装你的代码的所有依赖项。列出环境清单：conda env list删除环境： conda env remove -n env_name 参考： https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim中Python相关插件]]></title>
    <url>%2Fpost%2Fd52f3c59.html</url>
    <content type="text"><![CDATA[tell-k/vim-autopep8依照pep8的标准自动格式化代码插件依赖autopep81pip install --upgrade autopep8 安装插件1Plug &apos;tell-k/vim-autopep8&apos; 使用1234:Autopep8:Autopep8 --range 1 5 # with arguments:call Autopep8(&quot; --range 1 5&quot;) # with arguments:&apos;&lt;,&apos;&gt;Autopep8 # range selection 配置12autocmd FileType python noremap &lt;buffer&gt; &lt;F8&gt; :call Autopep8()&lt;CR&gt;let g:autopep8_max_line_length=119 Yggdroot/indentLine显示缩进指示线1Plug &apos;Yggdroot/indentLine&apos; Valloric/YouCompleteMeYouCompleteMe不支持Anaconda，所以要指定原生Python路径 依赖12sudo apt-get install build-essential cmakesudo apt-get install python-dev python3-dev 配置/安装12Plug &apos;Valloric/YouCompleteMe&apos;let g:ycm_server_python_interpreter=&apos;/usr/bin/python3.5&apos; 编译12cd ~/.vim/bundle/YouCompleteMe/usr/bin/python3.5 ./install.py 参考： https://www.jianshu.com/p/f0513d18742a https://github.com/Valloric/YouCompleteMe/issues/2876 https://github.com/JeffyLu/JeffyLu.github.io/issues/15]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM模版]]></title>
    <url>%2Fpost%2F22b97e54.html</url>
    <content type="text"><![CDATA[用Vim写Python的时候，每次都要在开头写路径和编码，索性直接用模版直接使用插件方式配置模版 安装插件使用vim-plug配置，vim .vimrc添加1Plug &apos;aperezdc/vim-template&apos; 保存，重新打开.vimrc，进行安装1:PlugInstall 配置模版模版文件在.vim/plugged/vim-template/templates下 参考： https://www.jianshu.com/p/996afb9e4086]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pygame相关]]></title>
    <url>%2Fpost%2F7e3c85d2.html</url>
    <content type="text"><![CDATA[pygame是主要构筑在SDL库基础上的一组Python模块的集合，它使我们能够用Python语言来创建功能完整的游戏和多媒体程序。pygame是高度括平台可移植的，在任何SDL支持的平台上都可以运行（几乎可以在任何平台和操作系统上运行）。 注：SDL(Simple DirectMedia Layer)是一个跨平台的多媒体库，可以用来访问底层的音频、键盘、鼠标、摇杆、3D硬件（通过OpenGL）以及2D视频缓冲。它被用在MPEG播放软件、模拟器和很多流行的游戏中，包括获得大奖的Linux版的”Civilization: Call To Power”。 安装Pygamehttps://www.pygame.org/wiki/GettingStarted1234pip install pygame#检验是否安装成功python3 -m pygame.examples.aliens 导入123import pygame# 引入 pygame 中的所有常量from pygame.locals import * 模块 模块 说明 cdrom 访问光驱 cursors 加载光标图像，包含标准光标 display 控制显示窗口或屏幕 draw 在Surface上绘制简单的图形 event 管理事件和事件队列 font 创建并呈现TrueType字体 image 保存并加载图像 joystick 管理游戏手柄设备 key 管理键盘 pygame.mixer 音效 mouse 管理鼠标 pygame.movie 播放视频 pygame.music 播放音频 pygame.rect 管理矩形区域 pygame.sprite 操作移动图像 sndarray 用numpy操纵声音 surfarray 用numpy处理图像 time 控制时间 transform 缩放，旋转和翻转图像 初始化和退出12345# 导入并初始化所有 pygame 模块，使用其他模块之前，必须先调用 init 方法pygame.init()# 卸载所有 pygame 模块，在游戏结束之前调用，没有必要显式的调用这个函数，因为pygame会在python退出的时候自动清理所有已经初始化的模块pygame.quit() 窗口/suiface pygame.displaypygame.display模块用于创建、管理游戏窗口需要先创建一个窗口。其他的活动都是基于窗口的 1pygame.display.set_mode(resolution=(0,0),flags=0,depth=0) resolution：指定屏幕的宽和高，默认创建的窗口大小和屏幕大小一致 flags：标志位 FULLSCREEN 创建一个全屏窗口 DOUBLEBUF 创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用 HWSURFACE 创建一个硬件加速的窗口，必须和FULLSCREEN同时使用 OPENGL 创建一个OPENGL渲染的窗口 RESIZABLE 创建一个可以改变大小的窗口 NOFRAME 创建一个没有边框的窗口 depth：颜色的位深，默认自动匹配 12345678910111213141516171819# 指定窗口的宽和高# 只能有一个screen = pygame.display.set_mode((600,500))screen = pygame.display.set_mode((1024, 768), pygame.FULLSCREEN)# 设置窗口的标题pygame.display.set_caption(&apos;Hello World!&apos;)# 填充背景颜色screen.fill((255,255,255))# 刷新屏幕内容显示，把内容显示到屏幕上pygame.display.update()# 如果使用DOUBLEBUF，需要用flip函数把内容显示到屏幕上pygame.display.flip()# 可以查看当前设备支持的分辨率pygame.display.list_modes() 游戏循环如果没有循环，窗口无法保持，只能看到一闪而过 一个游戏循环（也可以称为主循环）就做下面这三件事： 处理事件 更新游戏状态 绘制游戏状态到屏幕上 12while True: pass 12345678910111213import pygamefrom pygame.locals import *pygame.init()screen = pygame.display.set_mode((600,500))pygame.display.set_caption(&apos;Hello World&apos;)while True: passpygame.quit() 坐标系以左上角为（0，0）点，往右方向为X轴，往下方向为Y轴，单位为像素 矩形区域 pygame.Rectpygame.Rect是用于存储直角坐标的pygame对象，在游戏中所有可见的元素都是以矩形区域来描述位置的（区别于绘制图形中的矩形） 对象12Rect(left, top, width, height)Rect((left, top), (width, height)) 前两项描述位置，后两项描述大小 属性123456x,ytop, left, bottom, righttopleft, bottomleft, topright, bottomrightmidtop, midleft, midbottom, midrightcenter, centerx, centerysize, width, height 绘制图形 pygame.draw1234567891011121314151617181920212223242526pygame.draw.rect(Surface, color, Rect, width=0)# 绘制一个矩形形状pygame.draw.polygon(Surface, color, pointlist, width=0) # 绘制多边形pygame.draw.circle(Surface, color, pos, radius, width=0) # 围绕一个点画一个圆pygame.draw.ellipse(Surface, color, Rect, width=0)# 在矩形内绘制圆形pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1) # 绘制一个椭圆的局部部分pygame.draw.line(Surface, color, start_pos, end_pos, width=1) # 画出一条直线段pygame.draw.lines(Surface, color, closed, pointlist, width=1)# 绘制多个连续的线段pygame.draw.aaline(Surface, color, startpos, endpos, blend=1) # 画精美的抗锯齿线pygame.draw.aalines(Surface, color, closed, pointlist, blend=1) # 绘制抗锯齿线的连接序列 实例12345678910111213141516171819202122232425262728293031323334import pygamefrom pygame.locals import *from math import pi # 定义颜色RED = (255,0,0)GREEN = (0,255,0)BLUE = (0,0,255)pygame.init()screen = pygame.display.set_mode((600,600))pygame.display.set_caption(&apos;绘制图形&apos;)# screen.fill((255,255,255))pygame.draw.rect(screen,BLUE,(400,400,100,100))pygame.draw.polygon(screen,GREEN,[[400,0],[500,70],[450,100]],5)pygame.draw.circle(screen,BLUE,[10,500],40)pygame.draw.ellipse(screen,BLUE,(300,200,50,40))pygame.draw.ellipse(screen,RED,(200,200,50,40),5)pygame.draw.arc(screen,GREEN,(300,500,40,40),0,pi/2,2)pygame.draw.arc(screen,RED,(300,500,40,40),pi/2,pi,2)pygame.draw.arc(screen,BLUE,(300,500,40,40),pi,3*pi/2,2)pygame.draw.arc(screen,(255,255,255),(300,500,40,40),3*pi/2,2*pi,2)pygame.draw.line(screen,RED,[1,1],[50,50],5)pygame.draw.lines(screen,RED,True, [[0,80],[50,90],[200,80],[220,30]],5)pygame.draw.aaline(screen,RED,[80,80],[40,90],True)while 1: pass pygame.display.update() 字体/文本 pygame.fontpygame.font模块将文本打印到窗口 12345678910111213pygame.font.Font(filename, size)# filename：字体文件的文件名# size：字体的高 height，单位为像素pygame.font.Font.render(text, antialias, color, background=None)# text：要显示的文字，文字只能包含一行，换行符不会被画出来# antialias： 是否抗锯齿# color：字体颜色# background：背景颜色（可选参数），如果没有指定background，背景是透明的# 返回一个surgacepygame.font.get_fonts()# 获取可用的字体的列表 1234567891011121314151617181920import pygamepygame.init()screen = pygame.display.set_mode((300,300))pygame.display.set_caption(&apos;Font&apos;)# 1.字体对象，指定字体和大小myfont = pygame.font.Font(None,60)# myfont = pygame.font.Font(&apos;./font/楷体_GB2312.ttf&apos;,60)# 2.指定文本内容，文本颜色，文本背景色textSufaceObj = myfont.render(&apos;Hello world&apos;,True,(255,255,255),(0,255,0))# 3.指定文本位置screen.blit(textSufaceObj,(50,100))while 1: # 4.显示文本 pygame.display.update()pygame.quit() 图像123456789img = pygame.image.load(filename)# 加载一张图片# 返回一个包含图像的Surface，Surface的格式和原来的文件相同（包括颜色格式、透明色和alpha透明）pygame.Surface.blit(img, dest, area=None, special_flags = 0)# 将图片绘制到屏幕相应坐标上（后面两个参数默认，可以不传）pygame.image.save(img, filename)# 把img这个Surface的内容保存为filename指定的图像文件 123456789101112131415161718192021import pygamefrom pygame.locals import *pygame.init()screen = pygame.display.set_mode((100,100))pygame.display.set_caption(&apos;Image&apos;)image = pygame.image.load(&apos;./Ball.png&apos;)# 获得图像位置imageRect = image.get_rect()# 指定图片居中imageRect.center = (50,50)screen.fill((156,178,166))# screen.blit(image,(50,50))screen.blit(image,imageRect)while 1: pygame.display.update()pygame.quit() 音频背景音乐1pygame.mixer.music.load(filename) filename：音频文件的文件名该方法用来加载背景音乐，之后调用 pygame.mixer.music.play( ) 方法就可以播放背景音乐（Pygame 只允许加载一个背景音乐在同一个时刻）音乐文件可以很大，系统以流的形式播放 12345678910111213141516pygame.init() #进行全部模块的初始化， pygame.mixer.init() #或者只初始化音频部分 pygame.mixer.music.load(&apos;xx.mp3&apos;) #使用文件名作为参数载入音乐 ,音乐可以是ogg、mp3等格式。载入的音乐不会全部放到内容中，而是以流的形式播放的，即在播放的时候才会一点点从文件中读取。 pygame.mixer.music.play() #播放载入的音乐。该函数立即返回，音乐播放在后台进行。#play方法还可以使用两个参数 pygame.mixer.music.play(loops=0, start=0.0) #loops和start分别代表重复的次数和开始播放的位置 pygame.mixer.music.stop() #停止播放 pygame.mixer.music.pause() #暂停播放pygame.mixer.music.unpause() #取消暂停pygame.mixer.music.fadeout(time) #用来进行淡出，在time毫秒的时间内音量由初始值渐变为0，最后停止播放pygame.mixer.music.set_volume(value) #来设置播放的音量，音量value的范围为0.0到1.0pygame.mixer.music.get_busy() #判断是否在播放音乐,返回1为正在播放pygame.mixer.music.set_endevent(pygame.USEREVENT + 1) #在音乐播放完成时，用事件的方式通知用户程序，设置当音乐播放完成时发送pygame.USEREVENT+1 #事件给用户程序pygame.mixer.music.queue(filename) #使用指定下一个要播放的音乐文件，当前的音乐播放完成后自动开始播放指定的下一个。一次只能指定一个等待播放的音乐文件 123456789import pygamepygame.init()pygame.mixer.music.load(&apos;./sound/background.mp3&apos;)pygame.mixer.music.play()while 1: pass 循环播放123456789101112131415import pygamepygame.init()pygame.mixer.music.load(&apos;./sound/曲锦楠 - 霞光.mp3&apos;)pygame.mixer.music.play()clock = pygame.time.Clock()while 1: clock.tick(1) isbusy = pygame.mixer.music.get_busy() print(isbusy) if isbusy == 0: pygame.mixer.music.play() 特效声音要在游戏中播放碰撞、爆炸、语音等音效，需要使用pygame.mixer模块。这个模块支持同时播放多个音效文件，多个文件在多个不同的通道Channel中播放，一个通道一次只能播放一个音效文件。 音效和音乐的区别是：音效要整个文件载入到Sound对象中才能播放，而音乐不用完全载入，而以流的方式播放。12345678910111213141516171819202122232425262728293031323334353637383940pygame.mixer.get_num_channels()# 查看总共有多少个通道channel = pygame.mixer.Channel(i)# 取得第i个通道channel = pygame.mixer.find_channel()# 自动取得一个空闲的通道（没有音效正在播放的通道）sound = pygame.mixer.Sound(&apos;./sound/enemy1_down.wav&apos;)channel.play(sound)# 在一个通道中播放一个音效sound.play()# 自动找一个空闲的通道播放音效sound.stop()# 停止音效sound的播放channel.stop()# 停止在通道channel中播放的音效channel.pause()# 暂停通道中的音效channel.unpause()# 暂停的音效继续播放channel.get_busy()# 检查通道是否正在播放音效channel.fadeout(time)# 淡出，在time毫秒的时间内音量由初始值渐变为0，最后停止播放channel.queue(soundfile)# 为正在播放音效的通道指定下一个要播放的音效。当前的音效播放完成后，下一个音效会自动播放。一个通道只能有一个等待播放的音效。channel.set_volume(value)# 设置通道中播放的音效的音量sound.set_volume(value)# 设置单个音效的音量# 两者的取值范围都是0.0到1.0。音效播放的实际音量是通道音量和音效音量的乘积，比如通道音量0.5，音效音量0.6，则实际播放的音量为0.3 说了这么多，实际上只需要两句就足够了12sound = pygame.mixer.Sound(&apos;./sound/enemy1_down.wav&apos;)sound.play() 视频 pygame.moviehttps://stackoverflow.com/questions/37775635/pygame-movie-missing 该模块已经过时 要在游戏中播放片头动画、过场动画等视频画面，可以使用pygame.movie模块 要播放视频中的音乐，pygame.movie模块需要对音频接口的完全控制，不能初始化mixer模块。因此要这样完成初始化~~12pygame.init()pygame.mixer.quit() 或者只初始化1pygame.display.init() 12345678910111213141516171819202122movie = pygame.movie.Movie(’filename’)# 指定文件名载入视频。视频的格式可以为mpeg1。视频文件不会马上全部载入内存，而是在播放的时候一点一点的载入内存。movie.set_display(pygame.display.set_mode((640,480)))# 指定播放的surface。movie.set_volume(value)# 指定播放的音量。音量的值value的取值范围为0.0到1.0。movie.play() # 播放视频。这个函数会立即返回，视频在后台播放。这个函数可以带一个参数loops，指定重复次数。movie.stop()# 停止播放movie.pause()# 暂停播放movie.skip(seconds)# 使视频前进seconds秒钟。如有不懂的可以参考Pygame的官方例子，在Python安装目录下的\lib\site-packages\pygame\examples\movieplayer.py文件。 动画帧率（Frame rate）：每秒钟能够刷新的次数 12345pygame.time.Clock()# 获得 pygame 的时钟对象pygame.time.Clock.tick(FPS)# 设置 pygame 时钟的间隔时间 123456789101112131415161718192021222324252627import pygamefrom pygame.locals import *pygame.init()screen = pygame.display.set_mode((100,100))pygame.display.set_caption(&apos;Image&apos;)image = pygame.image.load(&apos;./Ball.png&apos;)imageRect = image.get_rect()imageRect.center = (50,50)# screen.blit(image,(50,50))fps = pygame.time.Clock()while 1: fps.tick(10) imageRect.x += 1 # 需要重新绘制背景 screen.fill((156,178,166)) screen.blit(image,imageRect) # pygame.display.flip() pygame.display.update()pygame.quit() 事件Pygame通过一个事件系统与用户进行交互，以及处理一些系统发生的事件。事件系统包括一个事件队列，其中每一项都是一个Event对象。所有的用户输入和一些系统事件，都会形成一个Event对象被添加到事件队列中。Event对象有各种不同的类型，通过Event.type属性来区分。不同的类型的Event对象还有不同的其它属性。通过Event.dict属性来查看。 详细：http://www.xefan.com/archives/83586.html 1234567891011121314151617181920212223242526272829303132333435363738import pygamefrom pygame.locals import *pygame.init()screen = pygame.display.set_mode((600,600))pygame.display.set_caption(&apos;Event&apos;)while 1: # 获取事件列表 for event in pygame.event.get(): # 点击关闭 if event.type == QUIT: pygame.quit() exit() # 鼠标移动 if event.type == MOUSEMOTION: print(event.pos) if event.type == MOUSEBUTTONDOWN: print(&apos;鼠标按下&apos;,event.pos) if event.type == MOUSEBUTTONUP: print(&apos;鼠标抬起&apos;,event.pos) # 方向键 if event.type == KEYDOWN: if (event.key == K_UP or event.key == K_w): print(&apos;上&apos;) if (event.key == K_DOWN or event.key == K_s): print(&apos;下&apos;) if (event.key == K_LEFT or event.key == K_a): print(&apos;左&apos;) if (event.key == K_RIGHT or event.key == K_d): print(&apos;右&apos;) if event.key == K_ESCAPE: pygame.quit() exit() 定时器每隔多少时间触发一次事件pygame中的时间是以毫秒（千分之一秒）表示的1234567891011# 自定义计时事件COUNT = pygame.USEREVENT +1# 每隔1秒发送一次自定义事件pygame.time.set_timer(COUNT,1000)# 获取事件for event in pygame.event.get(): # 判断事件是否为计时事件 if event.type == COUNT: pass 计时器1234567891011121314151617181920212223242526272829import pygame,timefrom pygame.locals import *SCREEN_RECT = pygame.Rect(0,0,700,200)COUNT = pygame.USEREVENT+1pygame.init()screen = pygame.display.set_mode(SCREEN_RECT.size)pygame.display.set_caption(&apos;time&apos;)font = pygame.font.Font(None,60)pygame.time.set_timer(COUNT,1000)while 1: for event in pygame.event.get(): if event.type == QUIT: pygame.quit() exit() if event.type == COUNT: now = time.ctime() clock = now[11:19] timeObj = font.render(clock,True,(255,255,255)) # timeObj = font.render(now,True,(255,255,255)) timeRect = timeObj.get_rect() timeRect.center = SCREEN_RECT.center screen.fill((0,0,0)) screen.blit(timeObj,timeRect) pygame.display.update() 冲突while True: # 程序主循环 for event in pygame.event.get():# 获取事件 if event.type == QUIT:# 判断事件是否为退出事件 pygame.quit()# 退出pygame sys.exit()# 退出系统 pygame.display.update()# 绘制屏幕内容 参考： http://www.xefan.com/archives/83574.html https://www.jianshu.com/u/e46ded17a290]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简明Python教程-读书笔记]]></title>
    <url>%2Fpost%2Fd1f541ed.html</url>
    <content type="text"><![CDATA[《简明Python教程》读书笔记 使用《简明Python教程》漠伦翻译版https://bop.mol.uno/使用Python3.5.1 关于Python简单、易于学习、自由且开放（FLOSS）、高级语言、跨平台性、解释性、面向对象、可扩展性、可嵌入性、丰富的库 在程序内部，Python会将源代码转换为称为字节码的中间形式，尔后再转换成你的电脑所使用的语，并运行它 安装Linux12sudo apt install python3python3 -V 第一步通过Python运行程序有两种方法 使用交互式解释器提示符&gt;&gt;&gt; 直接运行一个源代码python test.py Python区分大小写 获取帮助1help(&apos;input&apos;) 最好使用引号，不使用引号有时会出错，比如help(return)按q退出 基础 注释：使用# 字面常量 数字：整数1、浮点数3.23``52.3E-4 字符串：字符串是不可变的 单引号：所有引号中的空格、制表符保留原样（不是转义\t） 双引号：和单引号括起的字符串一样 三引号：”””或’’’，多行字符串 Python从0开始计数 字符串字符串格式化123age = 20name = &apos;Swaroop&apos;print(&apos;&#123;0&#125; was &#123;1&#125; years old when he wrote this book&apos;.format(name,age)) 不需要转换格式，数字可以不写 1234567#对于浮点数&apos;0.333&apos;保留小数点(.)后三位print(&apos;&#123;0:.3f&#125;&apos;.format(1.0/3))#使用下划线填充文本,并保持文字处于中间位置#使用(^)定义&apos;___hello___&apos;字符串长度为11print(&apos;&#123;0:_^11&#125;&apos;.format(&apos;hello&apos;))#基于关键词输出&apos;Swaroop wrote A Byte of Python&apos;，不能用&#123;0&#125;print(&apos;&#123;name&#125; wrote &#123;book&#125;&apos;.format(name=&apos;Swaroop&apos;,book=&apos;A Byte of Python&apos;)) print会以\n结尾，通过end可以指定结尾方式12print(&apos;a&apos;,end=&apos;&apos;)print(&apos;b&apos;,end=&apos; &apos;) print()用,连接字符串，且会自动加上空格1print(&apos;a&apos;,&apos;b&apos;) 字符串连接1name + &apos;is&apos; + str(age) + &apos;years old&apos; 不如格式化美观，容易出错，而且需要转换类型 转义字符 \&#39;：单引号 \n：换行 \t：制表符 在一个字符串中，一个放置在末尾的反斜杠表示字符串将在下一行继续，但不会换行 原始字符串r或R，在处理正则表达式时应全程使用原始字符串1r&apos;Newlines are indicated by \n&apos; 变量命名 第一个字符必须是字母表中的字母(大写ASCII字符或小写ASCII字符或Unicode字符)或下划线(_)。 标识符的其它部分可以由字符(大写 ASCII 字符或小写 ASCII 字符或 Unicode字符)、下划线(_)、数字(0~9)组成。 标识符名称区分大小写 Python将程序中的任何内容统称为对象，包括数字、字符串与函数 逻辑行与物理行物理行(Physical Line)是你在编写程序时你所看到的内容逻辑行(Logical Line)是Python所看到的单个语句 显式行连接12345s=&apos;This is a string \This continues the string.&apos;print(s)This is a string This continues the string. 隐式行连接逻辑行以括号开始，它可以是方括号或花括号，但不能是右括号可以不使用\ 缩进在逻辑行的开头留下空白区(使用空格或制表符)用以确定各逻辑行的缩进级别放置在一起的语句必须拥有相同的缩进，每一组这样的语句被称为块(block) 运算符与表达式运算符 + 、- 、* 、/ 、**(乘方)、//(整除)、% (取余) &lt;&lt;(二进制左移) 、&gt;&gt; (二进制右移) &amp;(按位与) 、|(按位或) 、^ (按位异或)、~(按位取反，x的按位取反结果为-(x+1)) 转换为二进制 &lt; 、&gt; 、&lt;= 、&gt;= 、== 、!= 所有的比较运算符返回的结果均为True或False。请注意这些名称之中的大写字母 not 、and 、or 短路计算 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数//永远是整数，即使除不尽129 / 3 输出3.0-13 // 3 输出-5 优先级从最低优先级到最高优先级，同一行的运算符具有相同优先级12345678910111213141516171819lambda Lambda表达式if-else 条件表达式or 布尔“或”and 布尔“与”not x 布尔“非”in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == 比较，包括成员资格测试和身份测试| 按位或^ 按位异或&amp; 按位与&lt;&lt;, &gt;&gt; 移动+, - 加与减*, /, //, % 乘、除、整除、取余+x, -x, ~x 正、负、按位取反** 求幂x[index], x[index:index], x(arguments...), x.attribute 下标、切片、调用、属性引用(expressions...), [expressions...], &#123;key:value...&#125;, &#123;expressions...&#125; 元组、列表、字典、集合 控制流if语句条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行1234567891011121314#!/usr/bin/env pythonnumber=23guess=int(input(&apos;Enter an interger:&apos;))if guess==number: print(&apos;Congratulations,you guessed it&apos;) print(&apos;(but you do not win any prizes!)&apos;)elif guess&lt;number: print(&apos;No,it is a little higher than that&apos;)else: print(&apos;No,it is a little lower than that&apos;)print(&apos;Done&apos;) while语句else语句在循环结束后执行12345678910111213141516171819#!/usr/bin/env pythonnumber=23running=Truewhile running: guess=int(input(&apos;Enter an integer:&apos;)) if guess==number: print(&apos;Congratulations,you guessed it&apos;) running=False elif guess&lt;number: print(&apos;No,it is a little higher than that.&apos;) else: print(&apos;No,it is a little lower than that.&apos;)else: print(&apos;The while loop is over.&apos;)print(&apos;Done&apos;) for语句rang()将会返回一个数字序列,从第一个数字开始,至第二个数字结束。range(1,5)将输出序列[1,2,3,4]range(1,5,2)将会输出[1,3]不会包括第二个数字在内range()每次只会生成一个数字，list(range(5))返回完整的数字列表 12345678for i in range(1,5): print(i)else: print(&apos;The loop is over&apos;)names=[&apos;Michael&apos;,&apos;Bob&apos;,&apos;Tracy&apos;]for name in names: print(name) else语句在循环结束后执行 break语句如果中断了一个for或while循环，任何相应循环中的else块都将不会被执行 123456while True: s=input(&apos;Enter something:&apos;) if s==&apos;quit&apos;: break print(&apos;Length of the string is&apos;,len(s))print(&apos;Done&apos;) continue语句12345678910while True: s=input(&apos;Enter something&apos;) if s==&apos;quit&apos;: break if len(s)&lt;3: print(&apos;Too small&apos;) continue print(&apos;Length of the string is&apos;,len(s))print(&apos;Done&apos;) 123456n=0while n&lt;10: n=n+1 if n%2 ==0: continue print(n) 函数1234def say_hello(): print(&apos;hello wolrd&apos;)say_hello() 1234567891011def print_max(a,b): if a&gt;=b: print(a) else: print(b)print_max(3,4)x=8y=10print_max(x,y) 在定义函数时给定的名称称作“形参”(Parameters)在调用函数时你所提供给函数的值称作“实参”(Arguments)函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”123&gt;&gt;&gt; a=abs&gt;&gt;&gt; a(-1)1 hex()把一个整数转换成十六进制表示的字符串 局部变量所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始12345678x=50def func(x): print(&apos;x is&apos;,x) x=2 print(&apos;x is&apos;,x)func(x)print(&apos;x is still&apos;,x) 结果是123x is 50x is 2x is still 50 当你在一个函数的定义中声明变量时，它们不会以任何方式与身处函数之外但具有相同名称的变量产生关系 全局变量123456789x=50def func(): global x print(&apos;x is&apos;,x) x=2 print(&apos;x is&apos;,x)func()print(&apos;x is&apos;,x) 结果为123x is 50x is 2x is 2 默认参数值默认参数值应该是常数12345def say(message,times=1): print(message*times)say(&apos;Hello&apos;)say(&apos;Hello&apos;,2) 关键字参数123456def func(a,b=5,c=10): print(&apos;a is &#123;&#125;,and b is &#123;&#125; and c is &#123;&#125;&apos;.format(a,b,c))func(3,7)func(25,c=24)func(c=50,a=100) 结果如下：123a is 3,and b is 7 and c is 10a is 25,and b is 5 and c is 24a is 100,and b is 5 and c is 50 可变参数当我们声明一个诸如*param的星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个称为“param”的元组(Tuple)类似地，当我们声明一个诸如**param的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个名为param的字典(Dictionary)123456789101112def total(a=5,*numbers,**phonebook): print(&apos;a&apos;,a) #遍历元组中的所有项目 for single_item in numbers: print(&apos;single_item&apos;,single_item) #遍历字典中的所有项目 for first_part,second_part in phonebook.items(): print(first_part,second_part)print(total(10,1,2,3,jack=1123,John=2231,Inge=1560)) 结果如下：12345678a 10single_item 1single_item 2single_item 3jack 1123John 2231Inge 1560None return语句从函数中返回，中断函数1234567def maximum(x,y): if x&gt;y: return x elif x&lt;y: return y else: return &apos;The numbers are equal&apos; DocStrings 文档字符串文档字符串约定的格式：一串多行字符串，其中第一行以某一大写字母开始，以句号结束。第二行为空行，后跟的第三行开始是任何详细的解释说明123456789101112131415def print_max(x,y): &apos;&apos;&apos;打印两个数值中的最大数。 这两个数都应该是整数 &apos;&apos;&apos; x=int(x) y=int(y) if x&gt;y: print(x,&apos;is maximum&apos;) else: print(y,&apos;is maximum&apos;)print_max(3,5)print(print_max.__doc__) 结果如下：12345 is maximum打印两个数值中的最大数。 这两个数都应该是整数 模块模块用于在别的程序中重用函数 编写模块的方法 创建一个包含函数与变量，以.py为后缀的文件 使用撰写Python解释器本身的语言来编写模块（C、Java） 模块分为内置模块（如sys）和自行编写的模块，Python解释器从sys.path所提供的路径中搜索自行编写的模块，所以必须将模块在sys.path内所列出的目录中，比如当前目录 标准库模块，sys模块包含了与Python解释器及其环境相关的功能，也就是所谓的系统功能运行的脚本名称在sys.argv的列表中是第一个，即sys.argv[0]1234567import sysprint(&apos;The command line arguments are:&apos;)for i in sys.argv: print(i)print(&apos;\n\nThe PYTHONPATH is&apos;,sys.path,&apos;\n&apos;) 运行：1python module_using_sys.py we are arguments 结果：12345678The command line arguments are:module_using_sys.pyweareargumentsThe PYTHONPATH is [&apos;/home/lee/Documents/pyte&apos;, &apos;/home/lee/Documents/pyte/pyte/lib/python36.zip&apos;, &apos;/home/lee/Documents/pyte/pyte/lib/python3.6&apos;, &apos;/home/lee/Documents/pyte/pyte/lib/python3.6/lib-dynload&apos;, &apos;/home/lee/anaconda3/lib/python3.6&apos;, &apos;/home/lee/Documents/pyte/pyte/lib/python3.6/site-packages&apos;] .pyc文件将Python模块转换成中间形式的文件，以提高效率按字节码编译的(Byte-Compiled)文件，这一文件以.pyc为其扩展名通常会创建在与对应的.py文件所处的目录中 from…import语句直接将需要的变量导入程序1from sys import argv 尽量避免使用from…import语句，而去使用import语句避免在你的程序中出现名称冲突 模块的name每个模块都有一个名称,而模块中的语句可以找到它们所处的模块的名称。可以用于确定模块是独立运行的还是被导入进来运行每一个Python模块都定义了它的__name__属性。如果它与__main__属性相同则代表这一模块是由用户独立运行的 1234if __name__ == &apos;__main__&apos;: print(&apos;This program is being run by itself&apos;)else: print(&apos;I am being imported from another module&apos;) 1234567python module_using_name.pyThis program is being run by itselfpython&gt;&gt;&gt; import module_using_nameI am being imported from another module&gt;&gt;&gt; 编写自己的模块要将模块放在sys.path列出的目录下，或者与其它我们即将导入这一模块的程序相同的目录下 12345&apos;&apos;&apos;mymodule.py&apos;&apos;&apos;def say_hi(): print(&apos;Hi,this is mymodule speaking.&apos;)__version__=&apos;0.1&apos; 12345&apos;&apos;&apos;mymodule_demo.py&apos;&apos;&apos;import mymodulemymodule.say_hi()print(&apos;Version&apos;,mymodule.__version__) 12345&apos;&apos;&apos;mymodule_demo2.py&apos;&apos;&apos;from mymodule import say_hi,__version__say_hi()print(&apos;Version&apos;,__version__) mymodule_demo2.py所输出的内容与mymodule_demo.py所输出的内容是一样的12Hi,this is mymodule speaking.Version 0.1 dir函数返回由对象所定义的名称列表该函数接受参数。如果参数是模块名称，函数将返回这一指定模块的名称列表。如果没有提供参数,函数将返回当前模块的名称列表。 1234567891011#给出sys模块中的属性名称&gt;&gt;&gt;dir(sys)[&apos;__displayhook__&apos;, &apos;__doc__&apos;, &apos;__excepthook__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;,...#给出当前模块的属性名称&gt;&gt;&gt;dir()[&apos;__annotations__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;module_using_name&apos;, &apos;sys&apos;]&gt;&gt;&gt;a=5[&apos;__annotations__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;a&apos;, ... 包包是指一个包含模块与一个特殊的__init__.py文件的文件夹，后者向Python表明这一文件夹是特别的,因为其包含了Python模块12345678910111213&lt;some folder present in the sys.path&gt;/ -world/ -__init__.py -asia/ -__init__.py -india/ -__init__.py -foo.py -africa/ -__init__.py -madagascar/ -__init__.py -bar.py 模块是一种可重用的程序。包是用以组织模块的一种层次结构 数据结构列表List列表是可变的，有序的元素的数据类型可以不同12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849shoplist=[&apos;apple&apos;,&apos;mango&apos;,&apos;carrot&apos;,&apos;banana&apos;]len(shoplist)#最后一个shoplist[len(shoplist)-1]shoplist[-1]# 遍历for item in shoplist: print(item,end=&apos; &apos;)# 增加shoplist.append(&apos;rice&apos;)shoplist.insert(1,&apos;water&apos;)# [&apos;apple&apos;, &apos;water&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]# 更新&gt;&gt;&gt; shoplist[1]=&apos;water&apos;&gt;&gt;&gt; shoplist[&apos;apple&apos;, &apos;water&apos;, &apos;carrot&apos;]# 删除最后一个&gt;&gt;&gt; shoplist.pop()&apos;banana&apos;&gt;&gt;&gt; shoplist[&apos;apple&apos;, &apos;water&apos;, &apos;mango&apos;, &apos;carrot&apos;]# 删除指定&gt;&gt;&gt; shoplist.pop(1)&apos;water&apos;&gt;&gt;&gt; shoplist[&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;]#排序改变本身shoplist.sort()print(&apos;Sorted shopping list is&apos;,shoplist)olditem=shoplist[0]del shoplist[0]L=[&apos;Apple&apos;,123,True]s=[&apos;python&apos;,&apos;java&apos;,[&apos;asp&apos;,&apos;php&apos;],&apos;scheme&apos;]&gt;&gt;&gt; L=[]&gt;&gt;&gt; L[]&gt;&gt;&gt; len(L)0 元组Tuple有序，不可变123456789101112131415161718192021222324# 空元组()# 只有一个元素的元组(1,)zoo=(&apos;python&apos;,&apos;elephent&apos;,&apos;penguin&apos;)len(zoo)new_zoo=&apos;monkey&apos;,&apos;camel&apos;,zoo # (&apos;monkey&apos;, &apos;camel&apos;, (&apos;python&apos;, &apos;elephent&apos;, &apos;penguin&apos;))new_zoo[2]new_zoo[2][2]# 元组中的可变元素&gt;&gt;&gt; t=(&apos;a&apos;,&apos;b&apos;,[&apos;A&apos;,&apos;B&apos;])&gt;&gt;&gt; t(&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])&gt;&gt;&gt; t[2][0]&apos;A&apos;&gt;&gt;&gt; t[2][0]=&apos;Y&apos;&gt;&gt;&gt; t(&apos;a&apos;, &apos;b&apos;, [&apos;Y&apos;, &apos;B&apos;]) 字典Dict无序使用键-值（key-value）存储，具有极快的查找速度在其他语言中称为map 1234567891011121314151617181920212223242526272829303132333435363738ab=&#123; &apos;Swaroop&apos;:&apos;swaroop@swaroopch.com&apos;, &apos;Larry&apos;:&apos;larry@wall.org&apos;, &apos;Matsumoto&apos;:&apos;matz@ruby-lang.org&apos;, &apos;Spammer&apos;:&apos;spammer@hotmail.com&apos;&#125;# 取值ab[&apos;Swaroop&apos;]# 删除del ab[&apos;Spammer&apos;]ab.pop(&apos;Spammer&apos;)len(ab)for name,address in ab.items(): print(&apos;Contact &#123;&#125; at &#123;&#125;&apos;.format(name,address))# 赋值ab[&apos;Guido&apos;]=&apos;guido@python.org&apos;# in判断是否存在if &apos;Guido&apos; in ab: print(&quot;\nGuido&apos;s address is&quot;,ab[&apos;Guido&apos;])# get()判断是否存在，不存在返回None，或指定的valueab.get(&apos;Thomas&apos;)ab.get(&apos;Thomas&apos;,-1)# 按key排序&gt;&gt;&gt; sorted(d.keys())[&apos;Adam&apos;, &apos;Jack&apos;, &apos;Michael&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; sorted(d.keys(),reverse=True)[&apos;Tracy&apos;, &apos;Michael&apos;, &apos;Jack&apos;, &apos;Adam&apos;]# 按value 排序&gt;&gt;&gt; sorted(d.items(),key=lambda item:item[1])[(&apos;Adam&apos;, 67), (&apos;Tracy&apos;, 85), (&apos;Jack&apos;, 88), (&apos;Michael&apos;, 95)] 返回None的时候Python的交互环境不显示结果 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 dict的key必须是不可变对象，使用key的Hash值计算value的存储位置 items() 方法将字典的元素转化为了元组，而key参数对应的 lambda 表达式的意思则是选取元组中的第二个元素作为比较参数（如果写作 key=lambda item:item[0] 的话则是选取第一个元素作为比较对象，也就是 key 值作为比较对象。lambda x:y中 x 表示输出参数，y 表示 lambda 函数的返回值），所以采用这种方法可以对字典的 value 进行排序。注意排序后的返回值是一个 list，而原字典中的名值对被转换为了 list 中的元组。 序列Sequence序列的三种形态——列表、元组与字符串资格测试（in、not in）、索引操作、切片切片操作不包含结束位置1234567891011121314151617181920212223242526272829shoplist=[&apos;apple&apos;,&apos;mango&apos;,&apos;caroot&apos;,&apos;banana&apos;]name=&apos;swaroop&apos;shoplist[0] #appleshoplist[1] #mangoshoplist[2] #carootshoplist[3] #bananashoplist[-1] #bananashoplist[-2] #carootshoplist[1:3] #[&apos;mango&apos;, &apos;caroot&apos;]shoplist[2:] #[&apos;caroot&apos;, &apos;banana&apos;]shoplist[1:-1] #[&apos;mango&apos;, &apos;caroot&apos;]shoplist[:] #[&apos;apple&apos;, &apos;mango&apos;, &apos;caroot&apos;, &apos;banana&apos;]shoplist[::1]# [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]shoplist[::2]# [&apos;apple&apos;, &apos;carrot&apos;]shoplist[::3]# [&apos;apple&apos;, &apos;banana&apos;]shoplist[::-1]# [&apos;banana&apos;, &apos;carrot&apos;, &apos;mango&apos;, &apos;apple&apos;]name[0] #sname[1:3] #waname[2:] #aroopname[1:-1] #warooname[:] #swaroop 集合Set无序，不重复不可以放入可变对象，因为无法保证不重复1234567891011121314151617# 创建一个set，需要提供一个list作为输入集合&gt;&gt;&gt; bri=set([&apos;brazil&apos;,&apos;russia&apos;,&apos;india&apos;])&gt;&gt;&gt; &apos;india&apos; in briTrue&gt;&gt;&gt; &apos;usa&apos; in briFalse&gt;&gt;&gt; bric=bri.copy() #不是同一个&gt;&gt;&gt; bric.add(&apos;china&apos;)&gt;&gt;&gt; bric.issuperset(bri)True&gt;&gt;&gt; bric&#123;&apos;india&apos;, &apos;china&apos;, &apos;russia&apos;, &apos;brazil&apos;&#125;&gt;&gt;&gt; bri&#123;&apos;india&apos;, &apos;russia&apos;, &apos;brazil&apos;&#125;&gt;&gt;&gt; bri.remove(&apos;russia&apos;)&gt;&gt;&gt; bri &amp; bric&#123;&apos;india&apos;, &apos;brazil&apos;&#125; 不可变对象str是不变对象，而list是可变对象 12345678910111213&gt;&gt;&gt; a=[&apos;c&apos;,&apos;b&apos;,&apos;a&apos;]&gt;&gt;&gt; a[&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&gt;&gt;&gt; a=&apos;abc&apos;&gt;&gt;&gt; b=a.replace(&apos;a&apos;,&apos;A&apos;)&gt;&gt;&gt; b&apos;Abc&apos;&gt;&gt;&gt; a&apos;abc&apos; replace方法创建了一个新字符串’Abc’并返回对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的 引用123456789101112shoplist=[&apos;apple&apos;,&apos;mango&apos;,&apos;carrot&apos;,&apos;banana&apos;]#两个变量指向同一个列表mylist=shoplistdel shoplist[0]print(&apos;shoplist is&apos;,shoplist)print(&apos;mylist is&apos;,mylist)#两个变量指向不同的列表mylist=shoplist[:]del mylist[0]print(&apos;shoplist is&apos;,shoplist)print(&apos;mylist is&apos;,mylist) 字符串123456789name = &apos;Swaroop&apos;name.startswith(&apos;Swa&apos;)&apos;a&apos; in namename.find(&apos;war&apos;) != -1delimiter = &apos;_*_&apos;mylist = [&apos;Brazil&apos;, &apos;Russia&apos;, &apos;India&apos;, &apos;China&apos;]print(delimiter.join(mylist))# Brazil_*_Russia_*_India_*_China 解决问题单独开一章 面向对象编程类与对象是面向对象编程的两个主要方面。一个类（Class）能够创建一种新的类型（Type），其中对象（Object）就是类的实例（Instance） 字段（Field）方法（Method）字段与方法通称类的属性（Attribute）实例变量（Instance Variables）类变量（Class Variables） 123456class Person: def say_hi(self): print(&apos;Hello, how are you?&apos;)p = Person()p.say_hi() init方法__init__方法会在类的对象被实例化（Instantiated）时立即运行，用于初始化123456789class Person: def __init__(self, name): self.name = name def say_hi(self): print(&apos;Hello, my name is&apos;, self.name)p = Person(&apos;Swaroop&apos;)p.say_hi() 类变量和对象变量123456789101112131415161718192021222324252627282930313233343536373839404142434445class Robot: &quot;&quot;&quot;表示有一个带有名字的机器人。&quot;&quot;&quot; # 一个类变量，用来计数机器人的数量 population = 0 def __init__(self, name): &quot;&quot;&quot;初始化数据&quot;&quot;&quot; self.name = name print(&quot;(Initializing &#123;&#125;)&quot;.format(self.name)) # 当有人被创建时，机器人 # 将会增加人口数量 Robot.population += 1 def die(self): &quot;&quot;&quot;我挂了。&quot;&quot;&quot; print(&quot;&#123;&#125; is being destroyed!&quot;.format(self.name)) Robot.population -= 1 if Robot.population == 0: print(&quot;&#123;&#125; was the last one.&quot;.format(self.name)) else: print(&quot;There are still &#123;:d&#125; robots working.&quot;.format( Robot.population)) def say_hi(self): &quot;&quot;&quot;来自机器人的诚挚问候 没问题，你做得到。&quot;&quot;&quot; print(&quot;Greetings, my masters call me &#123;&#125;.&quot;.format(self.name)) @classmethod def how_many(cls): &quot;&quot;&quot;打印出当前的人口数量&quot;&quot;&quot; print(&quot;We have &#123;:d&#125; robots.&quot;.format(cls.population))droid1 = Robot(&quot;R2-D2&quot;)droid1.say_hi()Robot.how_many()droid2 = Robot(&quot;C-3PO&quot;)droid2.say_hi()Robot.how_many() population是类变量，Robot.population或self.__class__.population，共享数据name是对象变量，self.name how_many是类方法 Robot.__doc__ 访问类的文档字符串Robot.say_hi.__doc__访问方法的文档字符串 __privatevar私有变量 继承12345678910111213141516171819202122232425262728293031323334353637class SchoolMember: def __init__(self,name,age): self.name=name self.age=age print(&apos;Initialized SchoolMember:&#123;&#125;&apos;.format(self.name)) def tell(self): print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name,self.age),end=&quot; &quot;)class Teacher(SchoolMember): def __init__(self,name,age,salary): SchoolMember.__init__(self,name,age) self.salary=salary print(&apos;Initialized Teacher:&#123;&#125;&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))class Student(SchoolMember): def __init__(self,name,age,marks): SchoolMember.__init__(self,name,age) self.marks=marks print(&apos;Initialized Student:&#123;&#125;&apos;.format(self.name)) def tell(self): SchoolMember.tell(self) print(&apos;Marks:&quot;&#123;:d&#125;&quot;&apos;.format(self.marks))t=Teacher(&apos;Mrs. Shrividya&apos;,40,30000)s=Student(&apos;Swaroop&apos;,25,75)print()members=[t,s]for member in members: member.tell() SchoolMember.__init__(self,name,age)调用父类的构造方法SchoolMember.tell(self)调用父类的方法多重继承 输入与输出1234567891011def reverse(text): return text[::-1]def is_palindrome(text): return text==reverse(text)something=input(&apos;Enter text:&apos;)if is_palindrome(something): print(&apos;Yes,it is a palindrome&apos;)else: print(&apos;No,it is not a palindrome&apos;) 12345678910111213141516171819poem=&apos;&apos;&apos;\Programming is funWhen the work is doneif you wanna make your work also fun: use Python!&apos;&apos;&apos;f=open(&apos;poem.txt&apos;,&apos;w&apos;)f.write(poem)f.close()f=open(&apos;poem.txt&apos;)while True: line=f.readline() if len(line)==0: break print(line,end=&apos;&apos;)f.close() 阅读模式（’r’）写入模式（’w’）追加模式（’a’）文本模式（’t’）二进制模式（’b’）在默认情况下，open() 会将文件视作文本（text）文件，并以阅读（read）模式打开它。 readline会读取换行符 Pickle将任何纯 Python 对象存储到一个文件中，并在稍后将其取回。这叫作持久化（Persistently）存储对象 1234567891011121314import pickleshoplistfile=&apos;shoplist.data&apos;shoplist=[&apos;apple&apos;,&apos;mango&apos;,&apos;carrot&apos;]f=open(shoplistfile,&apos;wb&apos;)pickle.dump(shoplist,f)f.close()del shoplistf=open(shoplistfile,&apos;rb&apos;)storedlist=pickle.load(f)print(storedlist) Unicode1# encoding=utf-8 使用 io.open 并提供了“编码（Encoding）”与“解码（Decoding）”参数来告诉 Python 我们正在使用 Unicode。 异常错误处理器：抛出错误，打印出检测到的错误发生的位置 EOFError，文件结尾错误（End of File） 处理异常12345678try: text=input(&apos;Enter something--&gt;&apos;)except EOFError: print(&apos;Why not you do an EOF on me?&apos;)except KeyboardInterrupt: print(&apos;You cancelled the operation.&apos;)else: print(&apos;You entered &#123;&#125;&apos;.format(text)) 1234567891011# Press ctrl + d$ python exceptions_handle.pyEnter something --&gt; Why did you do an EOF on me?# Press ctrl + c$ python exceptions_handle.pyEnter something --&gt; ^CYou cancelled the operation.$ python exceptions_handle.pyEnter something --&gt; No exceptionsYou entered No exceptions else 子句将在没有发生异常的时候执行 抛出异常raise 语句可以引发一次异常，具体方法是提供错误名或异常名以及要抛出（Thrown）异常的对象。12345678910111213141516class ShortInputException(Exception): def __init__(self,length,atleast): Exception.__init__(self) self.length=length self.atleast=atleasttry: text=input(&apos;Enter somethin---&gt;&apos;) if len(text)&lt;3: raise ShortInputException(len(text),3)except EOFError: print(&apos;Why did you do an EOF on me?&apos;)except ShortInputException as ex: print((&apos;ShortInputException:The input was &apos;+&apos;&#123;0&#125; long,expected at least &#123;1&#125;&apos;).format(ex.length,ex.atleast))else: print(&apos;No exception was raised.&apos;) Try…Finally无论是否会发生异常必然执行，finally12345678910111213141516171819202122import sysimport timef=Nonetry: f=open(&quot;poem.txt&quot;) while True: line=f.readline() if len(line)==0: break print(line,end=&apos;&apos;) sys.stdout.flush() print(&apos;Print ctrl-c now&apos;) time.sleep(2)except IOError: print(&apos;Could not find file poem.txt&apos;)except KeyboardInterrupt: print(&apos;!! You cancelled the reading from the file.&apos;)finally: if f: f.close() print(&apos;(Cleaning up:Closed the file)&apos;) with语句使用with open语句会自动关闭文件123with open(&apos;poem.txt&apos;) as f: for line in f: print(line,end=&apos;&apos;) 标准库sys模块日志模块logging 12345678910111213141516171819import osimport platformimport loggingif platform.platform().startswith(&apos;Windows&apos;): logging_file=os.path.join(os.getenv(&apos;HOMEDRIVE&apos;),os.getenv(&apos;HOMEPATH&apos;),&apos;test.log&apos;)else: logging_file=os.path.join(os.getenv(&apos;HOME&apos;),&apos;test.log&apos;)print(&apos;Logging to&apos;,logging_file)logging.basicConfig( level=logging.DEBUG, format=&apos;%(asctime)s:%(levelname)s:%(message)s&apos;, filename=logging_file, filemode=&apos;w&apos;,)logging.debug(&apos;Start of the program&apos;)logging.info(&apos;Doing something&apos;)logging.warning(&apos;Dying now&apos;) 更多Lambda1234points=[&#123;&apos;x&apos;:2,&apos;y&apos;:3&#125;,&#123;&apos;x&apos;:4,&apos;y&apos;:1&#125;]points.sort(key=lambda i:i[&apos;y&apos;])print(points) 列表推导123listone=[2,3,4]listtwo=[2*i for i in listone if i&gt;2]print(listtwo)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python备份文件]]></title>
    <url>%2Fpost%2F90c43b0e.html</url>
    <content type="text"><![CDATA[来自《简明Python教程》中解决问题一章，单独拿出来进行说明 需要解决的问题是 我想要一款程序来备份我所有的重要文件。 分析5W1HWhat？Where？When？Why？Who？How？备份什么？备份到哪里？– ？–？–？ 怎么备份？我们应该如何指定哪些文件是我们需要备份的？它们应该如何进行备份？以什么方式存储？储存到哪里? 设计： 需要备份的文件与目录应在一份列表中予以指定 备份必须存储在一个主备份目录中 备份文件将打包压缩成 zip 文件 zip 压缩文件的文件名由当前日期与时间构成 使用在任何 GNU/Linux 或 Unix 发行版中都会默认提供的标准 zip 命令进行打包 实现1234567891011121314151617181920212223242526import osimport time#1.指定源目录列表source=[&apos;/home/lee/Documents/pyte&apos;]#2.指定目标目录target_dir=&apos;/home/lee/Templates&apos;#3.指定目标文件名target=target_dir+os.sep+time.strftime(&apos;%Y%m%d%H%M%S&apos;)+&apos;.zip&apos;if not os.path.exists(target_dir): os.mkdir(target_dir)#4.组装zip命令zip_command=&apos;zip -r &#123;0&#125; &#123;1&#125;&apos;.format(target,&apos; &apos;.join(source))print(&apos;Zip command is:&apos;)print(zip_command)print(&apos;Running:&apos;)#5. 执行压缩命令os.system(zip_command)if os.system(zip_command)==0: print(&apos;Successful backup to&apos;,target)else: print(&apos;Backup Failed&apos;) 测试/调试部署/使用维护/改进第二版，创建日期目录，将压缩文件放在对应的目录下123456789101112131415161718192021222324import osimport timesource=[&apos;/home/lee/Documents/pyte&apos;]target_dir=&apos;/home/lee/Templates&apos;today=target_dir+os.sep+time.strftime(&apos;%Y%m%d&apos;)now=time.strftime(&apos;%H%M%S&apos;)#target=target_dir+os.sep+time.strftime(&apos;%Y%m%d%H%M%S&apos;)+&apos;.zip&apos;target=today+os.sep+now+&apos;.zip&apos;if not os.path.exists(today): os.mkdir(today)zip_command=&apos;zip -r &#123;0&#125; &#123;1&#125;&apos;.format(target,&apos; &apos;.join(source))print(&apos;Zip command is:&apos;)print(zip_command)print(&apos;Running:&apos;)if os.system(zip_command)==0: print(&apos;Successful backup to&apos;,target)else: print(&apos;Backup Failed&apos;) 第三版，压缩文件名添加注释12345678910111213141516171819202122232425262728import osimport timesource=[&apos;/home/lee/Documents/pyte&apos;]target_dir=&apos;/home/lee/Templates&apos;today=target_dir+os.sep+time.strftime(&apos;%Y%m%d&apos;)now=time.strftime(&apos;%H%M%S&apos;)#target=target_dir+os.sep+time.strftime(&apos;%Y%m%d%H%M%S&apos;)+&apos;.zip&apos;comment=input(&apos;Enter some comment:&apos;)if len(comment)==0: target=today+os.sep+now+&apos;.zip&apos;else: target=today+os.sep+now+&apos;_&apos;+comment.replace(&apos; &apos;,&apos;_&apos;)+&apos;.zip&apos;if not os.path.exists(today): os.mkdir(today)zip_command=&apos;zip -r &#123;0&#125; &#123;1&#125;&apos;.format(target,&apos; &apos;.join(source))print(&apos;Zip command is:&apos;)print(zip_command)print(&apos;Running:&apos;)if os.system(zip_command)==0: print(&apos;Successful backup to&apos;,target)else: print(&apos;Backup Failed&apos;) zip命令可以使用-p静默执行 第四版，使用zipfile而不是os压缩1class zipfile.ZipFile(file[, mode[, compression[, allowZip64]]]) 12345678910111213141516171819202122232425262728293031import osimport timeimport zipfilesources=[&apos;/home/lee/Documents/pyte&apos;]target_dir=&apos;/home/lee/Templates&apos;today=target_dir+os.sep+time.strftime(&apos;%Y%m%d&apos;)now=time.strftime(&apos;%H%M%S&apos;)#target=target_dir+os.sep+time.strftime(&apos;%Y%m%d%H%M%S&apos;)+&apos;.zip&apos;comment=input(&apos;Enter some comment:&apos;)if len(comment)==0: target=today+os.sep+now+&apos;.zip&apos;else: target=today+os.sep+now+&apos;_&apos;+comment.replace(&apos; &apos;,&apos;_&apos;)+&apos;.zip&apos;if not os.path.exists(today): os.mkdir(today)f=zipfile.ZipFile(target,&apos;a&apos;,zipfile.ZIP_DEFLATED)for source in sources: for dirpath,dirnames,filenames in os.walk(source): for dirname in dirnames: #这个循环是为了保证空目录也可以被压缩 f.write(os.path.join(dirpath,dirname)) for filename in filenames: f.write(os.path.join(dirpath,filename))print(f.namelist())f.close() 也可以使用12import shutilshutil.make_archive(output_filename, &apos;zip&apos;, dir_name)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之禅]]></title>
    <url>%2Fpost%2F6be2dbca.html</url>
    <content type="text"><![CDATA[import thisThe Zen of Python, by Tim Peters Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren’t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one– and preferably only one –obvious way to do it.Although that way may not be obvious at first unless you’re Dutch.Now is better than never.Although never is often better than right now.If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea – let’s do more of those!]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用virtualenv]]></title>
    <url>%2Fpost%2Fd528f132.html</url>
    <content type="text"><![CDATA[virtualenv用来为一个应用创建一套“隔离”的Python运行环境 1234567891011121314pip3 install virtualenv# 安装virtualenvmkdir myprojectcd myproject/virtualenv venvsource venv/bin/activate # 激活virtualenvpip install flexxdeactivate # 退出当前的venv环境 参考： https://www.kancloud.cn/thinkphp/python-guide/39429]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】字符编码常识及问题解析]]></title>
    <url>%2Fpost%2F7444a34.html</url>
    <content type="text"><![CDATA[转自：http://sharecore.net/2014/08/10/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%B8%B8%E8%AF%86%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/ 在面试的笔试题里出了一道开放性的题：请简述Unicode与UTF-8之间的关系。一道看似简单的题，能给出满意答案的却寥寥无几，确实挺失望的。所以今天就结合我以前做过的一个关于字符编码的分享，总结一些与字符编码相关的知识和问题。如果你这方面的知识已经掌握的足够了，可以忽略这篇文字。但如果你没法很好的回答我上面的面试题，或经常被乱码的问题所困扰，还是不妨一读。 基本常识1.位和字节说起编码，我们必须从最基础的说起，位和字节(别觉得这个过于简单不值一说，我还真见过很多个不能区分这两者的程序员)。位（bit）是指计算机里存放的二进制值(0/1)，而8个位组合成的“位串”称为一个字节，容易算出，8个位的组合有256（ 2^8 ）个组合方式，其取值范围是“00000000-11111111”，常用十六进制来表示。比如“01000001”就是一个字节，其对应的十六进制值为“0x41”。 而我们通常所讲的字符编码，就是指定义一套规则，将真实世界里的字母/字符与计算机的二进制序列进行相互转化。如我们可以针对上面的字节定义如下的转换规则：101000001（0x41）&lt;-&gt; 65 &lt;-&gt; &apos;A&apos; 即用字位序“01000001”来表示字母’A’。 2.拉丁字符拉丁字符是当今世界使用最广泛的符号了。通常我们说的拉丁字母，指的的是基础拉丁字母,即指常见的”ABCD“等26个英文字母，这些字母与英语中一些常见的符号（如数字，标点符号）称为基础拉丁字符，这些基础拉丁字符在使用英语的国家广为流行，当然在中国，也被用来当作汉语拼音使用。在欧洲其它一些非英语国家，为满足其语言需要，在基础拉丁字符的基础上，加上一些连字符，变音字符(如’Á’)，形成了派生拉丁字母，其表示的字符范围在各种语言有所不同，而完整意义上的拉丁字符是指这些变体字符与基础拉丁字符的全集。是比基础拉丁字符集大很多的一个集合。 编码标准前文提到，字符编码是一套规则。既然是规则，就必须有标准。下面我就仔细说说常见的字符编码标准。 1.拉丁编码ASCII的全称是American Standard Code for Information Interchange（美国信息交换标准代码）。顾名思义，这是现代计算机的发明国美国人设计的标准，而美国是一个英语国家，他们设定的ASCII编码也只支持基础拉丁字符。ASCII的设计也很简单，用一个字节（8个位）来表示一个字符，并保证最高位的取值永远为’0’。即表示字符含义的位数为7位，不难算出其可表达字符数为2^7=128个。这128个字符包括95个可打印的字符（涵盖了26个英文字母的大小写以及英文标点符号能）与33个控制字符（不可打印字符）。例如下表，就是几个简单的规则对应： 字符类型 字符 二进制 16进制 10进制 可打印字符 A 01000001 0x41 65 可打印字符 a 01100001 0x61 97 控制字符 \r 00001101 0x0D 13 控制字符 \n 00001010 0xA 10 前面说到了，ASCII是美国人设计的，只能支持基础拉丁字符，而当计算机发展到欧洲，欧洲其它不只是用的基础拉丁字符的国家（即用更大的派生拉丁字符集）该怎么办呢？ 当然，最简单的办法就是将美国人没有用到的第8位也用上就好了，这样能表达的字符个数就达到了2^8 =256个，相比较原来，增长了一倍，这个编码规则也常被称为EASCII。EASCII基本解决了整个西欧的字符编码问题。但是对于欧洲其它地方如北欧，东欧地区，256个字符还是不够用，如是出现了ISO 8859,为解决256个字符不够用的问题，ISO8859采取的不再是单个独立的编码规则，而是由一系列的字符集（共15个）所组成，分别称为ISO 8859-n(n=1,2,3…11,13…16,没有12)。其每个字符集对应不同的语言,如ISO 8859-1对应西欧语言，ISO 8859-2对应中欧语言等。其中大家所熟悉的Latin-1就是ISO 8859-1的别名,它表示整个西欧的字符集范围。需要注意的一点的是，ISO 8859-n与ASCII是兼容的，即其0000000(0x00)-01111111(0x7f)范围段与ASCII保持一致，而10000000（0x80）-11111111(0xFF)范围段被扩展用到不同的字符集。 2.中文编码以上我们接触到的拉丁编码，都是单字节编码，即用一个字节来对应一个字符。但这一规则对于其它字符集更大的语言来说，并不适应，比如中文，而是出现了用多个字节表示一个字符的编码规则。常见的中文GB2312（国家简体中文字符集）就是用两个字节来表示一个汉字（注意是表示一个汉字，对于拉丁字母，GB2312还是是用一个字节来表示以兼容ASCII）。我们用下表来说明各中文编码之间的规则和兼容性。 对于中文编码，其规则实现上是很简单的，一般都是简单的字符查表即可，重要的是要注意其相互之间的兼容性问题。如如果选择BIG5字符集编码，就不能很好的兼容GB2312，当做繁转简时有可能导致个别字的冲突与不一致，但是GBK与GB2312之间就不存在这样的问题。 3.Unicode以上可以看到，针对不同的语言采用不同的编码，有可能导致冲突与不兼容性，如果我们打开一份字节序文件，如果不知道其编码规则，就无法正确解析其语义，这也是产生乱码的根本原因。有没有一种规则是全世界字符统一的呢？当然有，Unicode就是一种。为了能独立表示世界上所有的字符，Unicode采用4个字节表示一个字符,这样理论上Unicode能表示的字符数就达到了2^31 = 2147483648 = 21 亿左右个字符，完全可以涵盖世界上一切语言所用的符号。我们以汉字”微信“两字举例说明：12微 &lt;-&gt; \u5fae &lt;-&gt; 00000000 00000000 01011111 10101110信 &lt;-&gt; \u4fe1 &lt;-&gt; 00000000 00000000 01001111 11100001 容易从上面的例子里看出，Unicode对所有的字符编码均需要四个字节，而这对于拉丁字母或汉字来说是浪费的，其前面三个或两个字节均是0，这对信息存储来说是极大的浪费。另外一个问题就是，如何区分Unicode与其它编码这也是一个问题，比如计算机怎么知道四个字节表示一个Unicode中的字符，还是分别表示四个ASCII的字符呢？ 以上两个问题，困扰着Unicode，让Unicode的推广上一直面临着困难。直至UTF-8作为Unicode的一种实现后，部分问题得到解决，才得以完成推广使用。说到此，我们可以回答文章一开始提出的问题了，UTF-8是Unicode的一种实现方式，而Unicode是一个统一标准规范，Unicode的实现方式除了UTF-8还有其它的，比如UTF-16等。 话说当初大牛Ben Thomson吃饭时，在一张餐巾纸上，设计出了UTF-8，然后回到房间，实现了第一版的UTF-8。关于UTF-8的基本规则，其实简单来说就两条（来自阮一峰老师的总结）： 规则1：对于单字节字符，字节的第一位为0，后7位为这个符号的Unicode码，所以对于拉丁字母，UTF-8与ASCII码是一致的。 规则2：对于n字节(n&gt;1)的字符，第一个字节前n位都设为1，第n+1位为0，后面字节的前两位一律设为10，剩下没有提及的位，全部为这个符号的Unicode编码。 通过，根据以上规则，可以建立一个Unicode取值范围与UTF-8字节序表示的对应关系，如下表， 举例来说，’微’的Unicode是’\u5fae’，二进制表示是”00000000 00000000 01011111 10101110“，其取值就位于’0000 0800-0000 FFFF’之间，所以其UTF-8编码为’11100101 10111110 10101110’ （加粗部分为固定编码内容）。 通过以上简单规则，UTF-8采取变字节的方式，解决了我们前文提到的关于Unicode的两大问题。同时，作为中文使用者需要注意的一点是Unicode(UTF-8)与GBK，GB2312这些汉字编码规则是完全不兼容的，也就是说这两者之间不能通过任何算法来进行转换，如需转换，一般通过GBK查表的方式来进行。 常见问题及解答1.windows Notepad中的编码ANSI保存选项，代表什么含义？ANSI是windows的默认的编码方式，对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。所以，如果将一个UTF-8编码的文件，另存为ANSI的方式，对于中文部分会产生乱码。 2.什么是UTF-8的BOM？BOM的全称是Byte Order Mark，BOM是微软给UTF-8编码加上的，用于标识文件使用的是UTF-8编码，即在UTF-8编码的文件起始位置，加入三个字节“EE BB BF”。这是微软特有的，标准并不推荐包含BOM的方式。采用加BOM的UTF-8编码文件，对于一些只支持标准UTF-8编码的环境，可能导致问题。比如，在Go语言编程中，对于包含BOM的代码文件，会导致编译出错。详细可见我的这篇文章。 3.为什么数据库Latin1字符集（单字节）可以存储中文呢？其实不管需要使用几个字节来表示一个字符，但最小的存储单位都是字节,所以，只要能保证传输和存储的字节顺序不会乱即可。作为数据库，只是作为存储的使用的话，只要能保证存储的顺序与写入的顺序一致，然后再按相同的字节顺序读出即可，翻译成语义字符的任务交给应用程序。比如’微’的UTF-8编码是’0xE5 0xBE 0xAE’，那数据库也存储’0xE5 0xBE 0xAE’三个字节，其它应用按顺序从数据库读取，再按UTF-8编码进行展现。这当然是一个看似完美的方案，但是只要写入，存储，读取过程中岔出任何别的编码，都可能导致乱码。 4.Mysql数据库中多个字符集变量（其它数据库其实也类似），它们之间分别是什么关系？ 我们分别解释： character_set_client：客户端来源的数据使用的字符集，用于客户端显式告诉客户端所发送的语句中的的字符编码。 character_set_connection：连接层的字符编码，mysql一般用character_set_connection将客户端的字符转换为连接层表示的字符。 character_set_results：查询结果从数据库读出后，将转换为character_set_results返回给前端。 而我们常见的解决乱码问题的操作：1mysql_query(&apos;SET NAMES GBK&apos;) 其相当于将以上三个字符集统一全部设置为GBK，这三者一致时，一般就解决了乱码问题。 character_set_database:当前选中数据库的默认字符集，如当create table时没有指定字符集，将默认选择该字符集。 character_set_database已经character_set_system，一般用于数据库系统内部的一些字符编码，处理数据乱码问题时，我们基本可以忽略。 5.什么情况下，表示信息丢失？对于mysql数据库，我们可以通过hex(colname)函数（其它数据库也有类似的函数，一些文本文件编辑器也具有这个功能），查看实际存储的字节内容，如： 通过查看存储的字节序，我们可以从根本上了解存储的内容是什么编码了。而当发现存储的内容全部是’3F’时，就表明存储的内容由于编码问题，信息已经丢失了，无法再找回。 之所以出现这种信息丢失的情况，一般是将不能相互转换的字符集之间做了转换，比如我们在前文说到，UTF-8只能一个个字节地变成Latin-1，但是根本不能转换的，因为两者之间没有转换规则，Unicode的字符对应范围也根本不在Latin-1范围内，所以只能用’?(0x3F)’代替了。 总结本文从基础知识与实际中碰到的问题上，解析了字符编码相关内容。而之所以要从头介绍字符编码的基础知识，是为了更好的从原理上了解与解决日常碰到的编码问题，只有从根本上了解了不同字符集的规则及其之间的关系与兼容性，才能更好的解决碰到的乱码问题，也能避免由于程序中不正确的编码转换导致的信息丢失问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【转】五种常见的开源协议整理]]></title>
    <url>%2Fpost%2Ffe81a09d.html</url>
    <content type="text"><![CDATA[来源： http://yansu.org/2013/04/23/opensource-licenses.html 简介开源软件(Open source software)对我们来说越来越不陌生，开源软件一方面让我们免费享用到了“免费的午餐”，另一方面有效的利用和学习开源软件，也能促进我们开发软件时的效率、提升软件质量。但是在使用和借鉴开源软件的时候，我们不得不关心一下它对使用者的诸多限制，比较常见的方式即协议授权(licence)，这些协议中明确说明了使用者应该遵循的原则。 现在开源协议众多，通过Open Source Initiative组织批准的开源协议有50多种，本文提到的五种常见协议也在其中，而且出现频率非常频繁，我们在使用开源代码或者开放自己源代码的时候，也应该尽量选择这些协议。 五种常见开源协议BSD协议BSD开源协议是一个给予使用者很大自由的协议。开发者可以自由使用和修改源代码，也可以将修改后的源代码作为开源或者专有软件再发布。但是有一下几个要求： 如果再发布的产品中含有源代码，则在源代码中必须带有原来代码中的BSD协议。如果再发布的只是二进制类库/软件，则需要再类库/软件的文档和版权申明中包含原有代码中的BSD协议。不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 Apache Licence 2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件： 需要给代码的用户一份Apache Licence。如果修改了代码，需要再被修改的文件中说明。在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。 GPL我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(“使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 LGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制。也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的. 各协议分析图乌克兰程序员Paul Bagwell画了一张分析图，说明应该怎么选择。阮一峰对图进行了汉化，如下图：]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reStructuredText常用语法]]></title>
    <url>%2Fpost%2F1d81ed52.html</url>
    <content type="text"><![CDATA[reStructuredText是一种标记语言，和markdown类似，但是能够提供比markdown更丰富的样式 标题123456789101112131415==========一级标题==========二级标题==========三级标题----------四级标题^^^^^^^^^^^ 字体样式1234567891011121314*这里是强调内容*`这里是引用内容`**这里是粗体内容**``这里是等宽文本``上标E = mc\ :sup:`2`下标H\ :sub:`2`\ O 段落1234567891011| 这里是段落 缩进的段落被视为引文。| 这里也是段落 缩进的段落被视为引文。| 这里还是段落 缩进的段落被视为引文。 代码12345678910行内代码``echo &quot;Hello World!&quot;;``代码块在代码块的上一个段落后面加2个冒号，空一行后开始代码块，代码块要缩进:: hello world hello world hello world 列表12345678910下级列表需要有空格缩进无序列表- jj- kk- jj有序列表1. ll2. oo3. pp 图片1.. image:: https://help.github.com/assets/images/site/favicon.ico 链接12345外部引用这篇文章来自我的Github,请参考 reference_。.. _reference: https://github.com/SeayXu/`SeayXu &lt;https://github.com/SeayXu/&gt;`_ 表格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758简单表格===== ===== ======输入 输出------------ ------A B A or B===== ===== ======False False FalseTrue False TrueFalse True TrueTrue True True===== ===== ======普通表格+------------------------+------------+----------+----------+| Header row, column 1 | Header 2 | Header 3 | Header 4 || (header rows optional) | | | |+========================+============+==========+==========+| body row 1, column 1 | column 2 | column 3 | column 4 |+------------------------+------------+----------+----------+| body row 2 | Cells may span columns. |+------------------------+------------+---------------------+| body row 3 | Cells may | - Table cells |+------------------------+ span rows. | - contain || body row 4 | | - body elements. |+------------------------+------------+---------------------+CSV表格.. csv-table:: 表头 :header: &quot;Treat&quot;, &quot;Quantity&quot;, &quot;Description&quot; :widths: 15, 10, 30 &quot;Albatross&quot;, 2.99, &quot;On a stick!&quot; &quot;Crunchy Frog&quot;, 1.49, &quot;If we took the bones out, it wouldn&apos;t be crunchy, now would it?&quot; &quot;Gannet Ripple&quot;, 1.99, &quot;On a stick!&quot;列表表格.. list-table:: 表头 :widths: 15 10 30 :header-rows: 1 * - Treat - Quantity - Description * - Albatross - 2.99 - On a stick! * - Crunchy Frog - 1.49 - If we took the bones out, it wouldn&apos;t be crunchy, now would it? * - Gannet Ripple - 1.99 - On a stick! 表格可以使用插件https://macplay.github.io/posts/shi-yong-vim-zai-markdown-ji-rst-wen-dang-zhong-chuang-jian-biao-ge/ 参考： https://www.jianshu.com/p/f60e9be4781d https://3vshej.cn/rstSyntax/index.html https://www.jianshu.com/p/9b8c2e10e5e9 http://docutils-zh-cn.readthedocs.io/zh_CN/latest/ref/rst/restructuredtext.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitLab+sphinx+Readthedocs]]></title>
    <url>%2Fpost%2F89c53863.html</url>
    <content type="text"><![CDATA[利用GitLab、sphinx、Readthedocs可以制作文档和博客，利用这种方式制作出来的博客更像一本书，能够结构化展示文章，比较适合笔记类Gitlab用来存储代码sphinx用来写博客Readthedocs用来展示 安装 Sphinx1pip install sphinx 创建工程123mkdir mybookcd mybooksphinx-quickstart 输入工程名、作者名、版本号，分离source和build目录Separate source and build directories (y/N) [n]: y build目录 运行make命令后，生成的文件都在这个目录里面source目录 放置文档的源文件 配置改主题1html_theme = &apos;sphinx_rtd_theme&apos; 创建仓库在gitlab上创建仓库 12345git initgit add .git commit -m &quot;sphinx start&quot;git remote add origin https://github.com/[yourusename]/[yourrepository].gitgit push origin master 导入ReadtheDocs注册ReadtheDocs账号，因为直接用gitlab账号登录，所以没有设置Webhooks从https://readthedocs.org/dashboard/import/导入git链接在管理中设置Python 配置文件source/conf.py，Python interpreterCpython 3.x，保存 目录结构index.rst123456.. toctree:: :maxdepth: 2 :caption: Contents: linux/index python/index python/index.rst12345678910Python==================================.. toctree:: :maxdepth: 2 :caption: Contents: :numbered: 变量 语句 本地查看命令行执行1make html 参考：https://www.jianshu.com/p/78e9e1b8553ahttp://abnerzhao.com/2017/10/14/quickstart-wiki/]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储引擎]]></title>
    <url>%2Fpost%2F4fa63392.html</url>
    <content type="text"><![CDATA[MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎，每种存数引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。 并发处理并发控制当多个连接对记录进行修改时保证数据的一致性和完整性。 锁 共享锁(读锁)：在同一时间内，多个用户可读取同一个资源，读取过程中数据不会发生任何变化。 排他锁(写锁)：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。 锁的力度(锁颗粒–锁定时的单位) 表锁，是一种开销最小的锁策略。对表进行写锁，所有用户不能对该表的任何记录操作。 行锁，是一种开销最大的锁策略。并行性最大，可能对表的所有记录写锁，开销大。 事务处理事务处理整个过程每一个单元全部完成才算事务处理成功，某一个单元失败事务就会回滚。 主要作用保证数据库的完整性 特性 原子性(Atomic)：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Consistency)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性(Isolation)：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性(Durable)：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 简称：ACID 外键是保证数据一致性的策略 索引是对数据表中一列或者多列的值进行排序的一种结构。索引好比目录。索引可以划分为：普通索引、唯一索引、全文索引、btree索引、hash索引。 各种存储引擎的特点MySQL支持的存储引擎MyISAM、InnoDB、Memory、CSV、Archive MyISAM/InnoDB：最广泛MyISAM：适用于事务的处理不多的情况。InnoDB：适用于事务处理比较多，需要有外键支持的情况。 设置存储引擎 修改MySQL配置文件实现 1default-storage-engine = engine_name 创建数据表命令来实现 123CREATE TABLE tbl_name(...) ENGINE = engine_name; 修改数据表命令实现 1ALTER TABLE tbl_name ENGINE [=] engine_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL自定义函数]]></title>
    <url>%2Fpost%2Fca4788ef.html</url>
    <content type="text"><![CDATA[自定义函数用户自定义函数(user-defined function, UDF)是一种对MySQL扩展的途径, 其用法与内置函数相同。 自定义函数的两个必要条件 参数：最多1024个任意类型的参数 返回值：任意类型 函数可以返回任意类型的值，同样可以接受这些类型的参数；函数的参数与返回值之间，没有必然的联系。 创建自定义函数1234CREATE FUNCTION function_nameRETURNS&#123;STRING|INTEGER|REAL|DECIMAL&#125;routine_body routine_body是函数体 关于函数体 函数体由合法的SQL语法构成; 函数体可以是简单的SELECT或INSERT语句; 函数体如果为复合结构则使用BEGIN…END语句； 复合结构可以包括声明，循环，控制结构。 创建不带参数的自定义函数创建日期时间自定义函数12345CREATE FUNCTION f1() RETURNS VARCHAR(30)RETURN DATE_FORMAT(NOW(),&apos;%Y年%m月%d日 %H点:%i分:%s秒&apos;);SELECT f1(); 创建带有参数的自定义函数创建带参数的自定义函数：123456CREATE FUNCTION f2(num1 SMALLINT UNSIGNED,num2 SMALLINT UNSIGNED)RETURNS FLOAT(10,2) UNSIGNEDRETURN (num1+num2)/2;SELECT f2(); //报错SELECT f2(10,15); //结果：12.5 创建具有复合结构函数体的自定义函数修改分隔符：DELEMITER 分隔符12DELIMITER // //将分隔符修改为 &apos;//&apos; 当函数体内执行多条语句时，使用BEGIN…END语句；当编写函数体内容的时候，使用 DELIMITER 关键字将分隔符;修改为别的，否则写到 ‘;’ 时会执行，导致函数编写失败。 12345678910DELIMITER //CREATE FUNCTION ADD_USER(p_id SMALLINT,username VARCHAR(20))RETURNS INT UNSIGNEDBEGININSERT user(p_id,username) VALUES(p_id,username);RETURN LAST_INSERT_ID();END//DELIMITER ; 删除函数1DROP FUNCTION [IF EXISTS] function_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】Hexo插入图片]]></title>
    <url>%2Fpost%2Fe01ea1fb.html</url>
    <content type="text"><![CDATA[在写博客中添加图片是很正常的，这里列举了本人使用的两种方法 本地引用当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。 1![](/img/image.jpg) 要注意这是绝对路径 CDN引用将图片上传到一些免费的CDN服务中。上传图片后，会生成对应的url地址，将地址直接拿来引用即可参考七牛、cloudinary]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL子查询]]></title>
    <url>%2Fpost%2F9da3e761.html</url>
    <content type="text"><![CDATA[子查询子查询是指出现在其他SQL语句内的SELECT子句 子查询嵌套在查询内部，且必须始终出现在圆括号内。 可以包含多个关键字或者条件，如DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等 外层查询可以是：SELECT、INSERT、UPDATE、SET或DO 返回值：标量、一行、一列或者子查询 1SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2); SELECT * FROM t1;称为Outer Query/外查询/Outer StatementSELECT column1 FROM t2; 称为Sub Query/子查询 使用比较运算符的子查询1=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; 语法结构1operand comparison_operator [ANY|SOME|ALL] subquery 当子查询返回多个结果的时候就可以用到ANY、SOME、ALL修饰符的比较运算符 Any: &gt;Any 表示至少大于一个值，即大于最小值。Any: All 表示大于每一个值。换句话说，它表示大于最大值All: &lt;All 表示小于每一个值。换句话说，它表示小于最小值ANY: =ANY 或者 SOME 都是等于他们本身 ANY SOME ALL &gt; &gt;= 最小值 最小值 最大值 &lt; &lt;= 最大值 最大值 最小值 = 任意值 任意值 – &lt;&gt; != – – 任意值 12345678910111213141516171819202122SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=5636.36; //查询所有商品不小于平均价格的SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=( SELECT ROUND(AVG(goods_price),2) FROM tdb_goods); //利用子查询来进行两者的结合查找SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=ANY ( SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=ALL ( SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=SOME ( SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;); 使用[NOT] IN 的子查询语法结构1operand comparison_operator [NOT] &#123;IN|EXISTS&#125; (subquery) IN 相当于 =ANY 或 =SOMENOT IN 相当于 !=ALL 或 &lt;&gt;ALL 1234SELECT goods_id,goods_name,goods_price FROM tdb_goodsWHERE goods_price IN ( SELECT goods_price FROM tdb_goods WHERE goods_cate = &apos;超级本&apos;); 使用[NOT] EXISTS 的子查询如果子查询返任何行，EXISTS返true；反之，返false。 1234CREATE TABLE IF NOT EXISTS tdb_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40) NOT NULL);]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL连接]]></title>
    <url>%2Fpost%2Fb63304bd.html</url>
    <content type="text"><![CDATA[联合查询的效率比较高 连接MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作语法结构1234table_reference A&#123;[INNER|CROSS] JOIN | &#123;LEFT|RIGHT&#125; [OUTER] JOIN&#125;table_reference BON condition_expr 连接类型 内连接在MySQL中，JOIN, CROSS JOIN 和 INNER JOIN 是等价的。显示左表及右表符合连接条件的记录123SELECT goods_id,goods_name,cate_name FROM tdb_goods INNER JOIN tdb_goods_cate ON tdb_goods.cate_id = tdb_goods_cate.cate_id; 外连接左外连接：LEFT [OUTER] JOIN：显示左表的全部记录及右表符合连接条件的记录。右外连接：RIGHT [OUTER] JOIN：显示右表的全部记录及左表符合连接条件的记录。 如果使用LEFT JOIN，左表中存在一条记录A，在右表中没有找到相应的记录，则在返回结果用会出现一条只有记录A中的相应字段内容，其他字段都为NULL在记录(RIGHT JOIN类似) 12345678910111213//查询所有商品的详细信息(通过左外连接实现) SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gLEFT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_id;//LEFT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G;//查询所有商品的详细信息(通过右外连接实现) SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS g RIGHT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_id;//RIGHT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 外链接 A LEFT JOIN B join_condition数据表B的结果集依赖数据表A。数据表A的结果集根据左连接条件依赖于所有数据表（B表除外）。左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下）。如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。 全连接显示左表、右表两边中的所有行，即把左联结果表 + 右联结果表组合在一起，然后过滤掉重复的。 多表的连接跟两张表的连接一样表的连接实质就是外键的逆向约束123456SELECT goods_id,goods_name,b.cate_name,c.brand_name,goods_priceFROM products AS a INNER JOIN products_cate AS b ON a.goods_cate = b.cate_idINNER JOIN products_brand AS c ON a.brand_name = c.brand_id; 数据表参照12table_referencetbl_name [[AS] alias] | table_subquery [AS] alias 数据表可以使用tbl_name AS alias_name 或 tbl_name alias_name赋予别名。table_subquery可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。 连接条件使用ON关键字来设定连接条件，也可以使用WHERE来代替 通常使用ON关键字来设定连接条件使用WHERE关键字来进行结果集记录的过滤 自身连接 – 无限分类自身连接：同一个数据表对其自身进行连接 对于常见的分类，比如商城中的书籍&gt;&gt;文学&gt;&gt;小说，并不是使用多个表，而是使用一个表来进行联合查询 在同一张表中既有父类，又有子类。通过对同一张数据表的自身连接来进行查询，需要对表标识别名。做自身连接的话一定要起别名，以区分是子表还是父表 表的结构是这样的，使用parent_id表示父类目的id12345CREATE TABLE tdb_goods_types(type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,type_name VARCHAR(20) NOT NULL,parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0); 查找所有分类及其父类1234SELECT s.type_id ,s.type_name,p.type_name FROM tdb_goods_types s LEFT JOIN tdb_goods_types p ON s.parent_id=p.type_id; 查找所有分类及其子类1234SELECT p.type_id ,p.type_name,s.type_name FROM tdb_goods_types p LEFT JOIN tdb_goods_types s ON p.type_id=s.parent_id; 查找所有分类及其子类的数目123456SELECT p.type_id ,p.type_name,COUNT(s.type_name) FROM tdb_goods_types p LEFT JOIN tdb_goods_types s ON p.type_id=s.parent_idGROUP BY p.type_name ORDER BY p.type_id; 补充： https://www.jianshu.com/p/c4c43f32b66f http://wxb.github.io/2016/12/15/MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8Djoin.html http://www.zsythink.net/archives/1105]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL函数]]></title>
    <url>%2Fpost%2Fed90cb85.html</url>
    <content type="text"><![CDATA[字符函数 函数名称 描述 举例 结果 CONCAT() 字符连接 SELECT CONCAT(‘a’,’-‘,’b’); a-b CONCAT_WS() 使用指定的分隔符进行字符连接 SELECT CONCAT_WS(‘ ‘,’A’,’B’,’C’); A B C FORMAT() 数字格式化 SELECT FORMAT(12560.78,1); 12,560.8 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 SELECT LEFT(‘mysql’,2); my RIGHT() 获取右侧字符 LTRIM() 删除前导空格(=LEFT TRIM()) RTRIM() 删除后续空格 TRIM() 删除前后两边的空格，还可以删除指定的前导和后续的字符,不能删除中间的字符 SELECT TRIM(LEADING’?’,’??MYSQL????’); SELECT TRIM(TRAILING’?’,’??MYSQL????’); SELECT TRIM(BOTH’?’,’??MYSQL???’); MYSQL???? ??MYSQL MYSQL REPLACE() 替换字符 SELECT REPLACE(‘??MYSQL???’,’?’,’-‘); –MYSQL— SUBSTRING(string，offset，length) 截取字符串 SELECT SUBSTRING(‘MYSQL’,2,3); SQL [NOT]LIKE 模糊匹配 (%)：代表任意个字符，0个或多个 (_)：代表任意一个字符，只有一个 SELECT name FROM test WHERE name LIKE’%O%’; SELECT name FROM test WHERE name LIKE’%1%%’ ESCAPE’1’; name 中带‘O’的name 中间带% 的匹配name LEAGTH() 获取字符串长度 数值运算符与函数 函数名称 描述 举例 结果 CEIL(数值) 向上取整 SELECT CEIL(3.01); 4 FLOOR(数值) 向下取整 SELECT FLOOR(3.99); 3 DIV 整数除法 SELECT 3 DIV 4; 0 MOD 取余，可以用%号代替 SELECT 4 MOD 3; SELECT 5.3 MOD 3; 12.3 POWER(数值,数值) 幂运算 SELECT POWER(3,3); 27 ROUND(数值,小数的位数) 四舍五入 ROUND(3.1415926,4) 3.142 TRUNCATE(数值，截取位数) 截断（不四舍五入） SELECT TRUNCATE(123.89,1) SELECT TRUNCATE(125.68,-1); 123.8120 比较运算符与函数 函数名称 描述 举例 结果 [NOT]BETWEEN…AND… [不]在范围之间，1为是，0为否 15 BETWEEND 1 AND 2015 NOT BETWEEND 1 AND 20 10 [NOT]IN() [不]在列出值范围内 10 IN(5,10,15) 1 IS [NOT] NULL [不]为空 NULL IS NULL ‘’ IS NULL 10 日期时间函数 函数名称 描述 NOW() 当前时间 含日期时间 CURDATE() 当前日期 只有日期 CURTIME() 当前时间 值有时间 DATE_ADD() 时间增减或减少 DATEDIFF() 日期差值 DATE_FORMAT() 日期格式化 123456789101112SELECT DATE_ADD(&apos;2014-3-12&apos;,INTERVAL 365 DAY); 2015-3-12 //在原有给定的时间上增加365天 //INTERVAL增加可以增加负值 单位 year,month,week,daySELECT DATEDIFF(&apos;2014-1-1&apos;,&apos;2015-1-1&apos;);-365 //时间差值计算 单位为日 前面时间减去后面时间SELECT DATE_FORMAT(&apos;2014-3-2&apos;,&apos;%m/%d/%d&apos;); 03/02/2014//日期格式转换 信息函数 函数名称 描述 举例 结果 CONNECTION_ID() 连接ID SELECT CONNECTION_ID(); SELECT CONNECTION_ID(); 3 SELECT DATABASE() 当前数据库 SELECT DATABASE(); users LAST_INSERT_ID(); 最后插入记录的 ID 号 SELECT LAST_INSERT_ID(); 如果是一次insert中插入的是多条记录，得到的是多条中的第一条（而不是最后一条！） USER() 当前用户 SELECT USER(); root@localhost VERSION(); 版本的信息 SELECT VERSION(); 5.7.21 聚合函数 函数名称 描述 举例 AVG() 平均值 SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods; COUNT() 计数 SELECT COUNT(goods_id) as counts FROM tdb_goods; MAX() 最大值 SELECT MAX(goods_price) as counts FROM tdb_goods; MIN() 最小值 SELECT MIN(goods_price) as counts FROM tdb_goods; SUM() 求和 SELECT SUM(goods_price) as counts FROM tdb_goods; 加密函数 函数名称 描述 举例 结果 MD5() 信息摘要算法，为以后的Web页面做准备，尽量使用MD5() SELECT MD5(‘admin’); 21232f297a57a5a743894a0e4a801fc3 PASSWORD() 密码算法通过PASSWORD()修改(重要用于MYSQL数据库)当前用户和其他用户的密码，修改客户端自己的密码 SELECT PASSWORD(‘admin’); SET PASSWORD=PASSWORD(‘dimitar’); *4ACFE3202A5FF5CF467898FC58AAB1D615029441 把密码修改成dimitar]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储过程]]></title>
    <url>%2Fpost%2F392b408.html</url>
    <content type="text"><![CDATA[定义存储过程是SQL语句与控制语句的预编译集合，以一个名称存储作为一个单元处理 输入SQL命令，MySQL引擎对命令进行分析，查看输入的语法是否正确，如果正确，再进行编译，编译成MySQL引擎可识别的命令，最后再进行执行，并将执行结果返回给客户端。 如果省略了语法分析和编译的阶段，则效率可提高。 存储过程：是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理（类似函数）。存储过程存储在数据库内，可以由应用程序调用执行，而且允许用户申明变量以及进行流程控制。存储过程可以接受输入类型的参数和输出类型的参数，并且可以存在多个返回值。只在第一次调用时进行语法分析和编译，以后的调用直接调用编译的结果，效率大大提高。 优点 增强SQL语句的功能和灵活性：可以通过控制语句对流程进行控制和判断 实现较快的执行速度：客户端第一次调用存储过程时，MySQL引擎会对其进行语法分析、编译等操作，然后将编译结果存储到内存中，所以第一次和之前的效率一样，然而以后会直接调用内存中的编译结果，效率提高 减少网络流量：例如删除一个记录，我们原本要输入DELETE FROM xx WHERE …; 要传输的字符较多，如果写成存储过程，就只要调用存储过程的名字和相应参数就行，传输的字符数量较少，所以减少了网络流量。 创建储存过程1234CREATE[DEFINER = &#123;user|CURRENT_USER&#125;]PROCEDURE sp_name ([proc_parameter[,...]]) //可以带0到多个参数[characteristic ...] routine_body 其中参数12proc_parameter:[IN | OUT | INOUT] param_name type IN, 表示该参数的值必须在调用存储过程时指定OUT, 表示该参数的值可以被存储过程改变，并且可以返回INOUT, 表示该参数的值调用时指定，并且可以被改变和返回 特性123COMMENT &apos;string&apos;| &#123;CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA| SQL SECURITY&#123;DEFINER|INVOKER&#125; COMMENT: 注释CONTAINS SQL: 包含SQL语句, 但不包含读或写数据的语句NO SQL: 不包含SQL语句READS SQL DATA: 包含读数据的语句MODIFIES SQL DATA: 包含写数据的语句SQL SECURITY {DEFINER|INVOKER} 指明谁有权限来执行 过程体 过程体由合法的SQL语句构成; 过程体可以是任意SQL语句; 过程体如果为复合结构则使用BEGIN…END语句 复合结构可以使用条件、循环等控制语句 创建无参的存储过程123CREATE PROCEDURE sp1() SELECT VERSION(); //创建CALL sp1; //调用CALL sp1(); 创建带IN类型参数的存储过程123456789101112//若带的参数与数据表中的字段一致，则删除整个数据表。DELIMITER //CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)BEGIN DELETE FROM users WHERE id = p_id;END//DELIMITER ;SELECT * FROM users;CALL removeUserById(22);SELECT * FROM users WHERE id = 22; 创建带IN OUT类型参数的存储过程1234567891011DELIMITER //CREATE PROCEDURE removeUserAndReturnUserNums(IN p_id INT UNSIGNED,OUT userNums INT UNSIGNED)BEGINDELETE FROM users WHERE id=p_id;SELECT COUNT(id) FROM users INTO userNums; END//DELIMITER ;CALL removerUserAndReturnUserName(10,@nums); SELECT @nums; SET @i = 7; INTO将SELECT语句结果返回给userNums变量通过@或SET设置的变量称为用户变量@nums 所代表的就是用户变量，可用 SELECT @nums 输出 局部变量与用户变量的区别用 DECLARE 声明的变量是局部变量，局部变量只能存在于 BEGIN…END 之间，且声明时必须置于 BEGIN…END 的第一行。而通过 SELECT…INTO…/SET @id = 07设置的变量称用户变量，只能存在于当前用户所使用的客户端有效。 创建带有多个OUT类型参数的存储过程明确OUT类型的参数的定义与作用OUT类型参数，表示在调用存储过程时，值可被存储过程改变，并且返回一个值。通常变量用“@”符号开头的变量，在BEGIN和END之中的变量是局部变量，在调用存储过程时写入的变量是“用户变量”。比如有一个存储过程的名称叫做“addUser()”，调用时addUser(@sum),sum就是用户变量。 ROW_COUNT()函数相当于PHP的MySQL函数库中的mysql_affected_rows()数作用相同，计算增删改查的个数总和。 1234567891011121314DELIMITER //CREATE PROCEDURE removeUserByAgeAndReturnInfos(IN p_age SMALLINT UNSIGNED,OUT deleteUsers SMALLINT UNSIGNED,OUT userCounts SMALLINT UNSIGNED)BEGINDELETE FROM users WHERE age=p_age;SELECT ROW_COUNT() INTO deleteUsers; #返回被增删改查的记录总数SELECT COUNT(id) FROM users INTO userCounts;END//DELIMITER ;CALL removeUserByAgeAndReturnInfos(20,@a,@b);SELECT @a,@b; #a是删除的记录数，b是剩余的记录数 修改存储过程1234ALTER PROCEDURE sp_name [characteristic]COMMENT &apos;string&apos;|&#123;CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA&#125;|SQL SECURITY&#123;DEFINER|INVOKER&#125; 调用存储过程1234CALL sp_name([parameter[,...]]) //带参数的存储过程的调用CALL sp_name[()] //不带参数的存储过程调用 删除存储过程123DROP PROCEDURE [IF EXISTS] sp_name;DROP PROCEDURE removeUserById; 储存过程与自定义函数的区别： 储存过程实现的功能要复杂一些；而函数的针对性更强。 储存过程可以返回多个值；函数只能有一个返回值。 储存过程一般独立的来执行；而函数可以作为其他SQL语句组成部分来出现。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL记录操作]]></title>
    <url>%2Fpost%2F2aaa8b1b.html</url>
    <content type="text"><![CDATA[insert 插入记录INSERT…VALUES比较常用，一次性插入多条记录，可输入表达式甚至是函数。12INSERT [INTO] table_name [(column_name,...)] &#123;VALUES|VALUE&#125; (&#123;expr|DEFAULT&#125;,...),(...),...; expr 表示表达式对于自动编号的字段，插入NULL或DEFAULT系统将自动依次递增编号；对于有默认约束的字段，可以插入DEFAULT表示使用默认值；列值可传入数值、表达式或函数，如密码可以用md5()函数进行加密（如md5(‘123’)）；可同时插入多条记录，多条记录括号间用逗号,隔开 1234567INSERT test VALUES(NULL,&apos;Tom&apos;);//插入单条记录INSERT users VALUES(DEFAULT,&apos;Tom&apos;,&apos;123&apos;,1+9*2,1),(NULL,&apos;John&apos;,md5(&apos;123&apos;),DEFAULT,0); //插入两条记录 INSERT…SET这种方法一次只能插入一条记录列值中有自动编号、默认值或Boolean类型均可以不赋值(使用子查询)1INSERT [INTO] table_name SET col_name=&#123; expr | DEFAULT &#125;,...; 1INSERT users SET username=&apos;Ben&apos;,password=&apos;456&apos;; INSERT…SELECT一般用于将其他表的数据插入到指定表，注意对应12INSERT [INTO] table_name(col_name,...) SELECT col_name,... FROM table_name [GROUP BY/HAVING/ORDER BY/LIMIT...]; 12345678INSERT test SELECT username FROM users WHERE age &gt;=30; // 字段不匹配提示INSERT test (username) SELECT username FROM users WHERE age &gt;=30;INSERT tdb_goods_cates(cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;//在表tdb_goods_cates中插入tdb_goods中的cate update 更新记录1234UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;exp1|DEFAULT&#125;[,col_name2=&#123;exp1|DEFAULT&#125;,...][WHERE where_condition] 省略WHERE条件则更新所有记录该列的值 单表更新1234UPDATE users SET age = age + 5,sex = 0; //使表里所有记录的age加5UPDATE users SET age = age + 10 WHERE id % 2=0; //取id为偶数的位置 多表更新使用连接进行多表更新，以下为连接的语法1234table_reference&#123;[INNER | CROSS] JOIN | &#123;LEFT|RIGHT&#125; [OUTER] JOIN&#125;table_referenceON conditional_expr 1234UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate=cate_name SET goods_cate=cate_id;//如果goods_cate等于cate_name那么就让goods_cate=cate_id 创建数据表同时将查询结果写入到数据表123CREATE TABLE [IF NOT EXISTS] tbl_name[(create_definition,...)]select_statement 1234567891011121314151617CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name; UPDATE tdb_goods AS g INNER JOIN tdb_goods_brands AS b ON g.brand_name = b.brand_name SET g.brand_name = b.brand_id;//多表更新 ALTER TABLE tdb_goods CHANGE goods_cate cate_id SMALLINT UNSIGNED NOT NULL,CHANGE brand_name brand_id SMALLINT UNSIGNED NOT NULL;//通过ALTER TABLE语句修改数据表结构 delete 删除记录单表删除1DELETE FROM table_name [WHERE where_conditon]; 省略条件则默认删除该表所有记录(仅删除所有记录，不删除数据表)删除后再插入，插入的id号从最大的往上加，而不是填补删除的。 1DELETE FROM users WHERE id=6; 多表删除INSERT … SELECT实现复制1234INSERT tdb_goods(goods_name,cate_id,brand_id) SELECT goods_name,cate_id,brand_id FROM tdb_goods WHERE goods_id IN (19,20); 查找重复记录SELECT goods_id,goods_nameFROM tdb_goodsGROUP BY goods_name HAVING count(goods_name) &gt;= 2;12删除重复记录 DELETE t1FROM tdb_goods AS t1LEFT JOIN ( SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2 ) AS t2ON t1.goods_name = t2.goods_nameWHERE t1.goods_id &gt; t2.goods_id;1234&lt;br&gt;## select 查找记录 SELECT select_expr [,select expr2…] //只查找某一个函数或表达式[FROM table_references //查询表名[WHERE where_conditon] //查询条件[GROUP BY {col_name|position} [ASC|DESC],…] //按某个字段进行分组，相同的只显示第一个[HAVING where_conditon] //分组时，给出显示条件[ORDER BY {col_name|expr|position} [ASC|DESC],…] //排序[LIMIT {[offset,]row_count|row_count OFFSET offset}] //限制返回数量}123456789### 查询表达式* 每一个表达式表示想要的一列，必须至少有一个* 多个列之间以英文逗号分隔* 星号(*)表示所以列 table_name.*可以表示命名表的所有列* 查询表达式可以使用`[As]alias_name`为其赋予别名* 别名可用于GROUP BY，ORDRE BY或HAVING子句SELECT 字段出现顺序影响结果集出现顺序，字段别名也影响结果集字段别名 SELECT * FROM users;SELECT id AS userid,usrname AS uname FROM users;SELECT users.id FROM users;12345### WHERE 条件表达式对记录进行过滤，如果没有指定的WHERE子句，则显示所有记录在WHERE表达式中，可以使用MYSQL支持的函数或运算符 SELECT * FROM users WHERE id=1;123### GROUP BY 查询结果分组 [GROUP BY {col_name|position} [ASC|DESC],…]123ASC：升序，默认DESC：降序position：SELECT语句中列的序号 SELECT sex FROM users GROUP BY sex;//对users中的sex按sex进行分组SELECT * FROM users GROUP BY 1;//1表示查询的第一个字段，这里是表中的第一个字段idSELECT sex FROM users GROUP BY 1;//1表示sex123456如果存在相同的值（例如上面的age可能有多个相同的值），**只会保留一个**。但使用ORDER BY 就不会省略。### HAVING 分组条件用在GROUP BY后面追加条件，条件要么为一个聚合函数，要么出现在SELECT要查询的字段中。 [HAVING when where_condition] SELECT sex FROM users GROUP BY 1 HAVING age &gt; 35; //有错SELECT sex,age FROM users GROUP BY 1 HAVING age &gt; 35;SELECT sex FROM users GROUP BY 1 HAVING count(id) &gt;= 2;//按照sex分组，条件id数大于2的分组留下显示//工作流程就是先从表中查询字段，然后根据GROUP BY的条件对查询结果进行分组，再根据HAVING条件对分组进行筛选，最后留下满足所有条件的分组结果。12345678聚合函数永远只有一个返回结果count是记录指定列的值的个数（NULL不计入）### ORDER BY 排序对查询结果进行排序，默认是升序，DESC是降序 [ORDER BY [col_name | expr | position } [ASC|DESC],…] SELECT FROM users ORDER BY id DESC;//对一个字段排序SELECT FROM users ORDER BY age,id DESC;//多字段排序，先按照age排序，如果age有重复的，重复的字段里按id排序123456多个排序条件之间以逗号相隔，在前面的排序条件满足时，忽略后面的排序条件，否则按照后面的排序条件进行排序。### LIMIT 限制查询结果数量 [LIMIT {[offset,] row_count | row_count OFFSET offset}]12获取头部记录LIMIT 10; //获取查询结果的前10条记录，**默认从0开始**获取中间记录LIMIT 2,10;//获取从第3条开始的10条记录 SELECT FROM users LIMIT 2;//从第一条开始（第一个为0），返回两条SELECT FROM users LIMIT 2,3;//从第三条开始（第一个为0），返回三条```]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL修改数据表]]></title>
    <url>%2Fpost%2F5f31036f.html</url>
    <content type="text"><![CDATA[总结： 1ALTER TABLE table_name ADD/DROP ...; 添加/删除列添加单列如果指定FIRST，则在整个表的最前方，默认不写为整个表的最后方；如果指定AFTER col_name，则在col_name的后面。123ALTER TABLE table_name ADD [COLUMN] col_name column_definition [FIRST | AFTER col_name];ALTER TABLE user1 ADD password varchar(32) not NULL AFTER name; 添加多列无法指定FIRST/AFTER、只能默认为最后方123ALTER TABLE table_name ADD [COLUMN] (col_name column_definition,...);ALTER TABLE user1 ADD password varchar(32) not NULL,pid smallint unsigned; 删除单列123ALTER TABLE table_name DROP [COLUMN] col_name;ALTER TABLE user1 DROP password; 删除多列123ALTER TABLE table_name DROP [COLUMN] col_name, DROP [COLUMN] col_name,DROP [COLUMN] col_name; 添加约束添加/删除主键约束constraint 给主键起名12345ALTER TABLE table_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...);ALTER TABLE table_name DROP PRIMARY KEY;ALTER TABLE users ADD CONSTRAINT pk_users_id PRIMARY KEY (id);ALTER TABLE users DROP PRIMARY KEY; 添加/删除唯一约束123456ALTER TABLE table_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name,...)ALTER TABLE table_name DROP &#123;INDEX|KEY&#125; index_name;//删除唯一约束只用删掉它的索引就行了ALTER TABLE users ADD UNIQUE (username);ALTER TABLE users drop INDEX username; 添加/删除外键约束1234567ALTER TABLE table_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name](index_col_name,...) reference_definition;ALTER TABLE table_name DROP FOREIGN KEY（fk_symbol);//fk_symbol 是CONSTRAINT定义的名字，如果没有定义可以通过 show create table table_name来查看ALTER TABLE users ADD FOREIGN KEY (pid) REFERENCES provinces (id);SHOW TABLE TABLE users;ALTER TABLE users DROP FOREIGN KEY (pid); 添加/删除默认约束1234ALTER TABLE table_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;ALTER TABLE users ALTER age SET DEFAULT 15;ALTER TABLE users ALTER age DROP DEFAULT; 修改列修改列定义123456ALTER TABLE table_name MODIFY [COLUMN] col_name column_definition [FIRST |AFTER col_name];ALTER TABLE users2 MODIFY id SMALLINT UNSIGNED NOT NULL FIRST; //将id字段的位置提到第一列ALTER TABLE users2 MODIFY id TINYINT UNSIGNED NOT NULL; //修改数据类型，需注意数据丢失的问题（范围大转范围小） 修改列名称1234ALTER TABLE table_name CHANGE [COLUMN] col_name new_col_name column_definition [FIRST|AFTER col_name];ALTER TABLE users2 CHANGE pid p_id TINYINT UNSIGNED; //修改列名称，类型可以通过show create table table_name复制原来的 数据表更名方法1123ALTER TABLE table_name RENAME [TO/AS] new_table_name;ALTER TABLE users2 RENAME (to/as) users3; 方法2123RENAME TABLE table_name TO new_table_name [,table_name2 TO new_table_name2] ...;RENAME TABLE users5 TO users2; 尽量少使用数据表的列名及表名的更名。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL约束]]></title>
    <url>%2Fpost%2F1df97176.html</url>
    <content type="text"><![CDATA[约束保证数据的完整性和一致性约束按功能分为PRIMARY KEY、UNIQUE KEY、DEFAULT、NOT NULL、FOREIGN KEY按数目分为列级约束和表级约束 查看约束12SHOW INDEX FROM table_name\G;SHOW INDEX FROM table_name; 主键约束：PRIMARY KEY主键可以写为PRIMARY KEY，也可以写成KEY 唯一性（可以赋值但是不能给两个记录赋一样的值）每张表只存在一个主键 主键保证记录的唯一性 主键自动为NOT NULL，也就是说必须要为主键赋值。但如果主键选择了AUTO_INCREMENT，那么不需要手动赋值 auto_increment必须和主键primary key一起使用，但是主键primary key不一定要和auto_increment一块使用 主键的字段是可以赋值的，但不能赋相同的值 1234CREATE TABLE user(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL); 记录如果删除了编号会出现间断 自增 AUTO_INCREMENT 自动编号，保证记录的唯一性，且必须与主键组合使用 默认情况下，初始为1，每次增长量为1. 对应的字段设置必须是数值类型，若是浮点类型，小数位必须为0. 自动编号必须是主键字段 1234CREATE TABLE tb3(id SMALLINT UNSIGNED AUTO_INCREMENT,username VARCHAR(30) NOT NULL); //报错，自动增量字段必须设置成主键 AUTO_INCREMENT必须是主键主键不一定要用AUTO_INCREMENT 唯一约束：UNIQUE KEY 唯一约束可以保证记录的唯一性 唯一约束的字段可以为空值（NULL），存储时只保留一个NULL 每张数据表可以存在多个唯一约束 12345CREATE TABLE tb2(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL UNIQUE KEY,age TINYINT UNSIGNED); 默认约束：DEFAULT如果没有明确为字段赋值会自动赋与默认值123456CREATE TABLE tb6(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL UNIQUE KEY,sex ENUM(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) DEFAULT &apos;3&apos;);//表示当sex没有赋值时，默认值为3 非空约束：NOT NULLNULL，字段值可以为空NOT NULL，字段值禁止为空，不赋值会报错 外键约束：FOREIGN KEY保持数据一致性，完整性；实现一对一或一对多关系 要求： 父表和子表必须使用相同的存储引擎，而且禁止使用临时表(子表：具有外键列的表；父表：子表参照的表) 数据表的存储引擎只能为InnoDB 外键列和参照列必须具有类似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引 在配置文件（my.ini\my.conf）中编辑默认的存储引擎：1default-storage-engine=INNODB 1234567891011CREATE TABLE table_name1(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL);CREATE TABLE table_name2(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL,pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES table_name1(id) );// 外键 pid 参照 table_name1中的 id 字段 显示创建表的语句：SHOW CREATE TABLE table_name；查看表是否有索引：SHOW INDEXS FROM table_name；以网格查看表是否有索引：SHOW INDEXS FROM table_name\G； 外键约束的参照操作 CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行 SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL RESTRICT：拒绝对父表的删除或更新操作 NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同 123456CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,pid SMALLINT,username VARCHAR(10) NOT NULL,FOREIGN KEY (pid) REFERENCES province (id) ON DELETE CASCADE); 从父表删除或更新行，会设置子表中的外键列为NULL，如果使用该选项，必须保证子表列没有指定NOT NULL 实际开发中，我们很少使用物理的外键约束，而是使用逻辑约束；物理的外键约束只有innoDB这种存储引擎才会支持，MYISAM这种引擎就不支持物理的外键约束。反过来说，当我们使用到的引擎为MYISAM时，只能使用逻辑外键（即两个表的设计的逻辑关系）。 表级约束与列级约束对一个数据列建立的约束，称为列级约束对多个数据列建立的约束，称为表级约束 列级约束既可以在列定义时声明，也可以在列定以后声明表级约束只能在列定义后声明 主键、外键、唯一既可以作为表级约束，也可作为列级约束not null、default只有列级约束]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据表]]></title>
    <url>%2Fpost%2F8ecc2d83.html</url>
    <content type="text"><![CDATA[数据表（或表）是数据库最重要的组成部分之一，是其他对象的基础，表是一个二维表，行称为【记录】，列称为【字段】 创建数据表首先打开数据库（数据库要存在）: USE 数据库名称 创建数据表123CREATE TABLE [IF NOT EXISTS] table_name(column_name(列名称) data_type（列类型）,.... ); 12345CREATE TABLE tb1(username VARCHAR(20),userage TINYINT UNSIGNED,salary FLOAT(8,2) UNSIGNED,); UNSIGNED 无符号 查看数据表列表1234SHOW TABLES [FROM db_name] [LIKE &apos;pattern&apos; | WHERE expr]；SHOW TABLES; //查看当前选择的数据库的所有表SHOW TABLES FROM test; //查看test数据库中的所有表，当前选择数据库位置不变 查看数据表的结构1SHOW COLUMNS FROM tb1; //查看tb1中的数据表结构 查看创建数据表的语句1SHOW CREATE TABLE table_name; 插入记录1234INSERT table_name [字段(colume),...] VALUES(val,...);INSERT tb1 VALUES(&apos;TOM&apos;,25,6782.12);INSERT tb1(username,salary) VALUES(&apos;John&apos;,3398.98); 省略字段后，values(记录内容必须按照表列顺序也就是字段顺序以逗号分隔，且插入内容一个不能少);若不省略字段(可部分省略，省略部分记录自动为空)，values(记录内容按照字段插入内容，写几个字段插入几个内容); 查找记录1SELECT expr(表达式),...FROM table_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2Fpost%2F47519a60.html</url>
    <content type="text"><![CDATA[数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型 整型整型的存储范围分有符号位和无符号位两种，一般无符号位是有符号位的两倍 选择数据类型要根据实际数据的大小，选择合适的数据类型有利于数据的优化 数据类型 字节 存储范围 tinyint 1 -128~127无符号0~255 smallint 2 -32768~32767无符号0~65535 mediumint 3 -2^23~2^23-1(800万)无符号0~2^24-1 int 4 -2^31~2^31-1(21亿)无符号0~2^32-1 bigint 8 -2^63~2^63-1无符号0~2^64-1 浮点型 数据类型 存储类型 float[(m,d]) -3.402E+38到-1.175E-380和1.175E-38到3.402+38m是数字总位数，d是小数点后面的位数，如果m和d被省略，会根据硬件允许的限制来保存值 double[(m,d)] -1.797E+308到-2.223E-308、0和2.225E-308到1.797E+308 float，单精度浮点，保留小数点后7位，C语言默认显示6位小数。double，双精度浮点，一般是float存储范围的十倍，C语言默认显示15位小数。 日期时间型 数据类型 存储范围 存储需求 YEAR 1970至2069 1 TIME -838:59:59至838:59:59 3 DATE 1000-1-1至9999-12-31 3 DATETIME 1000-1-1 00:00:00至9999-12-31 23:59:59 8 TIMESTAMP 1970-1-1 00:00:00到2037-12-31 23:59:59 4 字符型 列类型 存储需求 CHAR(M) M个字节 0&lt;=M&lt;=255 定长 M是5就5个字节 abc会在后面补两个空格 VARCHAR(M) L+1个字节 L&lt;=M,0&lt;=M&lt;=65535变长 abc就是abc TINYTEXT L+1个字节，L&lt;2的8次方 TEXT L+2个字节，L&lt;2的16次方（6w5），标准文本 MEDIUMTEXT L+3个字节，L&lt;2的24次方（1600w） LONGTEXT L+4个字节，L&lt;2的32次方 ENUM(‘value1’;’value2’,…) 1or2字节 取决于枚举值的个数（最多65535个值） SET（’value1’,’value2’,…) 1、2、3、4、8字节，取决于set成员个数（最多64个成员） booleanMySQL没有内置的布尔类型，但是它使用TINYINT(1)。 为了更方便，MySQL提供BOOLEAN或BOOL作为TINYINT(1)的同义词。 MySQL将布尔值作为整数存储在表中，但当显示表定义时，它是却是TINYINT(1)类型12345CREATE TABLE tasks (id INT PRIMARY KEY AUTO_INCREMENT,title VARCHAR(255) NOT NULL,completed BOOLEAN); https://www.yiibai.com/mysql/boolean.htmlhttps://dev.mysql.com/doc/refman/8.0/en/bit-type.html]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作]]></title>
    <url>%2Fpost%2Ff2cccc89.html</url>
    <content type="text"><![CDATA[创建数据库12CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name; DATABASE和SCHEMA是相同的，任选其一IF NOT EXISTS:如果创建的数据库存在，则不只报出warning，不写会报错CHRARCTER SET gbk:为表设置编码方式，如果不设置则用mysql默认的编码方式 查看数据库列表1SHOW &#123; DATABASES | SCHEMAS &#125; [LIKE &apos;pattern&apos; | WHERE expr]; 查看数据库详情1SHOW CREATE DATABASE xx; 展示数据库t1的创建命令和编码形式 数据库的修改：ALTER修改数据库编码方式12ALTER &#123; DATABASE | SCHEMAS &#125; [db_name][DEFAULT] CHARACTER SET [=] charset_name 删除数据库：DROP1DROP &#123; DATABASE | SCHEMAS &#125; [IF EXISTS] db_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用命令及语句规范]]></title>
    <url>%2Fpost%2Fed36abd2.html</url>
    <content type="text"><![CDATA[MySql语句规范 关键字和函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾 常用语句SELECT VERSION(); 查询当前服务器版本SELECT NOW(); 查询当前日期时间SELECT USER(); 查询当前用户]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句规范]]></title>
    <url>%2Fpost%2Fed36abd2.html</url>
    <content type="text"><![CDATA[MySql语句规范 关键字和函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL登录和退出]]></title>
    <url>%2Fpost%2F20f3fae1.html</url>
    <content type="text"><![CDATA[mysql命令参数12345678-D,--database=name 打开指定数据库 --delimiter=name 指定分隔符-h,--host=name 服务器名称-p,--password[=name] 密码-P,--port=# 端口号（默认为3306）--prompt=name 设置提示符-u,--user=name 用户名-V,--version 输出版本信息且推出 登录1mysql -uroot -P3306 -hlocalhost -p 退出123mysql&gt;exit;mysql&gt;quit;mysql&gt;\q;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL配置]]></title>
    <url>%2Fpost%2Fb62959c1.html</url>
    <content type="text"><![CDATA[配置文件的位置不一，在Centos7.4和MySQL5.5上是在/etc/my.cnf也可能在/etc/mysql/my.cnf 修改编码方式在mysql中可以通过status查看编码 12345[mysql]default-character-set=utf8[mysqld]character-set-server=utf8 修改提示符 连接客户端时通过参数指定 123mysql -uroot -p --prompt 提示符mysql -uroot -p --prompt &quot;[\D-\d\h\u]&quot; 连接上客户端后，通过prompt命令修改 1mysql&gt;prompt 提示符 提示符有：\D 完整的日期\d 当前数据库\h 服务器名称\u 当前用户]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL目录结构]]></title>
    <url>%2Fpost%2F1c0eeefa.html</url>
    <content type="text"><![CDATA[使用yum安装MySQL后的各目录位置相关路径直接通过find / -name &quot;mysql*&quot;和whereis mysqld查找： /usr/lib64/mysql 库文件/usr/share/mysql 配置文件，5.5后的默认安装路径/var/lib/mysql 数据库目录/etc/rc.d/init.d/ 启动脚本/usr/bin/ mysqladmin\mysqldump命令/usr/share/doc/ 文档]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome插件vimium]]></title>
    <url>%2Fpost%2F167caf1a.html</url>
    <content type="text"><![CDATA[以下部分快捷键标明了chrome自身的快捷键，毕竟有时因为焦点的原因可能失效 页面浏览12345678j 向下滚动一行k 向上滚动一行h 向左滚动l 向右滚动d 向下翻半屏u 向上翻半屏gg 到页面顶G 到页面底 标签12345678t 新建标签J、Ctrl-Tab 切换到下个标签K、Ctrl-Shift-Tab 切换到上个标签g0 切换到第一个标签g$ 切换到最后一个标签x、Ctrl-w 关闭当前标签X 恢复最后一个关闭的标签T 搜索当前打开的页签 链接1234f 在当前页打开链接F 在新页签打开链接o 在当前页签打开书签、url、历史 O 在新页签打开书签、url、历史 历史12H 回到历史L 向前 帮助1? 参考： https://github.com/philc/vimium#keyboard-bindings https://sspai.com/post/27723]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hyper终端的配置]]></title>
    <url>%2Fpost%2Fb6b46b46.html</url>
    <content type="text"><![CDATA[hyper是一款基于Electron的终端， Electron应用中比较出名的有Atom、VS code hyper的配置文件是.hyper.js1234567//不要用14，目前有一个不显示下划线的问题，https://github.com/zeit/hyper/issues/2812fontSize: 15,plugins: [ &quot;hyper-material-theme&quot;, &quot;hyper-search&quot;, ], 主题的安装可以通过在终端里输入hyper i verminal安装 https://github.com/zeit/hyper/issues/2812]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim多行注释和多行删除]]></title>
    <url>%2Fpost%2Fb837d84f.html</url>
    <content type="text"><![CDATA[多行注释和多行删除都是利用vim的块模式 多行注释 首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式; 在行首使用上下键选择需要注释的多行; 按下键盘（大写）“I”键，进入插入模式； 然后输入注释符（“//”、“#”等）; 最后按下Esc键。注：在按下esc键后，会稍等一会才会出现注释 删除多行注释 首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式; 选定要取消注释的多行; 按下x或者d.注意：如果是“//”注释，那需要执行两次该操作，如果是“#”注释，一次即可 多行删除 首先在命令模式下，输入:set nu显示行号； 通过行号确定你要删除的行； 命令输入:32,65d，回车键，32-65行就被删除了 如果无意中删除错了，可以使用u键恢复（命令模式下）]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux配置文件和插件]]></title>
    <url>%2Fpost%2Fc0cf1d1f.html</url>
    <content type="text"><![CDATA[配置文件（~/.tmux.conf）使用tmux source .tmux.conf使命令生效打开鼠标后使用shift键选中文字，再按Shift-Ctrl-c复制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 基础设置#设置默认终端模式为 256colorset -g default-terminal &quot;screen-256color&quot;set -g display-time 3000set -g escape-time 0set -g history-limit 65535set -g base-index 1set -g pane-base-index 1# 前缀绑定 (Ctrl+a)#set -g prefix ^a#unbind ^b#bind a send-prefix# 分割窗口#unbind &apos;&quot;&apos;#bind - splitw -v#unbind %#bind | splitw -h# 选中窗口#bind-key k select-pane -U#bind-key j select-pane -D#bind-key h select-pane -L#bind-key l select-pane -R# copy-mode 将快捷键设置为 vi 模式#setw -g mode-keys vi# 启用鼠标(Tmux v2.1)set -g mouse on# 更新配置文件bind r source-file ~/.tmux.conf \; display &quot;已更新&quot;#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;# Tmux Plugin Manager(Tmux v2.1)# Tmux Resurrectset -g @plugin &apos;tmux-plugins/tmux-resurrect&apos;# List of pluginsset -g @plugin &apos;tmux-plugins/tpm&apos;set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;# Other examples:# set -g @plugin &apos;github_username/plugin_name&apos;# set -g @plugin &apos;git@github.com/user/plugin&apos;# set -g @plugin &apos;git@bitbucket.com/user/plugin&apos;# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run &apos;~/.tmux/plugins/tpm/tpm&apos;#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 插件TPM的安装跟我们现在常用的很多软件类似，Tmux也支持插件系统，可以通过安装插件扩展出许多功能，让Tmux变得更加强大。在Tmux中，这款插件管理器叫做 TPM - Tmux Plugin Manager。 TPM的安装也比较简单:1$ git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 然后，修改Tmux配置文件，让其在启动时加载TPM1234567891011# List olugins# # Supports `github_username/repo` or full git repo URLsset -g @plugin &apos;tmux-plugins/tpm&apos;set -g @plugin &apos;tmux-plugins/tmux-resurrect&apos;set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;set -g @plugin &apos;tmux-plugins/tmux-urlview&apos;set -g @plugin &apos;tmux-plugins/tmux-open&apos;set -g @plugin &apos;tmux-plugins/tmux-yank&apos;set -g @plugin &apos;tmux-plugins/tmux-battery&apos;set -g @plugin &apos;tmux-plugins/tmux-cpu&apos; TPM主要提供插件的安装，更新和移除等管理功能：123&lt;prefix&gt; I 安装插件，并更新Tmux&lt;prefix&gt; U 更新所有已安装插件&lt;prefix&gt; Alt U 移除所有插件列表中不存在的插件 常用插件推荐有了TPM，我们就能够安装和使用各种插件了，这里介绍几款我比较常用的插件： Tmux Resurrect 一个非常好用的保存当前Tmux窗口和Panel布局的插件。它可以帮助你持久化当前Tmux中所有的窗口和Panel布局。如果你对窗口进行了分割并且精心调整过，在退出Tmux之前可以使用快捷键对布局进行持久化。下一次启动Tmux的时候，也能非常方便的用快捷键恢复上次的窗口布局，真是非常方便。插件地址：https://github.com/tmux-plugins/tmux-resurrect 将插件添加到TPM插件列表中.tmux.conf：1set -g @plugin &apos;tmux-plugins/tmux-resurrect&apos; 点击prefix + I获取插件并获取它。您现在应该可以使用该插件。12prefix + Ctrl-s - 保存prefix + Ctrl-r - 恢复 Tmux urlview 在终端界面中自动搜寻所有的URL链接地址，合并为一个可以选择的列表，然后选中直接在浏览器中打开URL。省去了用鼠标复制URL，再打开浏览器粘贴的繁琐操作，非常高效，值得推荐！插件地址：https://github.com/tmux-plugins/tmux-urlview Tmux open 使用系统中默认文件类型对应的程序，快速打开在终端中选中的文件名。这个也非常高效，值得推荐！ 插件地址：https://github.com/tmux-plugins/tmux-open 参考：https://xiaozhou.net/learn-the-command-line-tmux-2018-04-27.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux快捷键]]></title>
    <url>%2Fpost%2F6457d4b.html</url>
    <content type="text"><![CDATA[安装\启动12sudo apt install tmuxtmux 会话、窗口与窗格的概念Tmux中的主要概念分为三个： Session - Session是Tmux中最主要的概念了，默认开启Tmux的时候，就会自动新建一个会话，在这个会话中，也会给你开启一个默认的Window（也即窗口）。Tmux中可以拥有多个会话，多个会话之间可以来回无缝切换。 Window - 相比session，Windows是稍微小一点的单位。一个session中，可以开启多个window。这些window同属于一个Session，并由其管理。 Panel - Panel是比Window更小的界面元素。前面我们也提到了Tmux中可以对window进行任意分割，由window分割出来的单位就叫做panel了。在同一个window中，用户可以控制光标在分割出的panel中随意移动，用以选定当前作为激活状态的panel。 via 这里 常用这里是自己平时会用到的 12345678910111213141516tmux new -s 会话名 新建会话tmux ls 列出会话tmux at -t 会话名 恢复会话ctrl-b,:new 启动新会话ctrl-b,s 列出所有会话strl-b,d 关闭会话，后台存在ctrl-b,c 创建新窗口ctrl-b,w 列出所有窗口ctrl-b,n 后一个窗口ctrl-b,p 前一个窗口ctrl-b,&amp; 关闭当前窗口ctrl-b,q,数字 切换panel 会话session12345tmux [new -s 会话名 -n 窗口名] 启动新会话tmux at [-t 会话名] 恢复会话tmux ls 列出所有会话tmux kill-session -t 会话名 关闭会话tmux ls | grep : | cut -d. -f1 | awk &apos;&#123;print substr($1, 0, length($1)-1)&#125;&apos; | xargs kill 关闭所有会话 Tmux为我们默认预备的 &lt;prefix&gt;组合键，是 C-b (即Ctrl+b)开启tmux后使用 &lt;prefix&gt;1234&lt;prefix&gt; :new&lt;回车&gt; 启动新会话&lt;prefix&gt; s 列出所有会话&lt;prefix&gt; $ 重命名当前会话&lt;prefix&gt; d 退出 tmux（tmux 仍在后台运行） 窗口windows12345678&lt;prefix&gt; c 创建新窗口&lt;prefix&gt; w 列出所有窗口&lt;prefix&gt; n 后一个窗口&lt;prefix&gt; p 前一个窗口&lt;prefix&gt; f 查找窗口&lt;prefix&gt; , 重命名当前窗口&lt;prefix&gt; &amp; 关闭当前窗口&lt;prefix&gt; 0-9 切换到指定编号的窗口 窗格panel12345678910111213141516171819202122# 操作&lt;prefix&gt; % 垂直分割&lt;prefix&gt; &quot; 水平分割&lt;prefix&gt; o 交换窗格&lt;prefix&gt; x 关闭窗格&lt;prefix&gt; &lt;space&gt; 切换布局&lt;prefix&gt; q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格&lt;prefix&gt; &#123; 与上一个窗格交换位置&lt;prefix&gt; &#125; 与下一个窗格交换位置&lt;prefix&gt; u 切换窗格最大化&lt;prefix&gt; n 切换窗格最小化# 选择&lt;prefix&gt; 方向键 选择窗格#在配置文件中，set mouse on可以使用鼠标焦点某个窗格# 尺寸调整&lt;prefix&gt; H 当前窗格向左扩大3格&lt;prefix&gt; J 当前窗格向下扩大3格&lt;prefix&gt; K 当前窗格向上扩大3格&lt;prefix&gt; L 当前窗格向右扩大3格#在配置文件中，set mouse on可以使用鼠标拖动来调节尺寸 杂项：1234t 窗口中央显示一个数字时钟? 列出所有快捷键: 命令提示符 参考： https://gist.github.com/ryerh/14b7c24dfd623ef8edc7 https://xiaozhou.net/learn-the-command-line-tmux-2018-04-27.html https://harttle.land/2015/11/06/tmux-startup.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox安装CentOS7]]></title>
    <url>%2Fpost%2F85425272.html</url>
    <content type="text"><![CDATA[主要的安装过程不再详细说明，主要是针对安装后进行的一些配置进行说明 网络设置为桥接，因为本地要和虚拟机进行通信 centos7默认没有安装ifconfig命令，而一开始也是上不了网的，可以使用ip addr命令代替，也可以通过yum provides ifconfig查找对应的安装包，可以知道是net-tools，安装net-tools即可，当然在无法连网时，使用ip addr是为了获得网卡名称 vi /etc/sysconfig/network-scripts/ifcfg-eth0，修改对应文件名的配置文件，改onBoot为yes，重启网络systemctl restart network，这时可以ping或安装ifconfig]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell批量重命名增加文件时间戳前缀]]></title>
    <url>%2Fpost%2Fa989c9fe.html</url>
    <content type="text"><![CDATA[思路： 首先要获得文件的时间戳，ls --full-time和stat -c %y命令都可以 因为是批量，需要获得文件名列表，ls -p | grep [^/]$或find * -type -f 12345678#!bin/bashfiles=$(ls -p | grep [^/]$)for file in $filesdoDATE=$(ls --full-time $file | awk &apos;&#123;print $6&#125;&apos;)mv $file &quot;$DATE-$file&quot;done 依旧没有解决的问题：只能重命名当前目录，如果使用files=$(ls -p $1 | grep [^/]$)，然后传入参数，会报没有这个文件或目录]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo 站内链接和永久链接]]></title>
    <url>%2Fpost%2Fb1775bb9.html</url>
    <content type="text"><![CDATA[站内链接在写博客中，有时会引用站内的链接，之前因为文章不是很多，说明标题可以直接找到，但是现在文章多了，必然需要使用链接 hexo3.0以上可以直接使用下面的格式1&#123;% post_link hello-world %&#125; hello-world是博客的title 永久链接安装插件1npm install hexo-abbrlink --save 站点配置文件里:1234permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 显示的样式为http://localhost:4000/post/f525ac74.html#more 同时为以后方便，新建文章时统一以YYYY-mm-dd的时间格式开头，方便管理，而文章标题删除标题中的时间 参考： https://hexo.io/zh-cn/docs/permalinks.html http://blog.gezhiqiang.com/2016/11/27/hexo-inner-link/ http://www.wuliaole.com/post/permalink_and_internal_link_in_hexo/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo表格]]></title>
    <url>%2Fpost%2F5630467a.html</url>
    <content type="text"><![CDATA[我偶尔会在博客中添加表格，但是hexo原生表格有时会有一些问题 原生表格使用markdown语法123| 表格头 | 表格头 ||-------|-------|| 内容 | 内容 | 使用这种表格能够满足基本的需求，但是这种表格无法实现合并单元格，当然，这种表格是可以使用css的，只是要用F12查询对应的html标签，参考之前写的 html表格使用html表格可以实现合并单元格，可以使用tablesgenerator在线生成表格代码 这样生成的表格还会有一个问题，这个问题我不太清楚是Next主题（5.1.4）的问题，还是hexo的问题，就是在实际展示的时候出现了大量的空白，解决办法是使用html压缩工具去掉表格代码的空格]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 时间戳管理]]></title>
    <url>%2Fpost%2F29c3cf93.html</url>
    <content type="text"><![CDATA[stat 查看时间戳文件：metadata, data查看文件状态：stat 三个时间戳：access time：（文档最后一次）访问时间，简写为atime，读取文件内容modify time: 修改时间, mtime，改变文件内容（数据）change time: 改变时间, ctime，元数据发生改变 123Access - the last time the file was readModify - the last time the file was modified (content has been modified)Change - the last time meta data of the file was changed (e.g. permissions) touch 修改时间戳123456touch [OPTION]... FILE...选项：-a only atime-m only mtime-t STAMP [[CC]YY]MMDDhhmm[.ss]-c 如果文件不存，则不予创建]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令补全和路径补全]]></title>
    <url>%2Fpost%2F3781ba59.html</url>
    <content type="text"><![CDATA[命令补全bash执行命令内部命令外部命令：bash根据PATH环境变量定义的路径，自左而右在每个路径搜寻以给定命令名命名的文件，第一次找到即为要执行的命令 直接补全：Tab，用户给定的字符串只有一条惟一对应的命令以用户给定的字符串为开头对应的命令不惟一，则再次Tab会给出列表 路径补全把用户给出的字符串当做路径开头，并在其指定上级目录下搜索以指定的字符串开头的文件名如果惟一，则直接补全否则，再次Tab，给出列表]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 终端]]></title>
    <url>%2Fpost%2F43bb04d6.html</url>
    <content type="text"><![CDATA[用户与主机交互，必然用到的设备； 物理终端直接连接在主机上的显示器、键盘鼠标统称。在实际机架式服务器部署中，一般是多台服务器共享一套终端，简称KVM（Keyboard键盘，video显示器，mouse鼠标）/dev/console 虚拟终端tty附加在物理终端之上的以软件方式虚拟实现的终端，CentOS 6默认启动6个虚拟终端Ctrl+Alt+F#: [1,6]图形终端：附加在物理终端之上的以软件方式虚拟实现的终端，但额外会提供桌面环境；tty是teletypewriter的简称设备文件路径：/dev/tty# 模拟终端ptysh协议或telnet协议等远程打开的命令行界面，是运维工程师用的最多的一种连接服务器的方式。pts(pseudo-terminal slave)是pty的实现方法。设备文件：/dev/pts/# [0,oo) 查看当前的终端设备：tty 交互式接口启动终端后，在终端设备附加一个交互式应用程序 GUIX protocol, window manager, desktop Desktop: GNOME (C, gtk) KDE (C++, qt) XFCE (轻量级桌面) CLIshell程序： sh (bourn) csh tcsh ksh (korn) bash (bourn again shell), GPL zsh 显示当前使用的shell：echo ${SHELL} 显示当前系统使用的所有shell：cat /etc/shells]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux时间命令]]></title>
    <url>%2Fpost%2F4aed7274.html</url>
    <content type="text"><![CDATA[date 显示或设置日期12345678910111213date [OPTION]... [+FORMAT]# 显示日期FORMAT: 格式符号，类似%D、%F、%T，参考mandate [MMDDhhmm[[CC]YY][.ss]]# 设置日期MM 月份DD 几号hh 小时mm 分钟YY 两位年份CCYY 四位年份.ss 秒钟 Linux的两种时钟系统时钟(system time)：由Linux内核通过CPU的工作频率进行的计时，date命令硬件时钟(hardware clock)：clock命令 hwclock: 显示硬件时钟 -s, –hctosys Set the System Time from Hardware Clock 读取硬件时间到系统时间 -w, –systohc Set Hardware Clock to the current System Time 系统时间写入硬件时间 cal 日历12345cal# 显示当前月份cal [options] [[[day] month] year] # 显示指定时间的日历]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell echo命令]]></title>
    <url>%2Fpost%2Fa6281d67.html</url>
    <content type="text"><![CDATA[echo 回显命令123456789101112131415161718192021echo [选项] [输出内容]选项： -e：允许使用转义符-n: 禁止自动添加换行符号内容转义\a - 输出警告音\b - 退格符\n - 换行符\r - 回车键\t - 制表符，也就是tab键\v - 垂直制表符\0nnn - 按照八进制ASCII码输出字符\xhh - 按照十六进制ASCII表输出字符输出带颜色的内容 echo -e &quot;\e[1;31m文字\e[0m&quot;#输出颜色 \e[1;##m - 开启颜色显示； \e[0m - 关闭颜色显示#30m=黑色，31m=红色，32m=绿色，33m=黄色#34m=蓝色，35m=洋红，36m=青色，37m=白色 12echo &quot;$VAR_NAME&quot;: 变量会替换，双引号表弱引用echo &apos;$VAR_NAME&apos;: 变量不会替换，强引用 参考：Shell引号]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell引号]]></title>
    <url>%2Fpost%2Fca5ad791.html</url>
    <content type="text"><![CDATA[双引号””单词分割、路径名展开、波浪线展开和花括号展开都被禁止，参数展开、算术展开、命令替换仍然执行 在双引号中左右的特殊符号都没有特殊含义，但是“$”,”`”,”\”是例外。拥有“调用变量的值”，“引用命令”和“转义符”的特殊含义 使用双引号可以处理包含空格的文件名 12echo $(cal) #输出以空格分为不同的参数echo &quot;$(cal)&quot; #只有一个参数 单引号’’禁止所有展开在单引号中左右的特殊符号，如$、`(反引号)都没有特殊含义]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell展开]]></title>
    <url>%2Fpost%2F7e1cd31f.html</url>
    <content type="text"><![CDATA[输入的字符在shell起作用前会展开成为别的字符 路径展开 波浪号展开 算术表达式展开 花括号展开 参数展开 命令替换 单词分割 ##路径展开12345ls echo * #不显示隐藏文件echo D*echo *secho /usr/*/bin ##波浪号展开~会展开成为家目录1ls ~ ##算术表达式展开通过这种方式进行算术运算12echo $((2+2))echo $(($a+$b)) ##花括号展开可以从一个花括号的模式中创建多个字符串1234567echo front-&#123;a,b,1&#125;-endfront-a-end front-b-end front-1-endecho Number_&#123;1..5&#125;echo &#123;Z..A&#125;echo &#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;mkdir &#123;2007..2009&#125;-0&#123;1,9&#125; &#123;2007..2009&#125;-&#123;10..12&#125; ##参数展开即shell变量，多用于shell脚本 ##命令替换 把一个命令的输出作为作为一个展开1234echo $(ls)files=$(ls)echo `ls` 单词分割在默认情况下，单词分割机制会在单词中寻找空格、制表符和换行符，并把它们看作单词之间的界定符，它们只作为分隔符使用。所以不要用包含空格的名字命名文件unless you really know what you do 补充：https://www.jianshu.com/p/403f3554e2c1]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM插件NerdTree快捷键]]></title>
    <url>%2Fpost%2F2101d586.html</url>
    <content type="text"><![CDATA[打开当前目录1:NERDTreeFind 切换工作台和目录1234ctrl + w + h 光标 focus 左侧树形目录ctrl + w + l 光标 focus 右侧文件显示窗口ctrl + w + w 光标自动在左右侧窗口切换ctrl + w + r 移动当前窗口的布局位置 1234567891011121314151617181920212223242526272829303132333435363738394041o 在已有窗口中打开文件、目录或书签，并跳到该窗口go 在已有窗口 中打开文件、目录或书签，但不跳到该窗口t 在新 Tab 中打开选中文件/书签，并跳到新 TabT 在新 Tab 中打开选中文件/书签，但不跳到新 Tabi split 一个新窗口打开选中文件，并跳到该窗口gi split 一个新窗口打开选中文件，但不跳到该窗口s vsplit 一个新窗口打开选中文件，并跳到该窗口gs vsplit 一个新 窗口打开选中文件，但不跳到该窗口! 执行当前文件O 递归打开选中 结点下的所有目录x 合拢选中结点的父目录X 递归 合拢选中结点下的所有目录e Edit the current dif双击 相当于 NERDTree-o中键 对文件相当于 NERDTree-i，对目录相当于 NERDTree-eD 删除当前书签P 跳到根结点p 跳到父结点K 跳到当前目录下同级的第一个结点J 跳到当前目录下同级的最后一个结点k 跳到当前目录下同级的前一个结点j 跳到当前目录下同级的后一个结点C 将选中目录或选中文件的父目录设为根结点u 将当前根结点的父目录设为根目录，并变成合拢原根结点U 将当前根结点的父目录设为根目录，但保持展开原根结点r 递归刷新选中目录R 递归刷新根结点m 显示文件系统菜单cd 将 CWD 设为选中目录I 切换是否显示隐藏文件f 切换是否使用文件过滤器F 切换是否显示文件B 切换是否显示书签q 关闭 NerdTree 窗口? 切换是否显示 Quick Help 切换标签页123456789101112131415:tabnew [++opt选项] ［＋cmd］ 文件 建立对指定文件新的tab:tabc 关闭当前的 tab:tabo 关闭所有其他的 tab:tabs 查看所有打开的 tab:tabp 前一个 tab:tabn 后一个 tab标准模式下：gT 前一个 tabgt 后一个 tabMacVim 还可以借助快捷键来完成 tab 的关闭、切换cmd+w 关闭当前的 tabcmd+&#123; 前一个 tabcmd+&#125; 后一个 tab NerdTree在.vimrc中的常用配置1234567891011&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）autocmd VimEnter * NERDTree&quot; 按下 F2 调出/隐藏 NERDTreemap :silent! NERDTreeToggle&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）let NERDTreeWinPos=&quot;right&quot;&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarkslet NERDTreeShowBookmarks=1 转自：http://yang3wei.github.io/blog/2013/01/29/nerdtree-kuai-jie-jian-ji-lu/]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM配置]]></title>
    <url>%2Fpost%2F6f99625c.html</url>
    <content type="text"><![CDATA[位置打开VIM，输入:version123456789系统 vimrc 文件: &quot;$VIM/vimrc&quot;用户 vimrc 文件: &quot;$HOME/.vimrc&quot;第二用户 vimrc 文件: &quot;~/.vim/vimrc&quot;用户 exrc 文件: &quot;$HOME/.exrc&quot;系统 gvimrc 文件: &quot;$VIM/gvimrc&quot;用户 gvimrc 文件: &quot;$HOME/.gvimrc&quot; 第二用户 gvimrc 文件: &quot;~/.vim/gvimrc&quot;系统菜单文件: &quot;$VIMRUNTIME/menu.vim&quot;$VIM 预设值: &quot;/usr/share/vim&quot; 列出了几个 vimrc 文件，有一个系统的 vimrc 文件，还有用户的 vimrc 文件，以及系统和用户 gvimrc 文件。出于和vi兼容的目的，vim也支持vi的exrc配置文件。 一般来说，我们都使用用户目录下的$HOME/.vimrc文件即可123set numberset ruler&quot;这是注释 https://blog.easwy.com/archives/advanced-vim-skills-catalog/]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM配置及插件]]></title>
    <url>%2Fpost%2F6f99625c.html</url>
    <content type="text"><![CDATA[配置文件的位置打开VIM，输入:version123456789系统 vimrc 文件: &quot;$VIM/vimrc&quot;用户 vimrc 文件: &quot;$HOME/.vimrc&quot;第二用户 vimrc 文件: &quot;~/.vim/vimrc&quot;用户 exrc 文件: &quot;$HOME/.exrc&quot;系统 gvimrc 文件: &quot;$VIM/gvimrc&quot;用户 gvimrc 文件: &quot;$HOME/.gvimrc&quot; 第二用户 gvimrc 文件: &quot;~/.vim/gvimrc&quot;系统菜单文件: &quot;$VIMRUNTIME/menu.vim&quot;$VIM 预设值: &quot;/usr/share/vim&quot; 列出了几个 vimrc 文件，系统的 vimrc 文件(/etc/vim/vimrc)，还有用户的 vimrc 文件，以及系统和用户 gvimrc 文件。出于和vi兼容的目的，vim也支持vi的exrc配置文件。 一般来说，我们使用用户目录下的$HOME/.vimrc文件即可，家目录下的配置文件优先级更高 插件的安装因为自己使用的是ElementaryOS，需要使用tweaks关闭使用Ctrl-v作为复制的快捷键 使用插件管理 vim-plug 安装vim-plug12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 其他插件的安装需要先在配置文件中配置好，然后重新用vim打开.vimrc，输入:PlugInstall安装插件 vim-plug的一些命令123456:PlugInstall #安装插件:PlugUpdate #升级插件:PlugClean #删除未被使用的插件目录:PlugUpgrade #升级Vim-plug自身:PlugStatus #查看插件状态:q 退出 配置文件主要是使用插件管理安装插件，需要放在call plug#begin(&#39;~/.vim/plugged&#39;)和call plug#end()之间 1234567891011121314151617181920212223242526272829303132333435363738394041&quot;这是注释&quot;插件&quot;vim-plugcall plug#begin(&apos;~/.vim/plugged&apos;) let mapleader=&quot;,&quot;&quot;目录树&quot;F3打开目录Plug &apos;scrooloose/nerdtree&apos;Plug &apos;junegunn/fzf&apos;, &#123; &apos;dir&apos;: &apos;~/.fzf&apos;, &apos;do&apos;: &apos;./install --all&apos; &#125;Plug &apos;junegunn/fzf.vim&apos;nnoremap &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif&quot;markdown 语法高亮、预览&quot;:PrevimOpen在浏览器预览&quot;关闭折叠let g:vim_markdown_folding_disabled = 1Plug &apos;godlygeek/tabular&apos;Plug &apos;plasticboy/vim-markdown&apos;Plug &apos;kannokanno/previm&apos;Plug &apos;tyru/open-browser.vim&apos;&quot;模版Plug &apos;aperezdc/vim-template&apos;&quot;Plug &apos;ctrlpvim/ctrlp.vim&apos;&quot;文件搜索，f2搜索nnoremap &lt;F2&gt; :Files&lt;CR&gt;Plug &apos;Yggdroot/LeaderF&apos;, &#123; &apos;do&apos;: &apos;./install.sh&apos; &#125;call plug#end() &quot;插件结束&quot;添加vim-plug配置，以call plug#begin()开头，call plug#end()结尾，中间是插件列表，begin可以接受参数指定存放插件的位置set numberset ruler&quot;文件自动检测外部更改set autoread 补充：http://www.vimer.cn/archives/1372.html 参考： https://blog.csdn.net/rankun1/article/details/78775404 https://www.jianshu.com/p/f4fb7877829f http://www.zhaiqianfeng.com/2017/02/install-vim-plugins.html https://github.com/gabrielelana/vim-markdown https://bovink.com/2016/07/01/use-vim-to-write-markdown/ https://github.com/Yggdroot/LeaderF https://blog.easwy.com/archives/advanced-vim-skills-catalog/]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh安装、主题、插件]]></title>
    <url>%2Fpost%2F8ec9a3b8.html</url>
    <content type="text"><![CDATA[zsh和bash兼容，fish和bash不兼容 安装12345678910111213#安装zshyum -y install zsh#切换默认shell为zshchsh -s /bin/zsh#切换回去bashchsh -s /bin/bash#确认zsh是否是默认SHELLecho $SHELL#重启服务器让修改的配置生效 #安装on my zshcurl1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; wget1sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 修改oh my zsh 主题12345678#查看oh my zsh主题ls ~/.oh-my-zsh/themes#修改主题vim ~/.zshrc#ZSH_THEME=&quot;robbyrussell&quot; #默认的主题ZSH_THEME=&quot;avit&quot; #修改为avit oh my zsh插件修改~/.zshrc中plugins1plugins=(git z extract colored-man-pages) git：各种别名，ga\gp\gs\gcextract：功能强大的解压插件，所有类型的文件解压一个命令x全搞定z：强大的目录自动跳转命令，会记忆你曾经进入过的目录，用模糊匹配快速进入你想要的目录。 https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview 其他卸载on my zsh1uninstall_oh_my_zsh zsh http://ohmyz.sh/https://github.com/robbyrussell/oh-my-zsh/wiki/Themeshttps://blog.csdn.net/gatieme/article/details/52741221https://www.jianshu.com/p/556ff130fc65]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim使用系统剪贴板]]></title>
    <url>%2Fpost%2F333f9b1a.html</url>
    <content type="text"><![CDATA[查看vim版本是否支持clipboard123vim --version | grep &quot;clipboard&quot;-clipboard +insert_expand +path_extra +user_commands -clipboard 显示 - 号，说明不支持，需要安装vim-gnome123sudo apt install vim-gnome#再次查看，可以看到clipboard前面是+号vim --version | grep &quot;clipboard&quot; 复制、粘贴Vim 中的复制、删除的内容都会被存放到默认（未命名）寄存器中，之后可以通过粘贴操作读取默认寄存器中的内容。寄存器是完成这一过程的中转站，Vim 支持的寄存器非常多，其中常用的有 a-zA-Z0-9+“。其中： 0-9：表示数字寄存器，是 Vim 用来保存最近复制、删除等操作的内容，其中 0 号寄存器保存的是最近一次的操作内容。 a-zA-Z：表示用户寄存器，Vim 不会读写这部分寄存器 &quot;（单个双引号）：未命名的寄存器，是 Vim 的默认寄存器，例如删除、复制等操作的内容都会被保存到这里。 +：剪切板寄存器，关联系统剪切板，保存在这个寄存器中的内容可以被系统其他程序访问，也可以通过这个寄存器访问其他程序保存到剪切板中的内容。 12#查看所有寄存器中的内容，也可以只查看指定寄存器的内容（将寄存器名称作为参数）:reg [register_name] 1234&quot;+yy #复制当前行到剪切板&quot;+p #将剪切板内容粘贴到光标后面&quot;ayy #复制当前行到寄存器 a&quot;ap #将寄存器 a 中的内容粘贴到光标后面 参考： https://blog.csdn.net/zhangxiao93/article/details/53677764 https://www.zhihu.com/question/19863631/answer/89354508]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM插件]]></title>
    <url>%2Fpost%2F9b750e68.html</url>
    <content type="text"><![CDATA[Elementary os的终端好像不能用vim的块操作同时插件NerdTree也有问题，所以改用hyperhttps://hyper.is/https://github.com/zeit/hyper 插件管理 vim-plughttps://github.com/junegunn/vim-plug 安装12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 插件管理1vim ~/.vimrc 123456789101112131415161718192021222324252627set numbercall plug#begin(&apos;~/.vim/plugged&apos;)let mapleader=&quot;,&quot;&quot;目录树&quot;F3打开目录&quot;o打开文件Plug &apos;godlygeek/tabular&apos;nnoremap &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif&quot;markdown 语法高亮、预览&quot;:PrevimOpen在浏览器预览&quot;关闭折叠let g:vim_markdown_folding_disabled = 1Plug &apos;godlygeek/tabular&apos;Plug &apos;plasticboy/vim-markdown&apos;Plug &apos;kannokanno/previm&apos;Plug &apos;tyru/open-browser.vim&apos;&quot;文件搜索&quot;&lt;leader&gt;f搜索,因为这里设置leader为,号，所以是,+fPlug &apos;Yggdroot/LeaderF&apos;, &#123; &apos;do&apos;: &apos;./install.sh&apos; &#125;call plug#end()&quot;添加vim-plug配置，以call plug#begin()开头，call plug#end()结尾，中间是插件列表，begin可以接受参数指定存放插件的位置 12345678910#重新打开.vimrcvim ~/.vimrc:PlugInstall #安装插件:PlugUpdate #升级插件:PlugClean #删除未被使用的插件目录:PlugUpgrade #升级Vim-plug自身:PlugStatus #查看插件状态:q 退出 补充：http://www.vimer.cn/archives/1372.html 参考： https://blog.csdn.net/rankun1/article/details/78775404 https://www.jianshu.com/p/f4fb7877829f http://www.zhaiqianfeng.com/2017/02/install-vim-plugins.html https://github.com/gabrielelana/vim-markdown https://bovink.com/2016/07/01/use-vim-to-write-markdown/ https://github.com/Yggdroot/LeaderF]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下载命令]]></title>
    <url>%2Fpost%2Fc4eab17c.html</url>
    <content type="text"><![CDATA[发现自己安装了以下的大部分工具。。。 wget12345678910wget url/ftp-b：后台下载-c：断点续传-O 文件名：指定文件名#使用匿名用户下载wget ftp-url#ftp下载，指定用户名和密码wget --ftp-user=&lt;user_name&gt; --ftp-password=&lt;Give_password&gt; Download-url-address curl123curl [选项] url-o：指定文件名-O：使用原文件名 axelwget的出色替代者，是一款轻量级下载实用工具。它实际上是个加速器，因为它打开了多路http连接，可下载独立文件片段，因而文件下载起来更快速。 12apt install axelaxel url aria212apt install aria2 aria2c url 视频下载工具Youtube-dlhttps://github.com/rg3/youtube-dl1234567891011121314151617pip install youtube-dlyoutube-dl url-i：忽略错误youtube-dl -F [url] #查看可下载的视频格式youtube-dl -f [format code] [url] #指定下载视频的格式youtubd-dl --write-sub [url] #下载字幕#下载视频列表，以下三种方式下载的视频可能是mkv格式或者webm格式youtube-dl [playlist_url] youtube-dl -cit [playlist_url]youtube-dl --yes-playlist [url]#下载视频列表，指定下载格式youtube-dl -f [format code] [palylist_url] anniehttps://github.com/iawia002/annie12annie-master -p url#下载列表 Torrent下载工具12sudo apt install transmissionsudo apt-get install deluge 参考： wget:http://www.cnblogs.com/peida/archive/2013/03/18/2965369.html https://linux.cn/article-7369-1.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】Hexo注释]]></title>
    <url>%2Fpost%2F276480f9.html</url>
    <content type="text"><![CDATA[html 格式的注释 这样写的注释会出现在编译后的 Html 文件中，但不会被浏览器显示出来。 1&lt;!--这些是注释文本，不会显示--&gt; 编译后的 Html 文档中有这行文本，但浏览器不会显示它。这与分号开头的注释行不同，Html 方式注释的文字仍然会出现在编译后的 Html 文件中，只是不显示而已。 参考： https://www.w3cschool.cn/lme/q92a1srq.html]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM常用按键]]></title>
    <url>%2Fpost%2Fe15257f3.html</url>
    <content type="text"><![CDATA[最近看了黑马的Python基础教程，里面有讲vim，讲得很仔细，索性再按照讲的笔记再整理一下之前写的 在终端输入vimtutor命令可以打开vim的教程，输入:q退出 vi和ivm在很多Linux发行版中，直接把vi做成vim的软连接 1234567891011# 查找 vi 的运行文件which vils -l /usr/bin/vils -l /etc/alternatives/vils -l /usr/bin/vim.basic# 查找 vim 的运行文件which vimls -l /usr/bin/vimls -l /etc/alternatives/vimls -l /usr/bin/vim.basic vivi 是Visual interface的简称，是Linux中最经典的文本编辑器vi 的核心设计思想————让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作 vi 的特点： 没有图形界面的、功能强大的编辑器 只能是编辑文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 vimvim = vi improvedvim 是从 vi 发展出来的一个文本编辑器，支持代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，被称为编辑器之神（Emacs是神的编辑器） 12yum install vimapt install vim 打开和新建文件在终端中输入vim在后面跟上文件名即可1vim 文件名 如果文件已经存在，会直接打开该文件 如果文件不存在，会新建一个文件 打开文件并且定位行在日常工作中，有可能会遇到“打开一个文件，并定位到指定行”的情况，例如：在开发时，知道某一行代码有错误，可以快速定位到出错代码的位置，这个时候可以使用以下命令打开文件1vim 文件名 +行数 提示：如果只带上+而不指定行号，会直接定位到文件末尾 异常处理如果vim异常退出，在磁盘上可能会保存有交换文件，下次再使用vim编辑该文件时，会看到以下屏幕信息，按下字母d可以删除交换文件即可提示：按下键盘时，注意关闭输入法 工作模式这里将在屏幕末行输入命令这种情况单独拿出来叫做末行模式，是为了后面比较容易讲解 vi 有以下基本工作模式： 命令模式 打开文件首先进入命令模式，是使用vim的入口 通过命令对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 在其他图形编辑器下，通过快捷键或者鼠标实现的操作，都在命令模式下实现 末行模式 —— 执行 保存、退出 等操作 要退出vim返回到控制台，需要在末行模式下输入命令 末行模式是vim 的出口 编辑模式 —— 正常的编辑文字 使用ESC键从其他模式切换到命令模式，可以使用CTRL+[替代 末行模式命令末行命令主要是针对文件进行操作的：保存、退出、保存&amp;退出、搜索&amp;替换、另存、新建、浏览文件 命令 英文 功能 :w write 保存 :w filename 保存对文件的更改 :q quit 退出，如果没有保存，不允许退出 :q! quit 强行退出，不保存退出 :wq write &amp; quit 保存并退出 :x 保存并退出 文件相关命令 命令 英文 功能 :e 文件名 edit 打开一个新文件 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 提示： 切换文件之前，必须保证当前这个文件已经被保存！ 在实际开发中，可以使用 w 命令 阶段性的备份代码 分屏命令使用分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp [文件名] or :split split 水平分割当前窗口 :vsp [文件名] or :vsplit vertical split 垂直分割当前窗口 :split file 在第二个窗口中打开该文件 切换分屏窗口分屏窗口都是基于CTRL+W这个快捷键的，w对应的英文单词是window 命令 英文 功能 w window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi o other 关闭其他窗口 n 拆分窗口并开始编辑新文件 方向键 在方向键方向的窗口之间切换 调整窗口大小分屏窗口都是基于CTRL+W这个快捷键的，w对应的英文单词是window 命令 英文 功能 + 增加窗口高度 - 减少窗口高度 &gt; 增加窗口宽度 &lt; 减少窗口宽度 = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 常用命令使用vim命令时，注意关闭中文输入法vim的命令较多，不要期望一下子全部记住，个别命令忘记了只是会影响编辑速度而已 移动vim之所以快，关键在于能够快速定位到要编辑的代码行，移动命令能够和编辑操作命令组合使用 在命令模式下样快速移动光标 上、下、左、右 命令 功能 h or ← 移动左侧的一个字符 j or ↓ 向下移动一行 k or ↑ 向上移动一行 l or → 向右移动一字符 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首，第一个不是空白字符的位置 $ 行尾 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 nk 向上移动n行（向上移动9行-&gt;9k） 5G 移动到第五行 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 段落移动vim 中使用空行来区分段落在程序开发时，通常一段功能相关的代码会写在一起————之间没有空行 命令 功能 { 上一段 } 下一段 括号切换在程序世界中，()、[]、{} 使用频率很高，而且都是成对出现的 命令 功能 % 括号匹配及切换 标记在开发时，某一块代码可能需要稍后处理，例如：编辑、查看此时先使用m增加一个标记，这样可以在需要时快速地跳转回来或者执行其他编辑操作标记名称可以是a~z或者A~Z之间的任意一个字母添加了标记的行如果被删除，标记同时被删除如果在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母 ‘x 直接定位到标记 x 所在位置 选中文本（可视模式）学习复制命令前，应该先学会怎么样选中要复制的代码在vim中要选择文本，需要先使用Visual命令切换到可视模式vim 中提供了三种可视模式，可以方便程序员选择选中文本的方式按ESC可以放弃选中，返回到命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可视块模式 垂直方向选中文本 可视模式下，可以和移动命令连用，例如：ggVG能够选中所有内容 编辑操作删除、复制、粘贴、替换、缩排 删除文本(剪切) 命令 英文 功能 x cut 删除光标所在字符，或者选中文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 dw 删除单词 如果使用可视模式已经选中了一段文本，那么无论使用d还是x，都可以删除选中文本 删除命令可以和移动命令连用，以下是常见的组合命令123456dw # 从光标位置删除到单词末尾d0 # 从光标位置删除到一行的起始位置d&#125; # 从光标位置删除到段落结尾ndd # 从光标位置向下连续删除 n 行d代码行号G # 从光标所在行删除到指定代码行之间的所有代码d&apos;a # 从光标所在行删除到标记 a 之间的所有代码 撤销和恢复撤销redo和undo相反 命令 英文 功能 u undo 撤销上次命令 U 撤销对该行进行的所有最新更改 CTRL + r redo 恢复撤销的命令 复制、粘贴vim中提供有一个被复制文本的缓冲区复制 命令会将选中的文字保存在缓冲区删除(剪切) 命令删除的文字会被保存在缓冲区在需要的位置，使用粘贴命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y(移动命令) copy 复制 yy or Y copy 复制当前行，可以 nyy 复制多行 p paste 粘贴 P 在光标位置之前粘贴文本，将行放在当前行的上方 提示 命令d、x类似于图形界面的 剪切操作————CTRL+X 命令y类似于图形界面的 复制操作————CTRL+C 命令p类似于图形界面的 粘贴操作————CTRL+V vim 中的文本缓冲区同样只有一个，如果后续做过复制、剪切 操作，之前缓冲区中的内容会被替换 注意 vim 中的文本缓冲区和系统的剪贴板不是同一个 所以在其他软件中使用CTRL+C复制的内容，不能在vim中通过P命令粘贴 可以在编辑模式下使用鼠标右键粘贴 如果要使用系统剪贴板参考这里 替换替换命令的作用就是不用进入编辑模式，对文件进行轻量级的修改 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R命令可以进入替换模式，替换完成后，按下ESC可以回到命令模式 缩排和重复执行在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令重复执行指定次数 命令 功能 &gt;&gt; 向右增加缩进 &lt;&lt; 向左减少缩进 . 重复上次命令 缩排命令在开发程序时，统一增加代码的缩进比较有用！一次性在选中代码前增加 4 个空格，就叫做增加缩进一次性在选中代码前删除 4 个空格，就叫做减少缩进在可视模式下，缩排命令只需要使用 一个&gt;或者&lt; 在程序中，缩进通常用来表示代码的归属关系 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 查找常规查找 命令 功能 /str 查找 str ?str 向上查找 str \vstr str中的非字母数字字符被视为正则表达式特殊字符（不需转义字符） 查找到指定内容之后，使用Next查找下一个出现的位置： N: 查找上一个 n: 查找下一个如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 查找并替换在vim中查找和替换命令需要在末行模式下执行 基本命令格式：1:%s///g 全局替换一次性替换文件中的所有出现的旧文本，命令格式如下：1:%s/旧文本/新文本/g 可视区域替换先选中要替换文字的范围，命令格式如下：1:s/旧文本/新文本/g 确认替换如果把末尾的g改成gc在替换的时候，会有提示！推荐使用！123456789:%s/旧文本/新文本/gcy yes 替换n no 不替换a all 替换所有q quit 退出替换l last 最后一个，并把光标移动到行首^E 向下滚屏^Y 向上滚屏 插入命令在vim中除了常用的i进入编辑模式外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 i insert 在当前字符前插入文本 I insert 在行首插入文本 a append 在当前字符后添加文本 A append 在行末添加文本 o 在当前行后面插入一空行 O 在当前行前面插入一空行 参考 https://www.cheatography.com/zoltan/cheat-sheets/basic-vim/ https://vim.rtorr.com/lang/zh_cn/ http://michael.peopleofhonoronly.com/vim/]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 case、for、while、until]]></title>
    <url>%2Fpost%2F2d466a59.html</url>
    <content type="text"><![CDATA[多分支语句case1234567891011case $变量名 in &quot;值1&quot;) 如果变量值等于值1，执行程序1 ;; &quot;值2&quot;) 如果变量值等于值2，执行程序2 ;; *） 如果变量值都不是以上值，则执行此程序 ;;esac 与if多分支最大区别是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系 12345678910111213#!/bin/bash name=&apos;basename $0 .sh&apos; case $1 in s|start) echo &quot;start...&quot; ;; stop) echo &quot;stop ...&quot; ;; reload)echo &quot;reload...&quot; ;; *)echo &quot;Usage: $name [start|stop|reload]&quot; exit 1 ;;esac | 分割多个模式，相当于 or for123456789for 变量 in 值1 值2 值3... do 程序 donefor ((初始值;循环控制条件;变量变化)) do 程序 done in后面跟多少值，for循环就循环多少次，每次循环依次把值赋给变量，直到后面的值全都运行一遍。可以将要操作的数据内容放在一个文件中，利用 for i in $(cat 文件名)来避免手动输入。也可以将内容赋给变量，利用for i in $val 来避免手动输入。 123456789#!/bin/bash#从1加到100s=0for ((i=1;i&lt;=100;i=i+1)) do s=$(($s+$i)) done#没有i++ while循环1234while [ 条件判断式 ] do 程序 done 实例：从1加到10012345678910#!/bin/bashsum=0i=1while [ $i -le 100 ] do sum=$(( $sum+$i )) i=$(( $i+1 )) doneecho &quot;sum is : $sum&quot; http://wiki.jikexueyuan.com/project/shell-learning/case-statements.html]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 双分支if语句]]></title>
    <url>%2Fpost%2F14e12b20.html</url>
    <content type="text"><![CDATA[123456if [ 条件判断式 ] then 条件成立时执行的程序 else 条件不成立时，执行的另一个程序fi 实例：判断输入的路径是不是一个目录123456789#!/bin/bashread -t 30 -p &quot;Input a dir:&quot; dirif [ -d &quot;$dir&quot; ]then echo &quot;Yes,yes yes&quot;else echo &quot;No,no,no&quot;fi 实例：判断apache服务是否启动12345678910111213141516#!/bin/bashtest=$(ps aux |grep httpd |grep -v grep)#定义变量test 并且查找是否启动apache的结果赋值给test#ps aux 查看当前所有正在运行的进程 #grep httpd 过滤出apache进程#grep -v grep 排除自身进程if [ -n &quot;$test&quot; ]then cho &quot; $(date) httpd is ok &quot; &gt;&gt; /tmp/autostart-acc.logelse systemctl start httpd.service &amp;&gt;/dev/null #centos7 echo &quot; $(date) httpd is no \n httpd is autostart now&quot; &gt;&gt; /tmp/autostart-err.logfi]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 多分支if语句]]></title>
    <url>%2Fpost%2F3f9d305d.html</url>
    <content type="text"><![CDATA[123456789if [ 条件判断式1 ]then 当条件判断式1成立时，执行程序1elif [ 条件判断式2 ]then 当条件判断式2成立时，执行程序2else 当所有条件都不成立时，最后执行此程序fi]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 单分支if语句]]></title>
    <url>%2Fpost%2Fa1518663.html</url>
    <content type="text"><![CDATA[12345678if [ 条件判断式 ];then 程序fiif [ 条件判断式 ] then 程序fi 注： if语句使用fi结尾，和一般语言使用大括号结尾不同 [ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格 then后面跟符合条件之后执行的程序，可以放在[]之后，用;分割，也可以换行写入，就不需要;了 实例：判断当前登录用户是不是root1234567#!/bin/bashtestuser=$(env | grep &quot;USER&quot; | cut -d &quot;=&quot; -f 2)#env是linux的一个外部命令，可以显示当前用户的环境变量，其中一行显示当前用户if [ &quot;$testuser&quot; == &quot;root&quot; ]then echo &quot;Current user is root.&quot;fi 实例：判断分区使用率12345678#!/bin/bash#统计根分区使用率#/dev/sda3是df判断的test=$(df -h | grep &quot;/dev/sda3&quot; | awk &apos;&#123;print $5&#125;&apos; | cut -d &quot;%&quot; -f 1)if [ &quot;$test&quot; -ge 90 ]then echo &quot;/ is full&quot;fi]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 条件判断式]]></title>
    <url>%2Fpost%2F7f7d2ed7.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 80%; } 引用变量要加”” 按文件类型判断 测试选项 作用 -b 判断该文件是否存在，并且是否为块设备文件（是为真） -c 判断该文件是否存在，并且是否为字符设备文件（是为真） -d 判断该文件是否存在，并且是否为目录文件（是为真） -e 判断该文件是否存在（存在为真） -f 判断该文件是否存在，并且是否为普通文件（是为真） -L 判断该文件是否存在，并且是否为符号链接文件（是为真） -p 判断该文件是否存在，并且是否为管道文件（是为真） -s 判断该文件是否存在，并且是否为非空（非空为真） -S 判断该文件是否存在，并且是否为套接字文件（是为真） 两种判断格式12[-e /root/install.log] #常用test -e /root/install.log [-e /root/install.log] &amp;&amp; echo yes || echo no第一个判断命令如果正确执行，则打印yes，否则打印no&amp;&amp; 和 || 不可以调换位置 按文件权限判断 测试选项 作用 -r 判断该文件是否存在，并且是否该文件拥有读权限（有为真） -w 判断该文件是否存在，并且是否该文件拥有写权限（有为真） -x 判断该文件是否存在，并且是否该文件拥有执行权限（有为真） -u 判断该文件是否存在，并且是否该文件拥有SUID权限（有为真） -g 判断该文件是否存在，并且是否该文件拥有SGID权限（有为真） -k 判断该文件是否存在，并且是否该文件拥有SBit权限（有为真） 两个文件之间的比较 测试选项 作用 file1 -nt file2 判断文件1的修改时间是否比文件2的新(如果新则为真) file1 -ot file2 判断文件1的修改时间是否比文件2的旧(如果旧则为真) file1 -ef file2 判断文件1是否比文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的办法 两个整数之间的比较 测试选项 作用 num1 -eq num2 判断整数1是否和整数2相等(相等为真) num1 -ne num2 判断整数1是否和整数2不相等(不相等为真) num1 -gt num2 判断整数1是否大于整数2(大于为真) num1 -lt num2 判断整数1是否小于整数2(小于为真) num1 -ge num2 判断整数1是否大于或等于整数2(大于等于为真) num1 -le num2 判断整数1是否小于或等于整数2(小于等于为真) 字符串的判断 测试选项 作用 -z 字符串 判断字符串是否为空，为空返回真 -n 字符串 判断字符串是否为非空，非空返回真 字符串1 == 字符串2 判断两字符串是否相等，相等返回真，==左右加空格 字符串1 != 字符串2 判断两字符串是否不相等，不相等返回真，!=左右加空格 多重条件判断 测试选项 作用 判断1 -a 判断2 #逻辑与，判断1和判断2都成立，结果为真 判断1 -o 判断2 #逻辑或，判断1和判断2有一个成立，结果就为真 !判断 #逻辑非，判断结果取反 1[-n &quot;$a&quot; -a &quot;$a&quot; -gt 23]]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux DNS搭建 Bind服务]]></title>
    <url>%2Fpost%2F41272a58.html</url>
    <content type="text"><![CDATA[Centos123yum install bind bind-utils#centos默认的安装是没有host，dig，nsloopup等命令的，需要安装bind-utils Ubuntu1sudo apt-get install bind9 https://www.phpini.com/linux/fix-nslookup-dig-host-command-not-found]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerPoint 2016拆分汉字、制作笔画]]></title>
    <url>%2Fpost%2F218fd1f1.html</url>
    <content type="text"><![CDATA[需要工具word、powerpoint 打开word，输入汉字，设置字体为楷体GB2312/仿宋（这两种字体的笔画是分离的，WindowsXP中默认有这两种字体，但Windows 7开始系统默认没有这两种字体） 保存为doc格式 选中文字，【右击】，在快捷菜单中打开【字体】对话框，选择【空心】格式 复制“空心”汉字。打开PowerPoint中，【开始】选项卡–【选择性粘贴】，选择【图片（Windows元文件）】，取消组合两次。汉字笔画就分解出来了。删除不需要的对象（一般有1-2个空白形状） http://www.360doc.com/content/16/0107/08/982782_526070895.shtml]]></content>
      <tags>
        <tag>PPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 工具]]></title>
    <url>%2Fpost%2F82347a2b.html</url>
    <content type="text"><![CDATA[VifmVifm 是一个 Linux 控制台下的文件管理器，基于 ncurse 的两列面板界面1234#安装sudo apt install vifm#运行vifm 使用空格键从一个窗格移动到另一个窗格。要打开目录或文件，只需按Enter按钮。水平分割窗口按Ctrl-W然后s垂直分割窗口按Ctrl-W然后v一个窗格中的文件，另一个窗格中查看:view删除文件：dd 如果您在Vifm中删除文件，则会将其存储在垃圾箱中。 要查看垃圾邮件目录，请键入此命令。:trashes要查看垃圾桶中的文件，请运行lstrash命令（按q返回）。:lstrash 要从垃圾邮件目录还原文件，首先使用cd命令进入它。:cd /home/aaronkilik/.local/share/vifm/Trash然后选择要还原的文件，然后键入：:restore tmux终端分屏12sudo apt install tmuxtmux zshshhttp://ohmyz.sh/https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)https://www.zhihu.com/question/21418449 awesome桌面https://www.linuxzen.com/awesometmuxgnomedoda-zao-gao-xiao-linuxzhuo-mian-huan-jing.htmlhttps://wiki.archlinux.org/index.php/Awesome_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)http://www.hahack.com/tools/awesome/ Apvlvvim 化的 PDF 阅读工具 https://github.com/naihe2010/apvlvhttp://naihe2010.github.io/apvlv/ CMatrix黑客帝国样式的锁屏1234sudo apt install cmatrixcmatrix [-C color]Ctrl-c中止 https://github.com/abishekvashok/cmatrix vim炒股https://github.com/guofh/VimStockhttp://bluegene8210.is-programmer.com/posts/67910.html vimiumchrome插件，使用vim的按键来操作chrome https://sspai.com/post/27723 cVIM和vimium一样 https://blog.csdn.net/hk2291976/article/details/51280816]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyLinux.sh]]></title>
    <url>%2Fpost%2F6c3d6e2f.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940#/bin/bash# 使用Elementary OS 0.4#个别系统不能增加ppasudo apt install software-properties-commonsudo apt install vimif [ &quot;$?&quot; -ne 0 ] then exit 1fisudo apt install vifmif [ &quot;$?&quot; -ne 0 ] then exit 2fi#添加中文环境 Settings &gt;&gt; Language &amp; Region &gt;&gt; unLock &gt;&gt; Complete Installation &gt;&gt; click on English in the left sidebar &gt;&gt; Set System Language#安装fcitx五笔，其他相关包也会安装，fcitx\fcitx-config-gtk\fcitx-config-commonsudo apt install fcitx-table-wubi#baka-player#http://bakamplayer.u8sand.net/installation.phpcd ~/Downloadsudo apt install wgetwget https://github.com/u8sand/Baka-MPlayer/releases/download/v2.0.4/baka-mplayer_2.0.4-1_amd64.debsudo dpkg -i baka-mplayer_2.0.4-1_amd64.deb#filezillasudo apt install filezilla#virtual studio codesudo apt install code#virtualboxsudo apt install virtualbox-5.2]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk: run time error: not enough arguments passed to printf(5%)]]></title>
    <url>%2Fpost%2F3608f886.html</url>
    <content type="text"><![CDATA[问题使用awk &#39;{printf $1}&#39;时，系统提示出错，如下12awk: run time error: not enough arguments passed to printf(&quot;5%&quot;) FILENAME=&quot;b&quot; FNR=1 NR=1 解决因为要输出的内容里5% 包含%，printf认为这是格式语句，所以更改printf的使用方式使用如下格式：1awk &apos;&#123;printf(&quot;%s&quot;,$1)&#125;&apos;]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 sed命令]]></title>
    <url>%2Fpost%2F9826b1b6.html</url>
    <content type="text"><![CDATA[sed是一种几乎包括在所有的UNIX平台（包括Linux）的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。1234567891011121314sed [选项] &apos;[动作]&apos; 文件名#&apos;&apos;不能省略选项:-n 只输出经过sed处理过的行到屏幕-e 允许一次应用多个动作-i 直接修改文件,并且不由屏幕输出动作:a：追加,在当前行后添加一行或多行i：插入,在当前行前插入一行或多行c：整行替换，用c后面的字符串替换原数据行d：删除，删除指定的行p：打印，输出指定的行s: 字串替换(替换格式与vim中的类似) &apos;行范围s/旧字串/新字串/g&apos; 12345678sed -n &apos;2p&apos; student.txt 查看文件的第二行，如果没有-n将输出全部内容sed &apos;2,4d&apos; student.txt 表示删除第2-4行，但是不改变文件本身sed &apos;2a piaoliangdecxiaoguniang&apos; student.txt 在第2行之后添加字符串，但是不改变字符串本身sed &apos;2i heol&apos; student.txt 在第2行之前插入数据sed &apos;4c xxwmpg&apos; student.txt 将第二行的整行替换为xxwmpgsed &apos;6s/70/100/g&apos; student.txt 将第7行的所有70全部替换为100，如果不指定行的话会替换所有的指定字符串sed -i &apos;6s/70/100/g&apos; student.txt sed操作的数据直接写入文件sed -e &apos;s/fengj//g&apos;;s/cang//g&apos; student.txt 同时把fengj和cang替换为空]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 awk命令]]></title>
    <url>%2Fpost%2Fd2c69dfe.html</url>
    <content type="text"><![CDATA[123456789awk &apos;条件1&#123;动作1&#125;条件2&#123;动作2&#125;...&apos; 文件名条件-一般使用关系表达式作为条件-x&gt;10、x&gt;=10、x&lt;=10动作-格式化输出-流程控制 一个条件满足，就执行条件后面{}内的动作。没有条件就无条件执行{}内的动作，如果有条件，就只有满足条件才能执行{}内的动作。 awk的流程：依次读取每一行数据，读取完一行数据后，进行条件判断，如果满足条件，就执行该条件对应的动作，其中文件名为$0，剩下的每一列依次为$1\$2…，判断完一行后，继续判断下一行，直到知道文件全部判断完 123456awk &apos;&#123;printf $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&apos; student.txt #注意printf里面输出格式的双引号，printf中的转义符号都要用&quot;&quot;括起来。#printf后面要接换行符&quot;\n&quot;df -h| awk &apos;&#123;printf $1&quot;\t&quot; $5&quot;\n&quot;&#125;&apos;#查看系统使用率 BAGIN条件条件BAGIN表示在所有动作执行前先执行BEGIN后的那个动作123df -h | awk &apos;BEGIN&#123;print &quot;test&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos;会在最前面输出testawk在指定分隔符前面一定要加BEGIN END条件条件END表示在所有动作执行后才执行END后的那个动作12#df -h | awk &apos;END&#123;print &quot;test&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; 会在最后面输出test FS内置变量修改分隔符（默认为空格和制表符）在修改FS的变量的动作前要加上BEGIN，这样在执行所有其它动作之前先修改分割符，否则读取第一行数据的时候不能识别指定的分隔符12345cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; #3&#125;&apos;#awk在指定分隔符前面一定要加BEGIN，此例截取第1、3列cat student.txt | grep -v Name | awk &apos;$4&gt;=70&#123;print $2&#125;&apos;#此例截取除了列头的成绩大于等于70分的学生姓名，grep -v Name为取反命令，不输出带“Name”的行]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 格式化输出命令printf]]></title>
    <url>%2Fpost%2F50c951db.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122printf &quot;输出类型输出格式&quot; 输出内容输出类型：%ns：输出字符串。n是数字，指代输出几个字符%ni：输出整数。n是数字，指代输出几个数字%m.nf：输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2是小数位数，6位是整数输出格式：\a：输出警告声音\b：输出退格键，也就是Backspace键\f：清空屏幕\n：换行\r：回车，也就是Enter键\t：水平输出退格键，也就是Tab键\v：垂直输出退格键，也就是Tab键printf %s 1 2 3 4 5 6 123456printf %s %s %s 1 2 3 4 5 6 %s%s123456 后两个%s被当作输入printf &apos;%s %s %s&apos; 1 2 3 4 5 6 1 2 34 5 6 printf &apos;%s\t%s\t%s\n&apos; 1 2 3 4 5 61 2 34 5 6 使用printf输出命令，必须明确指出所有的格式如果想要使用printf读取文件中的内容就需要：12345printf &apos;%s&apos; $(cat student.txt) #不调整输出格式，文本内的内容输出到一行printf &apos;%s\t%s\t%s\t%s\n&apos; $(cat student.txt) #调整输出格式，根据文本内容进行调整 print在输出之后会在自动加入换行符，但Linux系统中默认没有print命令printf是标准格式输出命令，并不会自动加入换行符，如需换行，需要手动加入换行符printf “%s\n” a]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 cut]]></title>
    <url>%2Fpost%2F1a4651a4.html</url>
    <content type="text"><![CDATA[grep行提取，cut列提取 cut命令1234567891011cut [选项] 文件名选项 -f 列号：提取第几列（从1开始）-d 分隔符：按照指定分隔符分割列 默认为tabcut -f 列号,列号 文件名 （多个列号用逗号隔开；这个方法默认的文件以TAB制表符）cut -f 列号,列号 -d &quot;指定的分隔符&quot; 文件名grep &quot;bin/bash&quot; /etc/passwd 可以登录的用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; 排除root的可登录用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -f 1 -d &quot;:&quot; 提取非root登录用户用户名 cut命令的局限性用cut截取比较规律的文件，用默认制表符或其他符号作为分隔符，可以方便截取，如果是用空格或多个空格做分隔符，就会有问题12df -h | cut -d &quot; &quot; -f 1,3无法正确分隔多个空格，只能以一个空格分隔]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本去除重复行]]></title>
    <url>%2Fpost%2F44ec4983.html</url>
    <content type="text"><![CDATA[Find what:1^(.*)(\r?\n\1)+$ Replace with:1$1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 概述]]></title>
    <url>%2Fpost%2F515eec6a.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } 正则表达式是用于描述字符排列和匹配模式的一种语法规则。它主要用于字符串的模式分割、匹配、查找及替换操作。主要用于模糊匹配。 正则表达式与通配符的区别正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed等命令可以支持正则表达式 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符进行匹配 基础正则表达式 * 前一个字符匹配0次或任意多次 . 匹配除了换行符外任意一个字符 ^ 匹配行首。例如^hello会匹配以hello开头的行 $ 匹配行尾。例如hello$会匹配以hello结尾的行 [] 匹配中括号中指定的任意一个字符，只匹配一个字符。[0-9]匹配任意一位数字 [^] 匹配除中括号的字符以外的任意一个字符。 例如：[^0-9]匹配任意一位非数字字符[^a-z]表示任意一位非小写字母 \ 转义符。用于取消将特殊符号的含义取消 \{n\} 表示其前面的字符恰好出现N次例如：[0-9]\{4\} 匹配4位数字[1][3-8][0-9]\{9\} 匹配手机号码 \{n,\} 表示其前面的字符出现不小于n次。 例如 [0-9]\{2,\}表示两位及以上的数字 \{n,m\} 表示其前面的字符至少出现n次，最多出现m次。 例如[a-z]\{6,8\}匹配6到8位的小写字母 12345678910111213141516171819202122232425262728293031323334a* 匹配所有内容，包括空白行aa* 匹配至少包含有一个a的行aaa* 匹配最少包含两个连续a的字符串aaaaa* 匹配最少包含四个连续a的字符串区别于通配符里的*，通配符里的a*表示以a开头的字符串，这也说明了正则是一种包含匹配s..d 匹配s和d之间含有2个任意字符(除换行符)行，有多少个点就多少个字符s.*d 匹配s和d之间含有任意内容的行.* 匹配所有内容^s 匹配以s开头的行n$ 匹配以n结尾的行^$ 匹配空白行s[ao]id 匹配s和i字母中，要不是a，要不是o[0-9] 匹配任意任意一个数字^[a-z] 匹配用小写字母开头的行[a-zA-z] 匹配所有字母，shell中不支持[A-z]^[^a-z] 匹配非小写字母开头的行^[^a-zA-Z] 匹配非字母开头的行\.$ 匹配使用.结尾的行.$ 以任意字符结尾的行a\&#123;3\&#125; 匹配a字母连续出现三次的字符串[0-9]\&#123;3\&#125; 匹配包含连续的三个数字的字符串c\&#123;3\&#125;u 匹配u前面有三个c的字符串&quot;xc\&#123;3\&#125;u&quot; 匹配x和u之间三个c的字符串，x、u为定界符**实际使用中也会匹配多于n次的，如果需要准确匹配，则需要在前后使用分隔符**^[0-9]\&#123;3,\&#125;[a-z] 匹配最少用连续三个数字开头的行sa\&#123;1,3\&#125;i 匹配在字母s和字母i之间最少一个a，最多三个a 1234567正则表达式适合在文档中提取，不适合做写入的判断依据[0-9]\&#123;4\&#125;-[0-9]\&#123;2\&#125;-[0-9]\&#123;2\&#125;匹配日期^[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;匹配IP地址]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 通配符]]></title>
    <url>%2Fpost%2Fc3ae41ec.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } 1man glob 符号 作用 ? 匹配一个任意字符 * 匹配0个或多个任意字符 [] 匹配括号中任意一个字符 [-] 匹配括号中任意一个字符，-代表一个范围 [^] 匹配不是括号中的一个字符 [:space:] 空白字符 [:punct:] 标点符号 [:lower:] 小写字母 [:upper:] 大写字母 [:alpha:] 大小写字母 [:digit:] 数字 [:alnum:] 数字和大小写字母 注： a[a-z]b和a[A-Z]b不区分大小写，都可以匹配abc和aBc 专用字符集的[]和匹配括号中的任意一个字符不是一个同一个，专用字符集需要添加[] 1ls a[[:upper:]]b Bash中其他特殊符号 符号 作用 ‘’ 单引号，在单引号中左右的特殊符号，如$、`(反引号)都没有特殊含义 “” 双引号，在双引号中左右的特殊符号都没有特殊含义，但是“$”,”`”,”\”是例外。拥有“调用变量的值”，“引用命令”和“转义符”的特殊含义 `` 反引号，反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样。不过推荐使用$()，因为反引号非常容易看错 $() 和反引号作用一样，用来引用系统命令 # 在Shell脚本中，#开头的行代表注释 $ 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值 \ 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\\$将输出”$”符号，而不再是变量引用 12345678910echo `ls`echo dateecho `date`echo $(date)name=xiecho &apos;$name&apos;echo &quot;$name&quot;echo &apos;$(date)&apos;echo &quot;$(date)&quot; https://blog.csdn.net/tzs_1041218129/article/details/52896327]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 环境变量配置文件]]></title>
    <url>%2Fpost%2F8435a02b.html</url>
    <content type="text"><![CDATA[source命令123#修改配置文件后，必须注销重新登录才能生效，使用source命令可以不用重新登录source 配置文件. 配置文件 常用系统环境变量环境变量配置文件中主要是定义对系统操作环境生效的系统默认环境变量，如PATH等 -当前用户有效~/.bash_profile~/.bashrc-所有用户有效/etc/profile/etc/profile.d/*.sh/etc/bashrc 配置文件加载流程正常登录过程输入用户名和密码，正常登录/etc/profile–&gt;/etc/profile.d/*.sh–&gt;/etc/profile.d/lang.sh–&gt;/etc/sysconfig/i18n …/etc/profile–&gt;~/.bash_profile–&gt;~/.bashrc–&gt;/etc/bashrc–&gt;命令提示符 不正常简化登陆不输入用户名和密码，简化的加载过程，例如su - root/etc/bashrc–&gt;/etc/profile.d/*.sh–&gt;/etc/profile.d/lang.sh–&gt;/etc/sysconfig/i18n … /etc/profile的作用USER变量LOGNAME变量MAIL变量PATH变量HOSTNAME变量umask调用/etc/profile.d/*.sh文件 ~/.bash_profile的作用调用~/.bashrc文件在PATH变量后面加入了:$HOME/bin这个目录 .bashrc的作用定义命令别名调用/etc/bashrc文件 /etc/bashrc的作用PS1变量umaskPATH变量调用/etc/profile.d/*.sh文件 其他配置文件12~/.bash_logout#注销时生效的环境变量配置文件 12345~/.bash_history历史命令记录保存在硬盘的~/.bash_history文件中，当前登录后的命令保存在内存中，用户注销后才写入该文件历史记录保存多少条，在/etc/profile中记录用history 命令看，与 vi .bash_history 查看文件看的区别：history 记录的命令比后者的多，原因是，history 是记录在内存中，包含了本次登录后操作的命令；而后者还未将本次登录操作的命令保存在内 123456789101112131415161718192021/etc/issue#本地终端欢迎信息\d 显示当前系统日期\s 显示操作系统名称\l 显示登陆的终端号，这个比较常用\m 显示硬件系统结构，如i386，i686等\n 显示主机名\o 显示域名\r 显示内核版本\t 显示当前系统时间\u 显示当前登陆用户的序列号/etc/issue.net#远程登陆欢迎信息#转义符在该文件中不能使用#默认是不启用，是否显示此信息由/etc/ssh/sshd_config决定，加入&quot;Banner /etc/issue.net&quot;行才能生效/etc/motd#登陆之后欢迎信息#不管是本地登录，还是远程登录，都可以显示此信息issue是登陆之前生效的，motd是登陆之后生效的，建议写在motd中]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell运算符 变量测试]]></title>
    <url>%2Fpost%2F5e995419.html</url>
    <content type="text"><![CDATA[变量测试在脚本优化时使用 12345678910111213141516例子：测试x=$&#123;y-新值&#125;unset yx=$&#123;y-2&#125;echo $x2y=&quot;&quot;#将y的值设为空值x=$&#123;y-2&#125;echo $x#x为空y=1x=$&#123;y-2&#125;echo $x1]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell运算符 数值运算]]></title>
    <url>%2Fpost%2F4745a25f.html</url>
    <content type="text"><![CDATA[记住一名话就OK，$((运算式)) 数值运算方法一 declare -i12345aa=11bb=22declare -i cc=$aa+$bbecho $cc33 数值运算方法2：expr或let123456789101112aa=11bb=22dd=$(expr $aa + $bb)#+号两边必须有空格，没有空格依旧是字符串拼接echo $dd33aa=11bb=22let &quot;ee=aa+bb&quot;echo $ee33 数值运算方法3：$((运算式))或$[运算式]12345aa=11bb=22ff=$(($aa+$bb))echo $ff33 优先级]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell运算符 declare命令]]></title>
    <url>%2Fpost%2F2b659642.html</url>
    <content type="text"><![CDATA[declare命令12345678910111213141516declare [+/-][选项] 变量名 #declare命令用来声明shell的变量类型，因为shell变量默认都是字符串型选项：-：用于给变量设定类型属性+：用于取消变量的类型属性-a：将变量声明为数组型-i：将变量声明为整型-x：将变量声明为环境变量-r：将变量声明为只读变量-p：显示指定变量被声明的类型aa=11 bb=22declare -i cc=$aa+$bbdeclare -p c #查看变量cc的类型#声明变量cc的类型是整数型，它的值是aa和bb的和 声明数组变量12345678910#定义数组#数组的定义不需要declare命令也可以，直接使用movie[i]=valuemovie[0]=zpmovie[1]=tpdeclare -a movie[2]=live#查看数组echo $&#123;movie&#125; #输出数组下标为0的变量值echo $&#123;movie[2]&#125; echo $&#123;movie[*]&#125; #输出数组的全部值 声明环境变量12declare -x test=123#和export作用类似，export命令实际过程是调用declare命令 声明变量只读属性123declare -r test#给test赋予只读属性，赋予后不能修改该变量，不能删除，甚至不能取消只读属性#临时生效，重启无效 查询变量的属性12345declare -p#列出系统中所有变量的类型declare -p 变量名#查询指定变量的属性]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 Bash语系变量]]></title>
    <url>%2Fpost%2F35dd1cd2.html</url>
    <content type="text"><![CDATA[当前语系查询1234locale#查询当前系统语系#LANG:定义系统主语系的变量#LC_ALL:定义整体语系的变量 语系变量LANG1234echo $LANG#查看系统当前语系locale -a | more#查看Linux支持的所有语系 查询系统默认语系12cat /etc/sysconfig/i18n#下次开机以后的系统环境 设置当前语系1234LANG=zh_CN.UTF-8 #切换成中文LANG=en_US.UTF-8 Linux支持中文的前提条件是正确安装中文字体和中文语系 如果有图形界面，可以正确使用支持中文显示 如果使用第三方远程工具，只要语系设定正确，可以支持中文显示 如果使用纯字符界面，必须使用第三方插件（如zhcon等），即使设置LANG变量也没用]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 预定义变量和位置参数变量]]></title>
    <url>%2Fpost%2F6d83367e.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70% ; } 预定义变量 预定义变量 作用 $? 最后一次执行命令的返回状态。如果正确执行，则返回0；如果返回为非零（具体数值由命令决定），则上一条命令执行不正确 $$ 返回当前进程的PID $! 返回后台运行的最后一个进程的PID 1234567ls || echo yesls qwe &amp;&amp; echo no前面一条语句正确执行，才执行后一条语句。这里就是通过执行命令的返回值来判断的echo $?echo $$ #直接打印返回的是/bin/bash，需要时可以放到shell脚本里echo $! 可以通过一个简单的shell来展示一下12345#!/bin/bashehco &quot;dang qian de PID: $$&quot;find / hello.sh &amp;echo &quot;hou tai de PID: $!&quot; 位置参数变量位置参数变量本质上还是预定义变量 位置参数变量 作用 $n n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数需要用大括号包含，如 ${10} $* 这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体 $@ 这个变量也代表命令行中所有的参数，不过 $@ 把每个参数区分对待 $# 这个变量代表命令行中所有参数的个数 例子11234567#!/bin/bashnum1=$1num2=$2sum=$(($num1+$num2)) #变量 sum 的和是 num1 加 num2echo $sum #打印变量 sum 的值 12#执行脚本./test.sh 45 76 例子21234567#!/bin/bashecho &quot;A total of $# parameters&quot;#使用 $# 代表所有参数的个数echo &quot;The parameters is：$*&quot;#使用 $* 代表所有的参数echo &quot;The parameters is：$@&quot;#使用 $@ 代表所有的参数 12#执行脚本./test.sh 11 22 33 44 例子3123456789101112#!/bin/bashfor i in &quot;$*&quot;# $* 中所有参数看成是一个整体，所以这个 for 循环只会循环一次do echo &quot;The parameters is:$i&quot;donefor y in &quot;$@&quot;# $@ 中每个参数都看成是独立的，所以 $@ 中有几个参数，就会循环几次do echo &quot;Parameter:$y&quot;done 接收键盘输入123456read [选项] [变量名]选项：-p &quot;提示信息&quot;：在等待read输入时，输出提示信息-t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间-n 字符数：read命令只接受指定的字符数，就会执行-s：隐藏输入的数据，适用于机密信息的输入，比如密码 read.sh123456789101112131415#!/bin/bashread -p &quot;please input your name:&quot; -t 30 nameecho $name#如果超过30秒不输入，就终止当前命令read -p &quot;please input your passwd:&quot; -s passwdecho -e &quot;\n&quot;echo $passwd#输入的值是隐藏的，看不见的，但是在sh里面还是可以获取到的，并且可以输出的read -p &quot;please input your sex [M/F]:&quot; sexecho -e &quot;\n&quot;echo $sex#只能输入一个字符，且输入之后立马执行]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 环境变量]]></title>
    <url>%2Fpost%2F116321b2.html</url>
    <content type="text"><![CDATA[作用定义每个用户的操作环境 环境变量与用户自定义变量的区别环境变量是全局变量，用户自定义变量是局部变量。用户自定义变量只在当前的 shell 中生效，环境变量在当前 shell 和这个 shell 的所有子 shell 中生效。用户可以自定义环境变量，但对系统生效的环境变量名和变量作用是固定的。 用户自定义环境变量123456789export 变量名=变量值或变量名=变量值export 变量名export Y=1Z=1export Z 查看环境变量12345set #查看所有变量env #查看环境变量 删除环境变量12unset 环境名#没有$ 常用的环境变量HOSTNAME：主机名SHELL：当前的shellTERM：终端环境HISTSIZE：历史命令条数SSH_CLIENT：当前操作环境是用 ssh 连接的，这里记录客户端 ipSSH_TTY：ssh 连接的终端是 pts/1USER：当前登录的用户 PATH环境变量1234567#系统搜索命令的路径echo $PATH#查看PATH环境变量PATH=&quot;$PATH&quot;:/root/sh#临时增加PATH变量的值，系统重启后失效 PS1环境变量12345678910命令提示符设置[root@localhost ~]#\d：显示日期，格式为&quot;星期 月 日&quot;\H：显示完整的主机名\t：显示 24 小时制时间，格式为&quot;HH:MM:SS&quot;\A：显示 24 小时制时间，格式为&quot;HH:MM&quot;\u：显示当前用户名\w：显示当前所在目录的完整名称\W：显示当前所在目录的最后一个目录\$：提示符。root 用户为&quot;#&quot;，普通用户为&quot;$&quot;]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 用户自定义变量]]></title>
    <url>%2Fpost%2F69a08f8e.html</url>
    <content type="text"><![CDATA[定义变量1234567变量名=变量值#=号左右不可有空格#变量值有空格需要加&quot;&quot;#所有变量默认的值都是字符串类型，不可做Math运算x=5x=&quot;hello jx&quot; 调用变量123$变量名echo $x 变量叠加1234567x=123 #123x=&quot;$x&quot;456 #123456x=$&#123;x&#125;789 #123456789x=5y=6z=$x+$y #5+6 变量查看1234567set选项：-u：如果设定此选项，调用未声明变量里会报错（默认调用未声明变量无任何提示，值为空的变量也无任何提示）echo $jflajlfset -uecho $jflajlf 删除变量1234unset 变量名#注意变量名没有$，因为要删除的是变量，而不是变量的值unset x]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 变量]]></title>
    <url>%2Fpost%2Fbd7a1729.html</url>
    <content type="text"><![CDATA[Shell是一种脚本语言 变量命名规则 变量名必须以字母或下划线打头，名字中间只能由字母、数字和下划线组成 变量名的长度不超过255个字符 变量名在有效的范围内必须是唯一的，如再次定义则会替换上一个变量的值 在Bash中，变量的默认类型都是字符串型，系统把所有值都当作字符串放到变量中，不论这个“字符串”实际上是整数、浮点数等等，shell也不区分字符串型，整型，浮点型，日期型 目录名、文件名、变量名要有含义 变量的分类 用户自定义变量：变量自定义的 环境变量：这种变量中主要保存的是和系统操作环境相关的数据，变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。实际就是预定义变量的一种，只是功能单一固定，所以单独拿出来 预定义变量：Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 管道符]]></title>
    <url>%2Fpost%2F5f7a3c21.html</url>
    <content type="text"><![CDATA[多命令顺序执行 多命令执行符 格式 作用 ; 命令1;命令2 多个命令顺序执行，命令之间没有任何逻辑联系 &amp;&amp; 命令1&amp;&amp;命令2 逻辑与当命令1正确执行，则命令2才会执行当命令1执行不正确，则命令2不会执行 ` ` 命令1` `命令2 逻辑或当命令1执行不正确，则命令2才会执行当命令1正确执行，则命令2不会执行 123456date ; tar -zcvf etc.tar.gz /etc ; date #可以计算备份所用的时间ls &amp;&amp; echo yes || echo no #当ls正确执行时打印yes；当ls错误执行时打印no#顺序不能颠倒，不然命令出错的时候会同时输出no yes 管道符最后一个命令会在当前shell进程的子shell进程中执行1234567891011121314命令1 | 命令2 #命令1的正确输出作为命令2的操作对象netstat -an | grep ESTABLISHED | wc -l #查找当前有多少用户正在连接服务器ll -a /etc/ | moremore [文件名] #分页显示文件内容&quot;echo &quot;$PATH&quot; | tr &apos;a-z&apos; &apos;A-Z&apos;#转换为大写cat /etc/rc.d/rc.sysinit | tr &apos;a-z&apos; &apos;A-Z&apos; | more tee命令tee命令从标准输入读入数据，并且同时复制数据到标准输出和一个或多个文件12ls /usr/bin |tee ls.txt | grep.zip#屏幕打印同时重定向到文件]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 重定向]]></title>
    <url>%2Fpost%2Ff80df29c.html</url>
    <content type="text"><![CDATA[文件标识符 设备 设备文件名 文件标识符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/stdout 1 标准输出 显示器 /dev/stderr 2 标准错误输出 3-9是保留的标识符输出经常由两种类型组成，一，程序运行结果；二，状态和错误信息 输出重定向&gt;重定向符&gt;&gt;追加重定向，如果文件不存在，文件会被创建一旦使用数字、&amp;，数字、&amp;和&gt;、&gt;&gt;之间不能有空格没有数字、%有无空格没有关系，但是为了方便还是有比较好 类型符号作用标准输出重定向命令 &gt; 文件以覆盖的方式，把命令的正确输出输出到指定文件或设备中命令 &gt;&gt; 文件以追加的方式把命令的正确输出输出到指定文件或设备中标准错误输出重定向错误命令 2&gt;文件以覆盖的方式把命令的错误输出输出到指定文件或设备中错误命令 2&gt;&gt;文件以追加的方式把命令的错误输出输出到指定文件或设备中正确输出和错误输出同时保存命令 &gt;文件 2&gt;&amp;1以覆盖方式把命令的正确输出、输出到指定文件或设备中命令 &gt;&gt;文件 2&gt;&amp;1以追加方式把命令的正确输出、输出到指定文件或设备中命令 &amp;&gt;文件以覆盖方式把命令的正确输出、输出到指定文件或设备中命令 &amp;&gt;&gt;文件以追加方式把命令的正确输出、输出到指定文件或设备中命令 &gt;&gt;文件1 2&gt;&gt;文件2把正确的输出追加到文件1中，把错误的输出追加到文件2中只执行，不显示命令 &amp;&gt; /dev/null(a bit bucket) 将命令的结果丢入null（作用类似于垃圾箱）中，只执行，不显示 123456789ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1#传统方式，这种方式使用了两个重定向，一个是重定向标准输出到文件ls-output.txt，一个是重定向标准错误（2）到标准输出（1）#顺序不能变，标准错误的重定向必须总是出现在标准输出重定向之后ls -l /bin/usr &gt; ls-putput.txt 2&gt; ls-outputerror.txt#分别输出ls -l /bin/usr &amp;&gt; ls-output.txt#bash提供的第二种方式 123#技巧&gt; a.txt#删除文件内容或创建一个新的空文件 输入重定向命令 &lt; 文件名 #把文件的内容作为输入 命令 &lt;&lt; 标识符 #统计标识符到标识符再次出现之间的字符 cat &lt;&lt;EOF #展示键盘输入 cat &gt; /path/to/somefile &lt;&lt;EOF #将键盘输入放到文件，输入以EOF界定 参考： https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 历史命令]]></title>
    <url>%2Fpost%2Fb3bfabf4.html</url>
    <content type="text"><![CDATA[历史命令指的是把操作过的命令保留在系统当中, 当需要的时候可以重新进行调用 history123456789101112history [选项] [历史命令保存文件]选项：-a: 追加本次会话新执行的命令历史列表至历史文件中-d offset：删除历史中指定命令-c：清空历史命令-w：把缓存中的历史命令强制写入历史命令保存文件 ~/.bash_historynumber 显示历史中最近的number条命令不建议清空当本次操作出现错误可用过历史命令进行比对排错当登录后发现历史命令被清空, 则可判断出有人登录过该账户或服务器即使命令保存数目众多, 文件大小也不大, 不会给服务器造成多大压力 历史命令的配置历史命令默认保存1000条, 可以在环境变量配置文件/etc/profile中进行修改HISTSIZE=1000使用history命令查看的, 不止有之前保存下来的, 还有本次登录后新操作的命令, 这些命令只有本次正确退出之后才会写入 ~/.bash_history 历史命令相关环境变量 HISTSIZE：命令历史记录的条数 HISTFILE：命令历史文件，./bash_history HISTFILESIZE：命令历史文件记录历史的条数 HISTCONTROL：控制历史命令的记录方式 ignoredups：忽略连续且相同的命令， ignorespace：忽略所有以空白开关的命令 ignoreboth：ignoredups+ignorespace 历史命令的调用 使用上、下箭头调用以前的历史命令 使用 !n 重复执行一次第 n 条历史命令 使用 !! 重复执行一次上一条命令 使用 !字串重复执行最后一条以该字串开头的命令 调用上一条命令的最后一个参数：!$,ESC接.,Alt-. 命令与文本补全在Bash中, 命令与文件补全是非常方便与常用的功能, 我们只要在输入命令或文件时, 按”Tab”键就会自动进行补全系统进行命令补全依赖$PATH hash命令：shell搜寻到的外部命令的路径结果会缓存至kv(key-value)存储中；在环境变量PATH中搜索命令name的完整路径并记住它，这样以后再次执行相同的命令时，就不必搜索其完整路径了 12hash -d：清除指定缓存hash -r：清除所有缓存 https://blog.csdn.net/iEearth/article/details/52599900]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell Bash别名和快捷键]]></title>
    <url>%2Fpost%2Fc84d750c.html</url>
    <content type="text"><![CDATA[别名1234567891011121314151617181920212223#增加新的别名前要查看是否被占用type 别名alias#查看系统当中默认已经生效的别名alias ls=&apos;ls --color=auto&apos;#临时设定别名#不能有空格vi ~/.bashrcvi /root/.bashrcvi /etc/.bashrc#写入环境变量配置文件，系统再次重启后永久生效source .bashrc#使当前环境变量设置立即生效，不需要系统重启unalias ls#删除别名\cp#不执行别名，执行命令本身 命令生效顺序 第一顺位执行绝对路径或者相对路径的命令 第二顺位执行别名 第三顺位执行Bash的内部命令 第四顺位执行按照$PATH环境变量设置定义的目录顺序的第一个命令 快捷键ctrl + c 强制终止ctrl + l 清屏相当于clearctrl + a 光标快速回到行首ctrl + e 光标快速去到行尾ctrl + u 从光标所在位置删除到行首ctrl + k 从光标所在位置删除到行尾ctrl + z 把命令放入后台–，暂停ctrl + r 历史命令搜索]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本执行方式]]></title>
    <url>%2Fpost%2Fff97f2a0.html</url>
    <content type="text"><![CDATA[方法1：赋予执行权限，直接运行12chmod 755 hello.sh./hello.sh（或者绝对路径执行 /root/hello.sh） 方法2：通过Bash调用执行脚本12bash hello.sh#不需要执行权限，脚本作为bash的参数 在shell脚本中#!/bin/Bash不是注释，它标称下面的内容是linux的标准脚本程序如果该脚本使用纯shell语句完成，不加#!/bin/Bash运行是没问题的，但如果脚本调用了其他语言，就会报错]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell概述]]></title>
    <url>%2Fpost%2Fe2aa7539.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } Shell是一个命令行解释器（程序 -&gt; 依赖ASCII码表翻译为二进制 -&gt; Linux内核（发送请求）-&gt; 运行程序），它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至时编写一些程序。 Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令 Shell分类 Bourne Shell：主文件名为sh，从1979年起Unix就开始使用Bourne Shell C Shell:主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名 Shell的两种主要语法类型有Bourne和C，彼此不兼容。Bourne家族主要包括sh,ksh,Bash(Linux使用的标准Shell，不区分发行版),psh,zsh;C家族（Unix使用）主要包括：csh,tcsh（和Bash语法，配置微小区别） Linux，Unix的主要区别： Shell的不同 12345678910echo $SHELL #查看Shellcat /etc/shells#查看Linux支持的shellsh#进入sh模式exit#关闭模式 Bash：Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本ShellBourne Again Shell (bash) 是兼容Bourne Shell的一种相当于升级版本，注意命令bash中的ｂ是小写字母]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局域网安装ftp]]></title>
    <url>%2Fpost%2F399a1803.html</url>
    <content type="text"><![CDATA[写这篇文章的主要目的是方便局域网内的ftp配置 基本上实现这三点足够了： 不允许匿名访问，因为我不想其他机器随便都能登陆上来； 锁定一个共享目录，在这个目录下我可以上传和下载文件，进行文件共享； 不单独建立ftp用户，本机就可以访问； 123456789101112131415161718192021222324252627sudo apt-get install vsftpd #ubuntu的配置文件位置sudo vim /etc/vsftpd.confanonymous_enable=NO #禁止匿名登陆local_root=/home/user/ftp #设定一个共享目录local_enable=YES #本机可以访问write_enable=YES #可以写chroot_list_enable=YES chroot_list_file=/etc/vsftpd.chroot_list#不单独建立ftp用户#在其中写入可以使用ftp的用户名sudo vim /etc/vsftpd.chroot_list#去掉用户写权限#因为使用chroot_list_enable和chroot_list_file配置禁止用户拥有写权限chmod u-w,g-w ftp#为了能在共享目录复制粘贴，在ftp下创建一个user可写的目录，复制粘贴全在该目录下进行cd /home/user/ftpsudo mkdir FTPFILESsudo chown -R user:user FTPFILES#重启sudo service vsftpd restart 然后就可以使用各种客户端登陆了 参考： http://www.cnblogs.com/bcsflilong/p/4200139.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件传输-SFTP/SCP/FTP/lrzsz命令]]></title>
    <url>%2Fpost%2Fb2596d13.html</url>
    <content type="text"><![CDATA[FTP连接ftp服务器1ftp [hostname| [ip-address] 列出文件列表以及切换目录12lscd 下载文件下载文件通常用get和mget这两条命令。 123456789101112#get [remote-file] [local-file]#获取远程服务器上/usr/your/1.htmftp&gt; get /usr/your/1.htm 1.htmmget [remote-files]#从远端主机接收一批文件至本地主机#获取服务器上/usr/your/下的所有文件cd /usr/your/mget *.*#显示下载进度ftp&gt; hash 上传文件注意上传命令需要指定目标文件名12345678910put local-file [remote-file]#将本地一个文件传送至远端主机中。#把本地的1.htm传送到远端主机/usr/your,并改名为2.htmftp&gt; put 1.htm /usr/your/2.htmmput local-files#将本地主机中一批文件传送至远端主机。#把本地当前目录下所有html文件上传到服务器/usr/your/ 下ftp&gt; cd /usr/yourftp&gt; mput *.htm 断开连接12bye：中断与服务器的连接ftp&gt; bye 改变传输模式ftp的传输模式有ascii模式和二进制模式直接输入ascii则设置传输模式为ascii模式直接输入binary则设置传输模式为binary模式 12ftp&gt; asciiftp&gt; binary SFTPSFTP是安全文件传送协议，可以为传输文件提供一种安全的网络的加密方法。 SFTP 与 FTP 有着几乎一样的语法和功能。SFTP 为 SSH的其中一部分，所以说 SFTP 就是通过SSH端口（默认 22端口）和 Linux 用户和密码登陆的（例如 root 账号）。SFTP 使用加密传输认证信息和传输的数据，所以使用SFTP是非常安全的。但是由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多。 使用SFTP并不需要在服务器上做任何配置，只需要找个SFTP客户端，然后知道SSH端口、服务器用户名+密码即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243# 连接到SFTPsftp tecmint@27.48.137.6# 获得帮助?help# 检查本地工作目录lpwd# 检查远程工作目录pwd# 列出本地文件lls# 列出远程文件ls# 上传单个或多个文件put local.profile# 上传多个文件mput * .xls# 下载单个或多个文件get SettlementReport_1-10th.xls# 下载多个文件mget * .xls# 切换本地目录lcd Documents# 切换远程目录cd test# 创建目录mkdir testlmkdir test# 删除目录，该目录必须为空rm Report.xlsrmdir sub1# 退出SFTP!exit SCP使用SSH协议来传输文件的 SCP比较简单，是轻量级的，SFTP的功能则比较多 SCP的速度较快 SFTP在文件传输过程中中断的话，连接后还可以继续传输，但SCP不行 123456scp [-r] 用户名@ip:文件路径 本地路径# 网络复制命令, 下载文件 或加-r下载文件夹scp [-r] 本地文件 用户名@ip:上传路径# 网络复制命令, 上传文件 或加-r上传文件夹# 此为linux 与 linux之间进行文件传输的最简单方式 lrzszsz/rz 并不是Linux标准命令工具，有些Linux发行版本如Ubuntu会自带，有些可能没有，需要自己安装 安装lrzsz1yum -y install lrzsz 12#上传文件，执行命令rz，会跳出文件选择窗口，选择好文件，点击确认即可。rz 12#下载文件，执行命令szsz 参考： https://www.tecmint.com/sftp-command-examples/ https://www.jscape.com/blog/scp-vs-sftp]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP主动模式和被动模式]]></title>
    <url>%2Fpost%2Fed8800d8.html</url>
    <content type="text"><![CDATA[FTP只通过TCP连接，没有用于FTP的UDP组件。FTP不同于其他服务的是它使用了两个端口， 一个数据端口和一个命令端口(或称为控制端口)。通常21端口是命令端口，20端口是数据端口。根据FTP工作方式的不同，数据端口并不总是20，这就是主动与被动FTP的最大不同之处。（不管主动模式还是被动模式都是用TCP 21端口来传输控制信号的。） 主动FTP(PORT/Active)客户端从一个任意的非特权端口N（N&gt;1023）连接到FTP服务器的命令端口，也就是21端口。然后客户端开始监听端口N+1，并发送FTP命令“port N+1”到FTP服务器。接着服务器会从它自己的数据端口（20）连接到客户端指定的数据端口（N+1）。 针对FTP服务器前面的防火墙来说，必须允许以下通讯才能支持主动方式FTP： 任何大于1024的端口到FTP服务器的21端口。（客户端初始化的连接） FTP服务器的21端口到大于1023的端口。 （服务器响应客户端的控制端口） FTP服务器的20端口到大于1023的端口。（服务器端初始化数据连接到客户端的数据端口） 大于1023端口到FTP服务器的20端口（客户端发送ACK响应到服务器的数据端口） 被动FTP(PASV/Passive)为了解决服务器发起到客户的连接的问题，人们开发了一种不同的FTP连接方式。这就是所谓的被动方式，当客户端通知服务器它处于被动模式时才启用。 在被动方式FTP中，命令连接和数据连接都由客户端发起，这样就可以解决从服务器到客户端的数据端口的入方向连接被防火墙过滤掉的问题。 当开启一个 FTP连接时，客户端打开两个任意的非特权本地端口（N &gt; 1024和N+1）。第一个端口连接服务器的21端口，但与主动方式的FTP不同，客户端不会提交PORT命令并允许服务器来回连它的数据端口，而是提交 PASV命令。这样做的结果是服务器会开启一个任意的非特权端口（P &gt; 1024），并发送PORT P命令给客户端。然后客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。 对于服务器端的防火墙来说，必须允许下面的通讯才能支持被动方式的FTP: 从任何大于1023的端口到服务器的21端口 （客户端初始化的连接） 服务器的21端口到任何大于1023的端口 （服务器响应到客户端的控制端口的连接） 从任何大于1023端口到服务器的大于1023端口 （客户端初始化数据连接到服务器指定的任意端口） 服务器的大于1023端口到远程的大于1023的端口（服务器发送ACK响应和数据到客户端的数据端口） 主动与被动FTP优缺点：主动FTP对FTP服务器的管理有利，但对客户端的管理不利。因为FTP服务器企图与客户端的高位随机端口建立连接，而这个端口很有可能被客户端的防火墙阻塞掉。被动FTP对FTP客户端的管理有利，但对服务器端的管理不利。因为客户端要与服务器端建立两个连接，其中一个连到一个高位随机端口，而这个端口很有可能被服务器端的防火墙阻塞掉。 幸运的是，有折衷的办法。既然FTP服务器的管理员需要他们的服务器有最多的客户连接，那么必须得支持被动FTP。我们可以通过为FTP服务器指定一个有限的端口范围来减小服务器高位端口的暴露。这样，不在这个范围的任何端口会被服务器的防火墙阻塞。虽然这没有消除所有针对服务器的危险，但它大大减少了危险。 总结主动FTP： 命令连接：客户端 &gt;1023端口 -&gt; 服务器 21端口 数据连接：客户端 &gt;1023端口 &lt;- 服务器 20端口 被动FTP： 命令连接：客户端 &gt;1023端口 -&gt; 服务器 21端口 数据连接：客户端 &gt;1023端口 -&gt; 服务器 &gt;1023端口 主动模式是从服务器端向客户端发起连接；被动模式是客户端向服务器端发起连接。两者的共同点是都使用 21端口进行用户验证及管理，差别在于传送数据的方式不同，PORT模式的FTP服务器数据端口固定在20，而PASV模式则在1024-65535之间随机 PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用PORT命令告诉服务器：“我打开了XXXX端口，你过来连接我”。于是服务器从20端口向客户端的XXXX端口发送连接请求，建立一条数据链路来传送数据。 PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用PASV命令告诉客户端：“我打开了XXXX端口，你过来连接我”。于是客户端向服务器的XXXX端口发送连接请求，建立一条数据链路来传送数据。 当NAT(Network Address Translation)设备以主动模式访问FTP服务器时，由于NAT设备不会聪明的变更FTP包中的IP地址，从而导致无法访问服务器。 大部分互联网应用都是被动模式，因为大部分客户端都是在路由器后面，没有独立的公网IP地址，服务器想要主动连接客户端，难度太大，在现在真实的互联网环境里面几乎是不可能完成的任务。 大部分FTP客户端默认使用PASV方式，在大部分FTP客户端的设置里，常见到的字眼都是“PASV”或“被动模式”。 vsftpd配置1234# vi /etc/vsftpd/vsftpd.confpasv_enable=YESpasv_min_port=3000pasv_max_port=4000 参考： https://www.centos.bz/2012/08/ftp-port-pasv-mode/ http://www.serv-u.com/kb/1138/Active-and-Passive-FTP-Transfers-Defined http://blog.sina.com.cn/s/blog_5cdb72780100jwm9.html http://www.rfyy.net/archives/2641.html https://my.oschina.net/binny/blog/17469 https://zhuanlan.zhihu.com/p/36403412 http://www.cnblogs.com/xiaohh/p/4789813.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看用户登录时间及历史命令]]></title>
    <url>%2Fpost%2F2edd2f82.html</url>
    <content type="text"><![CDATA[12who#查看当前登录用户信息：用户名、终端类型、登陆日期以及远程主机 12users#当前登录的用户 123history#查看命令历史$HOME/.bash_history：每个用户都有一份命令历史记录 12345678910111213141516last#查看用户登录历史#此命令会读取 /var/log/wtmp 文件，/var/log/btmp可以显示远程登陆信息。 #last默认打印所有用户的登陆信息last 用户名#打印某个用户的登陆信息选项： -x：显示系统开关机以及执行等级信息 -a：将登陆ip显示在最后一行 -f ：读取特定文件，可以选择 -f /var/log/btmp文件 -d：将IP地址转换为主机名 -n：设置列出名单的显示列数 -t：查看指定时间的用户登录历史 例如： last -t 20150226160404 显示这个时间戳之前的登陆历史 123456789101112131415lastlog#查看所有用户最近一次登录历史#命令将读取 /var/log/lastlog 文件，用户排列顺序按照 /etc/passwd 中的顺序选项： -u：查看某个用户的最后一次登陆历史 例如： lastlog -u test 查看用户test的登陆历史 -t：查看最近几天之内的用户登录历史 例如： lastlog -t 1 查看最近1天之内的登陆历史-b：查看指定天数之前的用户登录历史 例如： lastlog -b 60 查看60天之前的用户登录历史 12345ac根据/var/log/wtmp文件中的登陆和退出时间报告用户连接的时间（小时），默认输出报告总时间 -p：显示每个用户的连接时间 -d：显示每天的连接时间 -y：显示年份，和-d配合使用]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下ls命令只显示目录或文件]]></title>
    <url>%2Fpost%2Fc28a470e.html</url>
    <content type="text"><![CDATA[本质上来说就是根据有没有以/结尾 只显示目录12345ls -F | grep /$ # -F使得ls将文件分类，通过在文件后面加一些标记来实现ls -F | grep /ls -l | grep ^dls -d */ls -ld */ 只显示文件1234567ls -F | grep [^\/]$ # 注意行尾匹配符号$不可少ls -F | grep [^/]$ls -l | grep ^-ls -l | grep ^- | wc -l # wc命令统计行数find . -type f -maxdepth 1 | xargs ls -alls -p | grep [^/]$ # -p使得ls命令在目录后面加斜杠find . ! -name . -prune -type f # 这个命令不会很好排序文件 参考： http://blog.163.com/ytyang__/blog/static/8405845201112502159277/]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux禁止ping以及开启ping的方法]]></title>
    <url>%2Fpost%2Fa436331.html</url>
    <content type="text"><![CDATA[Linux默认是允许Ping响应的，系统是否允许Ping由2个因素决定的：A、内核参数，B、防火墙，需要2个因素同时允许才能允许Ping，2个因素有任意一个禁Ping就无法Ping。 具体的配置方法如下： 内核参数设置允许ping设置12345678#临时允许PING操作的命令echo 0 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all#永久允许ping配置方法#/etc/sysctl.conf设置net.ipv4.icmp_echo_ignore_all=0#使新配置生效sysctl -p 禁止Ping设置12345678#临时禁止PING的命令echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all #永久禁止ping配置方法#/etc/sysctl.conf设置net.ipv4.icmp_echo_ignore_all=1#使新配置生效sysctl -p 防火墙设置注：此处的方法的前提是内核配置是默认值，也就是没有禁止Ping 这里以Iptables防火墙为例，其他防火墙操作方法可参考防火墙的官方文档。 允许ping设置1234iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT#或者也可以临时停止防火墙操作的service iptables stop 禁止ping设置1iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP 参考： https://www.cnblogs.com/chenshoubiao/p/4781016.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 系统资源查看]]></title>
    <url>%2Fpost%2F95daab36.html</url>
    <content type="text"><![CDATA[监控系统资源（memory swap system io cpu等）123456789101112131415161718192021222324252627282930313233vmstat [刷新延时 刷新次数]例：vmstat 1 3procs：进程信息字段-r：等待运行的进程数，数量越大，系统越繁忙-b：不可被唤醒和进程数量，数量越大，系统越繁忙memory：内存信息字段-swpd：虚拟内存的使用情况，单位KB-free：空闲的内存容量，单位KB-buff：缓冲的内存容量，单位KB-cache：缓存的内存容量，单位KBswap：交换分区的信息字段-si：从磁盘中交换到内存中数据的数量，单位KB-so：从内存中交换到磁盘中数据的数量，单位KB这两个数越大，证明需要经常在磁盘和内存之间交换，系统性能越差io：磁盘读写信息字段-bi：从块设备读入数据的总量，单位是块-bo：写到块设备的数据和总量，单位是块。这两个数越大，代表系统的I/O越繁忙 system：系统信息字段-in：每秒被中断的进程次数-cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙 CPU：CPU信息字段-us：非内核进程消耗CPU运算时间的百分比-sy：内核进程消耗CPU运算时间的百分比-id：空闲CPU的百分比-wa：等待I/O所消耗的CPU百分比-st：被虚拟机所盗用的CPU百分比 内存12345free [-b-k-m-g]-b：以字节为单位显示-k：以KBl为单位显示，默认就是以KB为单位显示-m：以MB为单位显示-g：以GB为单位显示（不满1g时显示精度丢失） 第一行：total是总内存数，used是已经使用的内存数，free是空闲的内存数，shared是多个进程共享的内存总数，buff是缓冲内存数，cache是缓存内存数。默认单位是KB 第二行：-/buffers/cache的内存数，相当于第一行的used-buffers-cached。+/buffers/cache的内存数，相当于第一行的free+buffers+cached 第二三行：total是swap的总数；used是已经使用的swap总数，free是空闲的swap数。默认单位是KB cpu1cat/proc/cpuinfo 硬盘1df -h 参考磁盘管理 平均负载12345678uptime#显示系统的系统时间，平均负载，当前登录用户数，即top命令的第一行（top命令耗费资源）top#侧重进程w#w命令侧重用户信息的显示 内核1234567891011121314uname [选项]#查看系统与内核相关信息选项：-a :查看系统所有相关信息-r :查看内核版本-s :查看内核名称cat /proc/version#查看系统与内核相关信息dmesg#开机时内核检测信息dmesg | grep cpu 判断当前系统的位数123file /bin/ls#通过查看命令的位数#64位cpu仍可以安装32位系统，不能通过cpu位数来判断 发行版信息12345678910#centos 7 可用#实际上，打开/etc目录可以看到redhat-release和system-release全都软链接到了centos-releaserpm -q centos-releasecat /etc/centos-releasecat /etc/redhat-releasecat /etc/system-release#centos 7.4不可用lsb_release -acat /etc/issue]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux进程管理03 修改进程优先级]]></title>
    <url>%2Fpost%2Fb32223bf.html</url>
    <content type="text"><![CDATA[Linux操作系统是一个多用户、多任务的操作系统，Linux系统中运行着非常多的进程，但是CPU在同一时钟周期内只能运算一个指令。进程优先级决定了每个进程处理的先后顺序 查看优先级1234ps -el #PRI(priority): 是系统的优先级#NI (nice)： 用户可以自定义的优先级#实际执行的优先级是PRI+NI，数字越小该进程优先级越高 给新执行的命令赋予NI值12345nice [选项] 命令#nice命令可以给新执行的命令直接赋予NI值，但是不能修改已经存在进程的NI值选项：-n NI值：给命令赋予NI值。例如：nice -n -5 service httpd start 修改NI值时有几个注意事项 NI值的范围是-20到19 普通用户调整NI值的范围是0到19,而且只能调整自己的进程 普通用户只能调高NI值，而不能降低，如原本NI值为0，则只能调整为大于0 root用户才能设定进程NI值为负值，而且可以调整任何用户的进程 PRI（最终值）=PRI（原始值）+NI 用户只能修改NI的值，不能直接修改PRI 修改已经存在进程的NI值1234renice [优先级] PID#renice命令是修改已经存在进程的NI值的命令renice -10 2125]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux进程管理02 杀死进程]]></title>
    <url>%2Fpost%2F6f02f8b5.html</url>
    <content type="text"><![CDATA[kill命令 杀死一个进程1234kill -l#查看可用的进程信号kill [信号] PID table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 20%; } table th:nth-of-type(3){ width: 60%; } 其中有两个常用信号 信号代号 信号名称 说明 1 SIGHUP 关闭读取配置文件后重启 9 SIGKILL 强制停止 12345678kill -HUP(或-1) 进程号#平滑重启服务#正常修改完配置文件后，需要重启服务#用普通的restart来重启会提出正在使用的用户，造成不好的用户体验。#平滑重启是重启服务配置，保留正在使用的用户。 kill -9 2236#强制杀死进程 killall命令 批量杀死同一类型的进程123456killall [选项] [信号] 进程名 #按照进程名杀死进程，可以批量杀死同一类型的进程选项：-i：交互式，询问是否要杀死某个进程-I：忽略进程名的大小写 pkill命令 批量杀死同一类型的进程12345pkill [选项] [信号] 进程名 #按照进程名终止进程，可以批量杀死同一类型的进程选项：-t 终端号：按照终端号踢出用户 案例：踢出登录用户123456w #查看当前登陆用户的用户 TTY列为终端号按照终端号杀死进程pkill -9 -t tty1#只有超级用户才能踢除用户]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux进程管理01 查看进程]]></title>
    <url>%2Fpost%2F14044ec9.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } 进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源 进程管理的作用 判断服务器健康状态 查看系统中所有的进程 杀死进程 ps命令 查看所有进程12345678910111213ps aux #查看系统中所有进程，使用BSD操作系统格式（没有-）ps -le#查看系统中所有进程，使用Linux标准命令格式ps -ef |grep ssh#aux和-ef没有多大区别，只是一风格不同，二如果COMMAND过长，aux会截断显示，而-ef不会选项-a :显示一个终端的所有进程-u :显示进程的归属用户及内存的使用情况-x :显示没有控制终端的进程-l :长格式显示，显示更加详细的信息-e :显示所有进程，和-A作用一致 输出详解 显示 含义 USER 该进程是由哪个用户产生的 %CPU 该进程占用CPU资源的百分比，占用越高，进程越耗费资源 %MEM 该进程占用物理内存的百分比，占用越高，进程越耗费资源 VSZ 该进程占用虚拟内存的大小 ，单位KB RSS 该进程占用实际物理内存的大小，单位KB TTY 表示该进程是在哪个终端运行的tty1-tty6是本地字符界面终端，tty7是本地图形终端 pts/0-255代表虚拟终端 STAT 进程的状态 R :运行 S :睡眠 T :停止s :包含子进程 + :位于后台 START 该进程的启动时间 TIME 该进程占用CPU的运算时间，注意不是系统时间 COMMAND 产生些进程的命令名 /sbin/init的pid永远是1，它是系统下所有进程的父进程，所有的进程都依赖于它 TTY是？，代表该进程是由系统内核启动的，一般认为是系统进程 pstree命令 查看进程树123pstree [选项]-p :显示进程的PID-u :显示进程的所属用户 top命令 查看系统健康状态1234567891011121314151617top [选项]选项：-d秒数：指定top命令每隔几秒更新。默认是3秒-b：使用批处理模式输出。 一般和 ”-n&quot;选项合用-n 次数：指定top 命令执行的次数。 一般和 “-b”选项合用在 top 命令的交互模式当中可以执行的命令：h：显示交互模式的帮助P：以CPU使用率排序，默认就是此项M：以内存的使用率排序N：以PID排序q：退出 toptop -b -n 1 &gt; /root/top.log #查看所有进程，因为直接使用top屏幕有限无法全部展示，所以放到文件中#将执行的top命令结果输出到log日志文件中#top命令耗费资源比较大，应及时关闭 输出详解 第一行为任务队列信息 12:26:46 系统当前时间 up 1 day,13:32 系统已运行的时长 2 users 当前登录的用户数量 load average 系统在之前1分钟，5分钟，15分钟的平均负载（与CPU核数相关，一般认为单核小于1时，负载较小，如果大于1,系统已经超出负荷，那么双核不超2，4核不超4） 第二行为进程信息 tasks:95 total 系统中的进程总数 1 running 正在运行的进程数 94 sleeping 睡眠的进程数 0,stopped 停止的进程数 1 zombie 僵尸进程（应该停止却没有停止的进程），如果不是0,需要手工检查僵尸进程 第三行为CPU信息 Cpu(s):0.1%us 用户模式占用的CPU百分比 0.1%sy 系统模式占用的CPU百分比 0.0%ni 改变过优先级的用户进程占用的CPU百分比 99.7%id 空闲CPU的CPU百分比 0.1%wa 等待输入/输出的进程的占用CPU百分比 0.0%hi 硬中断请求服务占用的CPU百分比 0.1%si 软中断请求服务占用的CPU百分比 0.0%st st(Steal time)虚拟时间百分比，就是当有虚拟CPU时，虚拟CPU占实际CPU的时间百分比 第四行为物理内存信息 Mem： 623434k total 物理内存的总量，单位kb 521313k free 空闲的物理内存 578322k used 已经使用的物理内存 623231 buff/cache 作为缓冲/缓存的内存数量 第五行是交换分区的信息 Swap: 8298492 total 交换分区的总量，单位kb 8292336 free 空闲的交换分区 6156 used 已经使用的交换分区 3129824 avail Mem 可用的交换分区 第六行类似ps PR 优先级 NI 任务nice值 VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES 物理内存用量 SHR 共享内存用量 TIME+ 累计cpu占用时间 cpu读写速度&gt;内存&gt;硬盘缓存cache是加速读取 减少对硬盘的读取缓冲buff是加速写入 减少对硬盘的写入 判断系统健康状况主要查看的参数： load average: 0.00, 0.00, 0.00 #表示系统在之前1分钟，5分钟，15分钟的平均负载。. Cpu（s）:…99.8%id #CPU空闲百分比 Mem：…6780k free #内存空闲率 Swap：…536723k free #swap空闲率 列出进程打开或使用的文件信息1234567891011121314151617181920lsof [选项]选项：-c 字符串 ：只列出以字符串开头的进程打开文件-u 用户名 ：只列出某个用户的进程打开的文件-p pid : 列出某个pid进程打开的文件示例：lsof | more#查询所有进程-分屏显示lsof /sbin/init#查询/sbin/init文件被哪个文件调用（只能查系统文件，其他自己建立的文件查没有意义）lsof -c httpd #查看httpd进程调用了哪个文件lsof -u root#按照用户名，查询某用户的进程所调用的文件名（数量可能很多） 参考： https://blog.csdn.net/qq_31666147/article/details/51557300]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux定时任务]]></title>
    <url>%2Fpost%2Fb3dc8f98.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70% ; } at 一次性定时任务12345chkconfig --list |grep atd#确定at安装service atd restart#启动at服务 访问控制 如果系统中有/etc/at.allow文件(白名单)，那么只有在此文件的用户可以使用at命令（/etc/at.deny文件会被忽略）； 如果系统中没有/etc/at.allow文件，只有/etc/at.deny文件(黑名单)，那么在此名单下的用户不能使用at命令【对root不起作用】 如果系统这两个文件都不存在，那么只有root用户可以使用at命令 1234567891011121314151617181920at [选项] 时间选项：-m :执行工作后通知执行at命令的用户-c :显示该at工作的实际内容时间：HH:MMHH:MM YYYY-MM-DDHH:MM[am|pm] [month][date]HH:MM +[minutes|hours|days|weeks]at now + 5 minutes&gt;&gt;at /root/test.sh五分钟后执行/root/test.sh脚本，必须写绝对路径用ctrl+删除键删除，按ctrl + d 保存退出atatq #查询当前服务器上的at工作atrm [工作号] #删除指定的at任务 用户 crontab 循环定时任务访问控制 当系统中有/etc/cron.allow文件(白名单)，只有写入此文件的用户可以使用crontab命令，没有写入的用户不能使用crontab命令。同样如果有此文件，/etc/cron.deny文件会被忽略，/etc/cron.allow文件的优先级更高； 如果系统中没有/etc/cron.allow文件，只有/etc/cron.deny文件(黑名单)，那么在此名单下的用户不能使用cron命令【对root不起作用】 如果系统这两个文件都不存在，那么只有root用户可以使用cron命令 被周期性执行的任务称为Cron Job周期性执行的任务列表称为Cron Table 1234567891011121314151617181920212223242526272829crontab -l#查询是否安装systemctl status crond#检查是否启动yum install crontabssystemctl start crond#启动systemctl enable crond#开机自启crontab [选项]选项：-e #进入crontab编辑界面，当前用户vim方式编辑-l #查看当前用户的crontab任务-r #删除当前用户所有的定时的任务-u #指定用户* * * * * 执行的任务#crontab -e 输入格式#第一个 * 一小时的第几分钟 0-59#第二个 * 一天当中的第几小时 0-23#第三个 * 一月当中第几天 1-31#第四个 * 一年当中第几个月 1-12#第五个 * 一周中的第几天 0-7(0和7都代表星期日) 特殊符号 含义 * 代表任何时间,如第一个* 代表每分钟执行一次 ， 代表不连续的时间,如:0 8,12,16 *代表每天的8点0分/12点0分/16点0分执行 - 代表连续时间, “0 5 * 1-6”代表每周一到周六5点执行 */n 代表每个多久执行一次,”/10 *”表示每10钟执行一次 注意 星期几与几号最好不要连用，因为都以天作为单位，容易让管理员混乱 六个选项都不能为空,必须填写。如果不确定使用*代表任意时间 最小有效时间为分钟,最大有效时间为月，像2018年某时执行，3点30分30秒这样的时间都不能使用 定时任务中的命令最好使用绝对路径，定时任务有自己的PATH路径（/etc/crontab） 时间 含义 * 5 * * 1 /root/hello.sh 每周一的5点的每分钟执行一次 */1 * * * * date &gt;&gt; /tmp/log.txt 每分钟打印当前时间到日志文件中 */2 * * * * 1-59/2 * * * * 每隔两分钟 * 2 * * * 2点的每分钟 0 23-7/1 * * * * 晚上23点到早上7点，每隔一个小时 0,30 * * * * 0-59/30 * * * * 每隔30分钟 59 1 1-7 4 * test date +\%w -eq 0 &amp;&amp; /root/a.sh 四月的第一个星期日早晨1时59分运行a.sh 每半分钟执行一次12*/1 * * * * date &gt;&gt; /tmp/date.log*/1 * * * * sleep 30s;date &gt;&gt; /tmp/date.log 系统 crontab 循环定时任务contab -e是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务，可是有些定时任务需要系统执行，这里我们就需要编辑/etc/crontab这个配置文件了 /etc/crontab的功能逐渐被anacron取代/etc/cron.{hourly,daily,weekly,monthly}不再依赖/etc/crontab而是anacron主要说明CentOS 执行系统任务的方法 手工执行定时任务：crontab -e 系统定时任务 将定时任务脚本复制到/etc/cron.{hourly,daily,weekly,monthly}目录中，就能自动定时执行（推荐） 修改crontab配置文件 crontab相关文件 /etc/crontab #系统配置文件，只有root用户才会把这些内容载入到计任务表中 /var/spool/cron #最终生成的计划任务文件 /var/spool/cron/root #root用户的定时任务 /var/spool/cron/user1 #user1用户的定时任务 /var/log/cron #crontab日志，保存cron的任务执行记录，echo会打印到这里 /var/log/cron-日期 anacron配置anacron 是用来保证在系统关机的时候错过的定时任务，可以在系统开机之后再执行 检测周期 anacron会使用一天、七天、一个月作为检测周期 在系统的/var/spool/anacron目录中存在cron.{daily.weekly,monthly}文件，用于记录上次执行cron的时间 和当前时间做比较，如果两个时间的差值超过了anacron的指定时间差，证明有cron任务被漏执行 在老的CentOS版本中，/etc/cron.{daily.weekly,monthly}这些目录即会被cron调用，也会被anacron调用，容易重复执行在CentOS 6.x中则只会被anacron调用，避免了重复执行在CentOS 6.x中，anacron不再是服务，而是系统命令 配置文件目录/etc/anacrontab 方法只需要将需要定时执行的任务脚本放到 /etc/cron.(daily,weekly,monthly) 目录下，就能自动定时执行 特点方便，易管理，一定程度上防止意外情况，执行时间不确定]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux后台管理]]></title>
    <url>%2Fpost%2F1515ab08.html</url>
    <content type="text"><![CDATA[工作（后台）管理指的是在单个登录终端中（shell界面）同时管理多个工作行为 注意事项 当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行 top、vi之类放在后台也是暂停的，因为一个需要用户来查看进程健康状态，一个需要用户写入 压缩、解压缩、cp、mv、find之类可以放在后台所以，想要让这个命令在后台运行，首先，不能与用户有交互。其次，它要运行一段时间 把进程放入后台12345tar -zcf etc.tar.gz /etc &amp; #在命令后加个&amp;，把命令放在后台执行top#ctrl+z放在后台暂停 查看后台的工作123456jobs [-l]-l:显示工作的PIDjobs默认是绑定终端的+代表最后一个放入的进程，也是工作恢复时，默认恢复的工作-代表倒二个放入的进程 把后台暂停的工作回复到前台执行12fg %工作号# %可以省略，但要注意工作号和PID的区别 把后台暂停的工作回复到后台执行12bg %工作号# 后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行 后台命令脱离终端执行把命令放入后台，只能在当前登录终端执行。当用户logout时或关闭终端，会向该用户终端下所有，进程发送SIGHUP信号，后台程序就会停止 mysqld不会跟随关闭，d表示守护进程damon，守护进程damon进程开机运行，某一个用户退出终端不影响该程序的运行，但把所有需要脱离终端执行的命令都放到守护进程里不切实际 把需要后台执行的命令加入/etc/rc.local文件，自启动文件 使用系统定时任务，让系统在指定的时间执行某个后台命令 使用 nohup命令（常用）123nohup 命令 &amp;nohup /root/for.sh &amp;#可以是脚本 补充： https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/ https://linux.cn/article-7918-1.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox扩容]]></title>
    <url>%2Fpost%2F93ab716c.html</url>
    <content type="text"><![CDATA[这篇文章用于在VirtualBox虚拟机上的CentOS扩充根目录空间，区别于新增硬盘以及添加新的挂载点 主机环境为Ubuntu 17.04VirtualBox 5.2虚拟机为CentOS 7 VirtualBox 中虚拟硬盘有几种形式，VMDK、VDI、VHD、HDD等。 VMDK：是VMware开发并使用的，同时也被SUN的xVM、QEMU、SUSE Studio、.NET DiscUtils支持，所以兼容性会好些。 VDI：是Virtual Box 自己的处理格式，而且Virtual Box支持Windows和Linux，所以对于使用VirtualBox的用户比较好。 VHD：是Windows专有的处理格式，HDD是Apple专有的处理格式，所以不会支持跨平台，一般不会考虑。 扩容磁盘文件在主机上操作VBoxManage命令是安装VirtualBox时安装的，如果无法使用该命令，请指定完整路径，寻找VirtualBox的安装目录，我的在/usr/bin下centos.vdi和centos.vmdk是VirtualBox创建的系统磁盘文件，一般位于用户的VirtualBox VMs文件夹下 123456789101112#VDI#单位为MVBoxManage modifyhd centos.vdi --resize 16000#VMDK#单位为M#如果是VMDK就要先转换成VDI，然后再扩容#vmdk是转换前的文件，vdi是转换之后的文件VBoxManage clonehd &quot;centos.vmdk&quot; &quot;centos.vdi&quot; --format vdiVBoxManage modifyhd &quot;centos.vdi&quot; --resize 16000#如果想再转回为VMDK，用这个命令就可以了，直接使用vdi格式也可以VBoxManage clonehd &quot;centos.vdi&quot; &quot;resized.vmdk&quot; --format vmdk 指定新磁盘文件打开虚拟机，选择系统 &gt; 右击 &gt; 设置 &gt; 存储 &gt; 控制器SATA &gt; 右边的添加虚拟硬盘 &gt; 选择转换后的文件在虚拟机打开系统，通过df -h查看发现，根目录还是原样 使用LVM扩展空间在虚拟机上操作因为要修改现有分区，所以要用LVMLVM（Logic Volume Manager）逻辑卷管理，像RedHat系的默认分区管理方式，是建立在硬盘分区之上，文件系统之下的逻辑层，用来解决在最初分区时未正确的评估和和分配分区容量，而造成系统分区不够用。 12345678910111213141516171819202122#查看当前系统分区情况fdisk -l#进行分区fdisk /dev/sda#重读分区表partprobe#将分区格式化为ext4格式mkfs.ext4 /dev/sda3#开始LVM操作,查看卷组名，即VG Name，我这里是centosvgdisplay#创建新物理卷，sda3是之前分区分配的pvcreate /dev/sda3#扩展到卷组vgextend centos /dev/sda3#查看根分区lvdisplay /dev/centos/root就是根分区，也是我们要扩展的分区12345#扩展到容量逻辑分区lvextend /dev/centos/root /dev/sda3#刷新逻辑分区容量resize2fs /dev/centos/root 报错因为我的centos7的某些分区用的是xfs的文件系统（使用df -T查看即可知道）使用xfs_growfs /dev/centos/root代替resize2fs /dev/centos/root 12#查看df -h 参考： 扩充根目录空间：https://www.awaimai.com/1194.html 添加新的挂载点：https://blog.csdn.net/ganshuyu/article/details/17954733 http://www.imooc.com/qadetail/100002]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux配置WordPress]]></title>
    <url>%2Fpost%2F96cee6f3.html</url>
    <content type="text"><![CDATA[安装LAMPhttps://lamp.sh/install.html 创建WordPress数据库和一个用户123456mysql&gt;create database wordpress;//wordpress是数据库名mysql&gt;create user &apos;wordpress&apos;@&apos;localhost&apos; identified by &apos;password&apos;;//wordpress是数据库名，一般使用localhost，password为密码mysql&gt;grant all privileges on wordpress.* to &apos;wordpress&apos;@&apos;localhost&apos;;mysql&gt;FLUSH PRIVILEGES; 下载WordPress安装包并解压12wget http://wordpress.org/latest.tar.gztar -xzvf latest.tar.gz 上传文件默认的网站根目录： /data/www/default将解压好的wordpress文件复制到该目录下 设置wp-config.php文件（这一步可以略过，通过下一步的网页设置）将wordpress目录下的wp-config-sample.php重命名为wp-config.php，并修改以下选项1234567891011121314/** The name of the database for WordPress */define(&apos;DB_NAME&apos;, &apos;wordpress&apos;);/** MySQL database username */define(&apos;DB_USER&apos;, &apos;wordpress&apos;);/** MySQL database password */define(&apos;DB_PASSWORD&apos;, &apos;password&apos;);/** MySQL hostname */define(&apos;DB_HOST&apos;, &apos;localhost&apos;);/** Database Charset to use in creating database tables. */define(&apos;DB_CHARSET&apos;, &apos;utf8&apos;); 使用在浏览器访问：http://ip/wordpress，填写好信息一键安装，安装好后就可以是使用了 参考：https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PR剪辑视频基础操作]]></title>
    <url>%2Fpost%2Fa80ec780.html</url>
    <content type="text"><![CDATA[尝试用PR剪了一个抖音合辑，基本上是不同视频片段的拼接 ##新建选择自定义宽和高，29，往往由素材的大小决定 ##剪辑空白处右键，波纹删除切片工具 ##字幕菜单栏，Title &gt; 静态字幕ctrl+c ctrl+v复制字幕alt替换字幕 ctrl+~(波浪号) 全屏预览]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Mysql]]></title>
    <url>%2Fpost%2F42bdef23.html</url>
    <content type="text"><![CDATA[CentOS通过yum安装查看要对应的yum库，https://dev.mysql.com/downloads/repo/yum/每个安装包下会有一个类似mysql80-community-release-el6-n.noarch.rpm，替换wget对应的链接 添加源12wget https://dev.mysql.com/get/mysql80-community-release-el6-n.noarch.rpmrpm -Uvh mysql80-community-release-el6-n.noarch.rpm 选择mysql安装的版本如果只需要安装最新版mysql，可以跳过这一步12#列出可以安装的版本yum repolist all | grep mysql 可以通过yum-config-manager选择安装的版本12345#安装yum-config-manager，通过yum provides yum-config-manager可以查到在yum-utils包里yum install -y yum-utils#禁用最新的版本，开启需要的版本yum-config-manager --disable mysql80-communityyum-config-manager --enable mysql57-community 也可以直接配置/etc/yum.repos.d/mysql-community.repo将需要使用的版本的enabled设为1，将现在激活的版本设为0123456[mysql80-community]name=MySQL 8.0 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 验证1yum repolist enabled | grep mysql 安装默认选择安装最新的MySQL版本的MySQL，会安装mysql-community-server、client、libs、common1yum install mysql-server 启动12systemctl start mysqldsystemctl status mysqld 初始化因为版本不同，可能第一次登录没有密码，可以先查看以下文件，为空则没有密码，不为空则使用列出的密码1grep &apos;temporary password&apos; /var/log/mysqld.log 使用此命令运行安全脚本，设置root密码，删除匿名用户，禁止远程root用户登录，删除测试数据库并对其进行访问，并重新加载权限表MySQL的 validate_password 插件默认安装。这将要求密码至少包含一个大写字母，一个小写字母，一个数字和一个特殊字符，并且总密码长度至少为8个字符。1mysql_secure_installation Ubuntu安装MySQL1sudo apt install mysql-server mysql-client libmysqlclient-cev]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装PHP]]></title>
    <url>%2Fpost%2F629155b4.html</url>
    <content type="text"><![CDATA[无脑输命令， CentOS 7.2/PHP5.6 12345678910111213yum -y install wgetwget http://hk1.php.net/get/php-5.6.36.tar.bz2/from/this/mirrortar -jxvf php-5.6.36.tar.bz2cd php-5.6.36sudo yum -y install autoconf automake libtool re2c flex bison libxml2 libxml2-devel./configure --profix=/usr/local/php56makemake test#Bug #69958#Bug #70172make install 环境变量 12345678910#只对当前登录用户生效vi ~/.bashrcexport PATH=/usr/local/php56/bin:$PATHsource ~/.bashrc#所有系统用户生效vi /etc/profilePATH=$PATH:/usr/local/php56/binexport PATHsource /etc/profile]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】Hexo中用CSS控制Markdown各列表格宽度]]></title>
    <url>%2Fpost%2F25ce1142.html</url>
    <content type="text"><![CDATA[123456789101112131415161718&lt;style&gt;table th:nth-of-type(1)&#123;width: 10%;&#125;table th:nth-of-type(2)&#123;width: 20%;&#125;table th:nth-of-type(3)&#123;width: 30%;&#125;table th:nth-of-type(4)&#123;width: 40%;&#125;&lt;/style&gt;| 一 | 二 | 三 | 四 || :-: | :-: | :-: | :-: || 1 | 2 | 3 | 4 | table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 20% ; } table th:nth-of-type(3){ width: 30%; } table th:nth-of-type(4){ width: 40%; } 一 二 三 四 1 2 3 4 参考： https://www.jixian.io/2017/10/11/Hexo%E4%B8%AD%E7%94%A8CSS%E6%8E%A7%E5%88%B6Markdown%E5%90%84%E5%88%97%E8%A1%A8%E6%A0%BC%E5%AE%BD%E5%BA%A6/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见服务列表]]></title>
    <url>%2Fpost%2F2690dd73.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 60% ; } table th:nth-of-type(3){ width: 20%; } 服务名称 功能简介 建议 acpid 电源管理接口。如果是笔记本用户建议开启，可以监听内核层的相关电源事件。 开启 anacron 系统的定时任务程序。cron 的一个子系统，如果定时任务错过了执行时间，可以通过 anacron 继续唤醒执行。 关闭 alsasound Alsa 声卡驱动。如果使用 alsa 声卡，开启 关闭 apmd 电源管理模块。如果支持 acpid，就不需要 apmd，可以关闭 关闭 atd 指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用 crond 来进行循环定时任务。 关闭 auditd 审核子系统。如果开启了此服务，SELinux 的审核信息会写入/var/log/audit/audit.log 文件，如果不开启，审核信息会记录在 syslog 中 开启 autofs 让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载 NFS 服务。如果没有 NFS 服务建议关闭 关闭 avahi-daemon Avahi 是 zeroconf 协 议 的 实 现 。 它可以在没有 DNS 服务的局域网里发现基于 zeroconf 协议的设备和服务。除非有兼容设备或使用zeroconf 协议，否则关闭。 关闭 bluetooth 蓝牙设备支持。一般不会在服务器上启用蓝牙设备，关闭它 关闭 capi 仅对使用 ISND 设备的用户有用。 关闭 chargen-dgram 使用 UDP 协议的 chargen server。主要功能是提供类似远程打字的功能。 关闭 chargen-stream 同上。 关闭 cpuspeed 可以用来调整 CPU 的频率。当闲置时可以自动降低 CPU 频率来节省电量。 开启 crond 系统的定时任务，一般的 Linux 服务器都需要定时任务帮助系统维护。建议开启 开启 cvs 一个版本控制系统 关闭 daytime-dgram daytime 使用 TCP 协议的 Daytime 守护进程，该协议为客户机实现从远程服务器获取日期 和时间的功能。 关闭 daytime-stream 同上。 关闭 dovecot 邮件服务中 POP3/IMAP 服务的守护进程。主要用来接收信件， 如果启动了邮件服务则开启，否则关闭 关闭 echo-dgram 服务器回显客户服务的进程。 关闭 echo-stream 同上。 关闭 firstboot 系统安装完成之后，有个欢迎界面，需要对系统进程初始设定。就是这个进程的作用。既然不是第一次启动了，关闭吧 关闭 gpm 在字符终端(tty1-tty6)中可以使用鼠标复制和粘贴。就是这个服务的功能。 开启 haldaemon 检测盒支持 USB 设备。如果是服务器可以关闭，个人机建议开启。 关闭 hidd 蓝牙鼠标、键盘等蓝牙设备检测。必须启动 bluetooth 服务。 关闭 hplip HP 打印机支持，如果没有 HP 打印机关闭吧 关闭 httpd apache 服务的守护进程。如果需要启动 apache，就开启。 开启 ip6tables IPv6 的防火墙，目前 IPv6 协议并没有使用，可以关闭 关闭 iptables 防火墙功能，Linux 中防火墙是内核支持功能。这是服务器的主要防护手段，必须开启。 开启 irda IrDA 提供红外线设备(笔记本，PDA’s，手机，计算器等等) 关闭间的通讯支持。关闭吧 关闭 irqbalance 支持多核处理器，让 CPU 可以自动分配系统中断(IRQ)，提高系统性能。目前服务器多是多核 CPU，请开启。 开启 isdn 使用 ISDN 设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN 已经非常少见，请关闭 关闭 kudzu 该服务可以在开机时进行硬件检测，并会调用相关的设置软件。建议关闭，仅在需要时开启 关闭 lvm2-monitor 该服务可以让系统支持 LVM 逻辑卷组，如果分区采用的是 LVM方式，那么应该开启。建议开启 开启 mcstrans SELinux 的支持服务。建议启动 开启 mdmonitor 该服务用来监测 Software RAID 或 LVM 的信息。不是必须服务，建议关闭 关闭 mdmpd 该服务用来监测 Multi-Path 设备。不是必须服务 关闭 messagebus 这是 Linux 的 IPC(Interprocess Communication，进程间通讯)服务，用来在各个软件中交换信息。个人建议关闭 关闭 microcode_ctl Intel 系列的 CPU 可以通过这个服务支持额外的微指令集。 关闭 mysqld mysql 数据库服务器。如果需要就开启，否则关闭 开启 named DNS 服务的守护进程，用来进行域名解析。如果是 DNS 服务器则开启，否则关闭 关闭 netfs 该服务用于在系统启动时自动挂载网络中的共享文件空间，比如:NFS，Samba 等等。需要就开启，否则关闭 关闭 network 提供网络设置功能。通过这个服务来管理网络，所以开启 开启 nfs NFS(Network File System)服务，Linux 与 Linux 之间的文件共享服务。需要就开启，否则关闭 关闭 nfslock 在 Linux 中如果使用了 NFS 服务，为了避免同一个文件被不同的用户同时编辑，所有有这个锁服务。有 NFS 是开启，否则关闭 关闭 ntpd 该服务可以通过互联网自动更新系统时间，使系统时间永远都准确。需要则开启，但不是必须服务 关闭 pcscd 智能卡检测服务，可以关闭 关闭 portmap 用在远程过程调用(RPC)的服务，如果没有任何 RPC 服务时， 可以关闭。主要是 NFS 和 NIS 服务需要。 关闭 psacct 该守护进程支持几个监控进程活动的工具。 关闭 rdisc 客户端 ICMP 路由协议 关闭 readahead_early 在系统开机的时候，先将某些进程加载如内存整理，可以加快一点启动速度。 关闭 readahead_later 同上 关闭 restorecond 用于给 SELinux 监测和重新加载正确的文件上下文。如果开启 SELinux 则需要开启。 关闭 rpcgssd 与 NFS 有关的客户端功能。如果没有 NFS 就关闭吧。 关闭 rpcidmapd 同上 关闭 rsync 远程数据备份守护进程。 关闭 sendmail sendmail 邮件服务的守护进程。如果有邮件服务就开启，否则关闭 关闭 setroubleshoot 该 服 务 用 于 将 SELinux 相 关 信 息 记 录 在 日 志/var/log/messages 中。建议开启 开启 smartd 该服务用于自动检测硬盘状态。建议开启 开启 smb 网络服务 samba 的守护进程。可以让 Linux 和 Windows 之间共享数据。如果需要则开启 关闭 squid 代理服务的守护进程。如果需要则开启，否则关闭 关闭 sshd ssh 加密远程登陆管理的服务。服务器的远程管理必须使用此服务，不要关闭 开启 syslog 日志的守护进程。 开启 vsftpd vsftp 服务的守护进程。如果需要 FTP 服务则开启，否则关闭 关闭 xfs 这个是 X Window 的字体守护进程。为图形界面提供字体服务，如果不启动图形界面，就不用开启。 关闭 xinetd 超级守护进程。如果有依赖 xinetd 的服务就必须开启。 开启 ypbind 为 NIS(网络信息系统)客户机激活 ypbind 服务进程。 关闭 yum-updatesd yum 的在线升级服务。 关闭 链接: https://pan.baidu.com/s/13cuRwKQ24MmGciC0twAH0Q 密码: 4qg6]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下批量重命名]]></title>
    <url>%2Fpost%2Fe80d20d.html</url>
    <content type="text"><![CDATA[需要命名一些文件，在文件名的前缀加上序列，这些文件的文件包空格、中文思路如下：重命名使用mv命令（不讨论其它重命名命令），需要提供文件名，通过ls命令可以获得文件名，将ls命令得到的文件名分割为数组，在遍历中进行重命名 123456789101112131415161718192021#!/usr/bin/env bash#这样只有一条pathp=&apos;/home/lee/Templates/&apos;path=$(ls -Art $p)# echo $pathIFS=$&apos;\n&apos;#只有加单引号且使用$才是换行符# https://blog.csdn.net/apache0554/article/details/47006609array=($path)i=0while [ $i -lt $&#123;#array[@]&#125; ]do echo $&#123;array[$i]&#125; echo &apos;s&apos; var=$(printf &quot;%03d&quot; $i) # echo $var mv &quot;$&#123;p&#125;$&#123;array[$i]&#125;&quot; &quot;$&#123;p&#125;$&#123;var&#125;$&#123;array[$i]&#125;&quot; let i++done]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务管理]]></title>
    <url>%2Fpost%2F18938cd7.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 60% ; } table th:nth-of-type(3){ width: 20%; } 系统的运行级别 运行级别 含义 0 关机 1 单用户模式，主要用于系统修复 2 不完全的命令行,不含NFS服务 3 完全的命令行 4 系统暴露 5 图形模式 6 重启 123456789101112runlevel#查询系统运行级别#结果：N 3 (当前是3 N是上一次登陆级别)init 5 #修改运行级别vi /etc/inittab #修改系统默认运行级别id:3:initdefault:#修改系统默认运行级别，这里默认是3 服务的分类 独立服务：独立的运行在内存中，一直在运行的 基于xinetd的服务：服务由xinetd来管控，平时不运行，一有访问，先到xinetd，然后由xinetd去调用现在基本上不再使用xinetd。默认没有安装，可以通过yum方式安装xinetd服务，在安装之前使用chkconfig可以查看系统的服务状态，安装完整之后会出现一组xinetd管理的服务，默认都是关闭的。123chkconfig --list #查看xinetd是否安装yum -y install xinetd #安装xinetdchkconfig --list #查看xinetd服务 RPM安装服务和源码包安装服务的区别：安装位置不同 源码包安装在知道位置，一般是/usr/local RPM包安装在默认位置中 目录 说明 /etc/ 配置文件位置 /etc/init.d/ 启动脚本位置 /etc/sysconfig/ 初始化环境配置文件位置 /etc/xinetd.conf xinetd配置文件 /etc/xinetd/ 基于xinetd服务的启动脚本 /var/lib/ 服务产生的数据目录 /var/log/ 日志 查询已经安装的服务 RPM包安装的服务：chkconfig --list查看服务自启动状态，可以看到所有RPM包安装的服务 源码包安装的服务：查看服务安装位置，一般是/usr/local下 服务与端口端口：每个协议都有65536个端口，默认给某个协议提供了端口，那么此端口就不在为其他协议体统服务。在/etc/services中可以查看服务与端口对应关系因为服务与端口的这种一一对应的关系，所以可以通过查询端口来查看服务状态1ps aux #查看系统中运行了哪些服务（包含程序） 查询系统中开启的服务12345678netstat -tlunp -t:列出tcp数据 -u:列出udp数据 -l:列出正在监听的网络服务(不包含已连接的网络服务) -n:用端口号来显示服务，而不是服务名 -p：列出该服务的进程id（PID）netstat -an #查看系统中开了哪些程序和服务占用了端口 服务的启动与自启动服务启动：就是在当前系统中让服务运行，并提供功能。服务自启动：让服务在系统开机或者重启动之后，随着系统的启动而自动启动服务。 推荐统一用配置文件的方式，这样不容易冲突 chkconfig off不需要添加启动级别 xinetd自启动和启动是相通的，相互一致 源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，其中有启动脚本的方法 让源码包的服务能被service命令管理启动：在init.d目录中做个软链接`ln -s /usr/local/apache2/bin/apache /etc/init.d/ 让源码包服务能被 chkconfig 与 ntsysv 命令管理自启动 12345678vi /etc/init.d/apache# chkconfig:35 86 76#指定httpd脚本可以被chkconfig命令管理。#格式： chkconfig ： 运行级别 启动顺序 关闭顺序#description： source package apache #说明，内容随意。把这两句加到/etc/rc.d/init.d/apachetctl 保存(需要带#)然后chkconfig --add apache 源码安装的Apache输入IP地址默认打开的网页是/usr/local/apache2/htdocs/index.htmlrpm包安装的Apache默认打开的是/var/www/html/下的文件，但是默认是没有的，所以打开Apache测试页。当在这个目录下建一个网页后，打开的是新增的网页。 /etc/rc3.d/下面的文件是运行级别3时，系统开启与关闭分别要执行的服务文件，启动顺序与关闭顺序不能和现有的冲突]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Fiddler]]></title>
    <url>%2Fpost%2Fdd92ed66.html</url>
    <content type="text"><![CDATA[安装mono： 1sudo apt install mono-complete 下载Fiddlerhttps://www.telerik.com/download/fiddler 用mono安装它，从提取的目录中运行： 1234mono Fiddler.exe#或者运行mono /path/to/extracted/fiddler/Fiddler.exe]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装Tomcat并部署Java web项目]]></title>
    <url>%2Fpost%2F367a9328.html</url>
    <content type="text"><![CDATA[在Linux上安装JDK略 在Linux上安装FTP略 在Linux上安装Tomcat下载Tomcat，利用FTP上传到服务器上1234567891011121314#解压，位置随意tar -zxvf apache-tomcat-8.0.29.tar.gz#防火墙里面开放8080端口vim /etc/sysconfig/iptables#重启防火墙service iptables restart#启动Tomcat/usr/local/tomcat/bin/startup.sh#tomcat自启动 vim /etc/rc.d/rc.local/usr/local/tomcat/bin/startup.sh Idea打包Java web项目点击Idea左下角，在右侧出现maven project选项，单击maven project选项，出现菜单，选择其中的Lifecycle菜单项，展开，执行里面的package命令即可。在项目文件夹/target/下可以找到 *.war 文件。 将war文件部署到tomcat上 将war文件拷贝到tomcat安装目录的$TOMCAT_HOME/webapps文件夹下。 修改$TOMCAT_HOME/conf/server.xml，在Host配置段中添加类似于如下内容：1&lt;Context path=&quot;/&quot; docBase=&quot;appname.war&quot; debug=&quot;0&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt; docBase=”appname.war”中的appname.war 替换成自己的war的名字。 重启tomcat，然后访问http://localhost:8080/appname 即可。 参考： https://blog.csdn.net/to_baidu/article/details/52823402 https://blog.csdn.net/yums467/article/details/51660683]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装vsftpd]]></title>
    <url>%2Fpost%2Fc81fedea.html</url>
    <content type="text"><![CDATA[记，这篇文章实际是相当复杂的，主要原因是出于安全考虑增加了很多内容，如果只是局域网内使用不需要如此复杂，只需要安装、关闭匿名、指定目录和用户，参考https://fengrenxiaoli.github.io/2018/05/18/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AE%89%E8%A3%85ftp/ vsftpd 的全称是”very secure FTP daemon“，是一款在Linux发行版中最受推崇的FTP服务器程序。特点是小巧轻快，安全易用。 总结起来只有几步 安装 配置文件 防火墙 设置ftp用户 一、安装FTP服务器1234#查看是否已经安装vsftpdrpm -qa | grep vsftpdyum -y install vsftpd 二、手动启动，并使其能够从下次系统启动时自动启动123systemctl start vsftpdsystemctl enable vsftpd#chkconfig vsftpd on 三、允许从外部系统访问FTP服务123firewall-cmd --permanent --zone=public --add-port=21/tcpfirewall-cmd --permanent --zone=public --add-service=ftpfirewall-cmd --reload 四、备份配置文件12cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bakcp /etc/vsftpd.userlist /etc/vsftpd.userlist.bak 五、配置/etc/vsftpd/vsftpd.conf没有的请自行添加12345678910111213anonymous_enable = NO＃禁用匿名登录local_enable = YES＃允许本地登录write_enable = YES＃启用更改文件系统的FTP命令local_umask = 022＃用于本地用户创建文件的umask值dirmessage_enable = YES＃用户首次进入新目录时启用显示消息xferlog_enable = YES＃会保存一个日志文件，详细说明上传和下载connect_from_port_20 = YES＃使用服务器机器上的端口20（ftp-data）进行端口连接xferlog_std_format = YES＃保持标准的日志文件格式listen = NO＃阻止vsftpd在独立模式下运行listen_ipv6 = YES＃vsftpd将监听IPv6套接字而不是IPv4套接字pam_service_name = vsftpd＃vsftpd将使用的PAM服务的名称userlist_enable = YES＃启用vsftpd加载用户名列表tcp_wrappers = YES＃打开tcp FTP基于用户列表文件允许/拒绝对用户的FTP访问默认情况下，如果userlist_enable = YES 并且userlist_deny = YES，在userlist_file=/etc/vsftpd/user_list列出的用户都无法登录访问FTP。 如果userlist_deny = NO，这意味着只有userlist_file = /etc/vsftpd/user_list中明确列出的用户才能登录。 123userlist_enable = YES ＃vsftpd将加载从userlist_file给出的用户名列表userlist_file = /etc/vsftpd/user_list＃存储用户名userlist_deny = NO when users login to the FTP server, they are placed in a chroot’ed jail, this is the local root directory which will act as their home directory for the FTP session only.当用户登录到FTP服务器时，他们被放置在chroot jail里，chroot jail是本地根目录，会作为FTP会话的主目录 限制FTP用户到他们的主目录12chroot_local_user = YES allow_writeable_chroot = YES chroot_local_user = YES意味着本地用户通过默认设置登录后，他们的主目录将被放置在chroot jail中 并且默认情况下，vsftpd不允许chroot jail目录因安全原因而可写，但是，我们可以使用选项allow_writeable_chroot = YES来覆盖此设置。 保存该文件并关闭它 六、配置SELinux12setsebool -P ftp_home_dir on#会报错 set SELinux rule to allow FTP to read/write user’s home directory12345semanage boolean -m ftpd_full_access --on-bash: semanage: command not foundyum provides semanageyum install policycoreutils-pythonsystemctl restart vsftpd 七、测试FTP服务器创建一个FTP用户12useradd -d /home/ftptest -g ftp -s /sbin/nologin ftptestpasswd ftpuser 将用户添加到文件/etc/vsftpd/user_list中12echo ftptest &gt;&gt; /etc/vsftpd.userlistcat /etc/vsftpd.userlist 分别测试匿名用户anonymous、root、ftptest 1234567ftp 192.168.0.203anonymous 530root 530ftptest 230#root因为在/etc/ftpusers目录里所以无法登录，该目录为禁止登录的用户#ftptest进入后，执行ls，可以测试是否为ftptest用户自己的主目录 八、配置不同的FTP用户主目录 使用allow_writeable_chroot=YES具有某些安全隐患，特别是在用户具有上载权限或shell访问权限的情况下。只有当你确切地知道你在做什么时才激活这个选项。需要注意的是，这些安全性影响并不是vsftpd特有的，它们适用于所有提供将本地用户放入chroot jail的FTP守护进程。 注释掉之前的语句1＃allow_writeable_chroot = YES 为用户创建替代本地根目录的目录（ravi您的可能不同），并将所有用户的写入权限移除到此目录123mkdir /home/ftptest/ftpchown nobody：nobody /home/ftptest/ftpchmod a+w /home/ftptest/ftp 修改vsftpd配置文件12user_sub_token = $USER＃将用户名插入本地根目录local_root = /home/$USER/ftp＃定义任何用户本地根目录 重启vsftpd 注意上传命令需要指定目标文件名1ftp put /path/to/local_file remote_file_name 九、开放端口如果使用云服务器，还需要开放端口 FTP服务器使用被动模式，需要先进行配置12345vi /etc/vsftpd/vsftpd.confpasv_enable=YESpasv_min_port=40000pasv_max_port=41000 这里使用阿里云服务器打开控制台，云服务器ECS-&gt;安全组-&gt;配置规则添加21和40000-41000 参考： 重点https://www.kancloud.cn/chandler/bc-linux/52710 http://how2j.cn/k/deploy2linux/deploy2linux-openport/1604.html https://www.tecmint.com/install-ftp-server-in-centos-7/ https://wsgzao.github.io/post/vsftpd/ https://blog.csdn.net/aiynmimi/article/details/77012507]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装Apache]]></title>
    <url>%2Fpost%2Fe76285ac.html</url>
    <content type="text"><![CDATA[安裝Apache1sudo yum install httpd 启动Apache，并且设定为开机自动启动12sudo systemctl start httpdsudo systemctl enable httpd 允许http服务通过防火墙CentOS 7的内置防火墙默认设置为阻止网络流量12345sudo firewall-cmd --add-service=http --permanentsudo firewall-cmd --add-service=https --permanent#sudo firewall-cmd --permanent --add-port=80/tcp#sudo firewall-cmd --permanent --add-port=443/tcpsudo systemctl restart firewalld 重启Apache1sudo systemctl restart httpd.service 配置文件 /etc/httpd/conf/httpd.conf1234567891011DocumentRoot &quot;/var/www/html/example.com/public_html&quot;...&lt;IfModule prefork.c&gt; StartServers 5 MinSpareServers 20 MaxSpareServers 40 MaxRequestWorkers 256 MaxConnectionsPerChild 5500&lt;/IfModule&gt; /etc/httpd/conf.d/vhost.conf12345678910NameVirtualHost *:80&lt;VirtualHost *:80&gt; ServerAdmin webmaster@example.com ServerName example.com ServerAlias www.example.com DocumentRoot /var/www/html/example.com/public_html/ ErrorLog /var/www/html/example.com/logs/error.log CustomLog /var/www/html/example.com/logs/access.log combined&lt;/VirtualHost&gt; 创建上面引用的目录：1sudo mkdir -p /var/www/html/example.com/&#123;public_html,logs&#125; 检查Apache的状态1sudo systemctl status httpd 停止Apache1sudo systemctl stop httpd 参考： https://www.linode.com/docs/web-servers/apache/install-and-configure-apache-on-centos-7/https://www.liquidweb.com/kb/how-to-install-apache-on-centos-7/SELinux：https://www.brilliantcode.net/170/centos-7-install-apache-httpd/SELinux：https://www.brilliantcode.net/145/centos-7-check-selinux-status-enabled-or-not/]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux desktop entriy]]></title>
    <url>%2Fpost%2Fff74c6a5.html</url>
    <content type="text"><![CDATA[在 Windows 平台上，用户可以通过点击位于桌面或菜单上的快捷方式轻松打开目标应用程序。现代 Linux 桌面系统的应用程序是通过*.desktop文件管理的。 一个应用程序对应一个.desktop文件，根据是用户自己可见还是所有用户可见的不同而放在 ~/.local/share/applications或者 /usr/share/applications/ 目录中。 可以自己添加.desktop文件来增加应用程序到launcher里，*.desktop文件格式如下： 1234567891011[Desktop Entry]Encoding=UTF-8Name=火狐浏览器Name[en]=FirefoxName[en_US]=FirefoxComment=Firefox for jasonExec=/opt/firefox/firefoxIcon=/opt/firefox/browser/icons/mozicon128.pngTerminal=falseType=ApplicationCategories=Application;Network; 使用流程： 创建文件，以.desktop为后缀。 编写内容，修改权限 测试是否能双击启动程序 移动到/usr/share/applications/目录下 文件中不能有多余的全角或半角空格，否则会出错 参考： https://linux.cn/article-9199-1.html https://wiki.archlinux.org/index.php/Desktop_entries_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) https://www.ibm.com/developerworks/cn/linux/l-cn-dtef/index.html https://blog.csdn.net/lwjdgl/article/details/49204659]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux用户管理 用户和用户组及配置文件]]></title>
    <url>%2Fpost%2F4ac3f250.html</url>
    <content type="text"><![CDATA[Linux是一个多用户的系统，那么如何保证不同用户之间不冲突，也能保证各个用户的隐私呢，这涉及到了用户管理和权限管理，先讲用户管理 用户用户就是使用操作系统的人，用户分为两类，超级用户和普通用户，而每一个用户都会有一个id，叫UID，系统中实际使用的是UID。 超级用户：root，UID为0 普通用户：UID可以为1-65535（实际没到这么多） 系统用户：对守护进程获取资源进行权限分配，UID在1-499之间（实际是设置的，不一定是500，CentOS 6: ID&lt;500，CentOS 7: ID&lt;1000） 登录用户：能够交互式登录的用户，UID在500+ 虚拟用户：不能登录的用户，比如vsftp 用户组用户组就是具有相同系统权限的一组用户，用户组分为基本组（主组）和附加组（额外组），其中基本组的组名和用户名是一样的，是在创建用户的同时创建的，该组只包含该用户，为用户的私有组 用户可以同时属于多个组，一个是主要组，其他的为附属组 配置文件配置文件有这么四个，用户和组，用户密码和用户组密码 /etc/passwd：用户及其属性信息 /etc/group：组及其属性信息 /etc/shadow：用户密码及相关属性 /etc/gshadow：组密码及其相关属性 /etc/passwd这个文件存储当前系统中所有用户的信息，passwd命令可以修改用户密码，man 5 passwd可以查看对应的/etc/passwd格式 user : x : 123 ： 456 ： xxxx ：/home/user ： /bin/bash用户名 : 密码占位符 : 用户编号UID : 用户组编号GID : 注释信息 ：用户主目录 ： shell类型 /etc/group这个文件存储当前系统中所有用户组的信息，man 5 group可以查看该文件的说明 Group ： x ： 501 ： abc,def,xyz组名称 ：组密码占位符 : 组编号GID ：以当前组为附加组的用户列表(分隔符为逗号) /etc/shadow存储当前系统中所有用户的密码信息，使用命令man 5 shadow查看该文件的说明 用户名:加密了的密码:最近一次更改密码的日期:密码的最小使用期限:最大密码使用期限:密码警告时间段:密码禁用期:账户过期日期:保留字段 最后一次更改密码的日期 最近一次更改密码的时间，表示从1970年1月1日开始的天数。 0 有特殊意思，表示用户应该在下次登录系统时更改密码。 空字段表示密码年龄功能被禁用。 密码的最小年龄 最小密码年龄是指，用户一次更改密码之后，要等多长时间才再次被允许更改密码。 空字段或 0 表示没有最小密码年龄。 最大密码年龄 最大密码年龄是指，这写天之后，用户必须更改密码。 这写天之后，密码仍然可用。用户将会在下次登录的时候被要求更改密码。 空字段表示没有最大密码年龄，没有密码警告时间段，没有密码禁用时间段。 如果最大密码年龄小于最小密码年龄，用户将会不能更改密码。 密码警告时间段 密码过期之前，提前警告用户的的天数(请参考上边的密码的最大年龄)。 空字段或者 0 表示没有密码警告期。 密码禁用期 密码过期(查看上边的密码最大年龄)后，仍然接受此密码的天数(在此期间，用户应该在下次登录时修改密码)。 密码到期并且过了这个宽限期之后，使用用户的当前的密码将会不能登录。用户需要联系系统管理员。空字段表示没有强制密码过期。 账户过期日期 账户过期的日期，表示从1970年1月1日开始的天数。 注意，账户过期不同于密码过期。账户过期时，用户将不被允许登录；密码过期时，用户将不被允许使用其密码登录。 空字段表示账户永不过期。 应该避免使用 0，因为它既能理解成永不过期也能理解成在1970年1月1日过期。 !!表示禁止登录 加密机制加密：明文–&gt; 密文解密：密文–&gt; 明文 单向加密：提取数据指纹 md5: message digest, 128bits sha1: secure hash algorithm, 160bits sha224: 224bits sha256: 256bits sha384: 384bits sha512: 512bits 雪崩效应：初始的条件的微小改变，将会引起结果的巨大改变；定长输出：不同长度的密码会输出相同长度的密文如果密码相同也是不一样的，因为会在密码中添加一个随机的字符串 密码的复杂性策略： 使用数字、大写字母、小写字母及特殊字符中至少3种； 足够长； 使用随机密码； 定期更换；不要使用最近曾经使用过的密码； /etc/gshadow存储当前系统中用户组的密码信息Group： * ： ：abc,def,xyz组名称： 组密码 ：组管理者：组中用户名列表 参考： https://www.thegeekdiary.com/understanding-etclogin-defs-file/]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux用户管理03 配置文件]]></title>
    <url>%2Fpost%2F4ac3f250.html</url>
    <content type="text"><![CDATA[用户：使用操作系统的人用户组：具有相同系统权限的一组用户 用户和用户组配置文件12345678910111213141516171819202122232425/etc/group 存储当前系统中所有用户组的信息-Group： x ： 501 ：abc,def,xyz-组名称：组密码占位符 ： 组编号：组中用户名列表组编号1-499是系统预留给软件的手动创建的用户从500开始/etc/gshadow 存储当前系统中用户组的密码信息-Group： * ： ：abc,def,xyz-组名称： 组密码 ：组管理者：组中用户名列表/etc/passwd 存储当前系统中所有用户的信息-user： x ： 123 ： 456 ： xxxxxxxx ：/home/user ： /bin/bash-用户名：密码占位符：用户编号： 用户组编号： 用户注释信息：用户主目录 ：shell类型/etc/shadow 存储当前系统中所有用户的密码信息-user ： vf;/Zu8sdf... ：：：：：-用户名 ： 密码 ：：：：：]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux用户管理 查看用户命令]]></title>
    <url>%2Fpost%2Fd4f799aa.html</url>
    <content type="text"><![CDATA[查看用户whoami 显示当前登录用户名1whoami who 查看系统当前所有的登录会话1234who 用户名登录名登陆终端登录时间（登陆来源IP地址） w 查看系统当前所有的登录会话及所做的操作12345678910w 用户名user 登陆的用户名tty 登陆终端from 从哪个IP地址登陆login@ 登陆时间idle 用户闲置时间jcpu 和终端连接所有进程占用的时间pcpu 当前进程所占用的时间what 正在运行的命令 id 查看用户相关的ID信息12345id [OPTION]... [USER]-u UID-g GID-G Groups-n Name 显示指定用户信息，包括用户编号、用户编号、主要组编号及名称、附属组列表 su 切换用户或以其他用户身份执行命令123456789101112131415su [options...] [-] [user [args...]]切换用户的方式：su UserName：非登录式切换，即不会读取目标用户的配置文件 echo $PATH显示自身的环境变量su - UserName：登录式切换，会读取目标用户的配置文件；完全切换 echo $PATH显示目标用户的环境变量Note：root su至其他用户无须密码；非root用户切换时需要密码；# 换个身份执行命令：su [-] UserName -c &apos;COMMAND&apos;选项：-l “su -l UserName”相当于“su - UserName” last 查询当前和过去登录的用户信息123456last 默认读取var/log/wtmp用户名登录终端登陆IP登录时间退出时间（在线时间） lastlog 查看所有用户最后一次登录信息123456lastlog lastlog命令默认是读取/var/log/lastlog文件内容用户名登录终端登陆ip最后一次登陆时间 其他命令12345678touch /etc/nologin #在etc目录下创建一个nologin文件(文件内容无关紧要)，暂时禁止除管理员外的用户登录wall [想说的话] 相当于喇叭广播的功能talk [用户名] 聊天框里聊天write [用户名] 相当于密聊who am i #显示登录用户groups 用户名 #显示用户所在的所有组，包括主要组和附属组]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux管理用户命令]]></title>
    <url>%2Fpost%2Fdcf68b37.html</url>
    <content type="text"><![CDATA[管理命令useradd 创建用户1234567891011121314useradd [options] LOGIN选项：-u UID [UID_MIN, UID_MAX], 定义在/etc/login.defs-g GID 指明用户所属基本组，可为组名，也可以GID，组必须存在-c &quot;COMMENT&quot; 用户的注释信息-d /PATH/TO/HOME_DIR 以指定的路径为家目录-s SHELL 指明用户的默认shell程序，可用列表在/etc/shells文件中-G GROUP1[,GROUP2,...[,GROUPN]]] 为用户指明附加组；组必须事先存在-r 创建系统用户-D 修改默认值，默认值设定在/etc/default/useradd文件中，也可以直接改文件useradd 用户名 #添加用户，所在用户组与用户名同名，uid默认为最近的一个+1useradd -g 组名 用户名 #添加用户，指定其所在的组useradd -d 目录 用户名 #添加用户，指定用户的家目录 注意：使用-d选项时，指定的目录不能是已经存在的，每次创建新用户都会在家目录下复制一些配置文件，比如.bashrc，如果使用已经存在的目录就没有相应的文件会出错，/etc/ske1/下即为需要复制的文件 /etc/login.defs文件中包含了以下信息： 用户邮箱的位置 密码时效控制 UID选择的最小值和最大值（1000到60000） GID选择的最小值和最大值（1000至60000） 添加新用户时是否应创建主目录 默认的umask 用于加密密码的加密方法 useradd和adduser的区别useradd是系统编译的本地二进制文件adduser是一个使用useradd制作的perl脚本 adduser比useradd更友好，所提供的功能没有区别 在使用adduser命令时，它会添加这个用户名，并创建和用户名名称相同的组名，并把这个用户名添加到自己的组里去，并在/home目录想创建和用户名同名的目录，并拷贝/etc/skel目录下的内容到/home/用户名/的目录下，并提示输入密码，并提示填写相关这个用户名的信息。用adduser这个命令创建的账号是普通账号，可以用来登陆系统。1adduser wo 在使用命令useradd时，它会添加这个用户名，并创建和用户名相同的组名，但它并不在/home目录下创建基于用户名的目录，也不提示创建新的密码。也就是说使用useradd mongo 创建出来的用户，将是默认的”三无“用户，无家目录，无密码，无系统shell，换句话说，它创建的是系统用户，无法用它来登陆系统。12345678910111213useradd wo#要用useradd创建的用户登陆系统则需要以下操作passwd womkdir wochown -R wo:wo /home/wo/#修改wo的登陆Shell为/bin/bashusermod -s /bin/bash wotail -1 /etc/passwd#将/etc/skel目录下的文件复制到该用户目录下cp -r /etc/skel /home/wo 也可以直接指定参数1234useradd -d /home/wo -m -s /bin/bash wo#-m 强制建立用户主文件夹-d 用户主文件夹 指定用户登录所进入的目录，并赋予用户对该目录的的完全控制权s shell 用户登录所使用的shell 实际中根据发行版的不同，配置的不同也会有区别 usermod 修改用户属性1234567891011121314151617181920usermod [OPTION] login选项：-u UID 新UID-g GID 新基本组-G GROUP1[,GROUP2,...[,GROUPN]]] 新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项，表示append-s SHELL 新的默认SHELL-c &apos;COMMENT&apos; 新的注释信息-d HOME 新的家目录；原有家目录中的文件不会同时移动至新的家目录；若要移动，则同时使用-m选项-l login_name 新的名字-L lock指定用户，会在密码前加一个!-U unlock指定用户-e YYYY-MM-DD 指明用户账号过期日期-f INACTIVE 设定非活动期限usermod -c 注释信息 用户名 #为指定用户名添加注释usermod -l 新用户名 旧用户名 #更改用户名usermod -d 目录 用户名 #更改用户个人文件夹的路径usermod -g 新用户组 用户名 #更改指定用户的基本组 userdel 删除用户12345userdel [OPTION]... login-r 删除用户家目录userdel 用户名 #删除用户，但是不删除用户个人文件夹里的文件userdel -r 用户名 #删除用户并且删除用户个人文件夹里的文件 passwd 给用户添加密码1234567891011121314passwd [OPTIONS] UserName: 修改指定用户的密码，仅root用户权限passwd: 修改自己的密码选项：-l 锁定指定用户-u 解锁指定用户-n mindays 指定最短使用期限-x maxdays 最大使用期限-w warndays 提前多少天开始警告-i inactivedays 非活动期限，一个用户账户密码已经过期inactivedays天之后，用户将不能再登录进账户--stdin：从标准输入接收用户密码 echo &quot;PASSWORD&quot; | passwd --stdin USERNAME pwck 检查密码的有效性groupadd 创建组1234groupadd [OPTION]... group_name选项：-g GID 指明GID号；[GID_MIN, GID_MAX]-r 创建系统组 groupmod 修改组属性1234567groupmod [OPTION]... group选项：-n group_name 新名字-g GID 新的GIDgroupmod -n 新组名 原组名 #更改用户组名称groupmod -g 组编号 组名 #设置用户组编号 groupdel 删除组前提是用户组内没有用户1groupdel GROUP gpasswd 管理/etc/gpasswd和/etc/gshadow123456789gpasswd [OPTION] GROUP选项：-a user 将user添加至指定组中-d user 删除用户user的以当前组为组名的附加组-A user1,user2,... 设置有管理权限的用户列表gpasswd -a 用户名 附属组 #给用户添加附属组gpasswd -d 用户名 附属组 #把用户从附属组中删除gpasswd 用户名 #更改组密码，回车会有相应的提示操作 newgrp 临时切换基本组1newgrp 组名 用户创建的文件默认为主要组；需要以附属组创建文件的，需将身份切换到附属组把用户的组切换到附属组，需要用户登录后，自己执行，切换组密码是在组切换时用的，如果有会要求输入组密码如果用户属于此组，则不需要组密码 chage 修改用户属性12345678chage [OPTION]... LOGIN选项：-d LAST_DAY-E, --expiredate EXPIRE_DATE-I, --inactive INACTIVE-m, --mindays MIN_DAYS-M, --maxdays MAX_DAYS-W, --warndays WARN_DAYS chsh 更改登录shell1234567chsh [Option] login选项：-l 列出可用的shell-s shell 指定shellchsh -l #列出所有shellchsh user1 #修改user1的登录shell chfn\finger 用户资料12chfn 用户名 #设置用户资料，依次输入用户资料finger 用户名 #显示用户详细资料，与chfn对应 参考： https://segmentfault.com/a/1190000007316406 https://askubuntu.com/questions/345974/what-is-the-difference-between-adduser-and-useradd https://my.oschina.net/lyp82nlf/blog/477319]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理06 swap分区]]></title>
    <url>%2Fpost%2F92783d86.html</url>
    <content type="text"><![CDATA[为磁盘添加SWAP交换分区 1.首先建立一个普通的Linux分区123fdisk /dev/sdb#参考MBR分区#输入p查看sdb的分区 2.修改分区类型的16进制编码12345输入t，输入要修改的磁盘编号 这里是 6（sdb6的6）；输入 L 来查看可以修改成的类型再输入82（Linux swap）,保存成功输入p来查看已经保存的情况输入w保存分区 3.格式化交换分区1mkswap（后面跟随设备名称） /dev/sdb6 完成格式化 4.启动交换分区123swapon /dev/sdb6 #启动交换分区free #查看加载状况swapoff /dev/sdb6 #关闭交换分区]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理05 挂载命令]]></title>
    <url>%2Fpost%2Ffd9a4071.html</url>
    <content type="text"><![CDATA[mount 命令123456789101112mount #查看系统中已挂载的设备mount -a #依据配置文件/etc/fstab内容，自动挂载 #光盘、U盘的数据不建议写入自动挂载中，否则开机时没有光盘和U盘的话，系统崩溃mount [-t 文件系统] [-o 特殊选项] [设备文件名] [挂载点]-t：加入文件系统类型来指定挂载的类型，ext3,ext4,iso9660等文件系统-o：可以指定挂载的额外选项mount -o remount，noexec /home#/home内的执行文件无法执行mount -o remount，exec /home ###挂载光盘1234mkdir /mnt/cdrom/ #建立挂载点mount -t iso9660 /dev/sr0 /mnt/cdrom #/dev/sr0是光盘设备名，也可以用/dev/cdrom（sr0的软连接，但需要系统完全启动才能用） -t iso9660 可以省略 因为系统知道sr0是iso9660 ###卸载1234umount [设备文件名或挂载点] umount /mnt/cdrom umount /dev/sr0 #都可以 卸载时位置不能在光盘目录下 ###挂载U盘123456789fdisk -l #查看U盘设备文件名 #U盘可以看成系统的第二块硬盘mount -t vfat /dev/sdb1 /mnt/usb/ #-t vfat windows的fat32文件系统注：linux默认不支持ntfs文件系统，所以移动硬盘正常没法挂载，能挂载后也只能读，不能写，所以用windows数据一般用网络传播#解决办法1. 编译内核 让linux 支持NTFS文件系统 2. 安装ntfs-3g 手动挂载分区手动挂载的分区，不具有永久性，系统重启后，挂载就会失效12345678910# 没有挂载无法使用，分区默认的挂载目录是/mnt目录sudo fdisk -l#查看系统的硬盘和硬盘分区情况，了解需要的设备，比如移动硬盘/U盘/windows下的分区/光盘sudo mkdir -p /media/usb#创建挂载目录sudo mount /dev/sdb /media/usb#挂载sudo umount /dev/sdb#卸载 永久挂载1vim /etc/fstab]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理04 格式化]]></title>
    <url>%2Fpost%2F5dc8807e.html</url>
    <content type="text"><![CDATA[格式化：又称逻辑格式化，它是指根据用户选定的文件系统（eg：FAT16（最大支持2GB分区），FAT32（单个文件大小不能超过4GB，最大支持16TB分区），NTFS，EXT2，EXT3，EXT4（centos6默认文件系统）等），在磁盘特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。 格式化的目的并不是清空数据，其根本目的是为了写入文件系统，能够更快查找读写数据，但是在进行格式化的操作时会先清空原有数据。 格式化具体进行的操作：将整个分区分割成等大小的数据块（Block），每个数据块默认4KB，存储文件的最小，可以手动选择1KB、2KB或4KB。假设存放10KB的文件，会使用3个数据块，三个数据块不一定是连续的，最后的一数据块中即使没有放满，也不能再存放其他文件。在分区列表中建立一个二维表格，记录了文件的id号（即文件放在那些数据库中，叫做iNode）、文件修改时间、文件的访问权限。操作文件时先访问此二维表进行权限匹配。 parted工具可以格式化，但是parted支持的文件系统有限无论使用MBR，还是GPT进行的分区，都可以使用”mkfs”进行分区格式化 123mkfs (-make for system)mkfs -t ext3 /dev/sda6 #将sda6分区格式化为ext3格式mkfs -t ext2 /dev/sda7 #将sda7分区格式化为ext2格式 MBR只有主分区和逻辑分区可以格式化， 扩展分区不可以格式化GPT类型格式化后，使用fdisk看不到各个分区的系统文件格式， 必须启动parted工具的print指令来查看 1ls -l /dev/sdb #查看sdb磁盘上的设备情况]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理03 GPT分区]]></title>
    <url>%2Fpost%2F5379c247.html</url>
    <content type="text"><![CDATA[MBR分区模式和GPT分区模式比较MBR 区容量最大2TB 分区命令fdisk /dev/sdxx 分区完毕，执行-w 写入分区表才能生效 分区表类型是：msdos 缺点：限制多，跟不上发展 GPT 主分区个数”几乎”没有限制（最多128个） 单个分区容量”几乎”没有限制(最大18EB) 使用parted命令工具（同时支持MBR,GPT分区） 分区表类型是：gpt 1EB=1024PB,1PB=1024TB,1TB=1024GB 缺点：GPT主分区中不适合安装x86的系统架构 使用parted进行分区fdisk只能给硬盘做MBR分区parted既能给硬盘做MBR分区，又能做GPT分区 123456789101112131415161718192021222324输入parted命令，启动parted分区工具，默认分区目标是系统的第一块硬盘输入help，查看帮助信息输入select /dev/sdc，切换分区目标磁盘输入mklable命令，给目标硬盘指定分区表的类型，然后才能给硬盘添加分区如果使用MBR分区，输入mklabel msdos；使用GPT分区，输入mklabel gpt输入print 查看当前分区详情；输入print all命令，查看所有分区详情parted分区操作模式：①交互模式（使用提问模式选择） ②命令模式**交互模式**输入mkpart #添加分区输入分区名称选择分区系统类型分区从第几MB开始，4K对齐对硬盘分区很重要，为了达到最佳性能，分出1MB空间，让数据块对齐结束位置**命令模式**命令模式下，分区名称不能省略mkpart test(分区名称) 2000(开始位置2000MB) 3000(结束位置MB)rm [分区编号] #删除分区unit GB #使用GB给分区指定开始和结束位置quit #退出分区工具 fdisk分区设计完成后 最后要通过w来写入硬盘,parted不需使用w保存]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理02 MBR分区]]></title>
    <url>%2Fpost%2F5a979475.html</url>
    <content type="text"><![CDATA[硬件设备都是由Linux系统自动识别的，必须对硬盘进行分区、格式化、挂载后才能使用 分区的意义：http://www.cnblogs.com/personnel/p/4584926.html Windows与Linux的磁盘使用流程 Windows：分区–&gt;格式化–&gt;分配盘符 Linux：分区–&gt;格式化–&gt;给每个分区起“设备文件名”–&gt;分配挂载点 MBRMBR=主引导区记录。硬盘的0磁道的第一个扇区称为MBR，它的大小是512字节，而这个区域可以分为三个部分。第一部分为pre-boot区（预启动区），占446字节；第二部分是Partition table区（分区表），占64个字节，硬盘中分区有多少以及每一分区的大小都记在其中。第三部分是magic number，占2个字节，固定为55AA。 MBR是针对整个硬盘而言的，而引导扇区是对单个分区而言的。每个分区的第一扇区就是引导扇区：像MBR一样，引导扇区里包含了一些引导操作系统所需要的相关信息。如果引导扇区被破坏了是个非常严重的问题，那就意味着这个分区不能被访问，安装在这个分区上的操作系统也不能被启动。所以说修复引导是使得每一个分区都能被正确识别引导。 ##MBR分区类型（所有系统都适用）： 主分区最多只能分4个，由硬盘的结构决定（硬盘分为一个个等大小的扇区，每个扇区512字节，其中446个字节用于记录启动信息， 剩下的64个字节进行分区表示，64个字节中每16个字节表示一个分区，所以最多只能表示4个分区，故而硬盘结构如果不变，主分区最多只能分4个）。每个主分区都有各自独立的引导块，可以用fdisk设定为启动区。 Windows下A、B作为软分区的盘符，C作为第一个主分区的盘符，所以最多还能分23个子分区。 ####扩展分区 一块硬盘中扩展分区只能有一个 主分区和扩展分区总数不能超过4个 可以将一个主分区作为扩展分区，即三个主分区，一个扩展分区，总计4个分区； 不能直接写入数据，只能用作包含逻辑分区。 区分扩展分区和逻辑分区，是突破主分区只能有4个的最主要的方法。 逻辑分区可以有多个，没有独立的引导块，不能用fdisk设定为启动区。 设备文件名Linux中一切皆文件，包括硬件、用户等。硬件的文件名即称作“硬件设备文件名”，硬件设备文件名作为硬件的标准称呼，是由Linux自动检测并分配的。硬件设备文件在目录中处于根目录（“/”代表根目录，最高级目录）下的dev文件夹（专用于放硬件设备文件）下，即“/dev”文件夹下。 分区的设备文件名分配规则hd代表IDE接口，sd代表SCSI接口或SATA接口；a代表第一块硬盘，如有多块硬盘b代表第二块硬盘，c代表第三块硬盘，以此类推；1代表一块硬盘上的第一个分区，2代表此硬盘的第二个分区，3代表此硬盘第三个分区，以此类推，其中1234编号只能代表主分区或扩展分区，逻辑分区的编号从5开始分配，最大分区编号16/dev/sda1 第一块SATA接口硬盘的第一个分区 挂载点Windows中使用字母标识符来指定在这个分区上的文件和目录，而Linux中使用目录作为挂载点（盘符）绝大多数目录都可以作为挂载点（部分必须和根目录放在同一个分区的目录除外，否则将导致系统不能启动）包括你手工创建的目录。 ##Linux 分区 ####必须分区： 根分区 /（挂载点根目录，根目录中要保存其他所有数据，根目录如果没有硬盘空间，根下的很多数据将没有地方存放）swap分区（交换分区，可理解为虚拟内存， 当真实内存不足时，可将swap分区中的硬盘空间作为内存使用，如果内存小于等于4GB，推荐swap分配内存的两倍，若内存大于4GB，建议swap空间与内存相等，不需要挂载点，swap分区不是给用户看的，是系统直接调用的所以无挂载点） 注：启动分区/boot需不需要创建要看实际情况，需要使用LVM时，由于/boot分区不支持lvmfs，所以要单独创建，这个目录是系统文件，一般不会动，但不要太小，如果升级内核可能就满了。个人使用没有必要 使用 “fdisk”命令进行硬盘分区123456789101112131415161718192021fdisk /dev/sdb 进入sdb硬盘分区模式输入m，查看命令帮助信息新建分区输入n，给硬盘添加一个新的分区输入p，主分区输入e，扩展分区，扩展分区不能直接使用，需要添加逻辑分区输入l，扩展分区只能有一个，不能再分扩展分区了，所以显示的是逻辑分区，5代表分区的编号从5开始给分区指定编号，1-4是预留给主分区或者扩展分区的Partition number( 1-4,defautl 1):给这个分区指定扇区发起始和终止位置扇区的起始位置： First sector (2048 - 16777215，default 2048):不输入默认2048扇区的终止位置：Last sector,+sectors or +size&#123;K,M,G&#125;&#123;2048-16777215,default 16777215&#125;:3000MCommand(m for help):输入p查看已经分好的区Command(m for help):输入n 继续添加分区删除分区： 输入d，随后输入删除的分区号逻辑分区是在拓展分区之内的，如果删除的拓展分区，随之而然的逻辑分区也被删除写入分区：输入w，直接就是保存并生效了； 参考： https://shengbao.org/691.html http://blog.51cto.com/13323775/2053921]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理01 基本命令]]></title>
    <url>%2Fpost%2Fe32f53bc.html</url>
    <content type="text"><![CDATA[df12345678df：查看磁盘分区使用状况-l：仅显示本地默认磁盘（默认）-a：显示所有文件系统的磁盘使用情况-h：以1024进制计算最合适的单位显示磁盘容量（默认KB显示）-H：显示以1000进制计算最合适的单位显示磁盘容量-T：显示磁盘分区类型-t：显示指定类型文件系统的磁盘分区 //如：df -t ext4-x：不显示指定类型文件系统的磁盘分区 du123456789du 统计磁盘上的文件大小-b 以byte为单位统计文件 //统计出来的都是四舍五入的大小-k 以KB为单位统计文件 //统计出来的都是四舍五入的大小-m 以MB为单位统计文件 //统计出来的都是四舍五入的大小-h 按照1024进制以最适合的单位统计文件-H 按照1000进制以最适合的单位统计文件-s 指定统计目标 du -s tmpdu -sb *.zip]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux su root和sudo su]]></title>
    <url>%2Fpost%2F6b4d1db7.html</url>
    <content type="text"><![CDATA[来自https://askubuntu.com/questions/86095/does-executing-sudo-su-and-su-root-do-the-same-thing?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa Does executing sudo su and su root do the same thing?What are the technical differences between the two? The only thing I noticed is that sudo surequires you to enter your own password (assuming you’re not root) su rootrequires you to enter root’s password. However both seem to log you into the root user account. The second command cannot be executed in a default Ubuntu installation, where the root account is not enabled. But supposing you have unlocked the root account giving him a password, the two commands could only differ in the environment and shell variable set, I think. Compare the output of env in the two situations, and maybe also the output of set to see the differences.]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 关机和重启]]></title>
    <url>%2Fpost%2F3ae572a2.html</url>
    <content type="text"><![CDATA[关机shutdown （建议使用）123456789101112131415161718shutdown [选项] 时间#相比其它命令更安全，在关机和重启时会正确保存正在运行的程序选项：-c 取消前一个关机命令-h 关机（halt）-r 重启时间: now 立刻+m 相对时间表示法，从命令提交开始多久之后，例如 +3hh:mm 绝对时间表示，指明具体时间shutdown -r 05:30 5:30重启shutdown -r 05:30 &amp; 后台运行shutdown -r now 立刻重启shutdown -r +30 30分钟后关机# 在服务器上尽量避免远程关机，因为再开机麻烦，所以远程重启就足够了# 服务器由于经常进行高速运算强制重启非常容易损坏硬件，也容易造成数据丢失，所以一定要小心 haltpoweroffinit 0 重启shutdown -r Timereboot123reboot-f: 强制，不调用shutdown-p: 切断电源 init 6退出登录命令123logout # LINUX默认同时256个登录，最大支持6万多# 每次使用后，建议退出当前用户，避免他人因账户占用无法使用！与windows中的注销相似！ 注意：如果关闭远程登录xshell时直接点X，该用户就卡在计算机里，因为没有正确退出，所以一定养成正确退出登录的习惯]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux文件管理01 文件和文件系统]]></title>
    <url>%2Fpost%2F9ffd3055.html</url>
    <content type="text"><![CDATA[文件linux中一切皆文件，目录为目录文件。普通文件用来保存数据，目录文件用来保存文件 文件有两类数据 元数据、metadata 元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode…)等等。 数据、data 数据是指普通文件中的实际数据。 文件名 文件名严格区分字符大小写；file1, File1, FILE1是不同的文件 文件名可使用除/以外的任意字符，不建议使用特殊字符 - /: 表示根目录，也用做路径分隔符 文件名长度最长不能超过255个字符 所以.开头的文件，均为隐藏文件 Linux下的文件类型 f 普通文件 d 目录文件 b 块设备 c 字符设备 l 符号链接文件 p 管道文件 s 套接字文件，socket 文件系统文件系统层次结构标准（Filesystem Hierarchy Standard，FHS）定义了Linux操作系统中的主要目录及目录内容。在大多数情况下，它是一个传统BSD文件系统层次结构的形式化与扩充。 设计FHS的目的是为了给Unix-like系统的管理员提供一个管理系统以及目录结构的参考。 由于利用Linux源码开发产品和发行版的企业或组织众多，如果每个组织都按照自己的喜好来组织系统中的文件结构，网络上必然出现各种各样的文件结构。这些产品的用户就不得不为每种不同的文件系统结构花费时间来学习。有了FHS之后，几乎所有的Unix-like系统的发行商或软件开发者都遵从该建议规范每个特定目录下分别只放哪些文件，方便了文件的组织和查找。 详细内容参考：https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf 根文件系统(rootfs)root filesystem /根目录是整个系统最重要的一个目录，因为在Linux系统中所有的目录都必须挂载在根目录下，也即所有的目录都是由根目录衍生出来。系统开机时所需要的开机软件、内核文件、函数库等都必须在根目录下。因此FHS也建议根目录不要安装在非常大、数据存取非常活跃的分区上，如此一来就能尽可能地降低系统不必要的错误。 FHS(Filesystem Hierarchy Standard) 目录 说明 /boot 引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader：grub)都存放于此目录 /bin 命令保存目录（普通用户就可以读取的命令）；不能关联至独立分区，OS启动即会用到的程序 /sbin 命令保存目录（超级用户才能使用的目录）；不能关联至独立分区，OS启动即会用到的程序 /lib 基本共享库文件，以及内核模块文件(/lib/modules)，为系统启动或根文件系统上的应用程序（/bin, /sbin）提供共享库（libc.so. ld），以及为内核提供内核模块（modules） /lib64 专用于x86_64系统上的辅助共享库文件存放位置 /etc 配置文件目录(纯文本文件，不能是二进制) /home/USERNAME 普通用户家目录 /root 管理员的家目录 /media 便携式移动设备挂载点(cdrom、usb) /mnt 临时文件系统挂载点 /dev 设备文件及特殊文件存储位置b: block device，随机访问 c: character device，线性访问 /opt 第三方应用程序的安装位置 /srv 系统上运行的服务用到的数据 /tmp 临时文件存储位置 /usr unix software resource，根据FHS建议软件安装后将他们的数据合理地分别放置到这个目 录下，而不要自行新建该软件自己的独立目录。 /usr/bin 保证系统拥有完整功能而提供的应用程序；供普通用户使用的系统命令 /usr/sbin 供超级用户使用的系统命令 /usr/lib /usr/lib64 /usr/include C程序的头文件(header files) /usr/share 结构化独立的数据，例如命令手册页man和自带文档doc等 /usr/src 程序的源码 /usr/local 第三方应用程序的安装位置/var/(bin, sbin, lib, lib64, etc, share) /var variable data files，可变数据文件，主要存储常变化的文件，包括缓存(cache)、登录 文件(logfile)以及某些软件运行所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等 /var/cache 应用程序产生的缓存文件 /var/lib 程序执行过程中，需要用到的数据文件放置的目录。此目录下各自的软件应该要有各自的目录 /var/local 专用于为/usr/local下的应用程序存储可变数据 /var/lock 锁文件，某些设备或者文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该 设备时，就可能产生一些错误，因此就得要将该设备或文件上锁(lock)，以确保该文件或设备只给一个程序使用 /var/log 日志目录及文件，/var/log/messages, /var/log/wtmp /var/mail 个人电子邮箱目录，通常与/var/spool/mail/目录互为链接 /var/opt 专用于为/opt下的应用程序存储可变数据 /var/run 运行中的进程相关的数据；通常用于存储进程的pid文件 /var/spool 应用程序数据池，存放等待其他程序使用的数据 /var/tmp 下次启动前会被删除的临时数据 /proc 用于输出内核与进程信息相关的虚拟文件系统，内核级进程存储其相关信息，多为内核参数，例 如net.ipv4.ipforward虚拟为net/ipv4/ipforward，存储于/proc/sys /sys 用于输出当前系统上硬件设备相关信息的虚拟文件系统，sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径；为管理内核提供了一种统一模型的接口 /selinux security enhanced Linux，selinux相关的安全策略等信息的存储位置 Linux上的应用程序的组成部分1234二进制程序：/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin库文件：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64配置文件：/etc, /etc/DIRECTORY, /usr/local/etc帮助文件：/usr/share/man, /usr/share/doc, /usr/local/share/man, /usr/local/share/doc 说明1234/usr/bin/ /usr/sbin/ /bin /sbin 这四个目录都是用来保存系统命令。其中，bin目录下的命令任何用户都可以执行，sbin目录下只有root才可以执行。linux使用此方式来区分用户权限。 FHS根据文件的可共享、不可共享、静态和动态等特点，将目录树架构分为/、/usr、/var三部分。参考这里 / (root, 根目录)：与开机系统有关 /usr (unix software resource)：与软件安装/执行有关 /var (variable)：与系统运作过程有关/usr放置的数据属于可分享的且不可变动的，/usr可分享给局域网内的其他主机来使用。 /proc、/sys，这两个目录保存的是内存的挂载点，不能直接操作。其中的数据直接写在内存中。避免数据丢失或由于内存溢出导致系统崩溃 参考： http://www.178linux.com/62805 https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86 http://wiki.jikexueyuan.com/project/learn-linux-step-by-step/directory-configuration-fhs.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理05 文件系统]]></title>
    <url>%2Fpost%2F9ffd3055.html</url>
    <content type="text"><![CDATA[文件系统层次结构标准（英语：Filesystem Hierarchy Standard，FHS）定义了Linux操作系统中的主要目录及目录内容。在大多数情况下，它是一个传统BSD文件系统层次结构的形式化与扩充。 设计FHS的目的是为了给Unix-like系统的管理员提供一个管理系统以及目录结构的参考。 由于利用Linux源码开发产品和发行版的企业或组织众多，如果每个组织都按照自己的喜好来组织系统中的文件结构，网络上必然出现各种各样的文件结构。这些产品的用户就不得不为每种不同的文件系统结构花费时间来学习。有了FHS之后，几乎所有的Unix-like系统的发行商或软件开发者都遵从该建议规范每个特定目录下分别只放哪些文件，方便了文件的组织和查找。 详细内容参考：https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354根文件系统(rootfs)： root filesystem / 根目录是整个系统最重要的一个目录，因为在Linux系统中所有的目录都必须挂载在根目录下，也即所有的目录都是由根目录衍生出来。系统开机是所需要的开机软件、内核文件、函数库等都必须在根目录下。因此FHS也建议根目录不要安装在非常大、数据存取非常活跃的分区上，如此一来就能尽可能地降低系统不必要的错误。建议：根目录越小越好，且应用程序安装目录不要和根目录放置于同一分区。LSB, FHS: (Filesystem Hierarchy Standard) /boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader：grub)都存放于此目录； /bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的程序； /sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序； /lib：基本共享库文件，以及内核模块文件(/lib/modules)； /lib64：专用于x86_64系统上的辅助共享库文件存放位置； /etc：配置文件目录(纯文本文件，不能是二进制)； /home/USERNAME：普通用户家目录； /root：管理员的家目录； /media：便携式移动设备挂载点； cdrom usb /mnt：临时文件系统挂载点； /dev：设备文件及特殊文件存储位置； b: block device，随机访问 c: character device，线性访问 /opt：第三方应用程序的安装位置； /srv：系统上运行的服务用到的数据； /tmp：临时文件存储位置； /usr: universal shared, read-only data； bin: 保证系统拥有完整功能而提供的应用程序；供用户使用 sbin:供管理员使用 lib： lib64： include: C程序的头文件(header files)； share：结构化独立的数据，例如命令手册页man和自带文档doc等； src：程序的源码 local：第三方应用程序的安装位置； bin, sbin, lib, lib64, etc, share /var: variable data files，可变数据文件，主要存储常变化的文件，包括缓存(cache)、登录文件(logfile)以及某些软件运行所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等 cache: 应用程序产生的缓存文件； lib: 程序执行过程中，需要用到的数据文件放置的目录。此目录下各自的软件应该要有各自的目录； local：专用于为/usr/local下的应用程序存储可变数据； lock: 锁文件，某些设备或者文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误，因此就得要将该设备或文件上锁(lock)，以确保该文件或设备只给一个程序使用 log: 日志目录及文件，/var/log/messages, /var/log/wtmp； mail 个人电子邮箱目录，通常与/var/spool/mail/目录互为链接 opt: 专用于为/opt下的应用程序存储可变数据； run: 运行中的进程相关的数据；通常用于存储进程的pid文件； spool: 应用程序数据池，存放等待其他程序使用的数据； tmp: 下次启动前会被删除的临时数据； /proc: 用于输出内核与进程信息相关的虚拟文件系统； /sys：用于输出当前系统上硬件设备相关信息的虚拟文件系统； 这两个目录保存的是内存的挂载点，不能直接操作。其中的数据直接写在内存中。避免数据丢失或由于内存溢出导致系统崩溃。 /selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置； Linux上的应用程序的组成部分1234二进制程序：/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin库文件：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64配置文件：/etc, /etc/DIRECTORY, /usr/local/etc帮助文件：/usr/share/man, /usr/share/doc, /usr/local/share/man, /usr/local/share/doc Linux下的文件类型1234567- (f)：普通文件；d: 目录文件；b: 块设备；c: 字符设备；l: 符号链接文件；p: 管道文件；s: 套接字文件；socket; 参考：http://www.178linux.com/62805https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86http://wiki.jikexueyuan.com/project/learn-linux-step-by-step/directory-configuration-fhs.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 字符处理命令sort、wc、tr、uniq]]></title>
    <url>%2Fpost%2F616ff62c.html</url>
    <content type="text"><![CDATA[sort 排序命令对文本中的行进行排序1234567891011121314151617sort [OPTION]... [FILE]...选项：-f 忽略大小写-n 以数值型进行排序，默认使用字符串型排序-r 反向排序-t DELIMITER 指定分隔符,默认是制表符-k n[,m] 按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)-u uniq，排序后去重sort /etc/passwd # 按照字母顺序a-z排列文件内容sort -r /etc/passwd # 反向排序，即按z-a顺序排列文件内容sort -t&quot; &quot; -k3 users# 使用空格把users文件分割 使用第3列排序sort -n -t &quot;:&quot; -k 3 /etc/passwd # 以数值型进行排序，指定分隔符为“:”，使用第3列排序 wc 统计命令(word count)12345678wc [选项] 文件名选项:-l 只统计行数-w 只统计单词数-m 只统计字符数-c 只统计字节数# 若不加参数，则列出行数 词数 字符数 wc执行后 输入 ctrl+d结束 会统计输入行数 单词数 字符数 tr 字符替换123tr [选项] ... SET1 [SET2]从键盘输入转换或删除字符-d 删除 uniq 去重命令对文本中的连续的重复行进行操作 如果不连续就不无法使用该命令，所以可以先用sort排序，可以看出哪些重复了 1234567891011121314uniq [OPTION]... [FILE]...-c: 显示每行重复出现的次数-d: 仅显示重复过的行-u: 仅显示不曾重复的行uniq uniqtest.txt# 连续重复的行只显示一行uniq -d uniqtest.txt# 只显示重复的行uniq -D uniqtest.txt# 显示全部重复的行uniq -c uniqtest.txt# 显示重复次数 cut命令：文本分割 cut 字符截取命令grep行提取，cut列提取12345678910111213141516171819cut [OPTION]... [FILE]... 选项 -f 列号 提取第几列，从1开始-d 分隔符 按照指定分隔符分割列，默认为tabcut -f 1 /etc/passwdcut -f 1-3 /etc/passwdcut -f 1,3 /etc/passwdcut -f 1-3,7 /etc/passwdcut -d: -f 1,3-5 /etc/passwd# 使用冒号分割passwd文件，显示第1、3至5列cut -de -f 1 users# 使用e字符分割文件 取第1列cut -d&apos; &apos; -f 1-2 users &gt;user2# 使用空格分割文件，显示1-2列，将标准输出重定向到新的文件grep &quot;bin/bash&quot; /etc/passwd 可以登录的用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; 排除root的可登录用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -f 1 -d &quot;:&quot; 提取非root登录用户用户名 cut命令的局限性用cut截取比较规律的文件，用默认制表符或其他符号作为分隔符，可以方便截取，如果是用空格或多个空格做分隔符，就会有问题12df -h | cut -d &quot; &quot; -f 1,3无法正确分隔多个空格，只能以一个空格分隔 例子以冒号分隔，取出/etc/passwd文件的第6至第10行，并将这些信息按第3个字段的数值大小进行排序；最后仅显示的各自的第1个字段；1head -n 10 /etc/passwd | tail -n 4 | sort -n -t &quot;:&quot; -k 3 | cut -f 1 -d &quot;:&quot;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理06 查看文本文件内容]]></title>
    <url>%2Fpost%2F30ec04f2.html</url>
    <content type="text"><![CDATA[相关命令：cat, tac, head, tail, more, less cat12345678cat [OPTION]... [FILE]...选项：-E: 显示行结束符$-n: 对显示出的每一行进行编号# 读取一个或多个文件，然后复制它们到标准输出cat movie.mpeg.0* &gt; movie.mpeg# cat可以用来连接文件，通配符是有序的 如果没有给cat任何参数，它会从标准输入读入数据，因为标准输入在默认情况下连接到键盘，它正在等待我们输入数据当我们通过键盘输入数据并按Ctrl-d（表示EOF，作用相当于在终端中输入exit后回车）后，它会复制标准输入到标准输出 tac和cat类似，逆序查看 head 从文件头部开始读1234head [OPTION]... [FILE]...-c number 指定获取前number字节-n number-number 指定获取前number行 tail 从文件尾部开始读12345tail [OPTION]... [FILE]...-c number 从尾指定显示number个字符-n number -number 从尾指定显示number行，默认是10行-f 实时显示文件新追加的内容，Ctrl-c退出 more 分页12more [OPTIONS...] FILE...-d 显示翻页及退出提示 less 分页1less [OPTIONS...] FILE... man命令即是以less进行分页的 操作方法123456789101112131415161718192021Space 向文件尾翻屏b 向文件首部翻屏d 向文件尾部翻半屏u 向文件首部翻半屏e 向文件尾部翻一行y 向文件首部翻一行q 退出number 跳转至第number行1G 回到文件首部G 翻至文件尾部文本搜索：/KEYWORD: 以KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索；不区分字符大小写 n: 下一个 N：上一个?KEYWORD:以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索；不区分字符大小写 n: 跟搜索命令同方向，下一个 N：跟搜索命令反方向，上一个]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理05 查看目录]]></title>
    <url>%2Fpost%2F8fef17bb.html</url>
    <content type="text"><![CDATA[ls 显示指定路径下的文件列表12345678910ls [选项] [文件或目录]选项-a 显示所有文件,包括隐藏文件-l 显示详细信息-d 查看目录自身的相关属性，通常要与-l一起使用-h 人性化显示文件大小-i 显示inode-r 逆序显示-R 递归ll命令表示ls -l Linux下的文件类型： (f)：普通文件；d: 目录文件；b: 块设备；c: 字符设备；l: 符号链接文件；p: 管道文件；s: 套接字文件；socket; file 查看文件类型查看文件是文本还是二进制等12file rfc959.txtrfc959.txt: ASCII text tree 显示目录树1234tree -d: 只显示目录-L level：指定显示的层级数目-P pattern: 只显示由指定pattern匹配到的路径 pwd 显示当前目录（print working directory）]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理04 链接命令]]></title>
    <url>%2Fpost%2F40d56de0.html</url>
    <content type="text"><![CDATA[命令123ln -s [原文件][目标文件] （link）#生成链接文件-s 创建软链接 硬链接 拥有相同的i节点和存储block块，可以看做是同一个文件。（在格式化时，1.将分区划分为等大小的block数据块，该数据块通常为4KB。2.建立分区表，并为每个文件建立一个相关数据。当用户搜索某个文件时，会先到分区表中查找文件所对应的block存储位置，接着到相应位置取出，并返回给用户。）硬链接与原文件拥有相同的i节点。因此，与原文件非常相似。当删除原文件或硬链接文件的任何一文件，不影响文件索引操作。可看做，同一个文件的不通进入点。它是同样的存储空间。 可通过i节点识别（相同的i） 不能跨分区建立 不能针对目录使用，只有文件才可以创建 1234ln ./source/abc ./target/bcd.hard# 创建后，引用计数+1ls -i ./source/abc ./target/bcd.hard# 可使用ls -i 来查看文件i节点号 不建议创建硬链接文件文件太过隐蔽，除了有i节点这样一个标识之外，很难区分它是不是硬链接硬链接限制较多，不能跨分区，不能针对目录，使用当中容易出现错误使用方法 ##软链接 类似于Windows快捷方式 软链接拥有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据。（拥有自己的分区表中索引数据,通过索引找到分区表中文件的目标索引数据，再通过目标索引数据，查找数据） lrwxrwxrwx l软链接， 软链接文件权限都为rwxrwxrwx, 虽然权限显示为777，但实际权限需要看原文件权限。 修改任意文件，另一个都改变 删除原文件，软链接不能使用 创建软链接，原文件一定要写绝对路径。否则，软链接会到它所在的同一目录去找原文件。 软链接的目的是：在不改变原目录/文件的前提下，起一个方便的别名。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理05 文件解压缩命令]]></title>
    <url>%2Fpost%2F3128504e.html</url>
    <content type="text"><![CDATA[常用压缩格式： .zip .gz .bz2 常用解压缩格式： .tar.gz .tar.bz2 .rar格式安装123456#yum无法安装#查看需要下载的版本，https://www.rarlab.com/download.htmwget https://www.rarlab.com/rar/rarlinux-x64-5.6.b4.tar.gztar -zxvf rarlinux-x64-5.6.b4.tar.gzcd rarmake 压缩12#将/etc 目录压缩为etc.rar rar a etc.rar /etc 解压缩12rar x etc.rar unrar -e etc.tar .zip格式安装1yum -y install zip unzip 压缩1234zip 压缩文件名 源文件 #压缩文件zip -r 压缩文件名 源目录 #压缩目录 解压缩12345unzip 压缩文件unzip 压缩文件 -d 指定目录unzip -O cp936 压缩文件#解决文件名乱码 .gz格式压缩123456789gzip 源文件#压缩为.gz格式的压缩文件，源文件消失gzip -c 源文件 &gt; 压缩文件#压缩为.gz格式，源文件保留gzip -c cangls &gt; cangls.gzgzip -r 目录#压缩目录下所有的子文件，但是不能压缩目录 解压缩12gzip -d 压缩文件 gunzip 压缩文件 .bz2格式12yum -y install bzip2#使用之前需要安装 没有安装会出现以下错误1234tar (child): lbzip2: Cannot exec: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now 压缩12345bzip2 源文件 #压缩文件，源文件消失bzip2 -k 源文件 #压缩之后保留源文件 #注意：bzip2命令不能压缩目录 解压缩12bzip2 -d 压缩文件 #解压缩，-k保留压缩文件bunzip2 压缩文件 #解压缩，-k保留压缩文件 打包命令tar123456789101112131415161718192021222324252627282930tar -cvf 打包文件名 源文件 # 压缩为tar格式tar -zcvf 压缩包名.tar.gz 源文件 # 压缩为.tar.gz格式tar -jcvf 压缩包名.tar.bz2 源文件 # 压缩为.tar.bz2格式**参数j、z要放在前边**#解压tartar -xvf 打包文件名 #解压tar格式文件tar -zxvf 压缩包名.tar.gz #解压.tar.gz格式文件tar -jxvf 压缩包名.tar.bz2 #解压.tar.bz2格式文件-c：打包-x：解打包-v：显示过程-f：指定打包后的文件名-z：压缩为.tar.gz格式-j：压缩为.tar.bz2格式其他用法tar -jxvf 打包文件名 -C 绝对路径 #指定解压缩位置tar -zcvf 绝对路径（/tmp/）+打包文件名 源文件 源文件 #将多个文件解压到指定路径tar -ztvf 压缩包文件名 #查看压缩包内文件 参考： https://blog.csdn.net/yonggeit/article/details/72190246]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理03 文件搜索命令]]></title>
    <url>%2Fpost%2F2bff0643.html</url>
    <content type="text"><![CDATA[文件搜索命令 locate123456789locate 文件名#在后台数据库中按文件名搜索，搜索速度更快/var/lib/mlocate (保存的搜索数据库)#locate 命令所搜索的后台数据库#数据库不是实时的，更新频率大概一天更新一次updatedb#更新数据库 对于新建的文件，由于数据库没有更新，使用locate不能查到。可以使用 updatedb强制更新数据库后即可查到。可使用 locate locate搜索locate相关文件，可看到locate数据库。在不同linux中，该数据库名字稍微不同，例如，locatedb、slocate、mlocate。 缺点：只能按照文件名进行搜索，但常用。 配置文件123456789101112131415161718touch /root/canglstouch /tmp/canglsupdatedblocate cangls#显示为 /root/cangls #只有一条，而/tmp下的cangls没有显示出来#原因在于locate搜索遵循配置文件 `/etc/updatedb.conf`#在PRUNEPATHS 中配置了/tmp/目录不进行搜索。所以没有进行查找/etc/updatedb.conf 配置文件PRUNE_BIND_MOUNTS = &quot;yes&quot;#开启搜索限制，yes为后面三项都生效。no为 后面三项都不生效PRUNEFS = #搜索时，不搜索的文件系统PRUNENAMES =#搜索时，不搜索的文件类型PRUNEPATHS =#搜索时，不搜索的路径 文件搜索命令 find.表示当前目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758find [搜索范围][搜索条件]#搜索文件find /home -name 文件名# find搜索默认是完全匹配# 避免大范围的搜索，会非常浪费系统资源# find是在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配find /home -name &quot;[12]*&quot;find /home -name &quot;test[12]&quot;#要加引号*匹配任意内容?匹配任意一个字符[]匹配任意一个中括号内的字符find /home -mtime +10 在home目录下，查找10天前修改的文件find /home -mtime 10 在home目录下，查找10天前当天修改的文件find . -mtime -10 在当前目录下，查找10天内修改的文件# atime 文件访问时间# ctime 改变文件属性# mtime 修改文件内容find . -type f#列出文件find /root -iname test # 不区分要搜索的test大小写格式find /root -user root # -user 按文件所有者搜索# 搜索root目录下的所有属于root用户的文件find /root -nouser #没有所属者的文件，liunx中，每个文件都有所属者，如果没有，那么一般都是垃圾文件，但还是有特例的，比如内核产生的文件，就没有所属者，一般在proc和sys目录下；还有外来文件，也就是U盘拷入的文件也会忽略所有者。find 目录 -size 25k# 查找文件大小是25KB的文件# 注意：文件大小用小写k和大写M# -25k 小于25k# 25k 等于25k# +25k 大于25kfind . -size 25M # 查询当前目录文件大小是25M的文件find /etc -size +20k -a -size -50k # 查找/etc下大于20k并且小于50k的文件# -a and,逻辑与，两个条件都满足# -o or,逻辑或，两个条件满足一个即可find . -type f -perm 644 -exec ls -l &#123;&#125; \;# 查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件find /etc -size +20k -a -size -50k -exec ls -lh &#123;&#125; \;-exec &#123;&#125; \; # 固定格式，表示直接对前面的搜索结果进行后面的命令处理# 注意，&#123;&#125;和\之间有空格，结尾有分号find . -inum 262422 # 查找inode是262422的文件# -inum 查询指定i节点的文件 字符串搜索命令 grep全目录全文搜索1234567891011grep [选项] 字符串 文件名# 在文件中匹配符合条件的字条串# 字符串使用 &quot;&quot; 包围，结果为行记录-i 忽略大小写-v 排除指定字符串/取反-n 显示行号-r 递归grep apple fruitlist.txtgrep -i apple fruitlist.txt #忽略大小写grep -nr apple * #搜索目录里所有文件，包括子目录，并且在结果中显示行号 find命令和grep命令的区别find：在 系统 中搜索符合条件的 文件名，使用 通配符（完全）匹配grep：在 文件 当中搜索符合条件的 字符串，使用 正则表达式 （包含）匹配 通配符（完全）匹配：搜索文件名正则表达式 （包含）匹配：搜索文件中的数据]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理02 文件的查看和处理]]></title>
    <url>%2Fpost%2F19cc11d8.html</url>
    <content type="text"><![CDATA[目录主目录，家目录：HOME123root /root普通用户 /home/USERNAME~ 用户的主目录 ls 显示指定路径下的文件列表12345678910ls [选项] [文件或目录]选项-a 显示所有文件，包括隐藏文件-l 显示详细信息-d 查看目录自身的相关属性，通常要与-l一起使用-h 人性化显示文件大小，单位换算-i 显示inode-r 逆序显示-R 递归ll命令表示ls -l tree 显示目录树12345tree选项：-d 只显示目录-L level 指定显示的层级数目-P pattern 只显示由指定pattern匹配到的路径 pwd 显示当前目录（print working directory）cd 切换目录（change directory）1234567891011cd [目录]cd\cd ~ 进入当前用户的家目录cd - 进入上次目录cd . 进入当前目录cd .. 进入上一级目录相关的环境变量：PWD 保存了当前目录路径OLDPWD 上一次所在目录路径 mkdir 建立目录（make directories）12345678mkdir [options] /path/to/somewhere选项：-p 存在时不报错，且可自动创建所需的各目录，当创建多级目录时需加-v 显示详细信息-m MODE 创建目录时直接指定权限mkdir lightmkdir -p imooc/linux/light 12345678# 创建/tmp/x/y1, /tmp/x/y2, /tmp/x/y1/a, /tmp/x/y1/b, /tmp/x/y2/a, /tmp/x/y2/bmkdir /tmp/x/&#123;y1,y2&#125;/&#123;a,b&#125; # 创建x_m, y_m, x_n, y_nmkdir &#123;x,y&#125;_&#123;m,n&#125;# 创建/tmp/bin, /tmp/sbin, /tmp/usr, /tmp/usr/bin, /tmp/usr/sbinmkdir -p /tmp/&#123;bin,sbin,usr/&#123;bin,sbin&#125;&#125; rmdir 删除空目录（remove empty directories）123rmdir [OPTION]... DIRECTORY...-v: 显示过程# 只能删除空目录 文件file 查看文件类型查看文件是文本还是二进制等12file rfc959.txtrfc959.txt: ASCII text stat 查看文件的元数据查看Linux 时间戳管理 rm 删除文件或目录（remove）1234567891011121314rm [选项] [文件或目录] 选项：-r 递归删除，用于删除目录-f 强制删除-i 交互式rm [文件名] 提示是否删除rm -r [目录] 删除目录需加 -r ，目录中含有子文件，将持续询问是否删除rm -rf [目录] 删除目录，不会询问是否删除而直接进行rm -rf /tmp/* 删除tmp目录下的内容rm -rf /tmp/ 删除tmp目录# 纯字符界面没有回收站。注意自杀指令：rm -rf /# 建议：删除文件或目录习惯使用命令 rm -rf [文件或目录] cp 复制命令（copy）12345678910111213141516cp [OPTION]... [-T] SOURCE DESTcp [OPTION]... SOURCE... DIRECTORYcp [OPTION]... -t DIRECTORY SOURCE...选项：-i 交互式-r\-R 递归复制目录及内部的所有内容-p 连带文件属性复制-d 若原文件是链接文件，则复制链接属性，单纯用-d也会报错，因为原文件链接使用相对路径-a 相当于 -pdr 全选--preserv[=ATTR_LIST] mode: 权限、ownership: 属主属组、timestamp: 、links、xattr、context、allcp abc /tmp/ 若目标目录不加文件名，则为原名复制cp abc /tmp/ana 若目标目录后加入文件名，则为改名复制cp -r japan/ /tmp/ 复制目录cp -a japan/ /tmp/ 完全复制，包括所有属性# 被复制文件的时间为执行复制命令的时间，若要使被复制的文件与原文件属性完全一致，需加 -a 源是文件结果一定是有一个文件产生，源是目录结果一定是有一个目录产生123456789101112131415161718cp SRC DEST SRC是文件： 如果目标不存在：新建DEST，并将SRC中内容填充至DEST中； 如果目录存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中； 此时建议为cp命令使用-i选项； 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填充至新文件中； SRC是目录： 此时使用选项：-r 如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中； 如果DEST存在： 如果DEST是文件：报错 如果DEST是目录：复制SRC目录和SRC目录中所有文件至DEST中cp SRC... DEST SRC...：多个文件 DEST必须存在，且为目录，其它情形均会出错； 目标目标文件不存在目标目录不存在文件目录不存在同名存在同名源文件创建目标文件，将源文件内容复制到目标文件报错，先使用mkdir创建目标目录覆盖新建同名文件覆盖目录(-r)报错创建目标目录，将源目录中的文件复制到目标目录报错新建同名目录覆盖 mv 剪切或改名命令（move）123456789mv [OPTION]... [-T] SOURCE DESTmv [OPTION]... SOURCE... DIRECTORYmv [OPTION]... -t DIRECTORY SOURCE...选项：-i 交互式-f 强制mv japan/ /tmp/ 剪切目录时不需加 -rmv abc longls 当原文件与目标目录，在同一目录下，则为改名命令]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装ssh]]></title>
    <url>%2Fpost%2Fed2580b6.html</url>
    <content type="text"><![CDATA[SSH（Secure Shell）安全外壳协议，建立在应用层基础上的安全协议，专为远程登录会话和其他网络服务提供安全性的协议 安装ssh1234567891011121314151617181920212223242526#查看ssh服务是否开启ps -e |grep ssh#安装ssh服务，openssh是ssh的开源实现方式#只要安装了ssh服务，本地linux可以当做服务器sudo apt install openssh-serversudo yum install openssh-server -y#本地安装ssh客户端，可能已经安装sudo apt install openssh-clientsudo yum install openssh-clients -y#配置sshsudo vi /etc/ssh/sshd_configPermitRootLogin yes 把注释去掉#开启ssh服务sudo service sshd startsudo systemctl start sshd.service#开机启动SSH服务sudo chkconfig sshd onsudo systemctl enable sshd.service#连接，端口默认为22，可以不写ssh -p 22 userName@192.168.1.100 使用别名登录ip打开~/.ssh/config，不存在就自己创建一个12345Host AAAAA #服务器主机名 HostName 192.168.0.222 #服务器地址 User work #work为登陆用户名，不是自己电脑的名字 Port 22 #主机端口，默认是22 IdentityFile /home/me/.ssh/id_rsa #自己生成的私钥的文件路径 12#使用别名登录ssh AAAAA 多对ssh管理指定不一样的私钥名1ssh-keygen -t rsa -f ~/.ssh/id_rsa.second 配置~/.ssh/config，在原有的基础上增加新的字段1234567891011# Default github user(first@mail.com) 默认配置，一般可以省略Host github Hostname github.com User git Identityfile ~/.ssh/id_rsa_github# second user(second@mail.com) 给一个新的Host称呼Host secondgithub #主机名字，不能重名 HostName github.com User git IdentityFile ~/.ssh/id_rsa.second #私钥路径 设置SSH免密码登录 生成ssh key 私钥放在本地~/.ssh目录 公钥放在服务器的~/.ssh/authorized_keys 1234567891011121314151617181920212223242526272829#1.客户端本地生成公钥和私钥，rsa是加密方式ssh-keygen -t rsa# ~/.ssh目录中创建两个名为id_rsa和id_rsa.pub的文件，id_rsa是私钥，id_rsa.pub是公钥#2.设置权限chmod -R 700 ~/.sshchmod 600 ~/.ssh/id_rsa #默认就是600#3. 复制公钥到服务器然后写入到~/.ssh/authorized_keys 方法一# 使用SSH远程登陆到服务器,发现家目录中还没有.ssh目录,使用mkdir创建mkdir .ssh# 发送公钥scp ./id_rsa.pub alice@192.168.0.10:/home/alice/.ssh# 将公钥追加写入~/.ssh/authorized_keys中，若authorized_keys不存在，则会创建并写入cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys#修改authorized_keys的权限为600,并删除公钥文件rm id_rsa.pub# 复制公钥到服务器然后写入到~/.ssh/authorized_keys 方法二# ssh-copy-id 命令可以把本地主机的公钥复制到远程主机的 authorized_keys 文件上ssh-copy-id -i ~/.ssh/id_rsa.pub user@serverchmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys#4.配置ssh，如果发现依旧无法连接，考虑是否打开配置sudo vi /etc/ssh/sshd_configRSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 清除SSH的私钥密码12345ssh-keygen -p# 选择需要修改的私钥，默认是/home/username/.ssh/id_rsa# 选好文件后按回车，会提示你输入旧密码。#输入好后会提示输入新密码。#直接回车，提示确认新密码再直接回车，此时指定的私钥的密码就被清除了 SSH相关命令参考 Linux网络管理 远程登录 补充：https://wiki.centos.org/HowTos/Network/SecuringSSH 参考： https://wiki.centos.org/HowTos/Network/SecuringSSH http://www.iosugar.com/2017/02/14/CentOS-remote-login-SSH-configuration/#SSH%E7%99%BB%E9%99%86 http://einverne.github.io/post/2016/06/ssh-copy-id.html https://www.ssh.com/ssh/copy-id https://linux.cn/article-6901-1.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理05 虚拟机网络配置详解(NAT、桥接、Hostonly)]]></title>
    <url>%2Fpost%2F67c33d98.html</url>
    <content type="text"><![CDATA[无论是vmware还是virtual box虚拟机软件，一般来说，虚拟机有三种网络模式: Bridged Adapter（桥接模式） NAT（网络地址转换模式） Host-only Adapter（主机模式） virtual box中还有lInternal 虚拟网卡在虚拟机安装好之后，会自动添加两张网卡(VMnet1和VMnet8)，VMnet1用Host-only网络连接，VMnet8用NAT方式的网络连接，原先的VMnet0用桥接网络连接。 桥接桥接网络是指宿主物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的IP地址也要设置为同一网段。会占用内网IP vmnet0实际上就是一个虚拟的网桥(2层交换机)，这个网桥有若干个接口，一个端口用于连接你的Host主机，其余端口可以用于连接虚拟机，他们的位置是对等的，谁也不是谁的网关。 主机A上的两个虚拟机1和虚拟机2，和主机A、B同处于一个网段，能够相互通信 虚拟机网卡配置，虚拟机上网需要IP/子网掩码/DNS/网关12345678DEVICE=&quot;eth0&quot;BOOTPROTO=“static&quot; #设置静态ip,动态为dhcpIPADDR=&quot;192.168.1.3&quot;GATEWAY=&quot;192.168.1.1&quot;HWADDR=&quot;08:00:27:C7:1B:22&quot;DNS1=&quot;8.8.8.8&quot;NETMASK=&quot;255.255.255.0&quot;ONBOOT=&quot;yes&quot; CentOS 7中ONBOOT默认为NO，需要打开 应用场景：虚拟机要求可以上网，且虚拟机完全模拟一台实体机 NATNAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。宿主能够联网，虚拟机也能联网(其他主机)。宿主没有联网，虚拟机也不能联网 vmnet1也是一个虚拟的交换机，交换机的一个 端口连接到你的Host上，另外一个端口连接到虚拟的DHCP服务器上（实际上是vmware的一个组件），另外剩下的端口就是连虚拟机了，主机A和虚拟机1和2能相互通信，虚拟机1和2能访问主机B和外网，主机B不能访问虚拟机1和2，虚拟机1和2能相互通信 虚拟机的配置:12345678DEVICE=&quot;eth0&quot;BOOTPROTO=“static&quot; #设置静态ip,动态为dhcpIPADDR=&quot;10.0.2.5&quot;GATEWAY=&quot;10.0.2.1&quot;HWADDR=&quot;08:00:27:C7:1B:22&quot;DNS1=&quot;10.0.2.1&quot;NETMASK=&quot;255.255.255.0&quot;ONBOOT=&quot;yes&quot; 应用场景：虚拟机只要求可以上网，无其它特殊要求，满足最一般需求 Host-Only所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的 虚拟系统和宿主机器系统是可以相互通信的。虚拟系统的TCP/IP配置信息(如IP地址、网关地址、DNS服务器等)，都是由VMnet1(host-only)虚拟网络的DHCP服务器来动态分配的。 主机和虚拟机之间的通信是通过 VMnet1虚拟网卡来实现的。虚拟机连接到VMnet1上，系统并不为其提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到真正的网络上。 Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。 虚拟机1和2之间可以相互通信，主机A能和虚拟机1和2通信，虚拟机1和2不能和主机通信(需要设置)，虚拟机不能和B主机以及外网通信 使用范围如果你想利用VMWare创建一个与网内其他机器相隔离的虚拟系统，进行某些特殊的网络调试工作，可以选择host-only模式。 内网模式内网模式，顾名思义就是内部网络模式：虚拟机与外网完全断开，只实现虚拟机于虚拟机之间的内部网络模式。 虚拟机与主机的关系：不能相互访问，彼此不属于同一个网络，无法相互访问。虚拟机与网络中其他主机的关系：不能相互访问，理由同上。虚拟机与虚拟机的关系：可以相互访问，前提是在设置网络时，两台虚拟机设置同一网络名称。如上配置图中，名称为intnet。 参考： http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html https://www.jianshu.com/p/305f7384cfe9 https://blog.csdn.net/bytxl/article/details/35569217 https://blog.csdn.net/clevercode/article/details/45934233 http://blog.51cto.com/wangchunhai/381225 https://github.com/waltcow/blog/issues/21 https://blog.csdn.net/guizaijianchic/article/details/72190394]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理04 远程登录]]></title>
    <url>%2Fpost%2Fb979e5b7.html</url>
    <content type="text"><![CDATA[参考 Linux 安装ssh SSH协议原理对称加密算法采用单钥密码系统的加密方法, 同一个秘钥可以同时用作信息的加密和解密, 这种加密方法称为对称加密, 也称为单秘钥加密. 缺点 : 加密解密使用相同密码, 需要告知对方密码, 等同于将自身多方习惯密码告知对方. 例如邮箱等密码, 造成威胁 非对称加密算法asymmetric cryptographic algorithm，又名 “公开秘钥加密算法” , 需要公开秘钥(publickey) 和私有秘钥(privatekey)linux 中为 gpg工具, windows 中为 pgp工具 过程原理, A 需要发送数据包给 B A 根据自己密码A 生成 公钥A 和私钥A B 根据自己密码B 生成 公钥B 和私钥B A 向 B 寻要 公钥B, 再结合自身的公钥A 对数据包进行加密, 并发送给B B 收到数据包之后, 可根据自身密码B 和 私钥B 对数据包进行解密且成功 此时, A 也可以根据自身密码A 结合 私钥A 对已加密的数据包进行解密 至此, 避免了泄露 A 自身的密码 SSH安全外壳协议在非对称加密算法之上演变而来密码足够复杂强壮可降低暴力破解的成功性SSH 保护数据传递过程中的安全, 但若在传递之前中病毒则不可避免通用的远程管理协议 过程原理, A 需要发送数据包给 B A 持有 公钥A 和 私钥A B 持有 公钥B 和 私钥B A 向 B 寻要 公钥B, 再结合自身的 公钥A 对数据包进行加密, 并发送给B B 收到数据包之后, 可根据自身 私钥B 对数据包进行解密 SSH 命令12345ssh 用户名@ip# 远程管理制定Linux服务器# 经过远程之后, 在家目录中的 .ssh 文件夹 know_hosts文件中保存着 连接成功的目标信息# 地址 加密算法 公钥#若目计算机进行了重装系统, 或地址被另一台机器占用, 此时 已下载的公钥无法使用, 使用vi 对改行进行删除, 当再次连接时, 会再次提示是否进行下载公钥 远程管理工具SecureCRT、Xshell WinSCP文件传输工具 FileZilla]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理03 网络配置]]></title>
    <url>%2Fpost%2Fab2af73b.html</url>
    <content type="text"><![CDATA[IP地址配置DHCP服务器可以自动分配IP ifconfig命令临时配置IP地址1234ifconfig查看当前网络状态ifconfig eth0 192.168.254.200 netmask 255.255.255.0临时设置eth0网卡的IP地址与子网掩码 setup工具永久配置IP地址 红帽专有图形化工具setup设置IP地址 CentOS系统中默认就没有setup命令，需要安装12345678910yum -y install setuptool 安装setup命令工具yum -y install ntsysv 安装setup工具配套的系统服务组件yum -y install system-config-securitylevel-tui安装setup工具配套的防火墙配置组件yum -y install system-config-network-tui 安装setup工具配套的网络配置组件yum -y install authconfig-gtk安装setup工具配套的验证配置组件 system-config-network-tui 无法安装，是因为网络设置改到nmtui命令中 修改网络配置文件因为配置文件不光可以配置IP，所以单独开一节 图形界面配置IP地址 修改网络配置文件网卡信息文件 主机名文件1234vi /etc/sysconfig/networkhostname [主机名]# 查看与临时设置主机名命令 DNS配置文件12vi /etc/resolv.conf# nameserver 名称服务器/DNS 虚拟机网络参数配置1.配置LinuxIP地址12setup#修改并配置IP地址 2.启动网卡1234vi /etc/sysconfig/network-scripts/ifcfg-eth0#把 ONBOOT = no改为 ONBOOT = yesservice network restart#重启网络服务 3.修改UUID(如果这是一台克隆/复制出来的机子则必须进行这个步骤，否则可以省去)12345vi /etc/sysconfig/network-scripts/ifcfg-eth0#删除MAC地址行rm -rf /etc/udev/rules.d/70-persistent-net.rules#删除网卡和MAC地址绑定文件#重启动系统 4.设置虚拟机网络连接方式 桥接模式：通过物理机的真实网卡进行通信，若选此项，则虚拟机需要配置与物理机相同的网关，缺点是需要占用真实网段的一个IP地址。这种模式更适用于实验，因为这种模式不仅可以与你的物理机可以通信还可以与同一局域网的其他主机通信，还可以访问公网。 NAT模式：在windows中（物理机中）是以VMware8虚拟网卡进行通信。这种模式只能与你自己的主机通信，不能与局域网的其他主机通信，但是可以通过物理的网卡访问公网。 仅主机模式：在windows中（物理机中）是以VMware1虚拟网卡进行通信。这种模式只能与你自己的主机通信，不能与局域网的其他主机通信，只能与自己的物理机通信，并且不能上公网。 切记：在选择桥接模式之后，需要选择桥接的网卡（即需要确定虚拟机需要通过哪个真实网卡连接网络），一般的虚拟机都是自动桥接，但是这种方式真的跟不靠谱**，所以你需要自己选择，如果你是通过有线接入网络，则选择有线桥接，若是通过无线接入网络，则通过无线接入。 5.修改桥接网卡]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理02 网络命令]]></title>
    <url>%2Fpost%2F9065ef14.html</url>
    <content type="text"><![CDATA[网络环境查看命令123456789101112131415161718192021222324252627282930313233343536373839404142ifconfig# 查看与临时配置网络状态，但无法查看网关和DNS#关闭与启动网卡ifdown 网卡设备名 #禁用该网卡设备ifup 网卡设备名 #启用该网卡设备#查询网络状态netstat 选项选项：一般为tuln或an-t：列出TCP协议端口-u：列出UDP协议端口-n：不使用域名与服务名，而使用IP地址和端口号-l：仅列出在监听状态的网络服务-a：列出所有的网络连接#统计计算机建立的远程连接数netstat -an | grep ESTABLISHED | wc -l#查看网关netstat -rn 选项：-r：列出路由表，功能和route命令一致。route -n #查看路由列表(可以看到网关)route add default gw 192.168.1.1#临时测定网关#域名解析命令nslookup [主机名或IP] #进行域名与IP地址解析，域名对应哪个IPnslookup&gt;server #本地设定的DNS的地址&gt;exit #退出 在一台服务器里，连接内网的网卡是不能设置网关的，只有连接外网的网卡才能设置，而且这个网关是由运营商设置好 它告诉我们的下一级网络地址。 随便设置一个网关是不行的，因为与外网通信时，要把消息转发到网关，网关负责把内网IP转换成功公网IP，随便设置则将找不到这个网关，导致呈现网络连接失败状态。 网络测试命令123456789101112131415161718192021222324252627282930ping [选项] ip或域名 #探测指定IP或域名的网络状况选项：-c 次数：指定ping包的次数telnet [域名或IP] [端口] #远程管理与端口探测命令，明文传递telnet 192.168.0.252 80#如果连接成功，将会进入连接状态，按ctrl+]退出到telnet，再键入quit返回命令行状态traceroute [选项] IP或域名 #路由跟踪命令，查看中间所经过的节点，故障定位。选项：-n 使用IP，不使用域名，速度更快#和ping一样都是利用的ICMP协议（Internet Control Message Protocol）Internet控制报文协议#家用网络大多数结点都禁止ping，就是*，可以根据路由来分析哪些结点出现了问题wget http://soft.vpser.net/lnmp/lnmp1.1-full.tar.gz #下载命令tcpdump -i eth0 -nnX port 21抓取eth0网卡上的数据包，以16进制拆分数据包(用port 21可以只拆分21端口)选项：-i：指定网卡接口-nn：将数据包中的域名与服务转为IP和端口-X：以十六进制和ASCII码显示数据包内容port：指定监听的端口 ftp也是明文：用来上传下载文件，默认是不允许用户登陆的 http都是明文，一旦截获了数据包，就能直接获取里面的数据 https才是加密的]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理01 网络基础]]></title>
    <url>%2Fpost%2F408bec44.html</url>
    <content type="text"><![CDATA[OSI模型开放系统互联模型，由ISO(国际标准化组织) 组织开发的 该模型为基础模型, 而实际中常用的TCP/IP模型是由七层模型演变的 上三层(应用层、表示层、会话层)是对用户提供服务, 下四层(传输层、网络层、数据链路层、物理层)对数据传输提供服务 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 70% ; } table th:nth-of-type(3){ width: 20%; } 每一层的变化不影响其他层 层级 作用 传输单元 应用层 用户接口，所有能产生网络流量的程序 APDU，应用协议数据单元 表示层 数据的表现形式/编码方式（ASCII、GB2312、jpg），在传输之前是否进行 加密、压缩 乱码 PPDU，表示协议数据单元 会话层 对应用会话的管理、同步。 确定网络数据是否要经过远程会话 netstat命令 可以查看木马 SPDU，会话协议数据单元 传输层 确定可靠与不可靠的传输（ TCP传输控制协议可靠不会丢、UDP用户数据报协议更快但可能会丢(一个包可以解决的问题，比如查询DNS，QQ聊天)）、传输前的错误检测、 流量控制（你发太快啦，慢点）、 确立端口号, 便于通过IP确定主机后, 通过端口确定交互的服务 TPDU，传输协议数据单元 网络层 负责提供逻辑地址(IP地址, 需要写入发件人IP与收件人IP）、 负责选择最佳路径，规划IP地址。 （确定IP地址，原IP、目地IP） ，IP4，IP6 报文 数据链路层 负责组成帧(组入MAC信息)，用MAC地址访问媒介（源地址&amp;目的地址）、错误的检测与修正。物理地址，就是计算机MAC地址，也就是计算机网卡地址。每一台电脑都有一个网卡地址，MAC地址负责局域网通信，IP地址负责外网通信。帧的开始和结束，透明传输（帧的转义字符的增加删除），差错校验（只检验，不纠正，纠正由传输层完成，或丢掉或重新传输） 帧 物理层 设备之间比特流的传输（ 最基本的数据传递）、物理接口标准（ 网线口、视频口、音频口）、电气特性 ，物理介质，如何在物理层上传输更快的速度 比特流 举例场景 用户A需要给用户B发送一份邮件 应用层 : 浏览器进入邮箱, 写邮件, 点击发送, 数据将传递至 表示层 表示层 : 进行的数据的编码, 而后数据传递至会话层 会话层 : 判断数据的发送类型, 是进行网络传输还是进行本地保存, 若是进行传输 传递至传输层 传输层 : 确立协议TCP或UDP, 写入邮件的发送及目标端口号, 传递至网络层 网络层 : 写入自身及目标IP地址, 传递至数据链路层 数据链路层 : 写入源MAC地址与目标MAC地址, 由于IP地址找到局域网, 再通过MAC地址在局域网中找到目标, 传递至物理层 物理层 : 数据传输 OSI参考模型和故障排除故障从下到上进行排除，因为越上层越复杂 物理层故障：查看发送和接收的数据包大小是否一致 数据链路层故障：mac冲突、ADSL过期、网速没办法协商一致（100M和1G）、计算机连接到错误的WLAN 网络层故障：配置错误的IP地址、子网掩码、网关，路由器没有配置到达的目标网络的路由 应用层故障（应用层、表现层、会话层、传输层）：应用程序配置错误 OSI参考模型和网络安全 物理层安全：别人可以接入你的网络 数据链路层安全：ASDL账号密码、无线AP、VLAN、交换机商品绑定mac地址 网络层安全：路由器上使用ACL控制数据包流量 应用层安全（应用层、表现层、会话层、传输层）：开发的应用程序漏洞 TCP/IPTCP/IP 四层模型与 OSI 七层模型对应关系 应用层 : 应用层、表示层、会话层为用户提供所需的各种服务, 例如 FTP、Telnet、DNS、SMTP等 传输层 : 传输层负责为应用层实体提供端到端的通信功能, 保证了数据包的顺序传送及数据的完整性, 该层定义了两个主要的协议 : 传输控制协议(TCP)可靠的面向连接，不会丢失，类似打电话，网页、邮件 和 用户数据报协议(UDP)不可靠的面向无连接,有可能丢失, 类似发短信、QQ 网际互联层 : 网络层主要解决主机到主机的通信问题, 它所包含的协议涉及数据包在整个网络上的逻辑传输, 该层有三个主要协议 : 网际协议(IP), 互联网组管理协议(IGMP), 互联网控制报文协议(ICMP) 网络接口层 : 数据链路层、物理层负责监视数据在主机和网络之间的交换, 事实上, TCP/IP本身并未定义该层的协议, 而由参与互连的各网络使用自己的物理层和数据链路层协议, 然后与TCP/IP的网络接入层进行连接. 地址解析协议(ARP) 工作在此层, 即OSI参考模型的数据链路层.地址解析协议(ARP) : 将IP地址 翻译成物理地址 数据封装过程发送是由上至下进行打包, 接收是由下至上进行拆包FCS：校验 数据解封装过程计算机在接收到数据帧后，需要去掉为了传输而添加的附加信息，这称为解封装 TCP/IP 模型与OSI 模型的比较共同点 OSI 参考模型和 TCP/IP参考模型都采用了层次结构的概念 都能够提供面向连接和无连接两种通信服务机制 不同点 OSI 七层, TCP/IP 四层 对可靠性要求不同(TCP/IP 更高) OSI 模型是在协议开发前设计的, 具有通用性. TCP/IP 是先有协议集, 然后建立模型, 不适用与非TCP/IP网络 实际市场应用不同( OSI 模型只是理论上的模型, 并没有成熟的产品, 而TCP/IP已经成为”实际上的国际标准”) IP地址IP包头(如图)横32位, 竖5行, 固定的共160位, 20字节, 另外有其他选项存在, 导致包头不固定, 因此每接收到包头, 需要进行检测包头长度才能够取出包头, 也是为何IPv4没有IPv6快的原因 包头中包含的IP地址只有32位, 即2的32次幂, 42亿9千万左右的IP IP地址分类IP分为A、B、C、D、E 五大类, 其中DE不对民用组织开放, 不可使用, 因此有效类只有ABC可根据第一位数值判断类别, 1-126 为A类, 128-172 为B类, 192-223 为C类 127.0.0.1 为本机 第一位表示不同网段, 不同网络, 不同网络之间的通信需要使用路由器，路由器是用来实现跨网络通信的, 同一网络下通信使用交换机即可. 第一位不变情况下, 后三位的变化都代表同一网络下的不同主机 A 类 : 每个网络中的第一个地址(X.0.0.0)代表网络本身,最后一个地址(X.255.255.255)代表当前网络的广播地址, 不能分配, 最大主机数 : 后三位的次幂, 减 第一和最后一个 , 2^24 -2 B 类 : 前两位代表网段, 后两位代表网段中的不同主机 C 类 : 前三位代表网段, 最后一位代表不同主机 私有IP : 不需要花钱买, 用来做内网IP, 可有效保护公网IP, 不能直接访问公网, 需要与公网之间进行转换才可访问互联网 子网掩码ABC类可以用不同的网段个数和主机个数, 是由子网掩码决定子网掩码用连续1的表示，例如255.0.0.0，255.255.0.0，255。255.255.255.0 子网掩码的作用：用来区分不同网段的IP—-子网掩码与IP相与，得到的结果相同则在同一网段。否则不在，需要经过路由器转发。 合理的子网掩码 : 所有的1必须连续, A 类地址可匹配B类子网掩码 IP和子网掩码必须一起配合使用。网络号=IP&amp;&amp;子网掩码 广播地址：主机号全为1,广播地址是专门用于同时向网络中所有工作站进行发送的一个地址 合理的子网掩码 : 所有的1必须连续, A 类地址可匹配B类子网掩码 端口 1234netstat -an# 查看本机启用的端口#-a:查看所有连接和监听端口#-n:显示IP地址和端口号，而不显示域名和服务名 TCP因为3次握手的机制所以需要监听，而UDP不需要监听 常见端口号 FTP（文件传输协议）：20、21； SSH（安全shell协议）：22； telnet（远程登录协议）：23； DNS（域名系统）：53； http（超文本传输协议）：80； SMTP（简单邮件传输协议）：25； POP3（邮局协议）：110； DNShosts和DNShosts文件：做静态IP和域名对应，优先于DNS.位置：C：\Windows\System32\drivers\etc\hosts/etc/hosthosts文件只可做临时解析用，名称解析效能下降，主机维护困难 DNS全称为——&gt;domain name system——&gt;域名系统 不配置DNS是不能联网的。 在互联网中，通过IP地址来进行通信。 IP地址是用数字来表示的，记忆起来太困难了(如116.213.120.232) 人对域名更加敏感，:http://www.imooc.com/ DNS服务的作用:将域名解析为IP地址过程：客户机向DNS服务器发送查询IP请求DNS服务器查询到web服务器的ip，告知用户用户访问web服务器 域名空间结构根域：.（13台服务器）——&gt;顶级域/一级域：包括组织域和地区域（组织域：gov政府/edu教育部门/com商业部门/org民间团体/net网络服务机构/mil军事部门 地区域：cn 中国 hk 香港 jp 日本 Uk 英国 au 澳大利亚）——&gt;二级域：企业或个人自行购买的（imooc /microsoft/ibm/sina）——&gt;主机名/3级域：申请完二级域后自己定义的（www/news） 三级域（www）+二级域（baidu）+顶级域（.com）组成完整域名空间 为什么要进行域名分级划分便于IP地址解析 DNS查询过程DNS客户机——&gt;本地域名服务器——&gt;根DNS服务器——&gt;cn服务器——&gt;com.cn服务器——&gt;imooc.com.cn——&gt;本地域名服务器——&gt;DNS客户机——&gt;web服务器www.imooc.com.cn DNS查询类型从查询方式上分 递归查询：客户机将请求发送给DNS服务器，服务器通过缓存或者询问其他服务器最后将一个准确的结果或者失败回复给客户机，客户机只负责问，所有事情都是服务器做。客户机对本地域名服务器查询的机制，必须反馈准确值（要么成功要么失败） 迭代查询：客户机像DNS服务器发送请求后，服务器向客户机返回另一个服务器的地址，客户机不停地向不同DNS服务器发送请求，所有事情都自己做。本地域名服务器分别对各级域名服务器的查询机制，不一定反馈准确值 从查询内容上分 正向：域名到IP ARP 反向：IP到域名 RARP 网关 网关（Gateway）又称网间连接器、协议转换器 网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层不同的网络互连 网关既可以用于广域网互连，也可以用于局域网互连 网关是一种充当转换重任的服务器或路由器 交换机不能识别ip，只能记录客户机的MAC地址。即只能在局域网中进行通信 访问不同网段，则需要引入网关。 网关：一个具有路由功能的设备，一般为路由器。 网关作用 网关在所有内网计算机访问的不是本网段的数据包时使用 把内网Ip转公网Ip，公网Ip转内网Ip]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 安装、卸载wine]]></title>
    <url>%2Fpost%2F8d5353b1.html</url>
    <content type="text"><![CDATA[安装1234sudo add-apt-repository ppa:wine/wine-buildssudo apt-get updatesudo apt-get install --install-recommends wine-stagingsudo apt-get install winehq-staging 卸载1234567sudo apt purge winerm -r ~/.winesudo apt-get autoremove#清理wine模拟运行的windows程序:sudo rm -r /home/username/.local/share/applications#清理残余的windows程序:sudo rm -r /home/username/.config/menus/applications-merged/wine* apt-get remove 会删除软件包而保留软件的配置文件 apt-get purge 会同时清除软件包和软件的配置文件]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用配置文件]]></title>
    <url>%2Fpost%2F6faff17a.html</url>
    <content type="text"><![CDATA[apt 源相关文件、目录12345/var/lib/apt/lists #ubuntu软件更新的源服务器的地址/etc/apt/sources.list#*.list文件在单独文件中写入源的地址，通常用来安装第三方的软件/etc/apt/sources.list.d yum 源1/etc/yum.repos.d/CentOS-Base.repo MySQL12/etc/mysql/my.cnf/etc/my.cnf 安装日志1234567/root/install.log #记录安装系统软件包以及其文件信息/root/install.log.syslog #记录安装过程留下来的事件记录/root/anacona-ks.cfg #以kickstart配置文件的格式记录安装过程中设置的选项信息#当要安装多台服务器时，可以先装一台，然后利用/root/anaconda-ks.cfg可以进行批量安装 网络配置123456/etc/sysconfig/network-scripts/ifcfg-eth0#网卡配置文件，IP/子网掩码/网关/DNS/ONBOOT/etc/sysconfig/network#设置主机名/etc/resolv.conf#DNS配置文件 用户管理12345678/etc/group #存储当前系统中所有用户组的信息/etc/gshadow #存储当前系统中用户组的密码信息/etc/passwd #存储当前系统中所有用户的信息/etc/shadow #存储当前系统中所有用户的密码信息 计划任务123456/etc/crontab #系统配置文件，只有root用户才会把这些内容载入到计任务表中/var/spool/cron #最终生成的计划任务文件/var/spool/cron/root #root用户的定时任务/var/spool/cron/user1 #user1用户的定时任务/var/log/cron #crontab日志，保存cron的任务执行记录，echo会打印到这里 /var/log/cron-日期 别名、历史123~/.bashrc/root/.bashrc/etc/bashrc 用户和用户组12/etc/login.defs #提供了几个用户帐户参数的缺省配置信息/etc/default/useradd #新建用户的默认配置]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下无法使用add-apt-repository命令]]></title>
    <url>%2Fpost%2F5ff43231.html</url>
    <content type="text"><![CDATA[Linux下无法使用add-apt-repository命令报错：add-apt-repository command not found 解决办法：12sudo apt install python-software-properties software-properties-common sudo apt update]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装JDK的两种方式]]></title>
    <url>%2Fpost%2F9df44923.html</url>
    <content type="text"><![CDATA[使用PPA源安装1234sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installersudo apt-get install oracle-java8-set-default oracle-java8-set-default：将jdk8设置为默认的Java运行版本 默认的安装路径是在/usr/lib/jvm/java-8-oracle中1echo $JAVA_HOME 使用源码包安装1uname -a #查询系统是32位还是64位 在http://www.oracle.com/technetwork/java/javase/downloads/index.html找需要的包下载 1234567891011sudo tar -zxvf ./jdk-8u171-linux-x64.tar.gz -C /usr/local/jdk1.8.0_171sudo vim /etc/profile#在文件的末尾追加下面行JAVA_HOME=/usr/local/jdk1.8.0_171PATH=$JAVA_HOME/bin:$PATH CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar export PATH JAVA_HOME CLASSPATH #使环境变量马上生效source /etc/profile #设置系统默认jdk 版本 卸载Java JDK12rpm -qa |grep jdkyum -y remove java java-1.6.0-openjdk-1.6.0.0-1.50.1.11.5.el6_3.x86_64 将上面查询出来的每个版本依次删掉即可。]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理05 脚本安装包]]></title>
    <url>%2Fpost%2F23683a56.html</url>
    <content type="text"><![CDATA[脚本安装包：准备工作1、本节以安装LNMP为例，所以需要先停止之前安装的apache和mysql服务（最好也将源码包安装的apache /usr/local/apache2删除） 2、保证yum源正常使用：可以使用yum list命令测试。（若是光盘yum源，记得挂载光盘） 3、关闭SELinux和防火墙： 永久关闭SELinux的方法：编辑文件/etc/selinux/config，将SELINUX=enforcing改为SELINUX=disabled，然后重启系统即可。 永久关闭防火墙的方法：chkconfig iptables off，开启为：chkconfig iptables on；临时关闭防火墙的方法：service iptables stop，开启为：service iptables start。 脚本安装1wget -c http://soft.vpser.net/lnmp.lnmp1.0-full.tar.gz &amp;&amp; tar zxvf lnmp1.0-full.tar.gz &amp;&amp; cd lnmp1.0-full &amp;&amp; ./centos.sh 脚本安装过程中，会将系统中已有的apache、mysql、php等卸载掉。 虚拟机中安装lnmp常常会卡在 starting php-fpm,真实环境中很少出现。其实安装已经完成，只需要杀掉php-fpm进程，再重新启动这个进程就好了 pkill -9 php-fpm : -9是强制杀死的意思，然后重新启动该进程【/etc/rc.d/init.d/php-fpm start】即可。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理04 源码包]]></title>
    <url>%2Fpost%2Fc064f8f9.html</url>
    <content type="text"><![CDATA[源码包和RPM包安装位置的不同：RPM包安装位置rpm包有安装的默认位置： /etc/ 配置文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib/ 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 当然RPM包可以指定安装位置，但是建议不要指定安装位置，就让它安装到默认位置，这样系统可以找到它，利用service XXX start的方式启动它，而且rpm提供-e选项来自动卸载，摆明了就是推荐你让它默认安装1rpm -ivh --profix=&lt;dir&gt; 源码包安装位置安装在指定位置当中，一般是/usr/local/软件名，源码包没有卸载命令 安装位置不同带来的影响rpm包安装的服务可以使用系统服务管理命令（service）来管理，例如： RPM包安装的apache的启动方法是：12/etc/rc.d/init.d/httpd start service httpd start 源码包安装的服务不能被服务管理命令管理，因为没有安装到默认路径中，所以只能用绝对路径进行服务的管理，不同软件请参考INSTALL或README，如：1/usr/local/apache2/bin/apachectl start 使用绝对路径启动程序的方法是通用的，通常软件包中会写上启动程序的方法的。 如果将源码包安装后的启动程序复制到/etc/rc.d/init.d目录中，则也是可以使用service命令执行的 源码包是不能使用service命令来启动服务，因为源码包的安装位置由用户指定，放在哪并不统一；rpm包安装后，通常都是放在/etc/rc.d/init.d目录中的，而service命令执行时，会自动搜索该目录，所以rpm包安装的服务可以使用service命令 安装安装准备 由于源码都是c语言写的，所以要先安装c语言编译器：gcc 从官方网站下载源码包，若是下载到了windows上面，可以使用ftp传到linux上 注：若已安装了二进制包，则源码包也是可以继续安装的，因为两者安装目录不一样。但是，并不建议这样做，因为端口会冲突。 对于要求效率的软件，要安装源码包版本，因为是本机编译，更具有兼容性和效率，而rpm包是软件开发者提供的大众版本，可用于不注重效率的应用。 netstat -tlun查找网络连接信息和系统开启的端口号使用 -t 选项列出 TCP 协议的连接使用 -l 选项列出正在监听的套接字使用 -u 选项列出 UDP 协议的连接使用 -n 选项禁用域名解析功能 安装注意事项 源代码一般保存位置：/usr/local/src 软件安装位置：`` 如何确定安装过程报错 安装过程停止 并出现error、warning、no的提示 安装步骤123456789101112#下载源码包wget http://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.33.tar.gz#解压缩tar -zxvf httpd-2.4.33.tar.gz#进入解压缩目录cd httpd-2.4.33#软件配置与检查，指定安装位置./configure --prefix=/usr/local/apache2#编译，根据当前目录下的Makefile内部信息编译make#编译安装，根据当前目录下的Makefile内部信息安装make install ./configure作用 定义需要的功能选项； 检测系统环境是否符合安装要求 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。 其中的apache2目录不需要提前创建，make install命令执行时会自动创建 解压的文件夹中有一个INSTALL或README文件，vi打开之就可以看到详细的安装说明了。 如果make环节出错，只需要make clean即可。如果make install安装环节出错，我们就得删除configure时制定的安装目录，因为其中生成的文件失效了。 源码包的卸载只需要把安装目录删除即可。因为安装过程中生成的所有文件都是存放在安装目录中的，所以将安装目录删除就不会留下任何垃圾。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理03 yum在线安装]]></title>
    <url>%2Fpost%2Fd361ed04.html</url>
    <content type="text"><![CDATA[yum源文件将所有软件包放到官方服务器上，当进行yum在线安装时，可以自动解决依赖性问题。（rpm缺点：安装过程中，rpm包依赖性太强） RedHat的yum是收费服务，而CentOS的yum是免费服务。 在/etc/yum.repos.d/目录中，默认有4个yum源文件，其中CentOS-Base.repo是基本yum源文件，如果我们能上网，那它是默认生效的，而其他的都是默认不生效的。 mirrorlist和baseurl一个是主站点，一个是辅助站点，代表内容一样，只写一个就行，可以修改为国内的源 gpgcheck：一般都要开启，开启后安装时会验证rpm包是否是官方的，以保证系统安全。 gpgkey：默认系统安装后，在目录/etc/pki/rpm-gpg下都会存在数字证书。 注：前面的file://表示文件协议，后面的/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6是数字证书的位置。1234567[root@CentOS6 ~]# cd /etc/pki/rpm-gpg[root@CentOS6 rpm-gpg]# ll总用量 16-rw-r--r--. 1 root root 1706 11月 27 2013 RPM-GPG-KEY-CentOS-6-rw-r--r--. 1 root root 1730 11月 27 2013 RPM-GPG-KEY-CentOS-Debug-6-rw-r--r--. 1 root root 1730 11月 27 2013 RPM-GPG-KEY-CentOS-Security-6-rw-r--r--. 1 root root 1734 11月 27 2013 RPM-GPG-KEY-CentOS-Testing-6 光盘搭建yum源如果没有网络，可以使用光盘 123456789101112131415161.挂载光盘mkdir /mnt/cdrom#建立挂载点mount /dev/cdrom /mnt/cdrom#挂载光盘2.使网络yum源失效 cd/etc/yum.repos.d/#进入yum源目录mv CentOS-Base.repo CentOS-Base.repo.bak#修改Yum源文件后缀名，使其失效；（判断yum源是根据后缀名repo来实现的，修改后缀名则可以使该yum源失效）3.使光盘yum源生效 yum命令查询1234567891011121314yum list# 查询所有可用软件包列表yum search 关键字# 搜索服务器上所有和关键字相关的包yum search ifconfig#可以得知ifconfig命令来自包net-tools.x86_64yum info xxx#软件包信息yum clean packages#清理缓存 安装12yum -y install 包名（只用包名即可）# -y 自动回答yes 升级12yum -y update 包名# -y 自动回答yes 卸载123yum -y remove 包名# -y 自动回答yes# 服务器使用最小化安装，用什么软件安装什么，尽量不卸载 yum软件组管理命令12345678910111213yum grouplist #列出所有可用的软件组列表 yum groupinstall 软件组名 #安装指定软件组，组名可以由grouplist查询出来 yum groupremove 软件组名 #卸载指定软件组 软件组名必须是英文LANG=en_US 临时更改语系为英文 LANG=zh_CN.utf8 临时生效 /etc/sysconfig/i18n中 修改配置文件永久生效 换源1234567mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupcd /etc/yum.repos.d/#https://mirrors.163.com/.help/centos.html，选择相应版本的centos源wget http://mirrors.163.com/.help/CentOS7-Base-163.repoyum makecacheyum -y update]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理02 RPM包管理]]></title>
    <url>%2Fpost%2F477f7d2e.html</url>
    <content type="text"><![CDATA[RPM包的来源所有RPM包都来自安装系统光盘的Packages目录中 RPM包命名规则 包全名：操作的包是没有安装的软件包时，使用包全名，而且要注意路径 包名：操作已安装的软件包时，使用包名，是搜索/var/lib/rpm/中的数据库 RPM包依赖性 树形依赖：a-&gt;b-&gt;c 解决方法：从后往前安装 环形依赖：a-&gt;b-&gt;c-&gt;a 解决方法：放在一条命令中安装即可 模块依赖：库文件依赖，库也叫模块，就是linux当中的函数，它有一个典型的特征，就是以.so.数字结尾，它依赖的其实是一个文件，而不是软件包。该文件藏身在某一个软件包当中。我们只要将该文件所在的软件包安装上，该文件也就安装了。解决方法：登录www.rpmfind.net 网站，输入库文件名称查询到对应的rpm包，然后安装即可。 RPM安装12345rpm -ivh 包全名# -i （install）安装# -v（verbose）显示详细信息# -h（hash）显示进度# --nodeps不检测依赖性（一般不用） RPM 升级12rpm -Uvh 包全名# -U（update）升级 需要包全名，而不是包名。可以如此理解：升级时的新包对于系统是新的，因此要包全名 如果这个包从来没有安装过，那么效果等同于rpm -ivh 包全名 RPM卸载123rpm -e 包名# -e（erase）卸载# --nodeps 不检查依赖性 rpm准备了这个卸载命令的原因是，我们安装时根本不知道这个包装了在哪里（要知道linux下的安装的软件的文件散布多个地方的，很难一一找），而rpm知道，所以干脆就为我们准备了这条便利的命令。 window下卸载软件，往往容易留很多垃圾数据难以除完，例如注册表等等。而linux中不会出现这个问题，只要把软件的安装目录所有都删除掉，就不会有残留。 RPM包查询1234567891011121314151617181920212223242526272829303132rpm -q 包名# 查询包是否安装# -q 查询（query）rpm -qa 包名# 查询所有已经安装的RPM包# -a 所有（all）# rpm -qa | grep httpdrpm -qi 包名# 查询软件包详细信息# -i (infomation) : 查询软件信息rpm -qip 包全名# -p (package) : 查询未安装报信息# 有时遇到问题, 可根据未安装包信息中所提供的网站进行查询资料rpm -ql 包名# 查询包中文件安装位置# -l (list) : 列表# -p (package) : 查询未安装包信息# 可查看包作者欲将包安装的位置rpm -qf 系统文件名# -f (file) : 查询系统文件属于哪个软件包# 查询系统文件属于哪个 RPM 包# 该文件必须是通过 RPM 包安装的rpm -qR 包名# 查询软件包的依赖性# -R (requires) : 查询软件包的依赖性 # -p (package) : 查询未安装包的信息 RPM包默认安装位置 RPM包校验1234rpm -V 已安装的包名# -V (verify) : 校验指定RPM包中的文件# 执行后, 无任何提示, 代表该文件没有被做任何修改# 判断本地的安装包与官方给出的是否一致, 从而判断是否被人修改 验证内容中的8个信息 S : 文件大小是否改变 M : 文件的类型或文件的权限( rwx )是否被改变 5 : 文件MD5 校验和是否改变( 可以看成文件内容是否改变 ) D : 设备的主从代码是否改变 L : 文件路径是否改变 U : 文件的属主( 所有者 ) 是否改变 G : 文件的属组是否改变 T : 文件的修改时间是否改变 验证内容中的文件类型 c (config file) : 配置文件 d (documentation) : 普通文档 g (ghost file) : “鬼”文件, 很少见, 就是该文件不应该被这个RPM包包含 L (license file) : 授权文件 r (read me) : 描述文件 MD5校验用来校验文件的完整性(文件内容是否被改变) 例如, 在官网下载的游戏, 官方会给出MD5校验码, 将下载的游戏通过专用的MD5校验工具校验后生成一份MD5校验码, 对比两份校验码是否一致, 不一致则说明，下载的文件可能丢包, 可能文件损坏, 可能被其他人动过手脚一直木马等 RPM包中的文件提取1rpm2cpio 包全名 | cpio -idv .文件绝对路径 前面的.代表当前路径，不能省略。 文件绝对路径和包里文件的绝对路径对应，也就是告诉了cpio要去包里提取哪个文件。 cpio只知道提取文件，并不知道要从什么地方提取文件，因此我们通常要使用|管道符或&lt;输入重定向告诉cpio我们应该从什么设备去取出文件。 12345cpio 选项 &lt; [文件|设备]# 使用输入重定向的cpio# -i：copy-in模式，还原# -d：还原时自动新建目录# -v：显示还原过程]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理01 软件包分类]]></title>
    <url>%2Fpost%2Ff062c1ba.html</url>
    <content type="text"><![CDATA[二进制包是经过源码包编译过的安装包，编译就是将源码解释为机器可以认识的二进制语言的过程，安装源码包比二进制包复杂，因为要经过一个编译的过程，这个过程容易出错，一旦出错，就要对源码进行修改。 在redhat中二进制包后缀是rpm，在debian系列里如ubuntu二进制包的后缀是deb，但是它们都是二进制包。Linux下安装软件只有俩种格式：二进制包和源代码包 源码包优点 开源，如果有足够的能力，可以修改源代码 可以自由选择所需的功能 软件是编译安装，所以更加适合自己的系统，更加稳定、效率更高 卸载方便（直接删除） 缺点 安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误 编译过程时间较长，安装比二进制安装时间长 因为是编译安装，安装过程中一旦报错新手很难解决 二进制包（RPM包、Deb包）二进制包安装速度快是它的优点，但是二进制包不是系统自己编译的，效率不如源码包。如果是生产环境，就要源码包安装，因为效率高。 优点 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 安装速度比源码包安装快的多 缺点 经过编译，不再可以看到源代码 功能选择不如源码包灵活 依赖性 脚本安装包把复杂的软件包安装过程写成了程序脚本，初学者可以执行脚本实现一键安装。但实际安装的还是源码包和二进制包,例如LAMP一键安装包 优点：安装简单、快捷 缺点：完全丧失了自定义性，不能定义安装软件的版本，不能定义所需要的软件功能，源码包的优势几乎完全丧失]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理06 chattr、lsattr]]></title>
    <url>%2Fpost%2F2ce6014e.html</url>
    <content type="text"><![CDATA[作用禁止修改某些重要的系统文件 使用条件 所支持的文件系统包括：ext2、ext3、ext4和xfs 一般要求内核版本不低于2.2(查看版本的命令如下：uname -a、lsb_release -a 不能保护 /、/tmp 、/dev、/var目录 chattr只能由root用户使用 chattr类似于chmod, chmod只是改变文件的读写、执行权限，更底层的属性控制是由chattr来改变的.1234567891011121314chattr [+-=] [选项] 文件或目录名* +：增加权限* -：减少权限 * =：等于某权限* a：即append * 如果对文件设置a属性，那么只能在文件中增加数据，不能删除也不能修改数据（不能使用vi，因为不能判断是增加还是修改，可以使用echo） * 如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除* i：即insert * 如果对文件设置i属性，那么不允许对文件进行删除、改名、设定链接关系，同时不能写入或新增内容 * 如果对目录设置i属性，那么只能修改目录下文件的数据，不允许建立和删除文件chattr +a abcchattr +i abc lsattr查看文件系统属性1234lsattr [选项] [文件名]* -a：列出目录下的所有文件，包括隐藏文件* -d：查看本目录自身的权限 参考： http://www.cnblogs.com/Jimmy1988/p/7265816.html https://www.imooc.com/video/9667]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理05 SUID、SGID、SBIT]]></title>
    <url>%2Fpost%2F271a6e14.html</url>
    <content type="text"><![CDATA[SUID(SetUID)使用户临时具有程序所有者（比如root）的权限来执行该程序，比如调用/usr/bin/passwd命令修改自己的密码 SetUID(或者 s 权限）：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然 “灵魂附体” 了，实际在以passwd命令所有者root的身份在执行，root当然可以将密码写入/etc/shadow文件，命令执行完成后该身份也随之消失。当然用户的passwd命令不能修改其他用户的密码，只能输入passwd来修改自己的密码 使用要求 只有可执行的二进制程序才可以设置SetUID 命令执行者必须对欲设置SetUID的文件具备可执行(x) 权限，没有x的文件会成为S，S不能正确使用，只有s可以正确使用 命令执行过程中，其它用户获取所有者的身份（灵魂附体） SetUID具有时间限制，即完成该程序执行后就消失 不能对目录使用 命令4代表SUID，s出现在文件所有者的x权限上 1234567#设置SetUIDchmod 4755 文件名chmod u+s 文件名（推荐，不影响其他权限）#取消SetUIDchmod 0755 文件名chmod u-s 文件名（推荐，不影响其他权限） 例程以普通用户执行12345678910ll /usr/bin/touchtouch test1sudo chmod u+s /usr/bin/touchll /usr/bin/touchtouch test2ll test1 test2#比较前后两次的属性差异-rw-rw-r--. 1 niesh niesh 0 7月 30 17:40 test1-rw-rw-r--. 1 root niesh 0 7月 30 17:42 test2 可以看到，在设置了SetUID之后，新建文件的所有者为root了，说明在执行touch的时候，用户自动升级为了所有者 危险性设置SetUID是具备很大危险性的，主要是设置权限过大而引起的问题我们需要定时查看系统中有哪些设置了SetUID权限 关键目录应严格控制写权限。比如 /、/usr 用户的密码设置要严格遵循密码三原则(#复杂性，易记忆性，时效性） 对系统中默认应该具有SetUID权限的文件做一个列表，然后定期检查有没有这之外的执行程序的命令文件被设置了SetUID 使用shell定期检查SetUID12345678910111213#!/bin/bashfind / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.checkfor i in $(cat /tmp/setuid.check)do grep $i /root/suid.log &gt; /dev/null if [ &quot;S?&quot; !=&quot;0&quot;] then echo &quot;$i isn&apos;t in listfile!&quot; &gt;&gt; /root/suid_log_$(date+%F) fidonerm -rf /tmp/setuid.check SGID(SetGID)SetGID基本与SetUID相同，SetUID是设置所有者的权限，SGID为设置所属组的权限区别点在于：SetGID也可以设置目录的相关SetGID权限 作用将用户所在组临时升级为某一个组，以执行只有该组才有相应权限进行的操作 使用要求 针对文件： 可执行的二进制文件 命令执行者（即所属组）对该文件具备 x 权限 命令执行者在执行程序的时候，组身份升级为该程序文件的属组 权限只在执行过程中有效 针对目录： 普通用户对目录具备r和x权限，才可以进入到该目录 普通用户在此目录中的有效组会变成此目录的所属组 如普通用户对该目录具备w权限，新建文件的所属组为该目录的所属组 命令2代表SGID，s出现在文件所属群组的x权限上1234567#设置SetGIDchmod 2xxx &lt;file/dir-name&gt;chmod g+s &lt;file/dir-name&gt; （推荐）#取消SetGIDchmod xxx &lt;file/dir-name&gt;chmod g-s &lt;file/dir-name&gt; 例程我们此处以locate命令进行讨论：locate查询命令，比find要快很多，为什么？因为其实搜索的数据库而非整个硬盘：12345[root@niesh ~]# ll /usr/bin/locate-rwx--s--x. 1 root slocate 40496 6月 10 2014 /usr/bin/locate[root@niesh ~]# ll /var/lib/mlocate/mlocate.db-rw-r-----. 1 root slocate 6306909 7月 30 19:15 /var/lib/mlocate/mlocate.db 我用普通用户进行locate查看：12[niesh@niesh root]$ locate mlocate.db/usr/share/man/man5/mlocate.db.5.gz 去掉locate的s权限：123456[root@niesh ~]# chmod g-s /usr/bin/locate[root@niesh ~]# ll /usr/bin/locate-rwx--x--x. 1 root slocate 40496 6月 10 2014 /usr/bin/locate[niesh@niesh root]$ locate mlocate.dblocate: 无法执行 stat () `/var/lib/mlocate/mlocate.db&apos;: 权限不够 也就是：当执行locate命令时，普通用户niesh自动升级为slocate的组成员。 /usr/bin/locate是可执行二进制程序，可以赋予SGID 执行用户niesh对/usr/bin/locate命令拥有执行权限 执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate命令查询mlocate.db数据库 命令结束，niesh用户的组身份返回为niesh组 SBIT(Sticky BIT)粘滞位 作用防止其他用户删除自己的文件，使用者在该目录下，仅自己与root才有权力删除新建的目录或文件 使用要求只对目录有效普通用户对该目录有w和x权限若没有粘滞位，则普通用户可以对目录下的文件/子目录进行删除操作（因为普通用户对目录具有w权限），包括其它用户建立的目录/文件；但若赋了SBIT，则普通用户只能删除自己创建的文件/目录，而不能删除不属于自己的文件/目录！ 命令1代表SBIT，t出现在文件其他用户的x权限上1234567#设置SBITchmod 1xxx &lt; dir-name &gt;chmod o+t &lt; dir-name &gt;#取消SBITchmod xxx &lt; dir-name &gt;chmod o-t &lt; dir-name &gt; 例程以/tmp为例：查看/tmp的权限：12[niesh@niesh tmp]$ ll -d /tmp/drwxrwxrwt. 8 root root 4096 7月 30 19:40 /tmp/ 会看到，/tmp目录的权限other部分为rwt,这个t就是我们设置的粘滞位接下来，我们用其它用户创建两个文件：123456[Jimmy@niesh tmp]$ touch test-file[Jimmy@niesh tmp]$ mkdir test-dir[Jimmy@niesh tmp]$ ll总用量 0drwxrwxr-x. 2 Jimmy Jimmy 6 7月 30 19:44 test-dir-rw-rw-r--. 1 root Jimmy 0 7月 30 19:44 test-file 切换到另外一个用户niesh:123456789[niesh@niesh tmp]$ ll总用量 0drwxrwxr-x. 2 Jimmy Jimmy 6 7月 30 19:44 test-dir-rw-rw-r--. 1 root Jimmy 0 7月 30 19:44 test-file在 niesh用户下，删除/tmp目录下的文件：[niesh@niesh tmp]$ rm -rf test-dir/ test-filerm: 无法删除&quot;test-dir/&quot;: 不允许的操作 无法删除！ 然后，我们切换到root，去掉/tmp的粘滞位：123456[niesh@niesh tmp]$ su -密码：上一次登录：日 7月 30 19:43:21 CST 2017pts/0 上[root@niesh ~]# chmod o-t /tmp/[root@niesh ~]# ll -d /tmp/drwxrwxrwx. 9 root root 4096 7月 30 19:48 /tmp/ 最后，切换到普通用户niesh，再次删除/tmp下的文件：123[niesh@niesh root]$ rm -rf /tmp/test-dir/ /tmp/test-file[niesh@niesh root]$ ll /tmp/总用量 0 参考： http://www.cnblogs.com/Jimmy1988/p/7260215.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理04 sudo权限]]></title>
    <url>%2Fpost%2F6ca02215.html</url>
    <content type="text"><![CDATA[目的赋予普通用户超级管理员的权限 使用12345678910111213141516visudo#实际修改的是/etc/sudoers文件#sudo的配置文件是/etc/sudoers。visudo会锁住sudoers文件，保存修改到临时文件/etc/sudoers.tmp，然后检查文件格式，确保正确后才会覆盖sudoers文件。必须保证sudoers格式正确，否则sudo将无法运行。root ALL=(ALL) ALL用户名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）%wheel ALL=(ALL) ALL%组名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）第二个all指，可以切换成任意身份，这个可以直接省略$sudo -l #查看可以执行的命令$sudo /sbin/shutdown -r now#普通用户执行超级命令的时候必须要加 sudo 命令的绝对路径 补充： http://www.cnblogs.com/Jimmy1988/p/7270881.html https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E6.9F.A5.E7.9C.8B.E5.BD.93.E5.89.8D.E8.AE.BE.E7.BD.AEhttp://man.linuxde.net/sudo?zwbizq=f0evo1]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理03 ACL权限]]></title>
    <url>%2Fpost%2F2b0963f2.html</url>
    <content type="text"><![CDATA[文件一般权限包括所有者权限、组权限和其他权限，有时候不能满足要求（一个不属于u/g/o的用户也要对文件有权限），这时候就需要ACL权限，用来解决用户身份不够的问题 CentOS不需要开启ACL权限，xfs文件系统默认开启了ACL权限，可以直接使用getfacl和setfacl命令 查看分区ACL权限是否开启123456789df ＃查看分区dumpe2fs -h /dev/sda5#dumpe2fs命令时查询指定分区详细文件系统信息的命令-h 仅显示超级块中信息，而不显示磁盘块的详细信息#仅适用于ext4等文件格式，xfs默认开启了acl权限文件信息里项：Default mount options: user_xattr acl那就说明分区是支持acl的 开启ACL权限临时开启分区ACL权限12mount -o remount,acl /#重新挂载根分区，并挂载加入acl权限 永久开启分区ACL权限1234567vi /etc/fstabUUID=c2ca6f57-b15c-43ea=bca0-f239083d8bd2 / ext4 defaults,acl 1（＃启动是否需要检测） 1(#启动是否需要备份)#加入aclmount -o remount /#重新挂载文件系统或重启系统，使修改生效 查看ACL权限1getfacl 文件名 会显示mask值 设置acl权限123456789101112131415setfacl 选项 文件名选项-m #设定acl权限-x #删除指定的acl权限-b #删除所有的acl权限-d #设定默认acl权限-k #删除默认acl权限-R #递归设定acl权限例：setfacl -m u:lw:rx /av#给用户lw赋予r-x权限，使用&quot;u:用户名:权限&quot;格式例：setfacl -m g:group2:rwx /av#给用户组group2赋予rwx权限，使用&quot;g:组名:权限&quot;格式 设定之后会在ls -al命令显示的权限末尾出现+号1drwxr-xr-x+ root root 最大有效权限maskmask是用来指定最大有效权限的。如果给用户赋予了acl权限，是需要和mask的权限“相与”才能得到用户的真正权限。相与是计算机中的术语，皆真方为真，有假便为假。 最大权限也会影响到组权限。例：某文件所有者为tony，chmod赋予的普通权限为7，而acl赋予tony的权限为5，则acl权限会高于chmod权限 修改mask值12setfacl -m m:rx 文件#设定mask权限为r-x。使用“m:权限”格式 删除acl权限12345678setfacl -x u:用户名 文件#删除指定用户的acl权限setfacl -x g:组名 文件#删除指定用户的acl权限setfacl -b 文件#删除文件所有的acl权限 递归ACL权限在给父目录赋予权限的同时，给已经存在于目录下的文件赋予相同的权限12setfacl -m u:用户名:权限 -R 目录名#R表示递归 注意 用递归的方式容易导致文件权限溢出(目录为r-x，子文件则也为r-x) 递归acl只能用在目录而不能用于普通文件 默认ACL权限给父目录下将来新建的文件默认赋予父目录的权限12setfacl -m d:u:用户名:权限 目录名#d表示default 设置后可以使用getfacl查看 补充：https://www.cnblogs.com/Jimmy1988/p/7249844.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理02 默认权限umask]]></title>
    <url>%2Fpost%2F815d598f.html</url>
    <content type="text"><![CDATA[Windows中的默认权限是从上级目录中继承的Linux的默认权限是通过umask设置的 查看默认权限123456umask #查看默认权限00220：文件特殊权限022：文件默认权限 修改默认权限12345# 临时修改umask 0002# 永久修改vi /etc/profile 文件的默认权限 文件默认最高权限为666 文件默认不能建立为执行文件，必须手工赋予执行权限,所以文件默认权限最大为666 默认权限需要推算成字母（rwx）再相减 建立文件之后的默认权限，为666减去umask值 目录的默认权限 目录的默认权限最大为777 默认权限需要换算成字母再相减 建立文件之后的默认权限，为777减去umask值 例如： 目录默认最大权限为777，umask值022 -rwxrwxrwx 减去 -----w--w-等于 -rwxr-xr-x]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理01 一般权限]]></title>
    <url>%2Fpost%2Fc2feff11.html</url>
    <content type="text"><![CDATA[文件的权限主要针对三类对象进行定义： owner: 属主, u group: 属组, g other: 其他, o 每个文件针对每类访问者都定义了三种权限： r: Readable w: Writable x: eXcutable 查看权限1ls -al 第1位 2-4位 5-7位 8-10位 11位 - rwx r-x r-x . 文件类型 u所有者 g所属组 o其他人 ACL权限 修改权限1234567891011chmod [OPTION]... OCTAL-MODE FILE...chmod [选项] 模式 文件名选项：-R 递归（用于目录）模式：[u/g/o/a] [+ - =] [rwx] 或 [mode=421]chmod a=rwx filenamechmod u+w filenamechmod [OPTION]... --reference=RFILE FILE...# 参考RFILE文件的权限，将FILE修改为同RFILE一样的权限 权限的作用权限对文件的作用 r：读取文件内容（cat/more/head/tail） w：编辑、新增、修改文件内容（vi/echo），不包括新增文件和删除文件 x：可执行，判断是否为可执行文件 文件中的数据存储在文件数据block里，而文件名储存位置在目录block中，要删除文件，意味着要删除文件名，所以要想删除文件，必须对目录block进行操作 权限对目录的作用 r：查询目录下的文件（ls） w：具有修改目录结构的权限。如新建文件和目录，删除此目录下的文件和目录，重命名此目录下文件和目录，剪切（touch/rm/mv/cp） x：进入目录（cd） 对文件来说，最高权限是x对目录来说，最高权限是w目录只有0，5 ，7权限有意义。4、1、6权限没有意义文件的常用权限是644目录的常用权限是755 其他命令12345678910111213#修改文件所有者chown 用户名 文件各-R: 递归#同时修改文件的所有者和所属组chown 用户名:所属组 文件名chown [OPTION]... --reference=RFILE FILE...#修改文件的所属组chgrp 所属组 文件名chgrp [OPTION]... GROUP FILE...chgrp [OPTION]... --reference=RFILE FILE... 分配文件基本权限时，核心原则：在最小权限情况下能够实现要求即可]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 帮助命令]]></title>
    <url>%2Fpost%2F4a7c8c06.html</url>
    <content type="text"><![CDATA[针对内部命令和外部命令有不同的帮助命令 内部命令help：shell内部命令帮助1help shell内部命令 type \ whereis可以用来判断一个命令是否是shell内部命令ls在/bin/下面有可执行文件，说明ls命令不是shell内部命令cd命令在/bin/下面没有相应的可执行文件，所以是shell自带的命令man命令不能获取shell的内部命令help命令只能获取shell的内部命令 外部命令COMMAND –help/-h12345外部命令 --help # 获取命令选项的帮助# 一些命令不支持该选项ls --help man：使用手册(manual)许多希望被命令行使用的可执行程序提供了一个正式的文档，叫做man page，man是manual的缩写，最常用的帮助命令man使用less命令显示参考手册无法提供shell内建命令的参考手册 配置配置文件：/etc/manpath.config\ /etc/man_db.config，指定从哪里读取man文件，MANPATH，/usr/share/man就是其中的一个读取路径1man -M /PATH/TO/SOMEWHERE COMMAND # 到指定位置下搜索COMMAND命令的手册页并显示 man的级别man所显示的参考手册被分成几个章节，包括用户命令、系统管理员命令、程序接口、文件格式 用户命令 可被内核调用的函数，系统调用 C库函数程序接口 特殊文件（主要是/dev目录下的文件），比如设备结点和驱动程序 配置文件 游戏娱乐，如屏幕保护程序 其它杂项 系统管理员命令 内核相关 帮助手册中的段落说明：NAME 简短的命令，数据名称说明SYNOPSIS 简短的命令执行语法简介DESCRIPTION 较为完整的说明OPTIONS 针对SYNPATH部分中，有列举的所有可用的选项说明EXAMPLES 一些可以参考的范例AUTHOR 作者REPORTING BUGS 是否有相关的错误SEE ALSO 这个命令或数据其他说明 SYNOPSIS： []：可选内容 &lt;&gt;: 必选内容 a|b：二选一 …: 同一内容可出现多次 man命令的操作方法12345678910111213141516171819man command# 获取指定命令的帮助man -f 命令# 查看命令的所有帮助等级# 相当于 whatis 命令# 因为whereis命令可以看到命令的帮助文档目录，所以也可以查看目录的等级man 级别 命令# 查看相应等级的命令man -5 passwdman -4 nullman -8 ifconfigman -k 命令 # 相当于 apropos 命令# 搜索含有关键词“命令”的所有帮助文档man -k passwd# 搜索含有关键词“passwd”的所有命令的帮助文档 123456789101112131415161718192021Space 向文件尾翻屏b 向文件首部翻屏d 向文件尾部翻半屏u 向文件首部翻半屏j 向文件尾部翻一行k 向文件首部翻一行q 退出number 跳转至第number行1G 回到文件首部G 翻至文件尾部文本搜索：/KEYWORD: 以KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索；不区分字符大小写 n: 下一个 N：上一个?KEYWORD:以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索；不区分字符大小写 n: 跟搜索命令同方向，下一个 N：跟搜索命令反方向，上一个 info信息页12345678info 命令# info里面内容十分繁琐，是关于命令的一个巨大的帮助文档，里面有各个版本对于此命令的说明。Enter 进入带*号的说明，*表示是一个链接u 进入上层页面n 进入下一个帮助小节p 进入上一个帮助小节q 退出 程序自身的帮助文档READMEINSTALLChangeLog 许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc目录下。这些文件大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。一些文件是 HTML 格式，可用网页浏览器来阅读。我们可能遇到许多以 “.gz” 结尾的文件。这表示 gzip 压缩程序已经压缩了这些程序。gzip 软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip压缩的文本文件的内容。 程序官方文档官方站点的Documentation 发行版的官方文档https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/ Google]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 命令的分类]]></title>
    <url>%2Fpost%2Fbc48c0fa.html</url>
    <content type="text"><![CDATA[命令的分类 shell内部命令，由shell自带的，而且通过某命令形式提供 外部命令，在当前系统的某文件系统路径下有对应的可执行程序文件，C、C++、shell、perl、python、ruby等，二进制文件、脚本文件，shell程序搜寻可执行程序文件的路径定义在$PATH环境变量中，自左至右搜寻 shell函数，环境变量中 命令别名 外部命令外部命令都有一个可执行程序，位于文件系统某目录下，通过 which, whereis可以查看shell程序搜寻可执行程序文件的路径定义在PATH环境变量中12echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/xxl/.local/bin:/home/xxl/bin 以:分隔，自左至右搜寻 type 查看命令类型可以用来区别内部或外部命令1234type 命令名type pwd # pwd 是 shell 内嵌type mkdir # mkdir 是 /usr/bin/mkdir which 显示一个外部命令对应的程序文件路径123which [OPTION] COMMAND# 不能看到命令的别名# 不能看到shell内部命令 whereis 显示外部命令所在路径及帮助文档所在位置1234567whereis 命令名选项：-b:只查找可执行文件-m:只查找帮助文件# 只能搜索系统命令，不能搜索自己凭空创建的普通文件# whereis不能看到shell内部命令（如：cd），只能看到外部安装的命令 whatis 查询一个命令执行什么功能123whatis 命令名whatis ls # 显示ls的作用 apropos 通过关键字搜索命令123apropos 关键字# 和man -k一样]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 命令]]></title>
    <url>%2Fpost%2F9da1ef6b.html</url>
    <content type="text"><![CDATA[命令提示符 prompt12345678[root@localhost ~]#root 当前登录用户localhost 主机名~ 当前所在目录（家目录）# 超级用户的提示符$ 普通用户的提示符环境变量 $PS1 命令的格式1COMMAND [OPTIONS...] [ARGUMENTS...] OPTIONS：选项用于启用或关闭命令的某个或某些功能短选项：-c, -l, -h等多个短选项可以写在一起，例如-l -h, 可写作-lh 长选项：--word，例如：--long, --human-readable ARGUMENTS：参数命令的作用对象，向命令提供数据 注意 多选项，以及多参数和命令之间都应该使用空白字符分隔 取消命令执行：Ctrl+c 个别命令使用不遵循此格式 命令的执行过程输入命令，回车，请求shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。表现为一个或多个进程。 路径 相对路径：从当前位置起始的路径 绝对路径：从根目录起始的路径 当前位置的表示方式： ./： ./sysconfig/network-scripts 省略上述符号: sysconfig/network-scripts 当前目录：current directory, 也称作working directory；用.表示pwd: printing working directory 打印当前目录 当前目录的上一级目录：..：表示当前目录的上一级目录]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令]]></title>
    <url>%2Fpost%2F9da1ef6b.html</url>
    <content type="text"><![CDATA[命令提示符123456789[root@localhost ~]#root 当前登录用户localhost 主机名~ 当前所在目录（家目录）# 超级用户的提示符$ 普通用户的提示符环境变量 $PS1 命令的格式12345678910111213COMMAND [OPTIONS...] [ARGUMENTS...]选项：用于启用或关闭命令的某个或某些功能； 短选项：-c, 例如：-l, -h 多个短选项可以写在一起，例如-l -h, 可写作-lh； 长选项：--word，例如：--long, --human-readable参数：命令的作用对象 向命令提供数据；注意：1、多选项，以及多参数和命令之间都应该使用空白字符分隔2、取消命令执行：Ctrl+c个别命令使用不遵循此格式 输入命令，回车：提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来；表现为一个或多个进程； 在shell中可执行的命令有两类：内建命令：由shell自带的，而且通过某命令形式提供；外部命令：在当前系统的某文件系统路径下有对应的可执行程序文件；which，whereis 用于查找并显示给定命令的绝对路径123456type COMMAND#区别内部或外部命令例子：[xxl@localhost ~]$ type pwdpwd 是 shell 内嵌[xxl@localhost ~]$ type mkdirmkdir 是 /usr/bin/mkdir 路径 相对路径：从当前位置起始的路径 绝对路径：从根目录起始的路径 当前位置的表示方式：(1) ./： ./sysconfig/network-scripts(2) 省略上述符号: sysconfig/network-scripts ..：表示当前目录的上一级目录 当前目录：current directory, 也称作working directory；用.表示pwd: printing working directory 打印当前目录]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 发行版及开源协议]]></title>
    <url>%2Fpost%2Ffd342599.html</url>
    <content type="text"><![CDATA[Linux的发行版基于kernal，会有不同的Linux发行版，这里 列出了2012年时的所有发行版，这里 列出了各个发行版的排名 12345678910111213141516slackware: suse opensusedebian: ubuntu mintredhat： rhel: redhat enterprise linux，每18个月发行一个新版本 CentOS：兼容rhel的格式 fedora：每6个月发行一个新版本ArchLinuxGentooLFS: Linux From scratchAndroid: kernel+busybox+java虚拟机 CentOS和Linux是什么关系？CentOS和RHEL是什么关系？CentOS是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。CentOS 是Community ENTerprise Operating System（社区企业操作系统）的简称，是Linux发行版之一，它是来自于Red Hat EnterpriseLinux（即RHEL）依照开放源代码规定释出的源代码所编译而成。RHEL是很多企业采用的linux发行版本，需要向RedHat付费才可以使用， 并能得到付过费用的服务和技术支持和版本升级。而CentOS可以像REHL一样的构筑linux系统环境，但不需要向RedHat付任何的费用，同样也 得不到任何有偿技术支持和升级服务。 开源协议GNU GPLv2, GPLv3, LGPL(lesser)Apache apacheBSD bsd 其他相关协议：Public DomainCC0wtfpl 下面是wtfpl的协议12345678910111213DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004 Copyright (C) 2004 Sam Hocevar &lt;sam@hocevar.net&gt; Everyone is permitted to copy and distribute verbatim or modified copies of this license document, and changing it is allowed as long as the name is changed. DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 0. You just DO WHAT THE FUCK YOU WANT TO. 具体的说明可以参考【转】五种常见的开源协议整理 参考： http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html http://pbagwl.com/post/5078147450/description-of-popular-software-licenses https://coolshell.cn/articles/4657.html http://www.wtfpl.net/txt/copying/ https://blog.csdn.net/wadefelix/article/details/6384317]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 计算机基础]]></title>
    <url>%2Fpost%2F2feeae2.html</url>
    <content type="text"><![CDATA[现代计算机设备的组成部分： 运算器、控制器、存储器、输入设备、输出设备 CPU bus：总线 memory: 编址存储设备 read ahead 高速缓存 IO: 与外部部件交互 磁盘 网卡 虚拟机：虚拟计算机 CPU：运算器、控制器 CPU指令，指令集； 特权指令：OS运行特权指令； 普通指令： 程序员： OS: Operating System 软件程序 通用目的 硬件驱动 进程管理 内存管理 网络管理 安全管理 System Call 系统调用 编程层次： 硬件规格：hardware specifiacation 系统调用： 库调用： library call UI: user interface 用户接口 GUI: Graphic User Interface 图形用户接口 CLI: Command Line Interface 命令行接口 ABI: Application Binary Interface 应用二进制接口API：Application Programming Interface 用用程序接口 CPU架构类型： x86 x64 arm m68000, m68k power powerpc ultrasparc alpha 安腾 WindowsLinux： Linus –&gt; Linux GNU/Linux Unix： System （Bell Lab） AIX （IBM） Solaris (SUN) HP-UX (HP) BSD: （BSRG）Berkeley System Distribution 伯克利软件套件 NetBSD OpenBSD FreeBSD MIT：Richard Stallman GNU: GNU is Not Unix； GPL：General Public LicenseCPU, memory, I/O 程序运行模式： 用户空间：user space, us 内核空间：system space POS: Portable Operating System 可移植操作系统 POSIX API: 编程接口； 运行程序格式： Windows: EXE, dll(dynamic link library 动态链接库文件) Linux: ELF, so(shared object 共享对象) 程序：指令+数据 指令：只读 数据：读写 程序：算法+数据结构 库调用，系统调用：允许被调用的程序； malloc(), free() 编程语言： 汇编语言：微码编程 系统中某些与硬件相关的特有代码、驱动程序开发； 高级语言C, C++： 系统级应用、驱动程序 高级应用java, python, php： 应用程序 unix-like LSB: Linux Standard Base Linux标准库 程序包管理器： rpm: RHEL, Fedora, S.u.S.E, CentOS dpt: Debian, Ubuntu 自由软件： 自由使用；自由学习和修改；自由分发；自由创建衍生版； Linux的哲学思想： 1、一切皆文件； 把几乎所有资源，包括硬件设备都组织为文件格式； 2、由众多单一目的小程序组成；一个程序只实现一个功能，而且要做好； 组合小程序完成复杂任务； 3、尽量避免跟用户交互； 目标：实现脚本编程，以自动完成某些功能； 4、使用纯文本文件保存配置信息； 目标：一款使用的文本编程器即能完成系统配置工作； 如何获取CentOS的发行版： http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com 登录： root/mageedu # startx &amp; 终端： 用户与主机交互，必然用到的设备； 物理终端：直接接入本机的显示器和键盘设备；/dev/console 虚拟终端：附加在物理终端之上的以软件方式虚拟实现的终端，CentOS 6默认启动6个虚拟终端 Ctrl+Alt+F#: [1,6] 图形终端：附加在物理终端之上的以软件方式虚拟实现的终端，但额外会提供桌面环境； 设备文件路径：/dev/tty# 模拟终端： 图形界面下打开的命令行接口，基于ssh协议或telnet协议等远程打开的界面 设备文件：/dev/pts/# [0,oo) 查看当前的终端设备：tty 交互式接口：启动终端后，在终端设备附加一个交互式应用程序 GUI： X protocol, window manager, desktop Desktop: GNOME (C, gtk) KDE (C++, qt) XFCE (轻量级桌面) CLI： shell程序： sh (bourn) csh tcsh ksh (korn) bash (bourn again shell), GPL zsh 显示当前使用的shell： # echo ${SHELL} 显示当前系统使用的所有shell： # cat /etc/shells 命令提示符：prompt [root@localhost ~]# [root@localhost ~]：PS1 prompt： 管理员：# 普通用户：$ 硬件系统主要有五大部分组成：运算器、控制器、存储器、输入设备、输出设备运算器：负责算术与逻辑运算。与控制器共同组成了中央处理器控制器：负责发送和接收指令存储器：用来存储正在进行程序、将要进行程序的数据及刚处理完的数据输入设备：用来进行输入的设备输出设备：用来进行输出的设备 硬件是基础，硬件需要通过系统软件控制来启动硬件，并让各个硬件之间相互协同工作，在系统软件的基础上是用户，用户操控的是系统软件，并在系统软件的基础上安装相应的应用软件，来完成用户所需要的工作，所以说最底层的是硬件，硬件上一层是系统软件，系统软件上一层是应用软件，而最上层的则是用户 计算机的工作原理算机的工作过程，就是执行程序的过程。怎样组织存储程序，涉及到计算机体系结构问题。现在的计算机都是基于“程序存储”概念设计末造出来的。了解了“程序存储”，再去理解计算机工作过程变得十分容易。如果想让计算机工作，就得先把程序编出来，然后通过输入设备送到存储器保存起来，即程序存储。根据冯·诺依的设计，计算机应能自动执行程序，而执行程序又归结为逐条执行指令。执行。执行一条指令可分为以下4个基本操作 取出指令：从存储器某个地址中取出要执行的指令送到CPU内部的指令寄存器暂存。 分析指令：把保存在指令寄存器中的指令送到指令译码器，译出该指令对应的微操作。 执行指令：根据指令译码，向各个部件发岀相应控制信号，完成指令規定的各种操作 为执行下一条指令作好准备，即取出下一条指令地址 计算机使用二进制的原因技术实现简单简化运算规则适合逻辑运算易于进行转换抗干扰能力强 机器数和真值一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1因为第一位是符号位，所以机器数的形式值就一等于真正的数值，将带符号位的机器数对应的真正数值称为机器数的真值（10000011的真值是-3，而不是131） 但是机器不是这么区分一个数的正负的，人可以直接看到第一位是1还是0来区分，机器如果直接判断会增加电路的复杂程度，所以人们就将符号位也参与运算，这样根据1-1=1+(-1)，只保留加法，于是有了原码、反码和补码 原码：符号位加上真值的绝对值，即用第一位表示符号，其余位表示值-1 &gt;&gt; 1000 00011 &gt;&gt; 0000 0001[-127,127] 反码：正数的补码是基本身负数和补码是在其原码的基础上，符号位不变，其余各个位数取反1 &gt;&gt; 0000 0001-1 &gt;&gt; 1111 1110 补码：正数的补码是基本身负数的补码是在其原码的基础上，符号位不变，其余各个位数取反，最后加1(即反码+1)1 &gt;&gt; 0000 0001-1 &gt;&gt; 1111 1111 在计算机系统中，数值一律使用补码来表示、存储因为这样减法可按加法来处理，0000 0001 + 1111 1111 = 0000 0000 ，进位舍去其实可以这样推导：为了实现一个正数i加上一个数等于0 ，所以用0-i，比如i等于0000 0001,那么0-i就是1111 1111, 我们知道0-1=-1, 所以 -1的补码就是1111 1111 ，以此类推，一个负数的补码就是0-对应正数的补码。 二进制 十进制 二进制 基本数字 10个，0-9 2个，0、1 进位规则 十进一 二进一 111001：2^5+2^4+2^3+2^0=57 二进制：计算机内部用二进制，运算简单，简化了计算机结构八进制：标志的开头用0表示，用0-7的数字表示十六进制：标志的开头用0x表示，用0-9、A、B、C、D、E、F表示 运算符 运算符 运算 示例 &amp; 与运算 6 &amp; 3 = 2 ` ` 或运算 `6 3 =7` ^ 异或运算 6 ^ 3 = 5 ~ 反码 ~6 = -7 &lt;&lt; 左移 3&lt;&lt;2 = 12 &gt;&gt; 右移 3&gt;&gt;1 = 1 &gt;&gt;&gt; 无符号右移 3&gt;&gt;&gt;1 = 1 按位与&amp;两位全为1，结果才为1按位与&amp;的特殊用法： 清零，如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都是零的数值相与，结果为零。10101110 &amp; 00000000 = 00000000 取一个数中指定位：找一个数，对应x要取的位，该数的对应位为1，其余位为零，此数与x进行“与运算”可以得到x中的指定位。10101110 &amp; 00001111 = 00001110 取后四位 按位或|只要有一个为1,结果就为1按位或|特殊用法：常用来对一个数据的某些位设置为1：找到一个数，对应x要设置1的位，该数的对应位为1，其余位为零。此数与x相或可使x中的某些位置1。10100000 | 00001111 = 10101111 后四位置一 异或^特殊用法：两位值不同则该位结果为1，否则为0 使特定位翻转：特定位异或1。10101110 ^ 00001111 = 10100001 后四位翻转 与0相异或，保留原值。10101110 ^ 00000000 = 10101110 两个变量交换值 借助第三个变量来实现 C=A;A=B;B=C; 利用加减法实现两个变量的交换 A=A+B;B=A-B;A=A-B 异或运算，一个数异或本身等于0和异或运算符合交换律 A=A^B;B=A^B;A=A^B 取反与运算~对一个二进制数按位取反，即将0变为1，1变0 左移&lt;&lt;将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0 右移&gt;&gt;将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。操作数每右移一位，相当于该数除以2 无符号右移运算&gt;&gt;&gt;各个位向右移指定的位数。右移后左边空出的位用零来填充。移除右边的位被丢弃。 负数以其正数的补码形式表示反码加1称为补码32位整数，最高位为1，就是负数负数 左移或者右移]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清华同方x46h开启Intel VT]]></title>
    <url>%2Fpost%2F8c4b67.html</url>
    <content type="text"><![CDATA[清华同方x46h是我在12年买的，在网上搜索的资料是说原本Intel VT技术是开启的，但是如果多次重装系统就会把它关闭，而且官方的BIOS是没有开启选项的，官方也没有提供BIOS更新，所以需要自己刷，结果我刷的代价就是主板被刷坏，花了350把主板修了，总之刷BIOS还是有风险的，这里只是提供具体方法 1、查看是否支持Intel VT技术以及是否开启下载leomoon-cpu-v，并安装 左边的对勾表示主板支持Intel VT右边的对勾表示主板已经开启Intel VT这张图片是已经开启的状态清华同方x46h的实际状态应该是左边对勾，右边叉 2、制作纯DOS启动U盘 下载MSDOS7.1解压 格式化U盘为FAT32分区格式 使用UltraIOS制作U盘启动盘和制作win7的启动U盘一样插入不用的U盘（因为需要格式化）在UltraIOS中文件》打开，选择解压后的MSDOS文件夹中的IOS镜像文件；点击启动》写入硬盘映像选择U盘，写入方式为USB-HDD+，点击写入 可以参考http://blog.sina.com.cn/s/blog_4ad042e50102eclt.html 3、下载需要刷的BIOS 在步骤2中制作好的U盘启动盘里新建文件夹，文件夹名叫12 下载X46H_BIOS，解压，将文件夹中的四个文件复制到12文件夹中 4、刷BIOS 重启电脑，按F2打开BIOS 将U盘设为电脑开启的第一启动项，保存，退出 插入U盘，重启电脑 会进入MSDOS界面，会先让你设置MSDOS，选择cancel取消设置 接下来输入以下命令 命令1： “C:” 回车 —将当前盘符切换到C:命令2： “CD 12” 回车 —将当前操作文件夹切换到C:\12下命令3： “fpt -bios -f GT_122.h09” 回车 —执行刷新命令 图4 刷新成功后 按开关机键 关机 ，将电池拔掉 ，电源线 移除 ，1分钟后安装好。 5、开启Intel VT开机，按F2进 BIOS 选择高级 Advanced 选项 会出现 虚拟化选项。打开后按F10保存并退出即可。 运行leomoon-cpu-v工具可以看到看到Intel VT已经开启 参考：http://benyouhui.it168.com/thread-1896445-1-1.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows配置JDK]]></title>
    <url>%2Fpost%2Fd6c16da1.html</url>
    <content type="text"><![CDATA[每次重装系统都要重新配置jdk每次都需要百度一下jdk的配置，毕竟也不是天天配java运行环境 1、下载jdk2、配置环境变量123JAVA_HOME D:\Java\jdk1.6.0_39CLASSPATH .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jarPath %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 注意CLASSPATH之前的点和分号 3、验证打开cmd，分别输入java -version，javac -version，如果可以看到版本号，说明成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】重装系统后hexo配置]]></title>
    <url>%2Fpost%2Fcb1fd277.html</url>
    <content type="text"><![CDATA[重装系统后需要重新配置Hexo，找了很多教程，结果不是这里出问题就是那里出问题，最后终于找到一个可以用的，所以记录下来 1、备份原Hexo文件夹下的source文件夹，以及站点目录下的_config.yml和主题目录下的_config.yml，后将整个Hexo文件夹删除 2、重装系统后，安装Node.js和Git for Windows，通过apt安装需要更新nodejs和npm1234sudo apt install nodejs npm gitsudo npm install -g nn stablesudo npm -g install npm@next 3、配置SSH key：在Git Bash敲入1ssh-keygen -t rsa -C “你的邮箱” 生成的密钥默认保存在C:\Users\XPS.ssh\id_rsa.pub，用笔记本打开该文件，复制里面的内容到Github&gt;Settings&gt;SSH and GPG keys&gt;New SSH key-Key一栏里，title可任意发挥1ssh -T git@github.com 测试是否成功 4、配置Git的个人信息：在Git Bash输入12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 5、在你要放置博客的文件夹打开Git Bash， 安装Hexo框架12sudo npm install hexo-cli -gsudo npm install hexo --save 6、hexo在指定文件夹中新建所需要的文件123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 7、Hexo3.0以上版本，需要安装hexo-deployer插件才能部署到Github1npm install hexo-deployer-git --save 8、在初始化完成后，将之前重装系统保存的Hexo文件夹下的这些文件夹拷贝至新的Hexo文件夹(即刚刚初始化完成的)内 9、执行以下命令来部署123hexo cleanhexo ghexo d 在重装系统完之后恢复Hexo初次部署需要一点时部署中如果弹出弹框，填yes即可。出现123To github.com:Aldrich-ayu/Aldrich-ayu.github.io.git+ cb4cda2...ec926bc HEAD -&gt; master (forced update)INFO Deploy done: git 即表示恢复Hexo并且部署成功！ 参考： http://yanziyu.tech/2017/04/04/reinstall-hexo/ https://hexo.io/zh-cn/docs/index.html https://aldrich-ayu.github.io/2017/07/31/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%81%A2%E5%A4%8D/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax工作原理]]></title>
    <url>%2Fpost%2F27441bd3.html</url>
    <content type="text"><![CDATA[12345678910111213141516172018年5月记，总结起来就几句话//创建xmlhttprequest对象var xhttp xhttp=new XMLHttpRequest();//使用xmlhttprequest对象的open()和send()方法发送资源请求给服务器xhttp.open(&quot;POST&quot;,&quot;ajax_info.txt&quot;,true);//调用onreadystatechange函数xhttp.onreadystatechange = function()&#123;&#125;;//获得服务器的响应document.getElementById(&quot;demo&quot;).innerHTML=xhttp.responseText;然后为了这四句能正确响应，添加必要的判断返回的响应也可能是各种形式，需要做各种处理是不是很简单 名称Asynchronous JavaScript and XML异步得JavaScript和XML 作用在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 同步与异步异步传输是面向字符的传输，它的单位是字符；异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致 同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。同步传输通常要比异步传输快速得多，同步传输的开销也比较少 包含的技术 使用CSS和XHTML来表示 使用DOM模型来交互和动态显示 使用XMLHttpRequest来和服务器进行异步通信 使用javascript来绑定和调用重点是3，理解XMLHttpRequest对象 XMLHttpRequest属性onreadystatechange 每次状态改变所触发事件的事件处理程序。responseText 从服务器进程返回数据的字符串形式。responseXML 从服务器进程返回的DOM兼容的文档数据对象。status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 使用ajax的步骤 创建xmlhttprequest对象，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。 使用xmlhttprequest对象的open()和send()方法发送资源请求给服务器 调用onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数 使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应 示例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;Let AJAX change this text.&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;loadDoc()&quot;&gt;Change Content&lt;/button&gt;&lt;script&gt;function loadDoc()&#123;// 1、创建xmlhttprequest对象var xhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;//var xhttp=new XMLHttpRequest();// 2、使用xmlhttprequest对象的open()和send()方法发送资源请求给服务器xhttp.open(&quot;POST&quot;,&quot;ajax_info.txt&quot;,true);//xhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);// 3、onreadystatechange函数xhttp.onreadystatechange = function()&#123; if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) &#123; // 4、使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应 document.getElementById(&quot;demo&quot;).innerHTML=xhttp.responseText;&#125;&#125;;xhttp.send();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 处理post表单post表单数据需要使用xmlhttprequest对象setRequestHeader方法增加一个HTTP头。post表单例子123xhttp.open(&quot;POST&quot;, &quot;ajax_test.aspx&quot;, true);xhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);xhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;); 处理xml需要放在if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) {}里面1234567xmlDoc = xhttp.responseXML;var txt = &quot;&quot;;x = xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i = 0; i &lt; x.length; i++) &#123; txt += x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;demo&quot;).innerHTML = txt; 处理json使用JSON.parse方法123456789101112131415xmlHttp.open(&quot;POST&quot;,&quot;tigongjson.php&quot;);//设置我们的请求头信息xmlHttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//需要放在if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) &#123;&#125;里面var data=xmlHttp.responseText;//json字符串转换成为json对象data=JSON.parse(data);var str=&quot;&quot;;for(var i=0;i&lt;data.length;i++)&#123; str+=&quot;姓名:&quot;+data[i].name+&quot;&lt;br&gt;&quot;; str+=&quot;年龄:&quot;+data[i].age+&quot;&lt;br&gt;&quot;; str+=&quot;性别:&quot;+data[i].sex+&quot;&lt;br&gt;&quot;;&#125;;div1.innerHTML=str; 其他请参考菜鸟教程 参考： AJAX 教程|菜鸟教程 Ajax的原理和应用(给公司做所的培训) Ajax的使用四大步骤 Ajax中解析Json的两种方法详解 使用原生ajax处理json组成的数组]]></content>
  </entry>
  <entry>
    <title><![CDATA[XML命名空间和XML Schema]]></title>
    <url>%2Fpost%2F7866b39f.html</url>
    <content type="text"><![CDATA[12018年5月记，看完之后相当懵逼，，我是为了什么写这个的 概念XML命名空间提供避免元素命名冲突的方法。标签可以放入命名空间中，不同的命名空间中的相同名称标签是不同的标签。 命名冲突在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。 这个 XML 携带 HTML 表格的信息：123456&lt;table&gt;&lt;tr&gt;&lt;td&gt;Apples&lt;/td&gt;&lt;td&gt;Bananas&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 这个 XML 文档携带有关桌子的信息（一件家具）：12345&lt;table&gt;&lt;name&gt;African Coffee Table&lt;/name&gt;&lt;width&gt;80&lt;/width&gt;&lt;length&gt;120&lt;/length&gt;&lt;/table&gt; 假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 元素，就会发生命名冲突。XML 解析器无法确定如何处理这类冲突。 语法在xml文件中，命名空间的定义如下：1&lt;d:student xmlns:d=&quot;http://www.develop.com/student&quot; &gt; 其中 student 是命名空间的标签。http://www.develop.com是命名空间的标识。d是命名空间的前缀。 命名空间标签由于命名空间采取元素属性的定义方式，所以需要一个标签。 xmlns 属性当在 XML 中使用前缀时，一个所谓的用于前缀的命名空间必须被定义。命名空间是在元素的开始标签的 xmlns 属性中定义的。xmlns:前缀=”URI”。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。命名空间 URI 不会被解析器用于查找信息。其目的是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。 命名空间标识命名空间标识是命名空间最重要的属性，重要到当输出一个命名空间时就直接转换为它的标识。标识有个规范的称呼:URI(统一资源定位符)。URI的最大特点是唯一性。如果不唯一就失去了辨识的意义。实际上相同URI不同的命名空间被看成同一个命名空间。 URI分为两种类型：URL(统一资源定位器):通俗的说URL就是网页地址。因为每个网页在internat上都是唯一的。 URN（统一资源名称)：可以不使用网页地址而使用唯一名称来定义。如：urn:2007-12-9/workgrop/xin/projiectname或 urn:E7f73B13-05FE-44ec-81CE-F898C4A6CDB4这个编号是在系统中注册的控件编号，因此是唯一的。 前缀前缀用于在XML中作为URI的简化引用。因为URI太长了。如：1234&lt;d:student xmlns:d=&quot;http://www.develop.com/student&quot;&gt;&lt;d:id&gt;3235329&lt;/d:id&gt;&lt;d:name&gt;Jeff Smith&lt;/d:name&gt;&lt;/d:student&gt; 使用前缀把标签放入对应的命名空间中。 有了命名空间区分后相同标签名可以不会被错误解析。实际上命名空间加上元素名叫做QName。QName有两个属性：uri和localName，分别获取命名空间名和本地名称。这个QName可以使用xml的name()方法得到。如上例子中的xml文件可以使用如下代码访问：12345var ns:Namespace=xml.namespace();var node:XMLList=xml.ns::id;var qNameName=node.name();trace(qName.uri);trace(qName.localName); 命名空间不一点要定义在根节点。可以在任何标签中定义，但只有定义了后才能使用。命名空间还可以嵌套或者被重定义。但这样会增加复杂性。一般用的比较少。一个xml文件中可以拥有多个命名空间。使用命名空间前缀可以轻松处理它们。如：12&lt;x:transform version=”1.0” xmlns:x=http://www.w3.org/1999/XSL/Transformxmlns:d=”urn:dm:student”&gt;&lt;x:template match=”student”/&gt;&lt;d:template match=”name”/&gt;&lt;/x:transform&gt; 默认的命名空间为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作xmlns=”namespaceURI”使用默认命名空间后，如果不加前缀则引用默认命名空间。使用默认命名空间会降低xml结构的清晰度。要慎用。 参考： http://m.blog.csdn.net/w938706428/article/details/41448821 http://www.runoob.com/xml/xml-namespaces.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[腐女与伪腐女]]></title>
    <url>%2Fpost%2F616e1358.html</url>
    <content type="text"><![CDATA[2017年2月2日写的。。 2018年5月重看，看完了之后有点觉得不知所云，不知道自己当初想说什么，或者说想要论证的太多，反而说不清了。。 腐是一种个人爱好，就和你喜欢喝茶，我喜欢喝咖啡，和别人无关，当然不能影响他人，就比如喜欢跳广场舞，但最好不要扰民，扰民了就不能怪别人说 没有必要区分伪腐和真腐，既然是一种个人爱好，你喜欢谁都无所谓的（不过不管伪腐还是真腐都喜欢帅哥吧哈哈），但是前面也说了，不能打扰别人，请不要贬低别人（大概是有人用这种方式炒作吧，毕竟这样就有人关注了） 腐和热心LGBT一点关系没有（好像有点绝对），也许有腐女会热心，但只能说是一种个人行为，有人也许会说我是因为喜欢腐圈才去了解LGBT，但你没法忽视一个问题：大部分腐女并没有这种意识，两个长的丑站在一起你不会萌，真的是一对你也不会萌的。那么是不是说我们一定要求腐女热心公益？当然不，各玩各的互不影响挺好 突然想写写这个话题，是因为最近上b站，老是看到评论里有一些人为了”腐女”和”伪腐女”而争执。 维基对于”腐女”的解释是： 腐女（日语：腐女子／ふじょし Fujoshi），主要是指喜欢BL，也就是喜欢男男爱情的女性。 百度百科和萌娘百科(ACG向wiki)类似，但是对于”伪腐”的概念有一些不同的地方。 维基百科中提到了”伪腐”，表示中国(其他国家没有这个概念，或者百科中没有提到)腐圈的一种概念 因为大众有时并不清楚“BL”与现实中的男同性恋的区别，误以为腐女就是“对男同友善的女性”。由此也衍生出“伪腐”一词用以形容“喜欢BL，但对男同性恋不友善”的腐女。 百度百科中有单独的”伪腐女”概念： 腐女群体里面一些不理智、疯狂、NC（脑残）的腐女，所谓的伪其实并非是假，只是其他理智的腐女对于这类腐女看不惯所采取的分类手段，为了不让人降低对腐女的印象，选择以“这些腐女并非是真正的腐女，是伪腐！”的借口来和NC腐女划分界限或推卸责任。 萌娘百科中这样定义： 喜欢BL只是因为二次元中的人物都十分美型，对于现实生活中真正的GAY群不一定持支持态度，甚至厌恶和嘲笑，像这样的“腐女”被称为“伪腐” 其实参考这些之后就可了解： 腐只能被看作一种爱好，无论你喜欢帅哥还是什么，都可以称作腐女，”伪腐女”并不是代表假的，而是用来形容那些不理智/疯狂/脑残的腐女。 结论1：腐只是一种个人爱好 结论2：伪腐女不等于不是腐女 “伪腐女”这个词的出现一方面不排除个别腐女的优越感，另一方面也说明一些腐女在行为方式上的让人感到反感，自己喜欢什么没人管，但是还请尊重他人(我想不论是不是腐女都应该尊重他人)，正如萌娘百科所说： 腐只是一种爱好，能否做到尊重他人、尊重他人隐私是做人的基本素养问题，与腐或不腐没有联系。 腐圈为了区分这些腐女所以创造了”伪腐女”这个词 常见的伪腐特征(来自萌娘百科，百度百科词条”伪腐女”有类似内容)： 仅喜欢长相俊秀、外貌美型的男子，对于现实中的GAY嗤之以鼻甚至深感厌恶。典型语句【长这么丑也好意思搞同性恋】。 喜欢偷窥、干涉现实中的GAY的生活，过度挖掘他人的隐私以满足自己的兴趣。 热衷于掰弯现实生活中的直男（如身边的男同学等），强迫周围的人搞基，令他人感到困扰，严重影响他人生活。 对不符合其审美观的男性，以及明确表示厌恶搞基的直男则采取敌视态度，进行贬损和污蔑。 无法接受LES（女同性恋），看不起她们。 对于GAY的交心信仅凭所看的耽美漫画、动画、小说等给予荒诞错误的建议，或将信件放在公共平台供大家讨论围观。 在大庭广众高调谈论腐相关，大有“我就是腐我真了不起”之意，令他人感到厌烦。 不接受男女之间的爱情故事，认为耽美就是小众就是清新就是高端大气上档次，男女之情都是庸俗三流泛滥成河，由此以为自己是文艺女青年而轻视看描写一般男女故事的人。 阅读更多：腐女（https://zh.moegirl.org/%E8%85%90%E5%A5%B3）本文引自萌娘百科（https://zh.moegirl.org/），文字内容遵守【知识共享 署名-非商业性使用-相同方式共享 3.0】协议。 结论3：一些腐女存在不尊重他人的行为，影响到了他人，一些行为真的让人反感，换句话说自己圈地自萌就好，请不要要求别人怎样，也别影响别人 那么也许会有疑问，是不是腐女都应该支持同性恋? 我个人觉得并不一定，腐毕竟只是作为一种个人的爱好，只要不影响他人就好，而不一定要把这种爱好强迫变成一种公益行为，一些做支持同性恋的腐女也请不要要求别的腐女一定要支持腐女，这就和你其他公益事业一样，你做公益事业，很不错，但是强迫别人也做就不好了。 结论4：腐不等于公益行为 结论5：腐圈和LGBT圈关系不大 参考资料：腐女-百度百科伪腐女-百度百科腐女-维基百科腐女-萌娘百科腐女与伪腐女之间的差别是什么？-知乎什么是腐女？-什么是腐女]]></content>
  </entry>
  <entry>
    <title><![CDATA[2016年突然想说的话]]></title>
    <url>%2Fpost%2F2667aef9.html</url>
    <content type="text"><![CDATA[2016年，感觉自己什么也没做，本来也不打算写年终博客的。 晚上和好友聊天，突然心情有点激动就想着，写写吧，写点什么，这大概只是有种想写的冲动吧，写出来的不见得有多好。 11月份的时候才意识到我放在SAE上的博客不在了，只备份了Wordpress的代码，没备份数据库，120篇博客找不回来了，上面写的都是一些问题怎么解决，以及自己在学习中的经验，印象最深的大概是如何在Elementaory OS系统上安装软件，直接把博客上的语句复制到shell里执行就好，最头疼的大概是安装输入法的问题，当时记得查了好多资料，最后每次重装都是因为update时输入法出问题，具体问题记不清楚了，好像是影响软件安装和更新。 考完研后一直在整理自己的东西，百度云、Onenote、印象笔记还有移动硬盘。 百度云里有很多资料和书籍，以前也整理过，大概地分离了各种资源，但条理并不是很清晰，索性需要的时候虎直接搜索就好，这次打算把以前备份的手机照片整理一下，顺便把很多很多的电子书整理分类，剔除重复，还有把图片和书籍备份到移动硬盘上，书籍还在下载中，还没有整理，图片已经整理好了，把大学四年的照片、保存的来自各种渠道的图片以及截图都理清了，回顾这些图片，把一些照片发给了相关的人，他们都很吃惊，哈哈。很多截图都是我在微信的聊天记录，我还找到了我和某人认识的大概时间。这些大概都算生活中的一点小乐趣了吧。 本来想将Onenote作为唯一的做笔记的应用，但是因为同步功能最后选择了印象笔记，充个标准会员，标签模式也不错，特别是用了Bear，可惜没有Mac，顺便一提，Bear真的好漂亮。 这一年确实过的浑浑噩噩，是我太幼稚，也是我在逃避，我真的没办法接受现实，可是人生不就是一步一步接受的过程吗？ 走吧，各人有各人的路要走，我既没法代替你，也没法陪你，甚至无法看着你 写的差不多了，确实只有写作的冲动，而没有写作的才华，哈哈哈。 2018年5月15日重看这篇文字，当时写完之后再也不敢看，现在因整理笔记打开觉得没什么，此时已经没有什么悲伤，我比较震惊我能写这么多文字哈哈，现在的感觉是每当我觉得突然明白了一些道理自己又长大了一点的时候，又觉得自己还是很幼稚]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo目录结构以及_config.yml配置文件]]></title>
    <url>%2Fpost%2Ff4cc7750.html</url>
    <content type="text"><![CDATA[目录结构1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 假设网站的根目录为D:/Hexo/，也称为站点目录站点配置文件 是指网站目录下的_config.yml文件，即D:/Hexo/_config.yml 主题配置文件 是指网站目录下对应的主题文件夹下的_config.yml文件，即D:/Hexo/themes/next/_config.yml. 站点配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap- # Deployment #部署，将 lmintlcx 改成用户名deploy: type: git repo: github创库地址.git branch: master 配置文件的冒号后面都有一个半角空格 主题配置文件12345678910111213141516171819202122232425262728293031menu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。 Home: / Archives: /archives About: /aboutwidgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。- search- category- tagcloudexcerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。plugins: twitter: #右边栏要显示twitter展示的话，需要在此设置 username: show_replies: false tweet_count: 5addthis: #分享设置 enable: true pubid: facebook: true twitter: true google: true pinterest: truefancybox: true #图片效果，默认google_analytics: #google_analytics统计IDrss: #生成RSS路径]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo中博客使用markdown格式约定]]></title>
    <url>%2Fpost%2F76175dd0.html</url>
    <content type="text"><![CDATA[tags标签使用[tag1,tag2,…]，注意冒号后需要一个半角空格 文章内标题使用###空格我是标题空格 内嵌代码使用反引号 1`我是代码` 其他代码使用125. 文字加粗使用两个星号 我是文字16. 文字斜体使用一个*星号 我是文字17. 引用使用&gt; 我是文字18. 链接使用以下方式 显示文字``` 表格内使用竖线用&amp;#124;]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo新建文章]]></title>
    <url>%2Fpost%2F2a1a4413.html</url>
    <content type="text"><![CDATA[新建文章进入博客站点目录1hexo n &quot;文章题目&quot; 执行完命令会在blog\sourse_posts目录中多出一个md文件，也可以直接在该目录下新建md文件 编辑文章使用markdown工具编辑_posts目录中的md文件，最后记得使用hexo g以及hexo d命令 删除文章直接删除目录下的md文件即可]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo常用命令]]></title>
    <url>%2Fpost%2F80937937.html</url>
    <content type="text"><![CDATA[常用命令：12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹 简写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】使用hexo d无法上传问题解决办法]]></title>
    <url>%2Fpost%2F453dda43.html</url>
    <content type="text"><![CDATA[问题1在使用hexo d上传时，可能出现以下错误1ERROR Deployer not found:git 解决办法1.在博客目录下安装hexo-deployer-git1npm install hexo-deployer-git --save 2.在博客目录下的_config.yml文件中1234deploy: type: git repository: https://github.com/fengrenxiaoli/fengrenxiaoli.github.io.git branch: master type使用git，冒号后面需要一个半角空格 问题2使用hexo d中，出现：123bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: No error 解决办法1.不要使用Cygwin等cmd工具，使用自带的cmd工具（具体可以参考https://github.com/atom/atom/issues/8984 2.使用ssh(具体格式在github中有)代替_config.yml文件中的deploy 如果出现1INFO Deploy done: git 则说明上传成功]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】修改Hexo博客的主题]]></title>
    <url>%2Fpost%2F5d01d58.html</url>
    <content type="text"><![CDATA[1.从https://hexo.io/themes/挑选喜欢的主题 2.从Github下载相应的主题12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/your-theme 注意修改自己选择主题的对应名字 3.更改站点_config.yml（即博客目录下的该文件，不是主题文件中的文件）中的theme字段为your-theme（名字要和第二步的对应）1theme: your-theme（theme后面有一个半角空格）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】使用Hexo搭建github博客]]></title>
    <url>%2Fpost%2Fa20da6f3.html</url>
    <content type="text"><![CDATA[1.创建github帐号，新建一个以用户名.github.io命名的仓库 2.安装git，创建ssh12345ssh-keygen -t rsa -f ~/.ssh/id_rsa_github#用于创建ssh，会有公钥和私钥，将公钥中的内容拷贝到github帐号 Settings &gt; SSH and GPG keys 中ssh -T git@github.com#用于测试是否成功 输入yes，其他使用默认即可，配置git12git config --global user.name &quot;cnfeat&quot;//用户名git config --global user.email &quot;cnfeat@gmail.com&quot;//邮箱 3.下载并安装hexo 4.新建一个目录用于放置本地博客12345678mkdir hexocd hexonpm install hexo-cli -g hexo init blogcd blognpm installhexo ghexo s #可以在本地http://localhost:4000/查看 5.修改blog目录下的_config.yml文件中的deploy：1234deploy:type: gitrepository: git@github.com:xxxxxx/xxxxxxx.github.io.gitbranch: master 6.安装hexo中关于git的组件，上传部署（需要cd到hexo\node_modules\hexo\Hexo目录）12345npm install hexo-deployer-git --savehexo cleanhexo ghexo d 如果出现问题请参考使用hexo d无法上传问题解决办法然后再使用以上代码 参考： http://kiya.space/2015/11/10/use-Github-Pages-Hexo-duoshuo-to-set-up-a-blog-basic-steps/ http://sunwhut.com/2015/10/30/buildBlog/ https://my.oschina.net/ryaneLee/blog/638440 http://www.jianshu.com/p/ab21abc31153 https://www.haomwei.com/technology/maupassant-hexo.html]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带不走的，留不下的]]></title>
    <url>%2Fpost%2F4ebc062a.html</url>
    <content type="text"><![CDATA[2018年5月记，转眼快两年了，没想到现在看来写的还挺好，那就发出来吧 时间我修改过，写这篇文字是在2016年的6月25日 写这篇文章的时候是大学毕业，准备离开而呆在学校的最后一天。 和不算很多的人约出来吃了饭，也许以后与这些人不会再见，也许要见也是几年之后了，几年有时候感觉很短，但当两人见面寒暄时，感叹一番，发现原来已经这么久没有见过了。 这几天除了吃饭和约人吃饭什么也不想干，就好像一个临终的人静静等待最后时刻的到来，不愿意去欣赏这里最后的景，也不想多留下一丝回忆。所做的只是交代后事，把自己和这里的人这里的事了结一些因果。 或许真的等我踏上火车准备上路时，才会伤心，才会遗憾，往事会如回马灯一样跳入脑海，原来我和你之间还能更加好一点，原来我应当做这件事的，许许多多的想法出现了，可是，只剩下发呆，留下的只有空白。 回想大学，自己就好像一只飞蛾，目标就是那里的火，逐渐走向自我的毁灭，我对生活的热情，我对未来的斗志都没有了，也许你是我最后的寄托吧，只是我们要毕业了，以后隔着的不光会是空间，还有时间，我带不走你，也留不下什么。 大学四年，我就像一个旁观者，看着你们一直往前走，我却带着原地，不想动，又像是一个行尸走肉，重复着南校、新校、本部三个点，没有带着什么，也不曾留下值得纪念的东西。 近来沉迷游戏，渴望在游戏中获得慰藉，交了几个亲友，最后呢，都离开了，除了花费金钱、消磨时间，什么也留不下了。 离开了，便开始一段新的旅程了，很多人许多事都随风飞走吧，带走了，留下了只能徒留伤感。 希望自己以后能够保持清醒，依靠自己，好好活着。 没了。]]></content>
  </entry>
</search>
