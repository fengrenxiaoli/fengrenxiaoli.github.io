<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018-06-08-【转】字符编码常识及问题解析]]></title>
    <url>%2Fpost%2F7444a34.html</url>
    <content type="text"><![CDATA[转自：http://sharecore.net/2014/08/10/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%B8%B8%E8%AF%86%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/ 在面试的笔试题里出了一道开放性的题：请简述Unicode与UTF-8之间的关系。一道看似简单的题，能给出满意答案的却寥寥无几，确实挺失望的。所以今天就结合我以前做过的一个关于字符编码的分享，总结一些与字符编码相关的知识和问题。如果你这方面的知识已经掌握的足够了，可以忽略这篇文字。但如果你没法很好的回答我上面的面试题，或经常被乱码的问题所困扰，还是不妨一读。 基本常识1.位和字节说起编码，我们必须从最基础的说起，位和字节(别觉得这个过于简单不值一说，我还真见过很多个不能区分这两者的程序员)。位（bit）是指计算机里存放的二进制值(0/1)，而8个位组合成的“位串”称为一个字节，容易算出，8个位的组合有256（ 2^8 ）个组合方式，其取值范围是“00000000-11111111”，常用十六进制来表示。比如“01000001”就是一个字节，其对应的十六进制值为“0x41”。 而我们通常所讲的字符编码，就是指定义一套规则，将真实世界里的字母/字符与计算机的二进制序列进行相互转化。如我们可以针对上面的字节定义如下的转换规则：101000001（0x41）&lt;-&gt; 65 &lt;-&gt; &apos;A&apos; 即用字位序“01000001”来表示字母’A’。 2.拉丁字符拉丁字符是当今世界使用最广泛的符号了。通常我们说的拉丁字母，指的的是基础拉丁字母,即指常见的”ABCD“等26个英文字母，这些字母与英语中一些常见的符号（如数字，标点符号）称为基础拉丁字符，这些基础拉丁字符在使用英语的国家广为流行，当然在中国，也被用来当作汉语拼音使用。在欧洲其它一些非英语国家，为满足其语言需要，在基础拉丁字符的基础上，加上一些连字符，变音字符(如’Á’)，形成了派生拉丁字母，其表示的字符范围在各种语言有所不同，而完整意义上的拉丁字符是指这些变体字符与基础拉丁字符的全集。是比基础拉丁字符集大很多的一个集合。 编码标准前文提到，字符编码是一套规则。既然是规则，就必须有标准。下面我就仔细说说常见的字符编码标准。 1.拉丁编码ASCII的全称是American Standard Code for Information Interchange（美国信息交换标准代码）。顾名思义，这是现代计算机的发明国美国人设计的标准，而美国是一个英语国家，他们设定的ASCII编码也只支持基础拉丁字符。ASCII的设计也很简单，用一个字节（8个位）来表示一个字符，并保证最高位的取值永远为’0’。即表示字符含义的位数为7位，不难算出其可表达字符数为2^7=128个。这128个字符包括95个可打印的字符（涵盖了26个英文字母的大小写以及英文标点符号能）与33个控制字符（不可打印字符）。例如下表，就是几个简单的规则对应： 字符类型 字符 二进制 16进制 10进制 可打印字符 A 01000001 0x41 65 可打印字符 a 01100001 0x61 97 控制字符 \r 00001101 0x0D 13 控制字符 \n 00001010 0xA 10 前面说到了，ASCII是美国人设计的，只能支持基础拉丁字符，而当计算机发展到欧洲，欧洲其它不只是用的基础拉丁字符的国家（即用更大的派生拉丁字符集）该怎么办呢？ 当然，最简单的办法就是将美国人没有用到的第8位也用上就好了，这样能表达的字符个数就达到了2^8 =256个，相比较原来，增长了一倍，这个编码规则也常被称为EASCII。EASCII基本解决了整个西欧的字符编码问题。但是对于欧洲其它地方如北欧，东欧地区，256个字符还是不够用，如是出现了ISO 8859,为解决256个字符不够用的问题，ISO8859采取的不再是单个独立的编码规则，而是由一系列的字符集（共15个）所组成，分别称为ISO 8859-n(n=1,2,3…11,13…16,没有12)。其每个字符集对应不同的语言,如ISO 8859-1对应西欧语言，ISO 8859-2对应中欧语言等。其中大家所熟悉的Latin-1就是ISO 8859-1的别名,它表示整个西欧的字符集范围。需要注意的一点的是，ISO 8859-n与ASCII是兼容的，即其0000000(0x00)-01111111(0x7f)范围段与ASCII保持一致，而10000000（0x80）-11111111(0xFF)范围段被扩展用到不同的字符集。 2.中文编码以上我们接触到的拉丁编码，都是单字节编码，即用一个字节来对应一个字符。但这一规则对于其它字符集更大的语言来说，并不适应，比如中文，而是出现了用多个字节表示一个字符的编码规则。常见的中文GB2312（国家简体中文字符集）就是用两个字节来表示一个汉字（注意是表示一个汉字，对于拉丁字母，GB2312还是是用一个字节来表示以兼容ASCII）。我们用下表来说明各中文编码之间的规则和兼容性。 对于中文编码，其规则实现上是很简单的，一般都是简单的字符查表即可，重要的是要注意其相互之间的兼容性问题。如如果选择BIG5字符集编码，就不能很好的兼容GB2312，当做繁转简时有可能导致个别字的冲突与不一致，但是GBK与GB2312之间就不存在这样的问题。 3.Unicode以上可以看到，针对不同的语言采用不同的编码，有可能导致冲突与不兼容性，如果我们打开一份字节序文件，如果不知道其编码规则，就无法正确解析其语义，这也是产生乱码的根本原因。有没有一种规则是全世界字符统一的呢？当然有，Unicode就是一种。为了能独立表示世界上所有的字符，Unicode采用4个字节表示一个字符,这样理论上Unicode能表示的字符数就达到了2^31 = 2147483648 = 21 亿左右个字符，完全可以涵盖世界上一切语言所用的符号。我们以汉字”微信“两字举例说明：12微 &lt;-&gt; \u5fae &lt;-&gt; 00000000 00000000 01011111 10101110信 &lt;-&gt; \u4fe1 &lt;-&gt; 00000000 00000000 01001111 11100001 容易从上面的例子里看出，Unicode对所有的字符编码均需要四个字节，而这对于拉丁字母或汉字来说是浪费的，其前面三个或两个字节均是0，这对信息存储来说是极大的浪费。另外一个问题就是，如何区分Unicode与其它编码这也是一个问题，比如计算机怎么知道四个字节表示一个Unicode中的字符，还是分别表示四个ASCII的字符呢？ 以上两个问题，困扰着Unicode，让Unicode的推广上一直面临着困难。直至UTF-8作为Unicode的一种实现后，部分问题得到解决，才得以完成推广使用。说到此，我们可以回答文章一开始提出的问题了，UTF-8是Unicode的一种实现方式，而Unicode是一个统一标准规范，Unicode的实现方式除了UTF-8还有其它的，比如UTF-16等。 话说当初大牛Ben Thomson吃饭时，在一张餐巾纸上，设计出了UTF-8，然后回到房间，实现了第一版的UTF-8。关于UTF-8的基本规则，其实简单来说就两条（来自阮一峰老师的总结）： 规则1：对于单字节字符，字节的第一位为0，后7位为这个符号的Unicode码，所以对于拉丁字母，UTF-8与ASCII码是一致的。 规则2：对于n字节(n&gt;1)的字符，第一个字节前n位都设为1，第n+1位为0，后面字节的前两位一律设为10，剩下没有提及的位，全部为这个符号的Unicode编码。 通过，根据以上规则，可以建立一个Unicode取值范围与UTF-8字节序表示的对应关系，如下表， 举例来说，’微’的Unicode是’\u5fae’，二进制表示是”00000000 00000000 01011111 10101110“，其取值就位于’0000 0800-0000 FFFF’之间，所以其UTF-8编码为’11100101 10111110 10101110’ （加粗部分为固定编码内容）。 通过以上简单规则，UTF-8采取变字节的方式，解决了我们前文提到的关于Unicode的两大问题。同时，作为中文使用者需要注意的一点是Unicode(UTF-8)与GBK，GB2312这些汉字编码规则是完全不兼容的，也就是说这两者之间不能通过任何算法来进行转换，如需转换，一般通过GBK查表的方式来进行。 常见问题及解答1.windows Notepad中的编码ANSI保存选项，代表什么含义？ANSI是windows的默认的编码方式，对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。所以，如果将一个UTF-8编码的文件，另存为ANSI的方式，对于中文部分会产生乱码。 2.什么是UTF-8的BOM？BOM的全称是Byte Order Mark，BOM是微软给UTF-8编码加上的，用于标识文件使用的是UTF-8编码，即在UTF-8编码的文件起始位置，加入三个字节“EE BB BF”。这是微软特有的，标准并不推荐包含BOM的方式。采用加BOM的UTF-8编码文件，对于一些只支持标准UTF-8编码的环境，可能导致问题。比如，在Go语言编程中，对于包含BOM的代码文件，会导致编译出错。详细可见我的这篇文章。 3.为什么数据库Latin1字符集（单字节）可以存储中文呢？其实不管需要使用几个字节来表示一个字符，但最小的存储单位都是字节,所以，只要能保证传输和存储的字节顺序不会乱即可。作为数据库，只是作为存储的使用的话，只要能保证存储的顺序与写入的顺序一致，然后再按相同的字节顺序读出即可，翻译成语义字符的任务交给应用程序。比如’微’的UTF-8编码是’0xE5 0xBE 0xAE’，那数据库也存储’0xE5 0xBE 0xAE’三个字节，其它应用按顺序从数据库读取，再按UTF-8编码进行展现。这当然是一个看似完美的方案，但是只要写入，存储，读取过程中岔出任何别的编码，都可能导致乱码。 4.Mysql数据库中多个字符集变量（其它数据库其实也类似），它们之间分别是什么关系？ 我们分别解释： character_set_client：客户端来源的数据使用的字符集，用于客户端显式告诉客户端所发送的语句中的的字符编码。 character_set_connection：连接层的字符编码，mysql一般用character_set_connection将客户端的字符转换为连接层表示的字符。 character_set_results：查询结果从数据库读出后，将转换为character_set_results返回给前端。 而我们常见的解决乱码问题的操作：1mysql_query(&apos;SET NAMES GBK&apos;) 其相当于将以上三个字符集统一全部设置为GBK，这三者一致时，一般就解决了乱码问题。 character_set_database:当前选中数据库的默认字符集，如当create table时没有指定字符集，将默认选择该字符集。 character_set_database已经character_set_system，一般用于数据库系统内部的一些字符编码，处理数据乱码问题时，我们基本可以忽略。 5.什么情况下，表示信息丢失？对于mysql数据库，我们可以通过hex(colname)函数（其它数据库也有类似的函数，一些文本文件编辑器也具有这个功能），查看实际存储的字节内容，如： 通过查看存储的字节序，我们可以从根本上了解存储的内容是什么编码了。而当发现存储的内容全部是’3F’时，就表明存储的内容由于编码问题，信息已经丢失了，无法再找回。 之所以出现这种信息丢失的情况，一般是将不能相互转换的字符集之间做了转换，比如我们在前文说到，UTF-8只能一个个字节地变成Latin-1，但是根本不能转换的，因为两者之间没有转换规则，Unicode的字符对应范围也根本不在Latin-1范围内，所以只能用’?(0x3F)’代替了。 总结本文从基础知识与实际中碰到的问题上，解析了字符编码相关内容。而之所以要从头介绍字符编码的基础知识，是为了更好的从原理上了解与解决日常碰到的编码问题，只有从根本上了解了不同字符集的规则及其之间的关系与兼容性，才能更好的解决碰到的乱码问题，也能避免由于程序中不正确的编码转换导致的信息丢失问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【转】五种常见的开源协议整理]]></title>
    <url>%2Fpost%2Ffe81a09d.html</url>
    <content type="text"><![CDATA[来源： http://yansu.org/2013/04/23/opensource-licenses.html 简介开源软件(Open source software)对我们来说越来越不陌生，开源软件一方面让我们免费享用到了“免费的午餐”，另一方面有效的利用和学习开源软件，也能促进我们开发软件时的效率、提升软件质量。但是在使用和借鉴开源软件的时候，我们不得不关心一下它对使用者的诸多限制，比较常见的方式即协议授权(licence)，这些协议中明确说明了使用者应该遵循的原则。 现在开源协议众多，通过Open Source Initiative组织批准的开源协议有50多种，本文提到的五种常见协议也在其中，而且出现频率非常频繁，我们在使用开源代码或者开放自己源代码的时候，也应该尽量选择这些协议。 五种常见开源协议BSD协议BSD开源协议是一个给予使用者很大自由的协议。开发者可以自由使用和修改源代码，也可以将修改后的源代码作为开源或者专有软件再发布。但是有一下几个要求： 如果再发布的产品中含有源代码，则在源代码中必须带有原来代码中的BSD协议。如果再发布的只是二进制类库/软件，则需要再类库/软件的文档和版权申明中包含原有代码中的BSD协议。不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 Apache Licence 2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件： 需要给代码的用户一份Apache Licence。如果修改了代码，需要再被修改的文件中说明。在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。 GPL我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(“使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 LGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制。也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的. 各协议分析图乌克兰程序员Paul Bagwell画了一张分析图，说明应该怎么选择。阮一峰对图进行了汉化，如下图：]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reStructuredText常用语法]]></title>
    <url>%2Fpost%2F1d81ed52.html</url>
    <content type="text"><![CDATA[reStructuredText是一种标记语言，和markdown类似，但是能够提供比markdown更丰富的样式 标题123456789101112131415==========一级标题==========二级标题==========三级标题----------四级标题^^^^^^^^^^^ 字体样式1234567891011121314*这里是强调内容*`这里是引用内容`**这里是粗体内容**``这里是等宽文本``上标E = mc\ :sup:`2`下标H\ :sub:`2`\ O 段落1234567891011| 这里是段落 缩进的段落被视为引文。| 这里也是段落 缩进的段落被视为引文。| 这里还是段落 缩进的段落被视为引文。 代码12345678910行内代码``echo &quot;Hello World!&quot;;``代码块在代码块的上一个段落后面加2个冒号，空一行后开始代码块，代码块要缩进:: hello world hello world hello world 列表12345678910下级列表需要有空格缩进无序列表- jj- kk- jj有序列表1. ll2. oo3. pp 图片1.. image:: https://help.github.com/assets/images/site/favicon.ico 链接12345外部引用这篇文章来自我的Github,请参考 reference_。.. _reference: https://github.com/SeayXu/`SeayXu &lt;https://github.com/SeayXu/&gt;`_ 表格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758简单表格===== ===== ======输入 输出------------ ------A B A or B===== ===== ======False False FalseTrue False TrueFalse True TrueTrue True True===== ===== ======普通表格+------------------------+------------+----------+----------+| Header row, column 1 | Header 2 | Header 3 | Header 4 || (header rows optional) | | | |+========================+============+==========+==========+| body row 1, column 1 | column 2 | column 3 | column 4 |+------------------------+------------+----------+----------+| body row 2 | Cells may span columns. |+------------------------+------------+---------------------+| body row 3 | Cells may | - Table cells |+------------------------+ span rows. | - contain || body row 4 | | - body elements. |+------------------------+------------+---------------------+CSV表格.. csv-table:: 表头 :header: &quot;Treat&quot;, &quot;Quantity&quot;, &quot;Description&quot; :widths: 15, 10, 30 &quot;Albatross&quot;, 2.99, &quot;On a stick!&quot; &quot;Crunchy Frog&quot;, 1.49, &quot;If we took the bones out, it wouldn&apos;t be crunchy, now would it?&quot; &quot;Gannet Ripple&quot;, 1.99, &quot;On a stick!&quot;列表表格.. list-table:: 表头 :widths: 15 10 30 :header-rows: 1 * - Treat - Quantity - Description * - Albatross - 2.99 - On a stick! * - Crunchy Frog - 1.49 - If we took the bones out, it wouldn&apos;t be crunchy, now would it? * - Gannet Ripple - 1.99 - On a stick! 表格可以使用插件https://macplay.github.io/posts/shi-yong-vim-zai-markdown-ji-rst-wen-dang-zhong-chuang-jian-biao-ge/ 参考： https://www.jianshu.com/p/f60e9be4781d https://3vshej.cn/rstSyntax/index.html https://www.jianshu.com/p/9b8c2e10e5e9 http://docutils-zh-cn.readthedocs.io/zh_CN/latest/ref/rst/restructuredtext.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitLab+sphinx+Readthedocs]]></title>
    <url>%2Fpost%2F89c53863.html</url>
    <content type="text"><![CDATA[利用GitLab、sphinx、Readthedocs可以制作文档和博客，利用这种方式制作出来的博客更像一本书，能够结构化展示文章，比较适合笔记类Gitlab用来存储代码sphinx用来写博客Readthedocs用来展示 安装 Sphinx1pip install sphinx 创建工程123mkdir mybookcd mybooksphinx-quickstart 输入工程名、作者名、版本号，分离source和build目录Separate source and build directories (y/N) [n]: y build目录 运行make命令后，生成的文件都在这个目录里面source目录 放置文档的源文件 配置改主题1html_theme = &apos;sphinx_rtd_theme&apos; 创建仓库在gitlab上创建仓库 12345git initgit add .git commit -m &quot;sphinx start&quot;git remote add origin https://github.com/[yourusename]/[yourrepository].gitgit push origin master 导入ReadtheDocs注册ReadtheDocs账号，因为直接用gitlab账号登录，所以没有设置Webhooks从https://readthedocs.org/dashboard/import/导入git链接在管理中设置Python 配置文件source/conf.py，Python interpreterCpython 3.x，保存 目录结构index.rst123456.. toctree:: :maxdepth: 2 :caption: Contents: linux/index python/index python/index.rst12345678910Python==================================.. toctree:: :maxdepth: 2 :caption: Contents: :numbered: 变量 语句 本地查看命令行执行1make html 参考：https://www.jianshu.com/p/78e9e1b8553ahttp://abnerzhao.com/2017/10/14/quickstart-wiki/]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储引擎]]></title>
    <url>%2Fpost%2F4fa63392.html</url>
    <content type="text"><![CDATA[MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎，每种存数引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。 并发处理并发控制当多个连接对记录进行修改时保证数据的一致性和完整性。 锁 共享锁(读锁)：在同一时间内，多个用户可读取同一个资源，读取过程中数据不会发生任何变化。 排他锁(写锁)：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。 锁的力度(锁颗粒–锁定时的单位) 表锁，是一种开销最小的锁策略。对表进行写锁，所有用户不能对该表的任何记录操作。 行锁，是一种开销最大的锁策略。并行性最大，可能对表的所有记录写锁，开销大。 事务处理事务处理整个过程每一个单元全部完成才算事务处理成功，某一个单元失败事务就会回滚。 主要作用保证数据库的完整性 特性 原子性(Atomic)：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Consistency)：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性(Isolation)：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性(Durable)：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 简称：ACID 外键是保证数据一致性的策略 索引是对数据表中一列或者多列的值进行排序的一种结构。索引好比目录。索引可以划分为：普通索引、唯一索引、全文索引、btree索引、hash索引。 各种存储引擎的特点MySQL支持的存储引擎MyISAM、InnoDB、Memory、CSV、Archive MyISAM/InnoDB：最广泛MyISAM：适用于事务的处理不多的情况。InnoDB：适用于事务处理比较多，需要有外键支持的情况。 设置存储引擎 修改MySQL配置文件实现 1default-storage-engine = engine_name 创建数据表命令来实现 123CREATE TABLE tbl_name(...) ENGINE = engine_name; 修改数据表命令实现 1ALTER TABLE tbl_name ENGINE [=] engine_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL自定义函数]]></title>
    <url>%2Fpost%2Fca4788ef.html</url>
    <content type="text"><![CDATA[自定义函数用户自定义函数(user-defined function, UDF)是一种对MySQL扩展的途径, 其用法与内置函数相同。 自定义函数的两个必要条件 参数：最多1024个任意类型的参数 返回值：任意类型 函数可以返回任意类型的值，同样可以接受这些类型的参数；函数的参数与返回值之间，没有必然的联系。 创建自定义函数1234CREATE FUNCTION function_nameRETURNS&#123;STRING|INTEGER|REAL|DECIMAL&#125;routine_body routine_body是函数体 关于函数体 函数体由合法的SQL语法构成; 函数体可以是简单的SELECT或INSERT语句; 函数体如果为复合结构则使用BEGIN…END语句； 复合结构可以包括声明，循环，控制结构。 创建不带参数的自定义函数创建日期时间自定义函数12345CREATE FUNCTION f1() RETURNS VARCHAR(30)RETURN DATE_FORMAT(NOW(),&apos;%Y年%m月%d日 %H点:%i分:%s秒&apos;);SELECT f1(); 创建带有参数的自定义函数创建带参数的自定义函数：123456CREATE FUNCTION f2(num1 SMALLINT UNSIGNED,num2 SMALLINT UNSIGNED)RETURNS FLOAT(10,2) UNSIGNEDRETURN (num1+num2)/2;SELECT f2(); //报错SELECT f2(10,15); //结果：12.5 创建具有复合结构函数体的自定义函数修改分隔符：DELEMITER 分隔符12DELIMITER // //将分隔符修改为 &apos;//&apos; 当函数体内执行多条语句时，使用BEGIN…END语句；当编写函数体内容的时候，使用 DELIMITER 关键字将分隔符;修改为别的，否则写到 ‘;’ 时会执行，导致函数编写失败。 12345678910DELIMITER //CREATE FUNCTION ADD_USER(p_id SMALLINT,username VARCHAR(20))RETURNS INT UNSIGNEDBEGININSERT user(p_id,username) VALUES(p_id,username);RETURN LAST_INSERT_ID();END//DELIMITER ; 删除函数1DROP FUNCTION [IF EXISTS] function_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入图片]]></title>
    <url>%2Fpost%2Fe01ea1fb.html</url>
    <content type="text"><![CDATA[在写博客中添加图片是很正常的，这里列举了本人使用的两种方法 本地引用当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。 1![](/img/image.jpg) 要注意这是绝对路径 CDN引用将图片上传到一些免费的CDN服务中。上传图片后，会生成对应的url地址，将地址直接拿来引用即可参考七牛、cloudinary]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL子查询]]></title>
    <url>%2Fpost%2F9da3e761.html</url>
    <content type="text"><![CDATA[子查询子查询是指出现在其他SQL语句内的SELECT子句 子查询嵌套在查询内部，且必须始终出现在圆括号内。 可以包含多个关键字或者条件，如DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等 外层查询可以是：SELECT、INSERT、UPDATE、SET或DO 返回值：标量、一行、一列或者子查询 1SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2); SELECT * FROM t1;称为Outer Query/外查询/Outer StatementSELECT column1 FROM t2; 称为Sub Query/子查询 使用比较运算符的子查询1=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; 语法结构1operand comparison_operator [ANY|SOME|ALL] subquery 当子查询返回多个结果的时候就可以用到ANY、SOME、ALL修饰符的比较运算符 Any: &gt;Any 表示至少大于一个值，即大于最小值。Any: All 表示大于每一个值。换句话说，它表示大于最大值All: &lt;All 表示小于每一个值。换句话说，它表示小于最小值ANY: =ANY 或者 SOME 都是等于他们本身 ANY SOME ALL &gt; &gt;= 最小值 最小值 最大值 &lt; &lt;= 最大值 最大值 最小值 = 任意值 任意值 – &lt;&gt; != – – 任意值 12345678910111213141516171819202122SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=5636.36; //查询所有商品不小于平均价格的SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=( SELECT ROUND(AVG(goods_price),2) FROM tdb_goods); //利用子查询来进行两者的结合查找SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=ANY ( SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=ALL ( SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;);SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price&gt;=SOME ( SELECT goods_price FROM tdb_goods WHERE goods_cate=&apos;超级本&apos;); 使用[NOT] IN 的子查询语法结构1operand comparison_operator [NOT] &#123;IN|EXISTS&#125; (subquery) IN 相当于 =ANY 或 =SOMENOT IN 相当于 !=ALL 或 &lt;&gt;ALL 1234SELECT goods_id,goods_name,goods_price FROM tdb_goodsWHERE goods_price IN ( SELECT goods_price FROM tdb_goods WHERE goods_cate = &apos;超级本&apos;); 使用[NOT] EXISTS 的子查询如果子查询返任何行，EXISTS返true；反之，返false。 1234CREATE TABLE IF NOT EXISTS tdb_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40) NOT NULL);]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL连接]]></title>
    <url>%2Fpost%2Fb63304bd.html</url>
    <content type="text"><![CDATA[联合查询的效率比较高 连接MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作语法结构1234table_reference A&#123;[INNER|CROSS] JOIN | &#123;LEFT|RIGHT&#125; [OUTER] JOIN&#125;table_reference BON condition_expr 连接类型 内连接在MySQL中，JOIN, CROSS JOIN 和 INNER JOIN 是等价的。显示左表及右表符合连接条件的记录123SELECT goods_id,goods_name,cate_name FROM tdb_goods INNER JOIN tdb_goods_cate ON tdb_goods.cate_id = tdb_goods_cate.cate_id; 外连接左外连接：LEFT [OUTER] JOIN：显示左表的全部记录及右表符合连接条件的记录。右外连接：RIGHT [OUTER] JOIN：显示右表的全部记录及左表符合连接条件的记录。 如果使用LEFT JOIN，左表中存在一条记录A，在右表中没有找到相应的记录，则在返回结果用会出现一条只有记录A中的相应字段内容，其他字段都为NULL在记录(RIGHT JOIN类似) 12345678910111213//查询所有商品的详细信息(通过左外连接实现) SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gLEFT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_id;//LEFT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G;//查询所有商品的详细信息(通过右外连接实现) SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS g RIGHT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_id;//RIGHT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 外链接 A LEFT JOIN B join_condition数据表B的结果集依赖数据表A。数据表A的结果集根据左连接条件依赖于所有数据表（B表除外）。左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下）。如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。 全连接显示左表、右表两边中的所有行，即把左联结果表 + 右联结果表组合在一起，然后过滤掉重复的。 多表的连接跟两张表的连接一样表的连接实质就是外键的逆向约束123456SELECT goods_id,goods_name,b.cate_name,c.brand_name,goods_priceFROM products AS a INNER JOIN products_cate AS b ON a.goods_cate = b.cate_idINNER JOIN products_brand AS c ON a.brand_name = c.brand_id; 数据表参照12table_referencetbl_name [[AS] alias] | table_subquery [AS] alias 数据表可以使用tbl_name AS alias_name 或 tbl_name alias_name赋予别名。table_subquery可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。 连接条件使用ON关键字来设定连接条件，也可以使用WHERE来代替 通常使用ON关键字来设定连接条件使用WHERE关键字来进行结果集记录的过滤 自身连接 – 无限分类自身连接：同一个数据表对其自身进行连接 对于常见的分类，比如商城中的书籍&gt;&gt;文学&gt;&gt;小说，并不是使用多个表，而是使用一个表来进行联合查询 在同一张表中既有父类，又有子类。通过对同一张数据表的自身连接来进行查询，需要对表标识别名。做自身连接的话一定要起别名，以区分是子表还是父表 表的结构是这样的，使用parent_id表示父类目的id12345CREATE TABLE tdb_goods_types(type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,type_name VARCHAR(20) NOT NULL,parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0); 查找所有分类及其父类1234SELECT s.type_id ,s.type_name,p.type_name FROM tdb_goods_types s LEFT JOIN tdb_goods_types p ON s.parent_id=p.type_id; 查找所有分类及其子类1234SELECT p.type_id ,p.type_name,s.type_name FROM tdb_goods_types p LEFT JOIN tdb_goods_types s ON p.type_id=s.parent_id; 查找所有分类及其子类的数目123456SELECT p.type_id ,p.type_name,COUNT(s.type_name) FROM tdb_goods_types p LEFT JOIN tdb_goods_types s ON p.type_id=s.parent_idGROUP BY p.type_name ORDER BY p.type_id; 补充： https://www.jianshu.com/p/c4c43f32b66f http://wxb.github.io/2016/12/15/MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8Djoin.html http://www.zsythink.net/archives/1105]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL函数]]></title>
    <url>%2Fpost%2Fed90cb85.html</url>
    <content type="text"><![CDATA[字符函数 函数名称 描述 举例 结果 CONCAT() 字符连接 SELECT CONCAT(‘a’,’-‘,’b’); a-b CONCAT_WS() 使用指定的分隔符进行字符连接 SELECT CONCAT_WS(‘ ‘,’A’,’B’,’C’); A B C FORMAT() 数字格式化 SELECT FORMAT(12560.78,1); 12,560.8 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 SELECT LEFT(‘mysql’,2); my RIGHT() 获取右侧字符 LTRIM() 删除前导空格(=LEFT TRIM()) RTRIM() 删除后续空格 TRIM() 删除前后两边的空格，还可以删除指定的前导和后续的字符,不能删除中间的字符 SELECT TRIM(LEADING’?’,’??MYSQL????’); SELECT TRIM(TRAILING’?’,’??MYSQL????’); SELECT TRIM(BOTH’?’,’??MYSQL???’); MYSQL???? ??MYSQL MYSQL REPLACE() 替换字符 SELECT REPLACE(‘??MYSQL???’,’?’,’-‘); –MYSQL— SUBSTRING(string，offset，length) 截取字符串 SELECT SUBSTRING(‘MYSQL’,2,3); SQL [NOT]LIKE 模糊匹配 (%)：代表任意个字符，0个或多个 (_)：代表任意一个字符，只有一个 SELECT name FROM test WHERE name LIKE’%O%’; SELECT name FROM test WHERE name LIKE’%1%%’ ESCAPE’1’; name 中带‘O’的name 中间带% 的匹配name LEAGTH() 获取字符串长度 数值运算符与函数 函数名称 描述 举例 结果 CEIL(数值) 向上取整 SELECT CEIL(3.01); 4 FLOOR(数值) 向下取整 SELECT FLOOR(3.99); 3 DIV 整数除法 SELECT 3 DIV 4; 0 MOD 取余，可以用%号代替 SELECT 4 MOD 3; SELECT 5.3 MOD 3; 12.3 POWER(数值,数值) 幂运算 SELECT POWER(3,3); 27 ROUND(数值,小数的位数) 四舍五入 ROUND(3.1415926,4) 3.142 TRUNCATE(数值，截取位数) 截断（不四舍五入） SELECT TRUNCATE(123.89,1) SELECT TRUNCATE(125.68,-1); 123.8120 比较运算符与函数 函数名称 描述 举例 结果 [NOT]BETWEEN…AND… [不]在范围之间，1为是，0为否 15 BETWEEND 1 AND 2015 NOT BETWEEND 1 AND 20 10 [NOT]IN() [不]在列出值范围内 10 IN(5,10,15) 1 IS [NOT] NULL [不]为空 NULL IS NULL ‘’ IS NULL 10 日期时间函数 函数名称 描述 NOW() 当前时间 含日期时间 CURDATE() 当前日期 只有日期 CURTIME() 当前时间 值有时间 DATE_ADD() 时间增减或减少 DATEDIFF() 日期差值 DATE_FORMAT() 日期格式化 123456789101112SELECT DATE_ADD(&apos;2014-3-12&apos;,INTERVAL 365 DAY); 2015-3-12 //在原有给定的时间上增加365天 //INTERVAL增加可以增加负值 单位 year,month,week,daySELECT DATEDIFF(&apos;2014-1-1&apos;,&apos;2015-1-1&apos;);-365 //时间差值计算 单位为日 前面时间减去后面时间SELECT DATE_FORMAT(&apos;2014-3-2&apos;,&apos;%m/%d/%d&apos;); 03/02/2014//日期格式转换 信息函数 函数名称 描述 举例 结果 CONNECTION_ID() 连接ID SELECT CONNECTION_ID(); SELECT CONNECTION_ID(); 3 SELECT DATABASE() 当前数据库 SELECT DATABASE(); users LAST_INSERT_ID(); 最后插入记录的 ID 号 SELECT LAST_INSERT_ID(); 如果是一次insert中插入的是多条记录，得到的是多条中的第一条（而不是最后一条！） USER() 当前用户 SELECT USER(); root@localhost VERSION(); 版本的信息 SELECT VERSION(); 5.7.21 聚合函数 函数名称 描述 举例 AVG() 平均值 SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods; COUNT() 计数 SELECT COUNT(goods_id) as counts FROM tdb_goods; MAX() 最大值 SELECT MAX(goods_price) as counts FROM tdb_goods; MIN() 最小值 SELECT MIN(goods_price) as counts FROM tdb_goods; SUM() 求和 SELECT SUM(goods_price) as counts FROM tdb_goods; 加密函数 函数名称 描述 举例 结果 MD5() 信息摘要算法，为以后的Web页面做准备，尽量使用MD5() SELECT MD5(‘admin’); 21232f297a57a5a743894a0e4a801fc3 PASSWORD() 密码算法通过PASSWORD()修改(重要用于MYSQL数据库)当前用户和其他用户的密码，修改客户端自己的密码 SELECT PASSWORD(‘admin’); SET PASSWORD=PASSWORD(‘dimitar’); *4ACFE3202A5FF5CF467898FC58AAB1D615029441 把密码修改成dimitar]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储过程]]></title>
    <url>%2Fpost%2F392b408.html</url>
    <content type="text"><![CDATA[定义存储过程是SQL语句与控制语句的预编译集合，以一个名称存储作为一个单元处理 输入SQL命令，MySQL引擎对命令进行分析，查看输入的语法是否正确，如果正确，再进行编译，编译成MySQL引擎可识别的命令，最后再进行执行，并将执行结果返回给客户端。 如果省略了语法分析和编译的阶段，则效率可提高。 存储过程：是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理（类似函数）。存储过程存储在数据库内，可以由应用程序调用执行，而且允许用户申明变量以及进行流程控制。存储过程可以接受输入类型的参数和输出类型的参数，并且可以存在多个返回值。只在第一次调用时进行语法分析和编译，以后的调用直接调用编译的结果，效率大大提高。 优点 增强SQL语句的功能和灵活性：可以通过控制语句对流程进行控制和判断 实现较快的执行速度：客户端第一次调用存储过程时，MySQL引擎会对其进行语法分析、编译等操作，然后将编译结果存储到内存中，所以第一次和之前的效率一样，然而以后会直接调用内存中的编译结果，效率提高 减少网络流量：例如删除一个记录，我们原本要输入DELETE FROM xx WHERE …; 要传输的字符较多，如果写成存储过程，就只要调用存储过程的名字和相应参数就行，传输的字符数量较少，所以减少了网络流量。 创建储存过程1234CREATE[DEFINER = &#123;user|CURRENT_USER&#125;]PROCEDURE sp_name ([proc_parameter[,...]]) //可以带0到多个参数[characteristic ...] routine_body 其中参数12proc_parameter:[IN | OUT | INOUT] param_name type IN, 表示该参数的值必须在调用存储过程时指定OUT, 表示该参数的值可以被存储过程改变，并且可以返回INOUT, 表示该参数的值调用时指定，并且可以被改变和返回 特性123COMMENT &apos;string&apos;| &#123;CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA| SQL SECURITY&#123;DEFINER|INVOKER&#125; COMMENT: 注释CONTAINS SQL: 包含SQL语句, 但不包含读或写数据的语句NO SQL: 不包含SQL语句READS SQL DATA: 包含读数据的语句MODIFIES SQL DATA: 包含写数据的语句SQL SECURITY {DEFINER|INVOKER} 指明谁有权限来执行 过程体 过程体由合法的SQL语句构成; 过程体可以是任意SQL语句; 过程体如果为复合结构则使用BEGIN…END语句 复合结构可以使用条件、循环等控制语句 创建无参的存储过程123CREATE PROCEDURE sp1() SELECT VERSION(); //创建CALL sp1; //调用CALL sp1(); 创建带IN类型参数的存储过程123456789101112//若带的参数与数据表中的字段一致，则删除整个数据表。DELIMITER //CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)BEGIN DELETE FROM users WHERE id = p_id;END//DELIMITER ;SELECT * FROM users;CALL removeUserById(22);SELECT * FROM users WHERE id = 22; 创建带IN OUT类型参数的存储过程1234567891011DELIMITER //CREATE PROCEDURE removeUserAndReturnUserNums(IN p_id INT UNSIGNED,OUT userNums INT UNSIGNED)BEGINDELETE FROM users WHERE id=p_id;SELECT COUNT(id) FROM users INTO userNums; END//DELIMITER ;CALL removerUserAndReturnUserName(10,@nums); SELECT @nums; SET @i = 7; INTO将SELECT语句结果返回给userNums变量通过@或SET设置的变量称为用户变量@nums 所代表的就是用户变量，可用 SELECT @nums 输出 局部变量与用户变量的区别用 DECLARE 声明的变量是局部变量，局部变量只能存在于 BEGIN…END 之间，且声明时必须置于 BEGIN…END 的第一行。而通过 SELECT…INTO…/SET @id = 07设置的变量称用户变量，只能存在于当前用户所使用的客户端有效。 创建带有多个OUT类型参数的存储过程明确OUT类型的参数的定义与作用OUT类型参数，表示在调用存储过程时，值可被存储过程改变，并且返回一个值。通常变量用“@”符号开头的变量，在BEGIN和END之中的变量是局部变量，在调用存储过程时写入的变量是“用户变量”。比如有一个存储过程的名称叫做“addUser()”，调用时addUser(@sum),sum就是用户变量。 ROW_COUNT()函数相当于PHP的MySQL函数库中的mysql_affected_rows()数作用相同，计算增删改查的个数总和。 1234567891011121314DELIMITER //CREATE PROCEDURE removeUserByAgeAndReturnInfos(IN p_age SMALLINT UNSIGNED,OUT deleteUsers SMALLINT UNSIGNED,OUT userCounts SMALLINT UNSIGNED)BEGINDELETE FROM users WHERE age=p_age;SELECT ROW_COUNT() INTO deleteUsers; #返回被增删改查的记录总数SELECT COUNT(id) FROM users INTO userCounts;END//DELIMITER ;CALL removeUserByAgeAndReturnInfos(20,@a,@b);SELECT @a,@b; #a是删除的记录数，b是剩余的记录数 修改存储过程1234ALTER PROCEDURE sp_name [characteristic]COMMENT &apos;string&apos;|&#123;CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA&#125;|SQL SECURITY&#123;DEFINER|INVOKER&#125; 调用存储过程1234CALL sp_name([parameter[,...]]) //带参数的存储过程的调用CALL sp_name[()] //不带参数的存储过程调用 删除存储过程123DROP PROCEDURE [IF EXISTS] sp_name;DROP PROCEDURE removeUserById; 储存过程与自定义函数的区别： 储存过程实现的功能要复杂一些；而函数的针对性更强。 储存过程可以返回多个值；函数只能有一个返回值。 储存过程一般独立的来执行；而函数可以作为其他SQL语句组成部分来出现。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL记录操作]]></title>
    <url>%2Fpost%2F2aaa8b1b.html</url>
    <content type="text"><![CDATA[insert 插入记录INSERT…VALUES比较常用，一次性插入多条记录，可输入表达式甚至是函数。12INSERT [INTO] table_name [(column_name,...)] &#123;VALUES|VALUE&#125; (&#123;expr|DEFAULT&#125;,...),(...),...; expr 表示表达式对于自动编号的字段，插入NULL或DEFAULT系统将自动依次递增编号；对于有默认约束的字段，可以插入DEFAULT表示使用默认值；列值可传入数值、表达式或函数，如密码可以用md5()函数进行加密（如md5(‘123’)）；可同时插入多条记录，多条记录括号间用逗号,隔开 1234567INSERT test VALUES(NULL,&apos;Tom&apos;);//插入单条记录INSERT users VALUES(DEFAULT,&apos;Tom&apos;,&apos;123&apos;,1+9*2,1),(NULL,&apos;John&apos;,md5(&apos;123&apos;),DEFAULT,0); //插入两条记录 INSERT…SET这种方法一次只能插入一条记录列值中有自动编号、默认值或Boolean类型均可以不赋值(使用子查询)1INSERT [INTO] table_name SET col_name=&#123; expr | DEFAULT &#125;,...; 1INSERT users SET username=&apos;Ben&apos;,password=&apos;456&apos;; INSERT…SELECT一般用于将其他表的数据插入到指定表，注意对应12INSERT [INTO] table_name(col_name,...) SELECT col_name,... FROM table_name [GROUP BY/HAVING/ORDER BY/LIMIT...]; 12345678INSERT test SELECT username FROM users WHERE age &gt;=30; // 字段不匹配提示INSERT test (username) SELECT username FROM users WHERE age &gt;=30;INSERT tdb_goods_cates(cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;//在表tdb_goods_cates中插入tdb_goods中的cate update 更新记录1234UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;exp1|DEFAULT&#125;[,col_name2=&#123;exp1|DEFAULT&#125;,...][WHERE where_condition] 省略WHERE条件则更新所有记录该列的值 单表更新1234UPDATE users SET age = age + 5,sex = 0; //使表里所有记录的age加5UPDATE users SET age = age + 10 WHERE id % 2=0; //取id为偶数的位置 多表更新使用连接进行多表更新，以下为连接的语法1234table_reference&#123;[INNER | CROSS] JOIN | &#123;LEFT|RIGHT&#125; [OUTER] JOIN&#125;table_referenceON conditional_expr 1234UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate=cate_name SET goods_cate=cate_id;//如果goods_cate等于cate_name那么就让goods_cate=cate_id 创建数据表同时将查询结果写入到数据表123CREATE TABLE [IF NOT EXISTS] tbl_name[(create_definition,...)]select_statement 1234567891011121314151617CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name; UPDATE tdb_goods AS g INNER JOIN tdb_goods_brands AS b ON g.brand_name = b.brand_name SET g.brand_name = b.brand_id;//多表更新 ALTER TABLE tdb_goods CHANGE goods_cate cate_id SMALLINT UNSIGNED NOT NULL,CHANGE brand_name brand_id SMALLINT UNSIGNED NOT NULL;//通过ALTER TABLE语句修改数据表结构 delete 删除记录单表删除1DELETE FROM table_name [WHERE where_conditon]; 省略条件则默认删除该表所有记录(仅删除所有记录，不删除数据表)删除后再插入，插入的id号从最大的往上加，而不是填补删除的。 1DELETE FROM users WHERE id=6; 多表删除INSERT … SELECT实现复制1234INSERT tdb_goods(goods_name,cate_id,brand_id) SELECT goods_name,cate_id,brand_id FROM tdb_goods WHERE goods_id IN (19,20); 查找重复记录SELECT goods_id,goods_nameFROM tdb_goodsGROUP BY goods_name HAVING count(goods_name) &gt;= 2;12删除重复记录 DELETE t1FROM tdb_goods AS t1LEFT JOIN ( SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2 ) AS t2ON t1.goods_name = t2.goods_nameWHERE t1.goods_id &gt; t2.goods_id;1234&lt;br&gt;## select 查找记录 SELECT select_expr [,select expr2…] //只查找某一个函数或表达式[FROM table_references //查询表名[WHERE where_conditon] //查询条件[GROUP BY {col_name|position} [ASC|DESC],…] //按某个字段进行分组，相同的只显示第一个[HAVING where_conditon] //分组时，给出显示条件[ORDER BY {col_name|expr|position} [ASC|DESC],…] //排序[LIMIT {[offset,]row_count|row_count OFFSET offset}] //限制返回数量}123456789### 查询表达式* 每一个表达式表示想要的一列，必须至少有一个* 多个列之间以英文逗号分隔* 星号(*)表示所以列 table_name.*可以表示命名表的所有列* 查询表达式可以使用`[As]alias_name`为其赋予别名* 别名可用于GROUP BY，ORDRE BY或HAVING子句SELECT 字段出现顺序影响结果集出现顺序，字段别名也影响结果集字段别名 SELECT * FROM users;SELECT id AS userid,usrname AS uname FROM users;SELECT users.id FROM users;12345### WHERE 条件表达式对记录进行过滤，如果没有指定的WHERE子句，则显示所有记录在WHERE表达式中，可以使用MYSQL支持的函数或运算符 SELECT * FROM users WHERE id=1;123### GROUP BY 查询结果分组 [GROUP BY {col_name|position} [ASC|DESC],…]123ASC：升序，默认DESC：降序position：SELECT语句中列的序号 SELECT sex FROM users GROUP BY sex;//对users中的sex按sex进行分组SELECT * FROM users GROUP BY 1;//1表示查询的第一个字段，这里是表中的第一个字段idSELECT sex FROM users GROUP BY 1;//1表示sex123456如果存在相同的值（例如上面的age可能有多个相同的值），**只会保留一个**。但使用ORDER BY 就不会省略。### HAVING 分组条件用在GROUP BY后面追加条件，条件要么为一个聚合函数，要么出现在SELECT要查询的字段中。 [HAVING when where_condition] SELECT sex FROM users GROUP BY 1 HAVING age &gt; 35; //有错SELECT sex,age FROM users GROUP BY 1 HAVING age &gt; 35;SELECT sex FROM users GROUP BY 1 HAVING count(id) &gt;= 2;//按照sex分组，条件id数大于2的分组留下显示//工作流程就是先从表中查询字段，然后根据GROUP BY的条件对查询结果进行分组，再根据HAVING条件对分组进行筛选，最后留下满足所有条件的分组结果。12345678聚合函数永远只有一个返回结果count是记录指定列的值的个数（NULL不计入）### ORDER BY 排序对查询结果进行排序，默认是升序，DESC是降序 [ORDER BY [col_name | expr | position } [ASC|DESC],…] SELECT FROM users ORDER BY id DESC;//对一个字段排序SELECT FROM users ORDER BY age,id DESC;//多字段排序，先按照age排序，如果age有重复的，重复的字段里按id排序123456多个排序条件之间以逗号相隔，在前面的排序条件满足时，忽略后面的排序条件，否则按照后面的排序条件进行排序。### LIMIT 限制查询结果数量 [LIMIT {[offset,] row_count | row_count OFFSET offset}]12获取头部记录LIMIT 10; //获取查询结果的前10条记录，**默认从0开始**获取中间记录LIMIT 2,10;//获取从第3条开始的10条记录 SELECT FROM users LIMIT 2;//从第一条开始（第一个为0），返回两条SELECT FROM users LIMIT 2,3;//从第三条开始（第一个为0），返回三条```]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL修改数据表]]></title>
    <url>%2Fpost%2F5f31036f.html</url>
    <content type="text"><![CDATA[总结： 1ALTER TABLE table_name ADD/DROP ...; 添加/删除列添加单列如果指定FIRST，则在整个表的最前方，默认不写为整个表的最后方；如果指定AFTER col_name，则在col_name的后面。123ALTER TABLE table_name ADD [COLUMN] col_name column_definition [FIRST | AFTER col_name];ALTER TABLE user1 ADD password varchar(32) not NULL AFTER name; 添加多列无法指定FIRST/AFTER、只能默认为最后方123ALTER TABLE table_name ADD [COLUMN] (col_name column_definition,...);ALTER TABLE user1 ADD password varchar(32) not NULL,pid smallint unsigned; 删除单列123ALTER TABLE table_name DROP [COLUMN] col_name;ALTER TABLE user1 DROP password; 删除多列123ALTER TABLE table_name DROP [COLUMN] col_name, DROP [COLUMN] col_name,DROP [COLUMN] col_name; 添加约束添加/删除主键约束constraint 给主键起名12345ALTER TABLE table_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...);ALTER TABLE table_name DROP PRIMARY KEY;ALTER TABLE users ADD CONSTRAINT pk_users_id PRIMARY KEY (id);ALTER TABLE users DROP PRIMARY KEY; 添加/删除唯一约束123456ALTER TABLE table_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name,...)ALTER TABLE table_name DROP &#123;INDEX|KEY&#125; index_name;//删除唯一约束只用删掉它的索引就行了ALTER TABLE users ADD UNIQUE (username);ALTER TABLE users drop INDEX username; 添加/删除外键约束1234567ALTER TABLE table_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name](index_col_name,...) reference_definition;ALTER TABLE table_name DROP FOREIGN KEY（fk_symbol);//fk_symbol 是CONSTRAINT定义的名字，如果没有定义可以通过 show create table table_name来查看ALTER TABLE users ADD FOREIGN KEY (pid) REFERENCES provinces (id);SHOW TABLE TABLE users;ALTER TABLE users DROP FOREIGN KEY (pid); 添加/删除默认约束1234ALTER TABLE table_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;ALTER TABLE users ALTER age SET DEFAULT 15;ALTER TABLE users ALTER age DROP DEFAULT; 修改列修改列定义123456ALTER TABLE table_name MODIFY [COLUMN] col_name column_definition [FIRST |AFTER col_name];ALTER TABLE users2 MODIFY id SMALLINT UNSIGNED NOT NULL FIRST; //将id字段的位置提到第一列ALTER TABLE users2 MODIFY id TINYINT UNSIGNED NOT NULL; //修改数据类型，需注意数据丢失的问题（范围大转范围小） 修改列名称1234ALTER TABLE table_name CHANGE [COLUMN] col_name new_col_name column_definition [FIRST|AFTER col_name];ALTER TABLE users2 CHANGE pid p_id TINYINT UNSIGNED; //修改列名称，类型可以通过show create table table_name复制原来的 数据表更名方法1123ALTER TABLE table_name RENAME [TO/AS] new_table_name;ALTER TABLE users2 RENAME (to/as) users3; 方法2123RENAME TABLE table_name TO new_table_name [,table_name2 TO new_table_name2] ...;RENAME TABLE users5 TO users2; 尽量少使用数据表的列名及表名的更名。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL约束]]></title>
    <url>%2Fpost%2F1df97176.html</url>
    <content type="text"><![CDATA[约束保证数据的完整性和一致性约束按功能分为PRIMARY KEY、UNIQUE KEY、DEFAULT、NOT NULL、FOREIGN KEY按数目分为列级约束和表级约束 查看约束12SHOW INDEX FROM table_name\G;SHOW INDEX FROM table_name; 主键约束：PRIMARY KEY主键可以写为PRIMARY KEY，也可以写成KEY 唯一性（可以赋值但是不能给两个记录赋一样的值）每张表只存在一个主键 主键保证记录的唯一性 主键自动为NOT NULL，也就是说必须要为主键赋值。但如果主键选择了AUTO_INCREMENT，那么不需要手动赋值 auto_increment必须和主键primary key一起使用，但是主键primary key不一定要和auto_increment一块使用 主键的字段是可以赋值的，但不能赋相同的值 1234CREATE TABLE user(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL); 记录如果删除了编号会出现间断 自增 AUTO_INCREMENT 自动编号，保证记录的唯一性，且必须与主键组合使用 默认情况下，初始为1，每次增长量为1. 对应的字段设置必须是数值类型，若是浮点类型，小数位必须为0. 自动编号必须是主键字段 1234CREATE TABLE tb3(id SMALLINT UNSIGNED AUTO_INCREMENT,username VARCHAR(30) NOT NULL); //报错，自动增量字段必须设置成主键 AUTO_INCREMENT必须是主键主键不一定要用AUTO_INCREMENT 唯一约束：UNIQUE KEY 唯一约束可以保证记录的唯一性 唯一约束的字段可以为空值（NULL），存储时只保留一个NULL 每张数据表可以存在多个唯一约束 12345CREATE TABLE tb2(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL UNIQUE KEY,age TINYINT UNSIGNED); 默认约束：DEFAULT如果没有明确为字段赋值会自动赋与默认值123456CREATE TABLE tb6(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL UNIQUE KEY,sex ENUM(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) DEFAULT &apos;3&apos;);//表示当sex没有赋值时，默认值为3 非空约束：NOT NULLNULL，字段值可以为空NOT NULL，字段值禁止为空，不赋值会报错 外键约束：FOREIGN KEY保持数据一致性，完整性；实现一对一或一对多关系 要求： 父表和子表必须使用相同的存储引擎，而且禁止使用临时表(子表：具有外键列的表；父表：子表参照的表) 数据表的存储引擎只能为InnoDB 外键列和参照列必须具有类似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引 在配置文件（my.ini\my.conf）中编辑默认的存储引擎：1default-storage-engine=INNODB 1234567891011CREATE TABLE table_name1(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) NOT NULL);CREATE TABLE table_name2(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,username VARCHAR(20) NOT NULL,pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES table_name1(id) );// 外键 pid 参照 table_name1中的 id 字段 显示创建表的语句：SHOW CREATE TABLE table_name；查看表是否有索引：SHOW INDEXS FROM table_name；以网格查看表是否有索引：SHOW INDEXS FROM table_name\G； 外键约束的参照操作 CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行 SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL RESTRICT：拒绝对父表的删除或更新操作 NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同 123456CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,pid SMALLINT,username VARCHAR(10) NOT NULL,FOREIGN KEY (pid) REFERENCES province (id) ON DELETE CASCADE); 从父表删除或更新行，会设置子表中的外键列为NULL，如果使用该选项，必须保证子表列没有指定NOT NULL 实际开发中，我们很少使用物理的外键约束，而是使用逻辑约束；物理的外键约束只有innoDB这种存储引擎才会支持，MYISAM这种引擎就不支持物理的外键约束。反过来说，当我们使用到的引擎为MYISAM时，只能使用逻辑外键（即两个表的设计的逻辑关系）。 表级约束与列级约束对一个数据列建立的约束，称为列级约束对多个数据列建立的约束，称为表级约束 列级约束既可以在列定义时声明，也可以在列定以后声明表级约束只能在列定义后声明 主键、外键、唯一既可以作为表级约束，也可作为列级约束not null、default只有列级约束]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据表]]></title>
    <url>%2Fpost%2F8ecc2d83.html</url>
    <content type="text"><![CDATA[数据表（或表）是数据库最重要的组成部分之一，是其他对象的基础，表是一个二维表，行称为【记录】，列称为【字段】 创建数据表首先打开数据库（数据库要存在）: USE 数据库名称 创建数据表123CREATE TABLE [IF NOT EXISTS] table_name(column_name(列名称) data_type（列类型）,.... ); 12345CREATE TABLE tb1(username VARCHAR(20),userage TINYINT UNSIGNED,salary FLOAT(8,2) UNSIGNED,); UNSIGNED 无符号 查看数据表列表1234SHOW TABLES [FROM db_name] [LIKE &apos;pattern&apos; | WHERE expr]；SHOW TABLES; //查看当前选择的数据库的所有表SHOW TABLES FROM test; //查看test数据库中的所有表，当前选择数据库位置不变 查看数据表的结构1SHOW COLUMNS FROM tb1; //查看tb1中的数据表结构 查看创建数据表的语句1SHOW CREATE TABLE table_name; 插入记录1234INSERT table_name [字段(colume),...] VALUES(val,...);INSERT tb1 VALUES(&apos;TOM&apos;,25,6782.12);INSERT tb1(username,salary) VALUES(&apos;John&apos;,3398.98); 省略字段后，values(记录内容必须按照表列顺序也就是字段顺序以逗号分隔，且插入内容一个不能少);若不省略字段(可部分省略，省略部分记录自动为空)，values(记录内容按照字段插入内容，写几个字段插入几个内容); 查找记录1SELECT expr(表达式),...FROM table_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2Fpost%2F47519a60.html</url>
    <content type="text"><![CDATA[数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型 整型整型的存储范围分有符号位和无符号位两种，一般无符号位是有符号位的两倍 选择数据类型要根据实际数据的大小，选择合适的数据类型有利于数据的优化 数据类型 字节 存储范围 tinyint 1 -128~127无符号0~255 smallint 2 -32768~32767无符号0~65535 mediumint 3 -2^23~2^23-1(800万)无符号0~2^24-1 int 4 -2^31~2^31-1(21亿)无符号0~2^32-1 bigint 8 -2^63~2^63-1无符号0~2^64-1 浮点型 数据类型 存储类型 float[(m,d]) -3.402E+38到-1.175E-380和1.175E-38到3.402+38m是数字总位数，d是小数点后面的位数，如果m和d被省略，会根据硬件允许的限制来保存值 double[(m,d)] -1.797E+308到-2.223E-308、0和2.225E-308到1.797E+308 float，单精度浮点，保留小数点后7位，C语言默认显示6位小数。double，双精度浮点，一般是float存储范围的十倍，C语言默认显示15位小数。 日期时间型 数据类型 存储范围 存储需求 YEAR 1970至2069 1 TIME -838:59:59至838:59:59 3 DATE 1000-1-1至9999-12-31 3 DATETIME 1000-1-1 00:00:00至9999-12-31 23:59:59 8 TIMESTAMP 1970-1-1 00:00:00到2037-12-31 23:59:59 4 字符型 列类型 存储需求 CHAR(M) M个字节 0&lt;=M&lt;=255 定长 M是5就5个字节 abc会在后面补两个空格 VARCHAR(M) L+1个字节 L&lt;=M,0&lt;=M&lt;=65535变长 abc就是abc TINYTEXT L+1个字节，L&lt;2的8次方 TEXT L+2个字节，L&lt;2的16次方（6w5），标准文本 MEDIUMTEXT L+3个字节，L&lt;2的24次方（1600w） LONGTEXT L+4个字节，L&lt;2的32次方 ENUM(‘value1’;’value2’,…) 1or2字节 取决于枚举值的个数（最多65535个值） SET（’value1’,’value2’,…) 1、2、3、4、8字节，取决于set成员个数（最多64个成员） booleanMySQL没有内置的布尔类型，但是它使用TINYINT(1)。 为了更方便，MySQL提供BOOLEAN或BOOL作为TINYINT(1)的同义词。 MySQL将布尔值作为整数存储在表中，但当显示表定义时，它是却是TINYINT(1)类型12345CREATE TABLE tasks (id INT PRIMARY KEY AUTO_INCREMENT,title VARCHAR(255) NOT NULL,completed BOOLEAN); https://www.yiibai.com/mysql/boolean.htmlhttps://dev.mysql.com/doc/refman/8.0/en/bit-type.html]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作]]></title>
    <url>%2Fpost%2Ff2cccc89.html</url>
    <content type="text"><![CDATA[创建数据库12CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name; DATABASE和SCHEMA是相同的，任选其一IF NOT EXISTS:如果创建的数据库存在，则不只报出warning，不写会报错CHRARCTER SET gbk:为表设置编码方式，如果不设置则用mysql默认的编码方式 查看数据库列表1SHOW &#123; DATABASES | SCHEMAS &#125; [LIKE &apos;pattern&apos; | WHERE expr]; 查看数据库详情1SHOW CREATE DATABASE xx; 展示数据库t1的创建命令和编码形式 数据库的修改：ALTER修改数据库编码方式12ALTER &#123; DATABASE | SCHEMAS &#125; [db_name][DEFAULT] CHARACTER SET [=] charset_name 删除数据库：DROP1DROP &#123; DATABASE | SCHEMAS &#125; [IF EXISTS] db_name;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句规范]]></title>
    <url>%2Fpost%2Fed36abd2.html</url>
    <content type="text"><![CDATA[MySql语句规范 关键字和函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL登录和退出]]></title>
    <url>%2Fpost%2F20f3fae1.html</url>
    <content type="text"><![CDATA[mysql命令参数12345678-D,--database=name 打开指定数据库 --delimiter=name 指定分隔符-h,--host=name 服务器名称-p,--password[=name] 密码-P,--port=# 端口号（默认为3306）--prompt=name 设置提示符-u,--user=name 用户名-V,--version 输出版本信息且推出 登录1mysql -uroot -P3306 -hlocalhost -p 退出123mysql&gt;exit;mysql&gt;quit;mysql&gt;\q;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL配置]]></title>
    <url>%2Fpost%2Fb62959c1.html</url>
    <content type="text"><![CDATA[配置文件的位置不一，在Centos7.4和MySQL5.5上是在/etc/my.cnf也可能在/etc/mysql/my.cnf 修改编码方式在mysql中可以通过status查看编码 12345[mysql]default-character-set=utf8[mysqld]character-set-server=utf8 修改提示符 连接客户端时通过参数指定 123mysql -uroot -p --prompt 提示符mysql -uroot -p --prompt &quot;[\D-\d\h\u]&quot; 连接上客户端后，通过prompt命令修改 1mysql&gt;prompt 提示符 提示符有：\D 完整的日期\d 当前数据库\h 服务器名称\u 当前用户]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL目录结构]]></title>
    <url>%2Fpost%2F1c0eeefa.html</url>
    <content type="text"><![CDATA[使用yum安装MySQL后的各目录位置相关路径直接通过find / -name &quot;mysql*&quot;和whereis mysqld查找： /usr/lib64/mysql 库文件/usr/share/mysql 配置文件，5.5后的默认安装路径/var/lib/mysql 数据库目录/etc/rc.d/init.d/ 启动脚本/usr/bin/ mysqladmin\mysqldump命令/usr/share/doc/ 文档]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome插件vimium]]></title>
    <url>%2Fpost%2F167caf1a.html</url>
    <content type="text"><![CDATA[以下部分快捷键标明了chrome自身的快捷键，毕竟有时因为焦点的原因可能失效 页面浏览12345678j 向下滚动一行k 向上滚动一行h 向左滚动l 向右滚动d 向下翻半屏u 向上翻半屏gg 到页面顶G 到页面底 标签12345678t 新建标签J、Ctrl-Tab 切换到下个标签K、Ctrl-Shift-Tab 切换到上个标签g0 切换到第一个标签g$ 切换到最后一个标签x、Ctrl-w 关闭当前标签X 恢复最后一个关闭的标签T 搜索当前打开的页签 链接1234f 在当前页打开链接F 在新页签打开链接o 在当前页签打开书签、url、历史 O 在新页签打开书签、url、历史 历史12H 回到历史L 向前 帮助1? 参考： https://github.com/philc/vimium#keyboard-bindings https://sspai.com/post/27723]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hyper终端的配置]]></title>
    <url>%2Fpost%2Fb6b46b46.html</url>
    <content type="text"><![CDATA[hyper是一款基于Electron的终端， Electron应用中比较出名的有Atom、VS code hyper的配置文件是.hyper.js1234567//不要用14，目前有一个不显示下划线的问题，https://github.com/zeit/hyper/issues/2812fontSize: 15,plugins: [ &quot;hyper-material-theme&quot;, &quot;hyper-search&quot;, ], 主题的安装可以通过在终端里输入hyper i verminal安装 https://github.com/zeit/hyper/issues/2812]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim多行注释和多行删除]]></title>
    <url>%2Fpost%2Fb837d84f.html</url>
    <content type="text"><![CDATA[多行注释和多行删除都是利用vim的块模式 多行注释 首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式; 在行首使用上下键选择需要注释的多行; 按下键盘（大写）“I”键，进入插入模式； 然后输入注释符（“//”、“#”等）; 最后按下Esc键。注：在按下esc键后，会稍等一会才会出现注释 删除多行注释 首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式; 选定要取消注释的多行; 按下x或者d.注意：如果是“//”注释，那需要执行两次该操作，如果是“#”注释，一次即可 多行删除 首先在命令模式下，输入:set nu显示行号； 通过行号确定你要删除的行； 命令输入:32,65d，回车键，32-65行就被删除了 如果无意中删除错了，可以使用u键恢复（命令模式下）]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux配置文件和插件]]></title>
    <url>%2Fpost%2Fc0cf1d1f.html</url>
    <content type="text"><![CDATA[配置文件（~/.tmux.conf）使用tmux source .tmux.conf使命令生效打开鼠标后使用shift键选中文字，再按Shift-Ctrl-c复制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 基础设置#设置默认终端模式为 256colorset -g default-terminal &quot;screen-256color&quot;set -g display-time 3000set -g escape-time 0set -g history-limit 65535set -g base-index 1set -g pane-base-index 1# 前缀绑定 (Ctrl+a)#set -g prefix ^a#unbind ^b#bind a send-prefix# 分割窗口#unbind &apos;&quot;&apos;#bind - splitw -v#unbind %#bind | splitw -h# 选中窗口#bind-key k select-pane -U#bind-key j select-pane -D#bind-key h select-pane -L#bind-key l select-pane -R# copy-mode 将快捷键设置为 vi 模式#setw -g mode-keys vi# 启用鼠标(Tmux v2.1)set -g mouse on# 更新配置文件bind r source-file ~/.tmux.conf \; display &quot;已更新&quot;#&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;# Tmux Plugin Manager(Tmux v2.1)# Tmux Resurrectset -g @plugin &apos;tmux-plugins/tmux-resurrect&apos;# List of pluginsset -g @plugin &apos;tmux-plugins/tpm&apos;set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;# Other examples:# set -g @plugin &apos;github_username/plugin_name&apos;# set -g @plugin &apos;git@github.com/user/plugin&apos;# set -g @plugin &apos;git@bitbucket.com/user/plugin&apos;# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run &apos;~/.tmux/plugins/tpm/tpm&apos;#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 插件TPM的安装跟我们现在常用的很多软件类似，Tmux也支持插件系统，可以通过安装插件扩展出许多功能，让Tmux变得更加强大。在Tmux中，这款插件管理器叫做 TPM - Tmux Plugin Manager。 TPM的安装也比较简单:1$ git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 然后，修改Tmux配置文件，让其在启动时加载TPM1234567891011# List olugins# # Supports `github_username/repo` or full git repo URLsset -g @plugin &apos;tmux-plugins/tpm&apos;set -g @plugin &apos;tmux-plugins/tmux-resurrect&apos;set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;set -g @plugin &apos;tmux-plugins/tmux-urlview&apos;set -g @plugin &apos;tmux-plugins/tmux-open&apos;set -g @plugin &apos;tmux-plugins/tmux-yank&apos;set -g @plugin &apos;tmux-plugins/tmux-battery&apos;set -g @plugin &apos;tmux-plugins/tmux-cpu&apos; TPM主要提供插件的安装，更新和移除等管理功能：123&lt;prefix&gt; I 安装插件，并更新Tmux&lt;prefix&gt; U 更新所有已安装插件&lt;prefix&gt; Alt U 移除所有插件列表中不存在的插件 常用插件推荐有了TPM，我们就能够安装和使用各种插件了，这里介绍几款我比较常用的插件： Tmux Resurrect 一个非常好用的保存当前Tmux窗口和Panel布局的插件。它可以帮助你持久化当前Tmux中所有的窗口和Panel布局。如果你对窗口进行了分割并且精心调整过，在退出Tmux之前可以使用快捷键对布局进行持久化。下一次启动Tmux的时候，也能非常方便的用快捷键恢复上次的窗口布局，真是非常方便。插件地址：https://github.com/tmux-plugins/tmux-resurrect 将插件添加到TPM插件列表中.tmux.conf：1set -g @plugin &apos;tmux-plugins/tmux-resurrect&apos; 点击prefix + I获取插件并获取它。您现在应该可以使用该插件。12prefix + Ctrl-s - 保存prefix + Ctrl-r - 恢复 Tmux urlview 在终端界面中自动搜寻所有的URL链接地址，合并为一个可以选择的列表，然后选中直接在浏览器中打开URL。省去了用鼠标复制URL，再打开浏览器粘贴的繁琐操作，非常高效，值得推荐！插件地址：https://github.com/tmux-plugins/tmux-urlview Tmux open 使用系统中默认文件类型对应的程序，快速打开在终端中选中的文件名。这个也非常高效，值得推荐！ 插件地址：https://github.com/tmux-plugins/tmux-open 参考：https://xiaozhou.net/learn-the-command-line-tmux-2018-04-27.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux快捷键]]></title>
    <url>%2Fpost%2F6457d4b.html</url>
    <content type="text"><![CDATA[安装\启动12sudo apt install tmuxtmux 会话、窗口与窗格的概念Tmux中的主要概念分为三个： Session - Session是Tmux中最主要的概念了，默认开启Tmux的时候，就会自动新建一个会话，在这个会话中，也会给你开启一个默认的Window（也即窗口）。Tmux中可以拥有多个会话，多个会话之间可以来回无缝切换。 Window - 相比session，Windows是稍微小一点的单位。一个session中，可以开启多个window。这些window同属于一个Session，并由其管理。 Panel - Panel是比Window更小的界面元素。前面我们也提到了Tmux中可以对window进行任意分割，由window分割出来的单位就叫做panel了。在同一个window中，用户可以控制光标在分割出的panel中随意移动，用以选定当前作为激活状态的panel。 via 这里 常用这里是自己平时会用到的 12345678910111213141516tmux new -s 会话名 新建会话tmux ls 列出会话tmux at -t 会话名 恢复会话ctrl-b,:new 启动新会话ctrl-b,s 列出所有会话strl-b,d 关闭会话，后台存在ctrl-b,c 创建新窗口ctrl-b,w 列出所有窗口ctrl-b,n 后一个窗口ctrl-b,p 前一个窗口ctrl-b,&amp; 关闭当前窗口ctrl-b,q,数字 切换panel 会话session12345tmux [new -s 会话名 -n 窗口名] 启动新会话tmux at [-t 会话名] 恢复会话tmux ls 列出所有会话tmux kill-session -t 会话名 关闭会话tmux ls | grep : | cut -d. -f1 | awk &apos;&#123;print substr($1, 0, length($1)-1)&#125;&apos; | xargs kill 关闭所有会话 Tmux为我们默认预备的 &lt;prefix&gt;组合键，是 C-b (即Ctrl+b)开启tmux后使用 &lt;prefix&gt;1234&lt;prefix&gt; :new&lt;回车&gt; 启动新会话&lt;prefix&gt; s 列出所有会话&lt;prefix&gt; $ 重命名当前会话&lt;prefix&gt; d 退出 tmux（tmux 仍在后台运行） 窗口windows12345678&lt;prefix&gt; c 创建新窗口&lt;prefix&gt; w 列出所有窗口&lt;prefix&gt; n 后一个窗口&lt;prefix&gt; p 前一个窗口&lt;prefix&gt; f 查找窗口&lt;prefix&gt; , 重命名当前窗口&lt;prefix&gt; &amp; 关闭当前窗口&lt;prefix&gt; 0-9 切换到指定编号的窗口 窗格panel12345678910111213141516171819202122# 操作&lt;prefix&gt; % 垂直分割&lt;prefix&gt; &quot; 水平分割&lt;prefix&gt; o 交换窗格&lt;prefix&gt; x 关闭窗格&lt;prefix&gt; &lt;space&gt; 切换布局&lt;prefix&gt; q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格&lt;prefix&gt; &#123; 与上一个窗格交换位置&lt;prefix&gt; &#125; 与下一个窗格交换位置&lt;prefix&gt; u 切换窗格最大化&lt;prefix&gt; n 切换窗格最小化# 选择&lt;prefix&gt; 方向键 选择窗格#在配置文件中，set mouse on可以使用鼠标焦点某个窗格# 尺寸调整&lt;prefix&gt; H 当前窗格向左扩大3格&lt;prefix&gt; J 当前窗格向下扩大3格&lt;prefix&gt; K 当前窗格向上扩大3格&lt;prefix&gt; L 当前窗格向右扩大3格#在配置文件中，set mouse on可以使用鼠标拖动来调节尺寸 杂项：1234t 窗口中央显示一个数字时钟? 列出所有快捷键: 命令提示符 参考： https://gist.github.com/ryerh/14b7c24dfd623ef8edc7 https://xiaozhou.net/learn-the-command-line-tmux-2018-04-27.html https://harttle.land/2015/11/06/tmux-startup.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox安装CentOS7]]></title>
    <url>%2Fpost%2F85425272.html</url>
    <content type="text"><![CDATA[主要的安装过程不再详细说明，主要是针对安装后进行的一些配置进行说明 网络设置为桥接，因为本地要和虚拟机进行通信 centos7默认没有安装ifconfig命令，而一开始也是上不了网的，可以使用ip addr命令代替，也可以通过yum provides ifconfig查找对应的安装包，可以知道是net-tools，安装net-tools即可，当然在无法连网时，使用ip addr是为了获得网卡名称 vi /etc/sysconfig/network-scripts/ifcfg-eth0，修改对应文件名的配置文件，改onBoot为yes，重启网络systemctl restart network，这时可以ping或安装ifconfig]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell批量重命名增加文件时间戳前缀]]></title>
    <url>%2Fpost%2Fa989c9fe.html</url>
    <content type="text"><![CDATA[思路： 首先要获得文件的时间戳，ls --full-time和stat -c %y命令都可以 因为是批量，需要获得文件名列表，ls -p | grep [^/]$或find * -type -f 12345678#!bin/bashfiles=$(ls -p | grep [^/]$)for file in $filesdoDATE=$(ls --full-time $file | awk &apos;&#123;print $6&#125;&apos;)mv $file &quot;$DATE-$file&quot;done 依旧没有解决的问题：只能重命名当前目录，如果使用files=$(ls -p $1 | grep [^/]$)，然后传入参数，会报没有这个文件或目录]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo 站内链接和永久链接]]></title>
    <url>%2Fpost%2Fb1775bb9.html</url>
    <content type="text"><![CDATA[站内链接在写博客中，有时会引用站内的链接，之前因为文章不是很多，说明标题可以直接找到，但是现在文章多了，必然需要使用链接 hexo3.0以上可以直接使用下面的格式1&#123;% post_link hello-world %&#125; hello-world是博客的title 永久链接安装插件1npm install hexo-abbrlink --save 站点配置文件里:1234permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 显示的样式为http://localhost:4000/post/f525ac74.html#more 同时为以后方便，新建文章时统一以YYYY-mm-dd的时间格式开头，方便管理，而文章标题删除标题中的时间 参考： https://hexo.io/zh-cn/docs/permalinks.html http://blog.gezhiqiang.com/2016/11/27/hexo-inner-link/ http://www.wuliaole.com/post/permalink_and_internal_link_in_hexo/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo表格]]></title>
    <url>%2Fpost%2F5630467a.html</url>
    <content type="text"><![CDATA[我偶尔会在博客中添加表格，但是hexo原生表格有时会有一些问题 原生表格使用markdown语法123| 表格头 | 表格头 ||-------|-------|| 内容 | 内容 | 使用这种表格能够满足基本的需求，但是这种表格无法实现合并单元格，当然，这种表格是可以使用css的，只是要用F12查询对应的html标签，参考之前写的 html表格使用html表格可以实现合并单元格，可以使用tablesgenerator在线生成表格代码 这样生成的表格还会有一个问题，这个问题我不太清楚是Next主题（5.1.4）的问题，还是hexo的问题，就是在实际展示的时候出现了大量的空白，解决办法是使用html压缩工具去掉表格代码的空格]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 时间戳管理]]></title>
    <url>%2Fpost%2F29c3cf93.html</url>
    <content type="text"><![CDATA[stat 查看时间戳文件：metadata, data查看文件状态：stat 三个时间戳：access time：（文档最后一次）访问时间，简写为atime，读取文件内容modify time: 修改时间, mtime，改变文件内容（数据）change time: 改变时间, ctime，元数据发生改变 123Access - the last time the file was readModify - the last time the file was modified (content has been modified)Change - the last time meta data of the file was changed (e.g. permissions) touch 修改时间戳123456touch [OPTION]... FILE...选项：-a only atime-m only mtime-t STAMP [[CC]YY]MMDDhhmm[.ss]-c 如果文件不存，则不予创建]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令补全和路径补全]]></title>
    <url>%2Fpost%2F3781ba59.html</url>
    <content type="text"><![CDATA[命令补全bash执行命令内部命令外部命令：bash根据PATH环境变量定义的路径，自左而右在每个路径搜寻以给定命令名命名的文件，第一次找到即为要执行的命令 直接补全：Tab，用户给定的字符串只有一条惟一对应的命令以用户给定的字符串为开头对应的命令不惟一，则再次Tab会给出列表 路径补全把用户给出的字符串当做路径开头，并在其指定上级目录下搜索以指定的字符串开头的文件名如果惟一，则直接补全否则，再次Tab，给出列表]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 终端]]></title>
    <url>%2Fpost%2F43bb04d6.html</url>
    <content type="text"><![CDATA[用户与主机交互，必然用到的设备； 物理终端直接连接在主机上的显示器、键盘鼠标统称。在实际机架式服务器部署中，一般是多台服务器共享一套终端，简称KVM（Keyboard键盘，video显示器，mouse鼠标）/dev/console 虚拟终端tty附加在物理终端之上的以软件方式虚拟实现的终端，CentOS 6默认启动6个虚拟终端Ctrl+Alt+F#: [1,6]图形终端：附加在物理终端之上的以软件方式虚拟实现的终端，但额外会提供桌面环境；tty是teletypewriter的简称设备文件路径：/dev/tty# 模拟终端ptysh协议或telnet协议等远程打开的命令行界面，是运维工程师用的最多的一种连接服务器的方式。pts(pseudo-terminal slave)是pty的实现方法。设备文件：/dev/pts/# [0,oo) 查看当前的终端设备：tty 交互式接口启动终端后，在终端设备附加一个交互式应用程序 GUIX protocol, window manager, desktop Desktop: GNOME (C, gtk) KDE (C++, qt) XFCE (轻量级桌面) CLIshell程序： sh (bourn) csh tcsh ksh (korn) bash (bourn again shell), GPL zsh 显示当前使用的shell：echo ${SHELL} 显示当前系统使用的所有shell：cat /etc/shells]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux时间命令]]></title>
    <url>%2Fpost%2F4aed7274.html</url>
    <content type="text"><![CDATA[date 显示或设置日期12345678910111213date [OPTION]... [+FORMAT]# 显示日期FORMAT: 格式符号，类似%D、%F、%T，参考mandate [MMDDhhmm[[CC]YY][.ss]]# 设置日期MM 月份DD 几号hh 小时mm 分钟YY 两位年份CCYY 四位年份.ss 秒钟 Linux的两种时钟系统时钟(system time)：由Linux内核通过CPU的工作频率进行的计时，date命令硬件时钟(hardware clock)：clock命令 hwclock: 显示硬件时钟 -s, –hctosys Set the System Time from Hardware Clock 读取硬件时间到系统时间 -w, –systohc Set Hardware Clock to the current System Time 系统时间写入硬件时间 cal 日历12345cal# 显示当前月份cal [options] [[[day] month] year] # 显示指定时间的日历]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell echo命令]]></title>
    <url>%2Fpost%2Fa6281d67.html</url>
    <content type="text"><![CDATA[echo 回显命令123456789101112131415161718192021echo [选项] [输出内容]选项： -e：允许使用转义符-n: 禁止自动添加换行符号内容转义\a - 输出警告音\b - 退格符\n - 换行符\r - 回车键\t - 制表符，也就是tab键\v - 垂直制表符\0nnn - 按照八进制ASCII码输出字符\xhh - 按照十六进制ASCII表输出字符输出带颜色的内容 echo -e &quot;\e[1;31m文字\e[0m&quot;#输出颜色 \e[1;##m - 开启颜色显示； \e[0m - 关闭颜色显示#30m=黑色，31m=红色，32m=绿色，33m=黄色#34m=蓝色，35m=洋红，36m=青色，37m=白色 12echo &quot;$VAR_NAME&quot;: 变量会替换，双引号表弱引用echo &apos;$VAR_NAME&apos;: 变量不会替换，强引用 参考：Shell引号]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell引号]]></title>
    <url>%2Fpost%2Fca5ad791.html</url>
    <content type="text"><![CDATA[双引号””单词分割、路径名展开、波浪线展开和花括号展开都被禁止，参数展开、算术展开、命令替换仍然执行 在双引号中左右的特殊符号都没有特殊含义，但是“$”,”`”,”\”是例外。拥有“调用变量的值”，“引用命令”和“转义符”的特殊含义 使用双引号可以处理包含空格的文件名 12echo $(cal) #输出以空格分为不同的参数echo &quot;$(cal)&quot; #只有一个参数 单引号’’禁止所有展开在单引号中左右的特殊符号，如$、`(反引号)都没有特殊含义]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell展开]]></title>
    <url>%2Fpost%2F7e1cd31f.html</url>
    <content type="text"><![CDATA[输入的字符在shell起作用前会展开成为别的字符 路径展开 波浪号展开 算术表达式展开 花括号展开 参数展开 命令替换 单词分割 ##路径展开12345ls echo * #不显示隐藏文件echo D*echo *secho /usr/*/bin ##波浪号展开~会展开成为家目录1ls ~ ##算术表达式展开通过这种方式进行算术运算12echo $((2+2))echo $(($a+$b)) ##花括号展开可以从一个花括号的模式中创建多个字符串1234567echo front-&#123;a,b,1&#125;-endfront-a-end front-b-end front-1-endecho Number_&#123;1..5&#125;echo &#123;Z..A&#125;echo &#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;mkdir &#123;2007..2009&#125;-0&#123;1,9&#125; &#123;2007..2009&#125;-&#123;10..12&#125; ##参数展开即shell变量，多用于shell脚本 ##命令替换 把一个命令的输出作为作为一个展开1234echo $(ls)files=$(ls)echo `ls` 单词分割在默认情况下，单词分割机制会在单词中寻找空格、制表符和换行符，并把它们看作单词之间的界定符，它们只作为分隔符使用。所以不要用包含空格的名字命名文件unless you really know what you do 补充：https://www.jianshu.com/p/403f3554e2c1]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM插件NerdTree快捷键]]></title>
    <url>%2Fpost%2F2101d586.html</url>
    <content type="text"><![CDATA[切换工作台和目录1234ctrl + w + h 光标 focus 左侧树形目录ctrl + w + l 光标 focus 右侧文件显示窗口ctrl + w + w 光标自动在左右侧窗口切换ctrl + w + r 移动当前窗口的布局位置 1234567891011121314151617181920212223242526272829303132333435363738394041o 在已有窗口中打开文件、目录或书签，并跳到该窗口go 在已有窗口 中打开文件、目录或书签，但不跳到该窗口t 在新 Tab 中打开选中文件/书签，并跳到新 TabT 在新 Tab 中打开选中文件/书签，但不跳到新 Tabi split 一个新窗口打开选中文件，并跳到该窗口gi split 一个新窗口打开选中文件，但不跳到该窗口s vsplit 一个新窗口打开选中文件，并跳到该窗口gs vsplit 一个新 窗口打开选中文件，但不跳到该窗口! 执行当前文件O 递归打开选中 结点下的所有目录x 合拢选中结点的父目录X 递归 合拢选中结点下的所有目录e Edit the current dif双击 相当于 NERDTree-o中键 对文件相当于 NERDTree-i，对目录相当于 NERDTree-eD 删除当前书签P 跳到根结点p 跳到父结点K 跳到当前目录下同级的第一个结点J 跳到当前目录下同级的最后一个结点k 跳到当前目录下同级的前一个结点j 跳到当前目录下同级的后一个结点C 将选中目录或选中文件的父目录设为根结点u 将当前根结点的父目录设为根目录，并变成合拢原根结点U 将当前根结点的父目录设为根目录，但保持展开原根结点r 递归刷新选中目录R 递归刷新根结点m 显示文件系统菜单cd 将 CWD 设为选中目录I 切换是否显示隐藏文件f 切换是否使用文件过滤器F 切换是否显示文件B 切换是否显示书签q 关闭 NerdTree 窗口? 切换是否显示 Quick Help 切换标签页123456789101112131415:tabnew [++opt选项] ［＋cmd］ 文件 建立对指定文件新的tab:tabc 关闭当前的 tab:tabo 关闭所有其他的 tab:tabs 查看所有打开的 tab:tabp 前一个 tab:tabn 后一个 tab标准模式下：gT 前一个 tabgt 后一个 tabMacVim 还可以借助快捷键来完成 tab 的关闭、切换cmd+w 关闭当前的 tabcmd+&#123; 前一个 tabcmd+&#125; 后一个 tab NerdTree在.vimrc中的常用配置1234567891011&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）autocmd VimEnter * NERDTree&quot; 按下 F2 调出/隐藏 NERDTreemap :silent! NERDTreeToggle&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）let NERDTreeWinPos=&quot;right&quot;&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarkslet NERDTreeShowBookmarks=1 转自：http://yang3wei.github.io/blog/2013/01/29/nerdtree-kuai-jie-jian-ji-lu/]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM配置]]></title>
    <url>%2Fpost%2F6f99625c.html</url>
    <content type="text"><![CDATA[位置打开VIM，输入:version123456789系统 vimrc 文件: &quot;$VIM/vimrc&quot;用户 vimrc 文件: &quot;$HOME/.vimrc&quot;第二用户 vimrc 文件: &quot;~/.vim/vimrc&quot;用户 exrc 文件: &quot;$HOME/.exrc&quot;系统 gvimrc 文件: &quot;$VIM/gvimrc&quot;用户 gvimrc 文件: &quot;$HOME/.gvimrc&quot; 第二用户 gvimrc 文件: &quot;~/.vim/gvimrc&quot;系统菜单文件: &quot;$VIMRUNTIME/menu.vim&quot;$VIM 预设值: &quot;/usr/share/vim&quot; 列出了几个 vimrc 文件，有一个系统的 vimrc 文件，还有用户的 vimrc 文件，以及系统和用户 gvimrc 文件。出于和vi兼容的目的，vim也支持vi的exrc配置文件。 一般来说，我们都使用用户目录下的$HOME/.vimrc文件即可123set numberset ruler&quot;这是注释 https://blog.easwy.com/archives/advanced-vim-skills-catalog/]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh安装、主题、插件]]></title>
    <url>%2Fpost%2F8ec9a3b8.html</url>
    <content type="text"><![CDATA[zsh和bash兼容，fish和bash不兼容 安装12345678910111213#安装zshyum -y install zsh#切换默认shell为zshchsh -s /bin/zsh#切换回去bashchsh -s /bin/bash#确认zsh是否是默认SHELLecho $SHELL#重启服务器让修改的配置生效 #安装on my zshcurl1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; wget1sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 修改oh my zsh 主题12345678#查看oh my zsh主题ls ~/.oh-my-zsh/themes#修改主题vim ~/.zshrc#ZSH_THEME=&quot;robbyrussell&quot; #默认的主题ZSH_THEME=&quot;avit&quot; #修改为avit oh my zsh插件修改~/.zshrc中plugins1plugins=(git z extract colored-man-pages) git：各种别名，ga\gp\gs\gcextract：功能强大的解压插件，所有类型的文件解压一个命令x全搞定z：强大的目录自动跳转命令，会记忆你曾经进入过的目录，用模糊匹配快速进入你想要的目录。 https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview 其他卸载on my zsh1uninstall_oh_my_zsh zsh http://ohmyz.sh/https://github.com/robbyrussell/oh-my-zsh/wiki/Themeshttps://blog.csdn.net/gatieme/article/details/52741221https://www.jianshu.com/p/556ff130fc65]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim使用系统剪贴板]]></title>
    <url>%2Fpost%2F333f9b1a.html</url>
    <content type="text"><![CDATA[查看vim版本是否支持clipboard123vim --version | grep &quot;clipboard&quot;-clipboard +insert_expand +path_extra +user_commands -clipboard 显示 - 号，说明不支持，需要安装vim-gnome123sudo apt install vim-gnome#再次查看，可以看到clipboard前面是+号vim --version | grep &quot;clipboard&quot; 复制、粘贴Vim 中的复制、删除的内容都会被存放到默认（未命名）寄存器中，之后可以通过粘贴操作读取默认寄存器中的内容。寄存器是完成这一过程的中转站，Vim 支持的寄存器非常多，其中常用的有 a-zA-Z0-9+“。其中： 0-9：表示数字寄存器，是 Vim 用来保存最近复制、删除等操作的内容，其中 0 号寄存器保存的是最近一次的操作内容。 a-zA-Z：表示用户寄存器，Vim 不会读写这部分寄存器 &quot;（单个双引号）：未命名的寄存器，是 Vim 的默认寄存器，例如删除、复制等操作的内容都会被保存到这里。 +：剪切板寄存器，关联系统剪切板，保存在这个寄存器中的内容可以被系统其他程序访问，也可以通过这个寄存器访问其他程序保存到剪切板中的内容。 12#查看所有寄存器中的内容，也可以只查看指定寄存器的内容（将寄存器名称作为参数）:reg [register_name] 1234&quot;+yy #复制当前行到剪切板&quot;+p #将剪切板内容粘贴到光标后面&quot;ayy #复制当前行到寄存器 a&quot;ap #将寄存器 a 中的内容粘贴到光标后面 参考： https://blog.csdn.net/zhangxiao93/article/details/53677764 https://www.zhihu.com/question/19863631/answer/89354508]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM插件]]></title>
    <url>%2Fpost%2F9b750e68.html</url>
    <content type="text"><![CDATA[Elementary os的终端好像不能用vim的块操作同时插件NerdTree也有问题，所以改用hyperhttps://hyper.is/https://github.com/zeit/hyper 插件管理 vim-plughttps://github.com/junegunn/vim-plug 安装12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 插件管理1vim ~/.vimrc 123456789101112131415161718192021222324252627set numbercall plug#begin(&apos;~/.vim/plugged&apos;)let mapleader=&quot;,&quot;&quot;目录树&quot;F3打开目录&quot;o打开文件Plug &apos;godlygeek/tabular&apos;nnoremap &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif&quot;markdown 语法高亮、预览&quot;:PrevimOpen在浏览器预览&quot;关闭折叠let g:vim_markdown_folding_disabled = 1Plug &apos;godlygeek/tabular&apos;Plug &apos;plasticboy/vim-markdown&apos;Plug &apos;kannokanno/previm&apos;Plug &apos;tyru/open-browser.vim&apos;&quot;文件搜索&quot;&lt;leader&gt;f搜索,因为这里设置leader为,号，所以是,+fPlug &apos;Yggdroot/LeaderF&apos;, &#123; &apos;do&apos;: &apos;./install.sh&apos; &#125;call plug#end()&quot;添加vim-plug配置，以call plug#begin()开头，call plug#end()结尾，中间是插件列表，begin可以接受参数指定存放插件的位置 12345678910#重新打开.vimrcvim ~/.vimrc:PlugInstall #安装插件:PlugUpdate #升级插件:PlugClean #删除未被使用的插件目录:PlugUpgrade #升级Vim-plug自身:PlugStatus #查看插件状态:q 退出 补充：http://www.vimer.cn/archives/1372.html 参考： https://blog.csdn.net/rankun1/article/details/78775404 https://www.jianshu.com/p/f4fb7877829f http://www.zhaiqianfeng.com/2017/02/install-vim-plugins.html https://github.com/gabrielelana/vim-markdown https://bovink.com/2016/07/01/use-vim-to-write-markdown/ https://github.com/Yggdroot/LeaderF]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下载命令]]></title>
    <url>%2Fpost%2Fc4eab17c.html</url>
    <content type="text"><![CDATA[发现自己安装了以下的大部分工具。。。 wget12345678910wget url/ftp-b：后台下载-c：断点续传-O 文件名：指定文件名#使用匿名用户下载wget ftp-url#ftp下载，指定用户名和密码wget --ftp-user=&lt;user_name&gt; --ftp-password=&lt;Give_password&gt; Download-url-address curl123curl [选项] url-o：指定文件名-O：使用原文件名 axelwget的出色替代者，是一款轻量级下载实用工具。它实际上是个加速器，因为它打开了多路http连接，可下载独立文件片段，因而文件下载起来更快速。 12apt install axelaxel url aria212apt install aria2 aria2c url 视频下载工具Youtube-dlhttps://github.com/rg3/youtube-dl1234567891011121314151617pip install youtube-dlyoutube-dl url-i：忽略错误youtube-dl -F [url] #查看可下载的视频格式youtube-dl -f [format code] [url] #指定下载视频的格式youtubd-dl --write-sub [url] #下载字幕#下载视频列表，以下三种方式下载的视频可能是mkv格式或者webm格式youtube-dl [playlist_url] youtube-dl -cit [playlist_url]youtube-dl --yes-playlist [url]#下载视频列表，指定下载格式youtube-dl -f [format code] [palylist_url] anniehttps://github.com/iawia002/annie12annie-master -p url#下载列表 Torrent下载工具12sudo apt install transmissionsudo apt-get install deluge 参考： wget:http://www.cnblogs.com/peida/archive/2013/03/18/2965369.html https://linux.cn/article-7369-1.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】Hexo注释]]></title>
    <url>%2Fpost%2F276480f9.html</url>
    <content type="text"><![CDATA[html 格式的注释 这样写的注释会出现在编译后的 Html 文件中，但不会被浏览器显示出来。 1&lt;!--这些是注释文本，不会显示--&gt; 编译后的 Html 文档中有这行文本，但浏览器不会显示它。这与分号开头的注释行不同，Html 方式注释的文字仍然会出现在编译后的 Html 文件中，只是不显示而已。 参考： https://www.w3cschool.cn/lme/q92a1srq.html]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM常用按键]]></title>
    <url>%2Fpost%2Fe15257f3.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } thead{ background-color:#3d3d3d; color:white } 安装12yum install vimapt install vim Cheat Sheet 模式 ESC 命令模式，在插入模式或可视模式下切换模式 i 插入模式 v 可视模式，以字符为单位 V 可视模式，以行为单位 撤消 u 撤消上一次操作 U 撤销对该行进行的所有最新更改 Ctrl+r 重做 光标移动 h or ← 移动左侧的一个字符 j or ↓ 向下移动一行 k or ↑ 向上移动一行 l or → 向右移动一行 :set number 临时设置行号 :n 跳到第n行（跳到第42行-&gt;:42） nk 向上移动n行（向上移动9行-&gt;9k） gg 移动到文件第一行 ngg 移动到文件第n行 G 移动到文件最后一行 5G 移动到第五行 0 移动到行首 ^ 移动到行首的非空白符 $ 移动到行尾 b 移到上一个单词的开头 e 移至单词的结尾 w 移至下一个单词开头 H 移动到当前⻚面顶部 M 移动到当前⻚面中间 L 移动到当前⻚面底部 插入 i 从光标前开始插入字符 I 从行首开始插入字符 a 从光标后开始插入字符 A 从行尾开始插入字符 o 在当前行之下另起一行，开始插入字符 O 在当前行之上另起一行，开始插入字符 ea 从当前单词末尾开始插入 复制、剪切、粘贴 yy or Y 复制当前行 :y 复制当前行 y 复制突出显示的文字 :d or dd 删除当前行 D 删除到行尾 d 删除突出显示的文本 dw 删除单词 dl 在光标位置删除字符 p 在光标位置后粘贴文本，将行放在当前行的下面 P 在光标位置之前粘贴文本，将行放在当前行的上方 x 删除当前字符 2dd 剪切2行 dw 剪切当前单词 2yy 复制2行 查找/替换 /pattern 查找pattern ?pattern 向上查找pattern \vpattern pattern中的非字母数字字符被视为正则表达式特殊字符（不需转义字符） n 查找下一个 N 查找上一个 noh 取消查找内容高亮 :%s/old/new/g 替换全部 :%s/old/new/gc （逐个）替换 标签 :tabnew 打开一个新标签 gt 转到下一个选项卡 gT 转到上一个标签 :tabmove n 将标签移动到位置n :tabc 关闭标签 文件 :e filename 打开一个新文件 :w filename 保存对文件的更改 :q 退出Vim。如果有未保存的文件，Vim将不会退出 :q! 退出Vim不保存更改 :x or zz 如果进行了更改，则退出Vim并将更改保存到文件中 Shell命令 :shell 打开命令提示符 exit 退出命令提示符 窗口 :split or :sp 水平分割当前窗口 :vsplit or :vs 垂直分割当前窗口 :split file 在第二个窗口中打开该文件 :n split file 打开一个新窗口n行高 :new 水平打开一个新窗口 :vnew 垂直打开一个新窗口 :res n 如果未提供n，则将窗口大小调整为n行大小窗口大小调整为最大大小 Ctrl+ww 在窗口之间切换光标 Ctrl+w&lt;←↓↑→&gt; 在方向键方向的窗口之间切换光标 Ctrl+wn 拆分窗口并开始编辑新文件 Ctrl+wr 旋转窗口位置 Ctrl+w or q or :q 关闭窗口 参考 https://www.cheatography.com/zoltan/cheat-sheets/basic-vim/ https://vim.rtorr.com/lang/zh_cn/ http://michael.peopleofhonoronly.com/vim/]]></content>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 case、for、while、until]]></title>
    <url>%2Fpost%2F2d466a59.html</url>
    <content type="text"><![CDATA[多分支语句case1234567891011case $变量名 in &quot;值1&quot;) 如果变量值等于值1，执行程序1 ;; &quot;值2&quot;) 如果变量值等于值2，执行程序2 ;; *） 如果变量值都不是以上值，则执行此程序 ;;esac 与if多分支最大区别是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系 12345678910111213#!/bin/bash name=&apos;basename $0 .sh&apos; case $1 in s|start) echo &quot;start...&quot; ;; stop) echo &quot;stop ...&quot; ;; reload)echo &quot;reload...&quot; ;; *)echo &quot;Usage: $name [start|stop|reload]&quot; exit 1 ;;esac | 分割多个模式，相当于 or for123456789for 变量 in 值1 值2 值3... do 程序 donefor ((初始值;循环控制条件;变量变化)) do 程序 done in后面跟多少值，for循环就循环多少次，每次循环依次把值赋给变量，直到后面的值全都运行一遍。可以将要操作的数据内容放在一个文件中，利用 for i in $(cat 文件名)来避免手动输入。也可以将内容赋给变量，利用for i in $val 来避免手动输入。 123456789#!/bin/bash#从1加到100s=0for ((i=1;i&lt;=100;i=i+1)) do s=$(($s+$i)) done#没有i++ while循环1234while [ 条件判断式 ] do 程序 done 实例：从1加到10012345678910#!/bin/bashsum=0i=1while [ $i -le 100 ] do sum=$(( $sum+$i )) i=$(( $i+1 )) doneecho &quot;sum is : $sum&quot; http://wiki.jikexueyuan.com/project/shell-learning/case-statements.html]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 双分支if语句]]></title>
    <url>%2Fpost%2F14e12b20.html</url>
    <content type="text"><![CDATA[123456if [ 条件判断式 ] then 条件成立时执行的程序 else 条件不成立时，执行的另一个程序fi 实例：判断输入的路径是不是一个目录123456789#!/bin/bashread -t 30 -p &quot;Input a dir:&quot; dirif [ -d &quot;$dir&quot; ]then echo &quot;Yes,yes yes&quot;else echo &quot;No,no,no&quot;fi 实例：判断apache服务是否启动12345678910111213141516#!/bin/bashtest=$(ps aux |grep httpd |grep -v grep)#定义变量test 并且查找是否启动apache的结果赋值给test#ps aux 查看当前所有正在运行的进程 #grep httpd 过滤出apache进程#grep -v grep 排除自身进程if [ -n &quot;$test&quot; ]then cho &quot; $(date) httpd is ok &quot; &gt;&gt; /tmp/autostart-acc.logelse systemctl start httpd.service &amp;&gt;/dev/null #centos7 echo &quot; $(date) httpd is no \n httpd is autostart now&quot; &gt;&gt; /tmp/autostart-err.logfi]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 多分支if语句]]></title>
    <url>%2Fpost%2F3f9d305d.html</url>
    <content type="text"><![CDATA[123456789if [ 条件判断式1 ]then 当条件判断式1成立时，执行程序1elif [ 条件判断式2 ]then 当条件判断式2成立时，执行程序2else 当所有条件都不成立时，最后执行此程序fi]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 单分支if语句]]></title>
    <url>%2Fpost%2Fa1518663.html</url>
    <content type="text"><![CDATA[12345678if [ 条件判断式 ];then 程序fiif [ 条件判断式 ] then 程序fi 注： if语句使用fi结尾，和一般语言使用大括号结尾不同 [ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格 then后面跟符合条件之后执行的程序，可以放在[]之后，用;分割，也可以换行写入，就不需要;了 实例：判断当前登录用户是不是root1234567#!/bin/bashtestuser=$(env | grep &quot;USER&quot; | cut -d &quot;=&quot; -f 2)#env是linux的一个外部命令，可以显示当前用户的环境变量，其中一行显示当前用户if [ &quot;$testuser&quot; == &quot;root&quot; ]then echo &quot;Current user is root.&quot;fi 实例：判断分区使用率12345678#!/bin/bash#统计根分区使用率#/dev/sda3是df判断的test=$(df -h | grep &quot;/dev/sda3&quot; | awk &apos;&#123;print $5&#125;&apos; | cut -d &quot;%&quot; -f 1)if [ &quot;$test&quot; -ge 90 ]then echo &quot;/ is full&quot;fi]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell条件判断 条件判断式]]></title>
    <url>%2Fpost%2F7f7d2ed7.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 80%; } 引用变量要加”” 按文件类型判断 测试选项 作用 -b 判断该文件是否存在，并且是否为块设备文件（是为真） -c 判断该文件是否存在，并且是否为字符设备文件（是为真） -d 判断该文件是否存在，并且是否为目录文件（是为真） -e 判断该文件是否存在（存在为真） -f 判断该文件是否存在，并且是否为普通文件（是为真） -L 判断该文件是否存在，并且是否为符号链接文件（是为真） -p 判断该文件是否存在，并且是否为管道文件（是为真） -s 判断该文件是否存在，并且是否为非空（非空为真） -S 判断该文件是否存在，并且是否为套接字文件（是为真） 两种判断格式12[-e /root/install.log] #常用test -e /root/install.log [-e /root/install.log] &amp;&amp; echo yes || echo no第一个判断命令如果正确执行，则打印yes，否则打印no&amp;&amp; 和 || 不可以调换位置 按文件权限判断 测试选项 作用 -r 判断该文件是否存在，并且是否该文件拥有读权限（有为真） -w 判断该文件是否存在，并且是否该文件拥有写权限（有为真） -x 判断该文件是否存在，并且是否该文件拥有执行权限（有为真） -u 判断该文件是否存在，并且是否该文件拥有SUID权限（有为真） -g 判断该文件是否存在，并且是否该文件拥有SGID权限（有为真） -k 判断该文件是否存在，并且是否该文件拥有SBit权限（有为真） 两个文件之间的比较 测试选项 作用 file1 -nt file2 判断文件1的修改时间是否比文件2的新(如果新则为真) file1 -ot file2 判断文件1的修改时间是否比文件2的旧(如果旧则为真) file1 -ef file2 判断文件1是否比文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的办法 两个整数之间的比较 测试选项 作用 num1 -eq num2 判断整数1是否和整数2相等(相等为真) num1 -ne num2 判断整数1是否和整数2不相等(不相等为真) num1 -gt num2 判断整数1是否大于整数2(大于为真) num1 -lt num2 判断整数1是否小于整数2(小于为真) num1 -ge num2 判断整数1是否大于或等于整数2(大于等于为真) num1 -le num2 判断整数1是否小于或等于整数2(小于等于为真) 字符串的判断 测试选项 作用 -z 字符串 判断字符串是否为空，为空返回真 -n 字符串 判断字符串是否为非空，非空返回真 字符串1 == 字符串2 判断两字符串是否相等，相等返回真，==左右加空格 字符串1 != 字符串2 判断两字符串是否不相等，不相等返回真，!=左右加空格 多重条件判断 测试选项 作用 判断1 -a 判断2 #逻辑与，判断1和判断2都成立，结果为真 判断1 -o 判断2 #逻辑或，判断1和判断2有一个成立，结果就为真 !判断 #逻辑非，判断结果取反 1[-n &quot;$a&quot; -a &quot;$a&quot; -gt 23]]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux DNS搭建 Bind服务]]></title>
    <url>%2Fpost%2F41272a58.html</url>
    <content type="text"><![CDATA[Centos123yum install bind bind-utils#centos默认的安装是没有host，dig，nsloopup等命令的，需要安装bind-utils Ubuntu1sudo apt-get install bind9 https://www.phpini.com/linux/fix-nslookup-dig-host-command-not-found]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerPoint 2016拆分汉字、制作笔画]]></title>
    <url>%2Fpost%2F218fd1f1.html</url>
    <content type="text"><![CDATA[需要工具word、powerpoint 打开word，输入汉字，设置字体为楷体GB2312/仿宋（这两种字体的笔画是分离的，WindowsXP中默认有这两种字体，但Windows 7开始系统默认没有这两种字体） 保存为doc格式 选中文字，【右击】，在快捷菜单中打开【字体】对话框，选择【空心】格式 复制“空心”汉字。打开PowerPoint中，【开始】选项卡–【选择性粘贴】，选择【图片（Windows元文件）】，取消组合两次。汉字笔画就分解出来了。删除不需要的对象（一般有1-2个空白形状） http://www.360doc.com/content/16/0107/08/982782_526070895.shtml]]></content>
      <tags>
        <tag>PPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 工具]]></title>
    <url>%2Fpost%2F82347a2b.html</url>
    <content type="text"><![CDATA[VifmVifm 是一个 Linux 控制台下的文件管理器，基于 ncurse 的两列面板界面1234#安装sudo apt install vifm#运行vifm 使用空格键从一个窗格移动到另一个窗格。要打开目录或文件，只需按Enter按钮。水平分割窗口按Ctrl-W然后s垂直分割窗口按Ctrl-W然后v一个窗格中的文件，另一个窗格中查看:view删除文件：dd 如果您在Vifm中删除文件，则会将其存储在垃圾箱中。 要查看垃圾邮件目录，请键入此命令。:trashes要查看垃圾桶中的文件，请运行lstrash命令（按q返回）。:lstrash 要从垃圾邮件目录还原文件，首先使用cd命令进入它。:cd /home/aaronkilik/.local/share/vifm/Trash然后选择要还原的文件，然后键入：:restore tmux终端分屏12sudo apt install tmuxtmux zshshhttp://ohmyz.sh/https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)https://www.zhihu.com/question/21418449 awesome桌面https://www.linuxzen.com/awesometmuxgnomedoda-zao-gao-xiao-linuxzhuo-mian-huan-jing.htmlhttps://wiki.archlinux.org/index.php/Awesome_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)http://www.hahack.com/tools/awesome/ Apvlvvim 化的 PDF 阅读工具 https://github.com/naihe2010/apvlvhttp://naihe2010.github.io/apvlv/ CMatrix黑客帝国样式的锁屏1234sudo apt install cmatrixcmatrix [-C color]Ctrl-c中止 https://github.com/abishekvashok/cmatrix vim炒股https://github.com/guofh/VimStockhttp://bluegene8210.is-programmer.com/posts/67910.html vimiumchrome插件，使用vim的按键来操作chrome https://sspai.com/post/27723 cVIM和vimium一样 https://blog.csdn.net/hk2291976/article/details/51280816]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyLinux.sh]]></title>
    <url>%2Fpost%2F6c3d6e2f.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940#/bin/bash# 使用Elementary OS 0.4#个别系统不能增加ppasudo apt install software-properties-commonsudo apt install vimif [ &quot;$?&quot; -ne 0 ] then exit 1fisudo apt install vifmif [ &quot;$?&quot; -ne 0 ] then exit 2fi#添加中文环境 Settings &gt;&gt; Language &amp; Region &gt;&gt; unLock &gt;&gt; Complete Installation &gt;&gt; click on English in the left sidebar &gt;&gt; Set System Language#安装fcitx五笔，其他相关包也会安装，fcitx\fcitx-config-gtk\fcitx-config-commonsudo apt install fcitx-table-wubi#baka-player#http://bakamplayer.u8sand.net/installation.phpcd ~/Downloadsudo apt install wgetwget https://github.com/u8sand/Baka-MPlayer/releases/download/v2.0.4/baka-mplayer_2.0.4-1_amd64.debsudo dpkg -i baka-mplayer_2.0.4-1_amd64.deb#filezillasudo apt install filezilla#virtual studio codesudo apt install code#virtualboxsudo apt install virtualbox-5.2]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk: run time error: not enough arguments passed to printf(5%)]]></title>
    <url>%2Fpost%2F3608f886.html</url>
    <content type="text"><![CDATA[问题使用awk &#39;{printf $1}&#39;时，系统提示出错，如下12awk: run time error: not enough arguments passed to printf(&quot;5%&quot;) FILENAME=&quot;b&quot; FNR=1 NR=1 解决因为要输出的内容里5% 包含%，printf认为这是格式语句，所以更改printf的使用方式使用如下格式：1awk &apos;&#123;printf(&quot;%s&quot;,$1)&#125;&apos;]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 sed命令]]></title>
    <url>%2Fpost%2F9826b1b6.html</url>
    <content type="text"><![CDATA[sed是一种几乎包括在所有的UNIX平台（包括Linux）的轻量级流编辑器。sed主要是用来将数据进行选取、替换、删除、新增的命令。1234567891011121314sed [选项] &apos;[动作]&apos; 文件名#&apos;&apos;不能省略选项:-n 只输出经过sed处理过的行到屏幕-e 允许一次应用多个动作-i 直接修改文件,并且不由屏幕输出动作:a：追加,在当前行后添加一行或多行i：插入,在当前行前插入一行或多行c：整行替换，用c后面的字符串替换原数据行d：删除，删除指定的行p：打印，输出指定的行s: 字串替换(替换格式与vim中的类似) &apos;行范围s/旧字串/新字串/g&apos; 12345678sed -n &apos;2p&apos; student.txt 查看文件的第二行，如果没有-n将输出全部内容sed &apos;2,4d&apos; student.txt 表示删除第2-4行，但是不改变文件本身sed &apos;2a piaoliangdecxiaoguniang&apos; student.txt 在第2行之后添加字符串，但是不改变字符串本身sed &apos;2i heol&apos; student.txt 在第2行之前插入数据sed &apos;4c xxwmpg&apos; student.txt 将第二行的整行替换为xxwmpgsed &apos;6s/70/100/g&apos; student.txt 将第7行的所有70全部替换为100，如果不指定行的话会替换所有的指定字符串sed -i &apos;6s/70/100/g&apos; student.txt sed操作的数据直接写入文件sed -e &apos;s/fengj//g&apos;;s/cang//g&apos; student.txt 同时把fengj和cang替换为空]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 awk命令]]></title>
    <url>%2Fpost%2Fd2c69dfe.html</url>
    <content type="text"><![CDATA[123456789awk &apos;条件1&#123;动作1&#125;条件2&#123;动作2&#125;...&apos; 文件名条件-一般使用关系表达式作为条件-x&gt;10、x&gt;=10、x&lt;=10动作-格式化输出-流程控制 一个条件满足，就执行条件后面{}内的动作。没有条件就无条件执行{}内的动作，如果有条件，就只有满足条件才能执行{}内的动作。 awk的流程：依次读取每一行数据，读取完一行数据后，进行条件判断，如果满足条件，就执行该条件对应的动作，其中文件名为$0，剩下的每一列依次为$1\$2…，判断完一行后，继续判断下一行，直到知道文件全部判断完 123456awk &apos;&#123;printf $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&apos; student.txt #注意printf里面输出格式的双引号，printf中的转义符号都要用&quot;&quot;括起来。#printf后面要接换行符&quot;\n&quot;df -h| awk &apos;&#123;printf $1&quot;\t&quot; $5&quot;\n&quot;&#125;&apos;#查看系统使用率 BAGIN条件条件BAGIN表示在所有动作执行前先执行BEGIN后的那个动作123df -h | awk &apos;BEGIN&#123;print &quot;test&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos;会在最前面输出testawk在指定分隔符前面一定要加BEGIN END条件条件END表示在所有动作执行后才执行END后的那个动作12#df -h | awk &apos;END&#123;print &quot;test&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; 会在最后面输出test FS内置变量修改分隔符（默认为空格和制表符）在修改FS的变量的动作前要加上BEGIN，这样在执行所有其它动作之前先修改分割符，否则读取第一行数据的时候不能识别指定的分隔符12345cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; #3&#125;&apos;#awk在指定分隔符前面一定要加BEGIN，此例截取第1、3列cat student.txt | grep -v Name | awk &apos;$4&gt;=70&#123;print $2&#125;&apos;#此例截取除了列头的成绩大于等于70分的学生姓名，grep -v Name为取反命令，不输出带“Name”的行]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 格式化输出命令printf]]></title>
    <url>%2Fpost%2F50c951db.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122printf &quot;输出类型输出格式&quot; 输出内容输出类型：%ns：输出字符串。n是数字，指代输出几个字符%ni：输出整数。n是数字，指代输出几个数字%m.nf：输出浮点数。m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2是小数位数，6位是整数输出格式：\a：输出警告声音\b：输出退格键，也就是Backspace键\f：清空屏幕\n：换行\r：回车，也就是Enter键\t：水平输出退格键，也就是Tab键\v：垂直输出退格键，也就是Tab键printf %s 1 2 3 4 5 6 123456printf %s %s %s 1 2 3 4 5 6 %s%s123456 后两个%s被当作输入printf &apos;%s %s %s&apos; 1 2 3 4 5 6 1 2 34 5 6 printf &apos;%s\t%s\t%s\n&apos; 1 2 3 4 5 61 2 34 5 6 使用printf输出命令，必须明确指出所有的格式如果想要使用printf读取文件中的内容就需要：12345printf &apos;%s&apos; $(cat student.txt) #不调整输出格式，文本内的内容输出到一行printf &apos;%s\t%s\t%s\t%s\n&apos; $(cat student.txt) #调整输出格式，根据文本内容进行调整 print在输出之后会在自动加入换行符，但Linux系统中默认没有print命令printf是标准格式输出命令，并不会自动加入换行符，如需换行，需要手动加入换行符printf “%s\n” a]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 字符截取命令cut]]></title>
    <url>%2Fpost%2F1a4651a4.html</url>
    <content type="text"><![CDATA[grep行提取，cut列提取 cut命令123456789101112cut [选项] 文件名选项 -f 列号：提取第几列（从1开始）-d 分隔符：按照指定分隔符分割列 默认为tabcut -f 列号,列号 文件名 （多个列号用逗号隔开；这个方法默认的文件以TAB制表符）cut -f 列号,列号 -d &quot;指定的分隔符&quot; 文件名cut -f 列号-列号grep &quot;bin/bash&quot; /etc/passwd 可以登录的用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; 排除root的可登录用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -f 1 -d &quot;:&quot; 提取非root登录用户用户名 cut命令的局限性用cut截取比较规律的文件，用默认制表符或其他符号作为分隔符，可以方便截取，如果是用空格或多个空格做分隔符，就会有问题12df -h | cut -d &quot; &quot; -f 1,3无法正确分隔多个空格，只能以一个空格分隔]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本去除重复行]]></title>
    <url>%2Fpost%2F44ec4983.html</url>
    <content type="text"><![CDATA[Find what:1^(.*)(\r?\n\1)+$ Replace with:1$1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 概述]]></title>
    <url>%2Fpost%2F515eec6a.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } 正则表达式是用于描述字符排列和匹配模式的一种语法规则。它主要用于字符串的模式分割、匹配、查找及替换操作。主要用于模糊匹配。 正则表达式与通配符的区别正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed等命令可以支持正则表达式 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符进行匹配 基础正则表达式 * 前一个字符匹配0次或任意多次 . 匹配除了换行符外任意一个字符 ^ 匹配行首。例如^hello会匹配以hello开头的行 $ 匹配行尾。例如hello$会匹配以hello结尾的行 [] 匹配中括号中指定的任意一个字符，只匹配一个字符。[0-9]匹配任意一位数字 [^] 匹配除中括号的字符以外的任意一个字符。 例如：[^0-9]匹配任意一位非数字字符[^a-z]表示任意一位非小写字母 \ 转义符。用于取消将特殊符号的含义取消 \{n\} 表示其前面的字符恰好出现N次例如：[0-9]\{4\} 匹配4位数字[1][3-8][0-9]\{9\} 匹配手机号码 \{n,\} 表示其前面的字符出现不小于n次。 例如 [0-9]\{2,\}表示两位及以上的数字 \{n,m\} 表示其前面的字符至少出现n次，最多出现m次。 例如[a-z]\{6,8\}匹配6到8位的小写字母 12345678910111213141516171819202122232425262728293031323334a* 匹配所有内容，包括空白行aa* 匹配至少包含有一个a的行aaa* 匹配最少包含两个连续a的字符串aaaaa* 匹配最少包含四个连续a的字符串区别于通配符里的*，通配符里的a*表示以a开头的字符串，这也说明了正则是一种包含匹配s..d 匹配s和d之间含有2个任意字符(除换行符)行，有多少个点就多少个字符s.*d 匹配s和d之间含有任意内容的行.* 匹配所有内容^s 匹配以s开头的行n$ 匹配以n结尾的行^$ 匹配空白行s[ao]id 匹配s和i字母中，要不是a，要不是o[0-9] 匹配任意任意一个数字^[a-z] 匹配用小写字母开头的行[a-zA-z] 匹配所有字母，shell中不支持[A-z]^[^a-z] 匹配非小写字母开头的行^[^a-zA-Z] 匹配非字母开头的行\.$ 匹配使用.结尾的行.$ 以任意字符结尾的行a\&#123;3\&#125; 匹配a字母连续出现三次的字符串[0-9]\&#123;3\&#125; 匹配包含连续的三个数字的字符串c\&#123;3\&#125;u 匹配u前面有三个c的字符串&quot;xc\&#123;3\&#125;u&quot; 匹配x和u之间三个c的字符串，x、u为定界符**实际使用中也会匹配多于n次的，如果需要准确匹配，则需要在前后使用分隔符**^[0-9]\&#123;3,\&#125;[a-z] 匹配最少用连续三个数字开头的行sa\&#123;1,3\&#125;i 匹配在字母s和字母i之间最少一个a，最多三个a 1234567正则表达式适合在文档中提取，不适合做写入的判断依据[0-9]\&#123;4\&#125;-[0-9]\&#123;2\&#125;-[0-9]\&#123;2\&#125;匹配日期^[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;匹配IP地址]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell正则表达式 通配符]]></title>
    <url>%2Fpost%2Fc3ae41ec.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } 1man glob 符号 作用 ? 匹配一个任意字符 * 匹配0个或多个任意字符 [] 匹配括号中任意一个字符 [-] 匹配括号中任意一个字符，-代表一个范围 [^] 匹配不是括号中的一个字符 [:space:] 空白字符 [:punct:] 标点符号 [:lower:] 小写字母 [:upper:] 大写字母 [:alpha:] 大小写字母 [:digit:] 数字 [:alnum:] 数字和大小写字母 注： a[a-z]b和a[A-Z]b不区分大小写，都可以匹配abc和aBc 专用字符集的[]和匹配括号中的任意一个字符不是一个同一个，专用字符集需要添加[] 1ls a[[:upper:]]b Bash中其他特殊符号 符号 作用 ‘’ 单引号，在单引号中左右的特殊符号，如$、`(反引号)都没有特殊含义 “” 双引号，在双引号中左右的特殊符号都没有特殊含义，但是“$”,”`”,”\”是例外。拥有“调用变量的值”，“引用命令”和“转义符”的特殊含义 `` 反引号，反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样。不过推荐使用$()，因为反引号非常容易看错 $() 和反引号作用一样，用来引用系统命令 # 在Shell脚本中，#开头的行代表注释 $ 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值 \ 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\\$将输出”$”符号，而不再是变量引用 12345678910echo `ls`echo dateecho `date`echo $(date)name=xiecho &apos;$name&apos;echo &quot;$name&quot;echo &apos;$(date)&apos;echo &quot;$(date)&quot; https://blog.csdn.net/tzs_1041218129/article/details/52896327]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 环境变量配置文件]]></title>
    <url>%2Fpost%2F8435a02b.html</url>
    <content type="text"><![CDATA[source命令123#修改配置文件后，必须注销重新登录才能生效，使用source命令可以不用重新登录source 配置文件. 配置文件 常用系统环境变量环境变量配置文件中主要是定义对系统操作环境生效的系统默认环境变量，如PATH等 -当前用户有效~/.bash_profile~/.bashrc-所有用户有效/etc/profile/etc/profile.d/*.sh/etc/bashrc 配置文件加载流程正常登录过程输入用户名和密码，正常登录/etc/profile–&gt;/etc/profile.d/*.sh–&gt;/etc/profile.d/lang.sh–&gt;/etc/sysconfig/i18n …/etc/profile–&gt;~/.bash_profile–&gt;~/.bashrc–&gt;/etc/bashrc–&gt;命令提示符 不正常简化登陆不输入用户名和密码，简化的加载过程，例如su - root/etc/bashrc–&gt;/etc/profile.d/*.sh–&gt;/etc/profile.d/lang.sh–&gt;/etc/sysconfig/i18n … /etc/profile的作用USER变量LOGNAME变量MAIL变量PATH变量HOSTNAME变量umask调用/etc/profile.d/*.sh文件 ~/.bash_profile的作用调用~/.bashrc文件在PATH变量后面加入了:$HOME/bin这个目录 .bashrc的作用定义命令别名调用/etc/bashrc文件 /etc/bashrc的作用PS1变量umaskPATH变量调用/etc/profile.d/*.sh文件 其他配置文件12~/.bash_logout#注销时生效的环境变量配置文件 12345~/.bash_history历史命令记录保存在硬盘的~/.bash_history文件中，当前登录后的命令保存在内存中，用户注销后才写入该文件历史记录保存多少条，在/etc/profile中记录用history 命令看，与 vi .bash_history 查看文件看的区别：history 记录的命令比后者的多，原因是，history 是记录在内存中，包含了本次登录后操作的命令；而后者还未将本次登录操作的命令保存在内 123456789101112131415161718192021/etc/issue#本地终端欢迎信息\d 显示当前系统日期\s 显示操作系统名称\l 显示登陆的终端号，这个比较常用\m 显示硬件系统结构，如i386，i686等\n 显示主机名\o 显示域名\r 显示内核版本\t 显示当前系统时间\u 显示当前登陆用户的序列号/etc/issue.net#远程登陆欢迎信息#转义符在该文件中不能使用#默认是不启用，是否显示此信息由/etc/ssh/sshd_config决定，加入&quot;Banner /etc/issue.net&quot;行才能生效/etc/motd#登陆之后欢迎信息#不管是本地登录，还是远程登录，都可以显示此信息issue是登陆之前生效的，motd是登陆之后生效的，建议写在motd中]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell运算符 变量测试]]></title>
    <url>%2Fpost%2F5e995419.html</url>
    <content type="text"><![CDATA[变量测试在脚本优化时使用 12345678910111213141516例子：测试x=$&#123;y-新值&#125;unset yx=$&#123;y-2&#125;echo $x2y=&quot;&quot;#将y的值设为空值x=$&#123;y-2&#125;echo $x#x为空y=1x=$&#123;y-2&#125;echo $x1]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell运算符 数值运算]]></title>
    <url>%2Fpost%2F4745a25f.html</url>
    <content type="text"><![CDATA[记住一名话就OK，$((运算式)) 数值运算方法一 declare -i12345aa=11bb=22declare -i cc=$aa+$bbecho $cc33 数值运算方法2：expr或let123456789101112aa=11bb=22dd=$(expr $aa + $bb)#+号两边必须有空格，没有空格依旧是字符串拼接echo $dd33aa=11bb=22let &quot;ee=aa+bb&quot;echo $ee33 数值运算方法3：$((运算式))或$[运算式]12345aa=11bb=22ff=$(($aa+$bb))echo $ff33 优先级]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell运算符 declare命令]]></title>
    <url>%2Fpost%2F2b659642.html</url>
    <content type="text"><![CDATA[declare命令12345678910111213141516declare [+/-][选项] 变量名 #declare命令用来声明shell的变量类型，因为shell变量默认都是字符串型选项：-：用于给变量设定类型属性+：用于取消变量的类型属性-a：将变量声明为数组型-i：将变量声明为整型-x：将变量声明为环境变量-r：将变量声明为只读变量-p：显示指定变量被声明的类型aa=11 bb=22declare -i cc=$aa+$bbdeclare -p c #查看变量cc的类型#声明变量cc的类型是整数型，它的值是aa和bb的和 声明数组变量12345678910#定义数组#数组的定义不需要declare命令也可以，直接使用movie[i]=valuemovie[0]=zpmovie[1]=tpdeclare -a movie[2]=live#查看数组echo $&#123;movie&#125; #输出数组下标为0的变量值echo $&#123;movie[2]&#125; echo $&#123;movie[*]&#125; #输出数组的全部值 声明环境变量12declare -x test=123#和export作用类似，export命令实际过程是调用declare命令 声明变量只读属性123declare -r test#给test赋予只读属性，赋予后不能修改该变量，不能删除，甚至不能取消只读属性#临时生效，重启无效 查询变量的属性12345declare -p#列出系统中所有变量的类型declare -p 变量名#查询指定变量的属性]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 Bash语系变量]]></title>
    <url>%2Fpost%2F35dd1cd2.html</url>
    <content type="text"><![CDATA[当前语系查询1234locale#查询当前系统语系#LANG:定义系统主语系的变量#LC_ALL:定义整体语系的变量 语系变量LANG1234echo $LANG#查看系统当前语系locale -a | more#查看Linux支持的所有语系 查询系统默认语系12cat /etc/sysconfig/i18n#下次开机以后的系统环境 设置当前语系1234LANG=zh_CN.UTF-8 #切换成中文LANG=en_US.UTF-8 Linux支持中文的前提条件是正确安装中文字体和中文语系 如果有图形界面，可以正确使用支持中文显示 如果使用第三方远程工具，只要语系设定正确，可以支持中文显示 如果使用纯字符界面，必须使用第三方插件（如zhcon等），即使设置LANG变量也没用]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 预定义变量和位置参数变量]]></title>
    <url>%2Fpost%2F6d83367e.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70% ; } 预定义变量 预定义变量 作用 $? 最后一次执行命令的返回状态。如果正确执行，则返回0；如果返回为非零（具体数值由命令决定），则上一条命令执行不正确 $$ 返回当前进程的PID $! 返回后台运行的最后一个进程的PID 1234567ls || echo yesls qwe &amp;&amp; echo no前面一条语句正确执行，才执行后一条语句。这里就是通过执行命令的返回值来判断的echo $?echo $$ #直接打印返回的是/bin/bash，需要时可以放到shell脚本里echo $! 可以通过一个简单的shell来展示一下12345#!/bin/bashehco &quot;dang qian de PID: $$&quot;find / hello.sh &amp;echo &quot;hou tai de PID: $!&quot; 位置参数变量位置参数变量本质上还是预定义变量 位置参数变量 作用 $n n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数需要用大括号包含，如 ${10} $* 这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体 $@ 这个变量也代表命令行中所有的参数，不过 $@ 把每个参数区分对待 $# 这个变量代表命令行中所有参数的个数 例子11234567#!/bin/bashnum1=$1num2=$2sum=$(($num1+$num2)) #变量 sum 的和是 num1 加 num2echo $sum #打印变量 sum 的值 12#执行脚本./test.sh 45 76 例子21234567#!/bin/bashecho &quot;A total of $# parameters&quot;#使用 $# 代表所有参数的个数echo &quot;The parameters is：$*&quot;#使用 $* 代表所有的参数echo &quot;The parameters is：$@&quot;#使用 $@ 代表所有的参数 12#执行脚本./test.sh 11 22 33 44 例子3123456789101112#!/bin/bashfor i in &quot;$*&quot;# $* 中所有参数看成是一个整体，所以这个 for 循环只会循环一次do echo &quot;The parameters is:$i&quot;donefor y in &quot;$@&quot;# $@ 中每个参数都看成是独立的，所以 $@ 中有几个参数，就会循环几次do echo &quot;Parameter:$y&quot;done 接收键盘输入123456read [选项] [变量名]选项：-p &quot;提示信息&quot;：在等待read输入时，输出提示信息-t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间-n 字符数：read命令只接受指定的字符数，就会执行-s：隐藏输入的数据，适用于机密信息的输入，比如密码 read.sh123456789101112131415#!/bin/bashread -p &quot;please input your name:&quot; -t 30 nameecho $name#如果超过30秒不输入，就终止当前命令read -p &quot;please input your passwd:&quot; -s passwdecho -e &quot;\n&quot;echo $passwd#输入的值是隐藏的，看不见的，但是在sh里面还是可以获取到的，并且可以输出的read -p &quot;please input your sex [M/F]:&quot; sexecho -e &quot;\n&quot;echo $sex#只能输入一个字符，且输入之后立马执行]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 环境变量]]></title>
    <url>%2Fpost%2F116321b2.html</url>
    <content type="text"><![CDATA[作用定义每个用户的操作环境 环境变量与用户自定义变量的区别环境变量是全局变量，用户自定义变量是局部变量。用户自定义变量只在当前的 shell 中生效，环境变量在当前 shell 和这个 shell 的所有子 shell 中生效。用户可以自定义环境变量，但对系统生效的环境变量名和变量作用是固定的。 用户自定义环境变量123456789export 变量名=变量值或变量名=变量值export 变量名export Y=1Z=1export Z 查看环境变量12345set #查看所有变量env #查看环境变量 删除环境变量12unset 环境名#没有$ 常用的环境变量HOSTNAME：主机名SHELL：当前的shellTERM：终端环境HISTSIZE：历史命令条数SSH_CLIENT：当前操作环境是用 ssh 连接的，这里记录客户端 ipSSH_TTY：ssh 连接的终端是 pts/1USER：当前登录的用户 PATH环境变量1234567#系统搜索命令的路径echo $PATH#查看PATH环境变量PATH=&quot;$PATH&quot;:/root/sh#临时增加PATH变量的值，系统重启后失效 PS1环境变量12345678910命令提示符设置[root@localhost ~]#\d：显示日期，格式为&quot;星期 月 日&quot;\H：显示完整的主机名\t：显示 24 小时制时间，格式为&quot;HH:MM:SS&quot;\A：显示 24 小时制时间，格式为&quot;HH:MM&quot;\u：显示当前用户名\w：显示当前所在目录的完整名称\W：显示当前所在目录的最后一个目录\$：提示符。root 用户为&quot;#&quot;，普通用户为&quot;$&quot;]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell变量 用户自定义变量]]></title>
    <url>%2Fpost%2F69a08f8e.html</url>
    <content type="text"><![CDATA[定义变量1234567变量名=变量值#=号左右不可有空格#变量值有空格需要加&quot;&quot;#所有变量默认的值都是字符串类型，不可做Math运算x=5x=&quot;hello jx&quot; 调用变量123$变量名echo $x 变量叠加1234567x=123 #123x=&quot;$x&quot;456 #123456x=$&#123;x&#125;789 #123456789x=5y=6z=$x+$y #5+6 变量查看1234567set选项：-u：如果设定此选项，调用未声明变量里会报错（默认调用未声明变量无任何提示，值为空的变量也无任何提示）echo $jflajlfset -uecho $jflajlf 删除变量1234unset 变量名#注意变量名没有$，因为要删除的是变量，而不是变量的值unset x]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 变量]]></title>
    <url>%2Fpost%2Fbd7a1729.html</url>
    <content type="text"><![CDATA[Shell是一种脚本语言 变量命名规则 变量名必须以字母或下划线打头，名字中间只能由字母、数字和下划线组成 变量名的长度不超过255个字符 变量名在有效的范围内必须是唯一的，如再次定义则会替换上一个变量的值 在Bash中，变量的默认类型都是字符串型，系统把所有值都当作字符串放到变量中，不论这个“字符串”实际上是整数、浮点数等等，shell也不区分字符串型，整型，浮点型，日期型 目录名、文件名、变量名要有含义 变量的分类 用户自定义变量：变量自定义的 环境变量：这种变量中主要保存的是和系统操作环境相关的数据，变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的 位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。实际就是预定义变量的一种，只是功能单一固定，所以单独拿出来 预定义变量：Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 管道符]]></title>
    <url>%2Fpost%2F5f7a3c21.html</url>
    <content type="text"><![CDATA[多命令顺序执行 多命令执行符 格式 作用 ; 命令1;命令2 多个命令顺序执行，命令之间没有任何逻辑联系 &amp;&amp; 命令1&amp;&amp;命令2 逻辑与当命令1正确执行，则命令2才会执行当命令1执行不正确，则命令2不会执行 ` ` 命令1` `命令2 逻辑或当命令1执行不正确，则命令2才会执行当命令1正确执行，则命令2不会执行 123456date ; tar -zcvf etc.tar.gz /etc ; date #可以计算备份所用的时间ls &amp;&amp; echo yes || echo no #当ls正确执行时打印yes；当ls错误执行时打印no#顺序不能颠倒，不然命令出错的时候会同时输出no yes 管道符最后一个命令会在当前shell进程的子shell进程中执行1234567891011121314命令1 | 命令2 #命令1的正确输出作为命令2的操作对象netstat -an | grep ESTABLISHED | wc -l #查找当前有多少用户正在连接服务器ll -a /etc/ | moremore [文件名] #分页显示文件内容&quot;echo &quot;$PATH&quot; | tr &apos;a-z&apos; &apos;A-Z&apos;#转换为大写cat /etc/rc.d/rc.sysinit | tr &apos;a-z&apos; &apos;A-Z&apos; | more tee命令tee命令从标准输入读入数据，并且同时复制数据到标准输出和一个或多个文件12ls /usr/bin |tee ls.txt | grep.zip#屏幕打印同时重定向到文件]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 重定向]]></title>
    <url>%2Fpost%2Ff80df29c.html</url>
    <content type="text"><![CDATA[文件标识符 设备 设备文件名 文件标识符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/stdout 1 标准输出 显示器 /dev/stderr 2 标准错误输出 3-9是保留的标识符输出经常由两种类型组成，一，程序运行结果；二，状态和错误信息 输出重定向&gt;重定向符&gt;&gt;追加重定向，如果文件不存在，文件会被创建一旦使用数字、&amp;，数字、&amp;和&gt;、&gt;&gt;之间不能有空格没有数字、%有无空格没有关系，但是为了方便还是有比较好 类型符号作用标准输出重定向命令 &gt; 文件以覆盖的方式，把命令的正确输出输出到指定文件或设备中命令 &gt;&gt; 文件以追加的方式把命令的正确输出输出到指定文件或设备中标准错误输出重定向错误命令 2&gt;文件以覆盖的方式把命令的错误输出输出到指定文件或设备中错误命令 2&gt;&gt;文件以追加的方式把命令的错误输出输出到指定文件或设备中正确输出和错误输出同时保存命令 &gt;文件 2&gt;&amp;1以覆盖方式把命令的正确输出、输出到指定文件或设备中命令 &gt;&gt;文件 2&gt;&amp;1以追加方式把命令的正确输出、输出到指定文件或设备中命令 &amp;&gt;文件以覆盖方式把命令的正确输出、输出到指定文件或设备中命令 &amp;&gt;&gt;文件以追加方式把命令的正确输出、输出到指定文件或设备中命令 &gt;&gt;文件1 2&gt;&gt;文件2把正确的输出追加到文件1中，把错误的输出追加到文件2中只执行，不显示命令 &amp;&gt; /dev/null(a bit bucket) 将命令的结果丢入null（作用类似于垃圾箱）中，只执行，不显示 123456789ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1#传统方式，这种方式使用了两个重定向，一个是重定向标准输出到文件ls-output.txt，一个是重定向标准错误（2）到标准输出（1）#顺序不能变，标准错误的重定向必须总是出现在标准输出重定向之后ls -l /bin/usr &gt; ls-putput.txt 2&gt; ls-outputerror.txt#分别输出ls -l /bin/usr &amp;&gt; ls-output.txt#bash提供的第二种方式 123#技巧&gt; a.txt#删除文件内容或创建一个新的空文件 输入重定向命令 &lt; 文件名 #把文件的内容作为输入 命令 &lt;&lt; 标识符 #统计标识符到标识符再次出现之间的字符 cat &lt;&lt;EOF #展示键盘输入 cat &gt; /path/to/somefile &lt;&lt;EOF #将键盘输入放到文件，输入以EOF界定 参考： https://www.ibm.com/developerworks/cn/linux/l-iotips/index.html]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 历史命令]]></title>
    <url>%2Fpost%2Fb3bfabf4.html</url>
    <content type="text"><![CDATA[历史命令指的是把操作过的命令保留在系统当中, 当需要的时候可以重新进行调用 history123456789101112history [选项] [历史命令保存文件]选项：-a: 追加本次会话新执行的命令历史列表至历史文件中-d offset：删除历史中指定命令-c：清空历史命令-w：把缓存中的历史命令强制写入历史命令保存文件 ~/.bash_historynumber 显示历史中最近的number条命令不建议清空当本次操作出现错误可用过历史命令进行比对排错当登录后发现历史命令被清空, 则可判断出有人登录过该账户或服务器即使命令保存数目众多, 文件大小也不大, 不会给服务器造成多大压力 历史命令的配置历史命令默认保存1000条, 可以在环境变量配置文件/etc/profile中进行修改HISTSIZE=1000使用history命令查看的, 不止有之前保存下来的, 还有本次登录后新操作的命令, 这些命令只有本次正确退出之后才会写入 ~/.bash_history 历史命令相关环境变量 HISTSIZE：命令历史记录的条数 HISTFILE：命令历史文件，./bash_history HISTFILESIZE：命令历史文件记录历史的条数 HISTCONTROL：控制历史命令的记录方式 ignoredups：忽略连续且相同的命令， ignorespace：忽略所有以空白开关的命令 ignoreboth：ignoredups+ignorespace 历史命令的调用 使用上、下箭头调用以前的历史命令 使用 !n 重复执行一次第 n 条历史命令 使用 !! 重复执行一次上一条命令 使用 !字串重复执行最后一条以该字串开头的命令 调用上一条命令的最后一个参数：!$,ESC接.,Alt-. 命令与文本补全在Bash中, 命令与文件补全是非常方便与常用的功能, 我们只要在输入命令或文件时, 按”Tab”键就会自动进行补全系统进行命令补全依赖$PATH hash命令：shell搜寻到的外部命令的路径结果会缓存至kv(key-value)存储中；在环境变量PATH中搜索命令name的完整路径并记住它，这样以后再次执行相同的命令时，就不必搜索其完整路径了 12hash -d：清除指定缓存hash -r：清除所有缓存 https://blog.csdn.net/iEearth/article/details/52599900]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell Bash别名和快捷键]]></title>
    <url>%2Fpost%2Fc84d750c.html</url>
    <content type="text"><![CDATA[别名1234567891011121314151617181920212223#增加新的别名前要查看是否被占用type 别名alias#查看系统当中默认已经生效的别名alias ls=&apos;ls --color=auto&apos;#临时设定别名#不能有空格vi ~/.bashrcvi /root/.bashrcvi /etc/.bashrc#写入环境变量配置文件，系统再次重启后永久生效source .bashrc#使当前环境变量设置立即生效，不需要系统重启unalias ls#删除别名\cp#不执行别名，执行命令本身 命令生效顺序 第一顺位执行绝对路径或者相对路径的命令 第二顺位执行别名 第三顺位执行Bash的内部命令 第四顺位执行按照$PATH环境变量设置定义的目录顺序的第一个命令 快捷键ctrl + c 强制终止ctrl + l 清屏相当于clearctrl + a 光标快速回到行首ctrl + e 光标快速去到行尾ctrl + u 从光标所在位置删除到行首ctrl + k 从光标所在位置删除到行尾ctrl + z 把命令放入后台–，暂停ctrl + r 历史命令搜索]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本执行方式]]></title>
    <url>%2Fpost%2Fff97f2a0.html</url>
    <content type="text"><![CDATA[方法1：赋予执行权限，直接运行12chmod 755 hello.sh./hello.sh（或者绝对路径执行 /root/hello.sh） 方法2：通过Bash调用执行脚本12bash hello.sh#不需要执行权限，脚本作为bash的参数 在shell脚本中#!/bin/Bash不是注释，它标称下面的内容是linux的标准脚本程序如果该脚本使用纯shell语句完成，不加#!/bin/Bash运行是没问题的，但如果脚本调用了其他语言，就会报错]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell概述]]></title>
    <url>%2Fpost%2Fe2aa7539.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } Shell是一个命令行解释器（程序 -&gt; 依赖ASCII码表翻译为二进制 -&gt; Linux内核（发送请求）-&gt; 运行程序），它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至时编写一些程序。 Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令 Shell分类 Bourne Shell：主文件名为sh，从1979年起Unix就开始使用Bourne Shell C Shell:主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名 Shell的两种主要语法类型有Bourne和C，彼此不兼容。Bourne家族主要包括sh,ksh,Bash(Linux使用的标准Shell，不区分发行版),psh,zsh;C家族（Unix使用）主要包括：csh,tcsh（和Bash语法，配置微小区别） Linux，Unix的主要区别： Shell的不同 12345678910echo $SHELL #查看Shellcat /etc/shells#查看Linux支持的shellsh#进入sh模式exit#关闭模式 Bash：Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本ShellBourne Again Shell (bash) 是兼容Bourne Shell的一种相当于升级版本，注意命令bash中的ｂ是小写字母]]></content>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局域网安装ftp]]></title>
    <url>%2Fpost%2F399a1803.html</url>
    <content type="text"><![CDATA[写这篇文章的主要目的是方便局域网内的ftp配置 基本上实现这三点足够了： 不允许匿名访问，因为我不想其他机器随便都能登陆上来； 锁定一个共享目录，在这个目录下我可以上传和下载文件，进行文件共享； 不单独建立ftp用户，本机就可以访问； 123456789101112131415161718192021222324252627sudo apt-get install vsftpd #ubuntu的配置文件位置sudo vim /etc/vsftpd.confanonymous_enable=NO #禁止匿名登陆local_root=/home/user/ftp #设定一个共享目录local_enable=YES #本机可以访问write_enable=YES #可以写chroot_list_enable=YES chroot_list_file=/etc/vsftpd.chroot_list#不单独建立ftp用户#在其中写入可以使用ftp的用户名sudo vim /etc/vsftpd.chroot_list#去掉用户写权限#因为使用chroot_list_enable和chroot_list_file配置禁止用户拥有写权限chmod u-w,g-w ftp#为了能在共享目录复制粘贴，在ftp下创建一个user可写的目录，复制粘贴全在该目录下进行cd /home/user/ftpsudo mkdir FTPFILESsudo chown -R user:user FTPFILES#重启sudo service vsftpd restart 然后就可以使用各种客户端登陆了 参考： http://www.cnblogs.com/bcsflilong/p/4200139.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件传输-SFTP/SCP/FTP/lrzsz命令]]></title>
    <url>%2Fpost%2Fb2596d13.html</url>
    <content type="text"><![CDATA[FTP连接ftp服务器1ftp [hostname| [ip-address] 列出文件列表以及切换目录12lscd 下载文件下载文件通常用get和mget这两条命令。 123456789101112#get [remote-file] [local-file]#获取远程服务器上/usr/your/1.htmftp&gt; get /usr/your/1.htm 1.htmmget [remote-files]#从远端主机接收一批文件至本地主机#获取服务器上/usr/your/下的所有文件cd /usr/your/mget *.*#显示下载进度ftp&gt; hash 上传文件注意上传命令需要指定目标文件名12345678910put local-file [remote-file]#将本地一个文件传送至远端主机中。#把本地的1.htm传送到远端主机/usr/your,并改名为2.htmftp&gt; put 1.htm /usr/your/2.htmmput local-files#将本地主机中一批文件传送至远端主机。#把本地当前目录下所有html文件上传到服务器/usr/your/ 下ftp&gt; cd /usr/yourftp&gt; mput *.htm 断开连接12bye：中断与服务器的连接ftp&gt; bye 改变传输模式ftp的传输模式有ascii模式和二进制模式直接输入ascii则设置传输模式为ascii模式直接输入binary则设置传输模式为binary模式 12ftp&gt; asciiftp&gt; binary SFTPSFTP是安全文件传送协议，可以为传输文件提供一种安全的网络的加密方法。 SFTP 与 FTP 有着几乎一样的语法和功能。SFTP 为 SSH的其中一部分，所以说 SFTP 就是通过SSH端口（默认 22端口）和 Linux 用户和密码登陆的（例如 root 账号）。SFTP 使用加密传输认证信息和传输的数据，所以使用SFTP是非常安全的。但是由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多。 使用SFTP并不需要在服务器上做任何配置，只需要找个SFTP客户端，然后知道SSH端口、服务器用户名+密码即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243# 连接到SFTPsftp tecmint@27.48.137.6# 获得帮助?help# 检查本地工作目录lpwd# 检查远程工作目录pwd# 列出本地文件lls# 列出远程文件ls# 上传单个或多个文件put local.profile# 上传多个文件mput * .xls# 下载单个或多个文件get SettlementReport_1-10th.xls# 下载多个文件mget * .xls# 切换本地目录lcd Documents# 切换远程目录cd test# 创建目录mkdir testlmkdir test# 删除目录，该目录必须为空rm Report.xlsrmdir sub1# 退出SFTP!exit SCP使用SSH协议来传输文件的 SCP比较简单，是轻量级的，SFTP的功能则比较多 SCP的速度较快 SFTP在文件传输过程中中断的话，连接后还可以继续传输，但SCP不行 123456scp [-r] 用户名@ip:文件路径 本地路径# 网络复制命令, 下载文件 或加-r下载文件夹scp [-r] 本地文件 用户名@ip:上传路径# 网络复制命令, 上传文件 或加-r上传文件夹# 此为linux 与 linux之间进行文件传输的最简单方式 lrzszsz/rz 并不是Linux标准命令工具，有些Linux发行版本如Ubuntu会自带，有些可能没有，需要自己安装 安装lrzsz1yum -y install lrzsz 12#上传文件，执行命令rz，会跳出文件选择窗口，选择好文件，点击确认即可。rz 12#下载文件，执行命令szsz 参考： https://www.tecmint.com/sftp-command-examples/ https://www.jscape.com/blog/scp-vs-sftp]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP主动模式和被动模式]]></title>
    <url>%2Fpost%2Fed8800d8.html</url>
    <content type="text"><![CDATA[FTP只通过TCP连接，没有用于FTP的UDP组件。FTP不同于其他服务的是它使用了两个端口， 一个数据端口和一个命令端口(或称为控制端口)。通常21端口是命令端口，20端口是数据端口。根据FTP工作方式的不同，数据端口并不总是20，这就是主动与被动FTP的最大不同之处。（不管主动模式还是被动模式都是用TCP 21端口来传输控制信号的。） 主动FTP(PORT/Active)客户端从一个任意的非特权端口N（N&gt;1023）连接到FTP服务器的命令端口，也就是21端口。然后客户端开始监听端口N+1，并发送FTP命令“port N+1”到FTP服务器。接着服务器会从它自己的数据端口（20）连接到客户端指定的数据端口（N+1）。 针对FTP服务器前面的防火墙来说，必须允许以下通讯才能支持主动方式FTP： 任何大于1024的端口到FTP服务器的21端口。（客户端初始化的连接） FTP服务器的21端口到大于1023的端口。 （服务器响应客户端的控制端口） FTP服务器的20端口到大于1023的端口。（服务器端初始化数据连接到客户端的数据端口） 大于1023端口到FTP服务器的20端口（客户端发送ACK响应到服务器的数据端口） 被动FTP(PASV/Passive)为了解决服务器发起到客户的连接的问题，人们开发了一种不同的FTP连接方式。这就是所谓的被动方式，当客户端通知服务器它处于被动模式时才启用。 在被动方式FTP中，命令连接和数据连接都由客户端发起，这样就可以解决从服务器到客户端的数据端口的入方向连接被防火墙过滤掉的问题。 当开启一个 FTP连接时，客户端打开两个任意的非特权本地端口（N &gt; 1024和N+1）。第一个端口连接服务器的21端口，但与主动方式的FTP不同，客户端不会提交PORT命令并允许服务器来回连它的数据端口，而是提交 PASV命令。这样做的结果是服务器会开启一个任意的非特权端口（P &gt; 1024），并发送PORT P命令给客户端。然后客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。 对于服务器端的防火墙来说，必须允许下面的通讯才能支持被动方式的FTP: 从任何大于1023的端口到服务器的21端口 （客户端初始化的连接） 服务器的21端口到任何大于1023的端口 （服务器响应到客户端的控制端口的连接） 从任何大于1023端口到服务器的大于1023端口 （客户端初始化数据连接到服务器指定的任意端口） 服务器的大于1023端口到远程的大于1023的端口（服务器发送ACK响应和数据到客户端的数据端口） 主动与被动FTP优缺点：主动FTP对FTP服务器的管理有利，但对客户端的管理不利。因为FTP服务器企图与客户端的高位随机端口建立连接，而这个端口很有可能被客户端的防火墙阻塞掉。被动FTP对FTP客户端的管理有利，但对服务器端的管理不利。因为客户端要与服务器端建立两个连接，其中一个连到一个高位随机端口，而这个端口很有可能被服务器端的防火墙阻塞掉。 幸运的是，有折衷的办法。既然FTP服务器的管理员需要他们的服务器有最多的客户连接，那么必须得支持被动FTP。我们可以通过为FTP服务器指定一个有限的端口范围来减小服务器高位端口的暴露。这样，不在这个范围的任何端口会被服务器的防火墙阻塞。虽然这没有消除所有针对服务器的危险，但它大大减少了危险。 总结主动FTP： 命令连接：客户端 &gt;1023端口 -&gt; 服务器 21端口 数据连接：客户端 &gt;1023端口 &lt;- 服务器 20端口 被动FTP： 命令连接：客户端 &gt;1023端口 -&gt; 服务器 21端口 数据连接：客户端 &gt;1023端口 -&gt; 服务器 &gt;1023端口 主动模式是从服务器端向客户端发起连接；被动模式是客户端向服务器端发起连接。两者的共同点是都使用 21端口进行用户验证及管理，差别在于传送数据的方式不同，PORT模式的FTP服务器数据端口固定在20，而PASV模式则在1024-65535之间随机 PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用PORT命令告诉服务器：“我打开了XXXX端口，你过来连接我”。于是服务器从20端口向客户端的XXXX端口发送连接请求，建立一条数据链路来传送数据。 PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用PASV命令告诉客户端：“我打开了XXXX端口，你过来连接我”。于是客户端向服务器的XXXX端口发送连接请求，建立一条数据链路来传送数据。 当NAT(Network Address Translation)设备以主动模式访问FTP服务器时，由于NAT设备不会聪明的变更FTP包中的IP地址，从而导致无法访问服务器。 大部分互联网应用都是被动模式，因为大部分客户端都是在路由器后面，没有独立的公网IP地址，服务器想要主动连接客户端，难度太大，在现在真实的互联网环境里面几乎是不可能完成的任务。 大部分FTP客户端默认使用PASV方式，在大部分FTP客户端的设置里，常见到的字眼都是“PASV”或“被动模式”。 vsftpd配置1234# vi /etc/vsftpd/vsftpd.confpasv_enable=YESpasv_min_port=3000pasv_max_port=4000 参考： https://www.centos.bz/2012/08/ftp-port-pasv-mode/ http://www.serv-u.com/kb/1138/Active-and-Passive-FTP-Transfers-Defined http://blog.sina.com.cn/s/blog_5cdb72780100jwm9.html http://www.rfyy.net/archives/2641.html https://my.oschina.net/binny/blog/17469 https://zhuanlan.zhihu.com/p/36403412 http://www.cnblogs.com/xiaohh/p/4789813.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看用户登录时间及历史命令]]></title>
    <url>%2Fpost%2F2edd2f82.html</url>
    <content type="text"><![CDATA[12who#查看当前登录用户信息：用户名、终端类型、登陆日期以及远程主机 12users#当前登录的用户 123history#查看命令历史$HOME/.bash_history：每个用户都有一份命令历史记录 12345678910111213141516last#查看用户登录历史#此命令会读取 /var/log/wtmp 文件，/var/log/btmp可以显示远程登陆信息。 #last默认打印所有用户的登陆信息last 用户名#打印某个用户的登陆信息选项： -x：显示系统开关机以及执行等级信息 -a：将登陆ip显示在最后一行 -f ：读取特定文件，可以选择 -f /var/log/btmp文件 -d：将IP地址转换为主机名 -n：设置列出名单的显示列数 -t：查看指定时间的用户登录历史 例如： last -t 20150226160404 显示这个时间戳之前的登陆历史 123456789101112131415lastlog#查看所有用户最近一次登录历史#命令将读取 /var/log/lastlog 文件，用户排列顺序按照 /etc/passwd 中的顺序选项： -u：查看某个用户的最后一次登陆历史 例如： lastlog -u test 查看用户test的登陆历史 -t：查看最近几天之内的用户登录历史 例如： lastlog -t 1 查看最近1天之内的登陆历史-b：查看指定天数之前的用户登录历史 例如： lastlog -b 60 查看60天之前的用户登录历史 12345ac根据/var/log/wtmp文件中的登陆和退出时间报告用户连接的时间（小时），默认输出报告总时间 -p：显示每个用户的连接时间 -d：显示每天的连接时间 -y：显示年份，和-d配合使用]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下ls命令只显示目录或文件]]></title>
    <url>%2Fpost%2Fc28a470e.html</url>
    <content type="text"><![CDATA[本质上来说就是根据有没有以/结尾 只显示目录12345ls -F | grep /$ # -F使得ls将文件分类，通过在文件后面加一些标记来实现ls -F | grep /ls -l | grep ^dls -d */ls -ld */ 只显示文件1234567ls -F | grep [^\/]$ # 注意行尾匹配符号$不可少ls -F | grep [^/]$ls -l | grep ^-ls -l | grep ^- | wc -l # wc命令统计行数find . -type f -maxdepth 1 | xargs ls -alls -p | grep [^/]$ # -p使得ls命令在目录后面加斜杠find . ! -name . -prune -type f # 这个命令不会很好排序文件 参考： http://blog.163.com/ytyang__/blog/static/8405845201112502159277/]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux禁止ping以及开启ping的方法]]></title>
    <url>%2Fpost%2Fa436331.html</url>
    <content type="text"><![CDATA[Linux默认是允许Ping响应的，系统是否允许Ping由2个因素决定的：A、内核参数，B、防火墙，需要2个因素同时允许才能允许Ping，2个因素有任意一个禁Ping就无法Ping。 具体的配置方法如下： 内核参数设置允许ping设置12345678#临时允许PING操作的命令echo 0 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all#永久允许ping配置方法#/etc/sysctl.conf设置net.ipv4.icmp_echo_ignore_all=0#使新配置生效sysctl -p 禁止Ping设置12345678#临时禁止PING的命令echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all #永久禁止ping配置方法#/etc/sysctl.conf设置net.ipv4.icmp_echo_ignore_all=1#使新配置生效sysctl -p 防火墙设置注：此处的方法的前提是内核配置是默认值，也就是没有禁止Ping 这里以Iptables防火墙为例，其他防火墙操作方法可参考防火墙的官方文档。 允许ping设置1234iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT#或者也可以临时停止防火墙操作的service iptables stop 禁止ping设置1iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP 参考： https://www.cnblogs.com/chenshoubiao/p/4781016.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 系统资源查看]]></title>
    <url>%2Fpost%2F95daab36.html</url>
    <content type="text"><![CDATA[监控系统资源（memory swap system io cpu等）123456789101112131415161718192021222324252627282930313233vmstat [刷新延时 刷新次数]例：vmstat 1 3procs：进程信息字段-r：等待运行的进程数，数量越大，系统越繁忙-b：不可被唤醒和进程数量，数量越大，系统越繁忙memory：内存信息字段-swpd：虚拟内存的使用情况，单位KB-free：空闲的内存容量，单位KB-buff：缓冲的内存容量，单位KB-cache：缓存的内存容量，单位KBswap：交换分区的信息字段-si：从磁盘中交换到内存中数据的数量，单位KB-so：从内存中交换到磁盘中数据的数量，单位KB这两个数越大，证明需要经常在磁盘和内存之间交换，系统性能越差io：磁盘读写信息字段-bi：从块设备读入数据的总量，单位是块-bo：写到块设备的数据和总量，单位是块。这两个数越大，代表系统的I/O越繁忙 system：系统信息字段-in：每秒被中断的进程次数-cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙 CPU：CPU信息字段-us：非内核进程消耗CPU运算时间的百分比-sy：内核进程消耗CPU运算时间的百分比-id：空闲CPU的百分比-wa：等待I/O所消耗的CPU百分比-st：被虚拟机所盗用的CPU百分比 内存12345free [-b-k-m-g]-b：以字节为单位显示-k：以KBl为单位显示，默认就是以KB为单位显示-m：以MB为单位显示-g：以GB为单位显示（不满1g时显示精度丢失） 第一行：total是总内存数，used是已经使用的内存数，free是空闲的内存数，shared是多个进程共享的内存总数，buff是缓冲内存数，cache是缓存内存数。默认单位是KB 第二行：-/buffers/cache的内存数，相当于第一行的used-buffers-cached。+/buffers/cache的内存数，相当于第一行的free+buffers+cached 第二三行：total是swap的总数；used是已经使用的swap总数，free是空闲的swap数。默认单位是KB cpu1cat/proc/cpuinfo 硬盘1df -h 参考磁盘管理 平均负载12345678uptime#显示系统的系统时间，平均负载，当前登录用户数，即top命令的第一行（top命令耗费资源）top#侧重进程w#w命令侧重用户信息的显示 内核1234567891011121314uname [选项]#查看系统与内核相关信息选项：-a :查看系统所有相关信息-r :查看内核版本-s :查看内核名称cat /proc/version#查看系统与内核相关信息dmesg#开机时内核检测信息dmesg | grep cpu 判断当前系统的位数123file /bin/ls#通过查看命令的位数#64位cpu仍可以安装32位系统，不能通过cpu位数来判断 发行版信息12345678910#centos 7 可用#实际上，打开/etc目录可以看到redhat-release和system-release全都软链接到了centos-releaserpm -q centos-releasecat /etc/centos-releasecat /etc/redhat-releasecat /etc/system-release#centos 7.4不可用lsb_release -acat /etc/issue]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux进程管理03 修改进程优先级]]></title>
    <url>%2Fpost%2Fb32223bf.html</url>
    <content type="text"><![CDATA[Linux操作系统是一个多用户、多任务的操作系统，Linux系统中运行着非常多的进程，但是CPU在同一时钟周期内只能运算一个指令。进程优先级决定了每个进程处理的先后顺序 查看优先级1234ps -el #PRI(priority): 是系统的优先级#NI (nice)： 用户可以自定义的优先级#实际执行的优先级是PRI+NI，数字越小该进程优先级越高 给新执行的命令赋予NI值12345nice [选项] 命令#nice命令可以给新执行的命令直接赋予NI值，但是不能修改已经存在进程的NI值选项：-n NI值：给命令赋予NI值。例如：nice -n -5 service httpd start 修改NI值时有几个注意事项 NI值的范围是-20到19 普通用户调整NI值的范围是0到19,而且只能调整自己的进程 普通用户只能调高NI值，而不能降低，如原本NI值为0，则只能调整为大于0 root用户才能设定进程NI值为负值，而且可以调整任何用户的进程 PRI（最终值）=PRI（原始值）+NI 用户只能修改NI的值，不能直接修改PRI 修改已经存在进程的NI值1234renice [优先级] PID#renice命令是修改已经存在进程的NI值的命令renice -10 2125]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux进程管理02 杀死进程]]></title>
    <url>%2Fpost%2F6f02f8b5.html</url>
    <content type="text"><![CDATA[kill命令 杀死一个进程1234kill -l#查看可用的进程信号kill [信号] PID table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 20%; } table th:nth-of-type(3){ width: 60%; } 其中有两个常用信号 信号代号 信号名称 说明 1 SIGHUP 关闭读取配置文件后重启 9 SIGKILL 强制停止 12345678kill -HUP(或-1) 进程号#平滑重启服务#正常修改完配置文件后，需要重启服务#用普通的restart来重启会提出正在使用的用户，造成不好的用户体验。#平滑重启是重启服务配置，保留正在使用的用户。 kill -9 2236#强制杀死进程 killall命令 批量杀死同一类型的进程123456killall [选项] [信号] 进程名 #按照进程名杀死进程，可以批量杀死同一类型的进程选项：-i：交互式，询问是否要杀死某个进程-I：忽略进程名的大小写 pkill命令 批量杀死同一类型的进程12345pkill [选项] [信号] 进程名 #按照进程名终止进程，可以批量杀死同一类型的进程选项：-t 终端号：按照终端号踢出用户 案例：踢出登录用户123456w #查看当前登陆用户的用户 TTY列为终端号按照终端号杀死进程pkill -9 -t tty1#只有超级用户才能踢除用户]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux进程管理01 查看进程]]></title>
    <url>%2Fpost%2F14044ec9.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70%; } 进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源 进程管理的作用 判断服务器健康状态 查看系统中所有的进程 杀死进程 ps命令 查看所有进程12345678910111213ps aux #查看系统中所有进程，使用BSD操作系统格式（没有-）ps -le#查看系统中所有进程，使用Linux标准命令格式ps -ef |grep ssh#aux和-ef没有多大区别，只是一风格不同，二如果COMMAND过长，aux会截断显示，而-ef不会选项-a :显示一个终端的所有进程-u :显示进程的归属用户及内存的使用情况-x :显示没有控制终端的进程-l :长格式显示，显示更加详细的信息-e :显示所有进程，和-A作用一致 输出详解 显示 含义 USER 该进程是由哪个用户产生的 %CPU 该进程占用CPU资源的百分比，占用越高，进程越耗费资源 %MEM 该进程占用物理内存的百分比，占用越高，进程越耗费资源 VSZ 该进程占用虚拟内存的大小 ，单位KB RSS 该进程占用实际物理内存的大小，单位KB TTY 表示该进程是在哪个终端运行的tty1-tty6是本地字符界面终端，tty7是本地图形终端 pts/0-255代表虚拟终端 STAT 进程的状态 R :运行 S :睡眠 T :停止s :包含子进程 + :位于后台 START 该进程的启动时间 TIME 该进程占用CPU的运算时间，注意不是系统时间 COMMAND 产生些进程的命令名 /sbin/init的pid永远是1，它是系统下所有进程的父进程，所有的进程都依赖于它 TTY是？，代表该进程是由系统内核启动的，一般认为是系统进程 pstree命令 查看进程树123pstree [选项]-p :显示进程的PID-u :显示进程的所属用户 top命令 查看系统健康状态1234567891011121314151617top [选项]选项：-d秒数：指定top命令每隔几秒更新。默认是3秒-b：使用批处理模式输出。 一般和 ”-n&quot;选项合用-n 次数：指定top 命令执行的次数。 一般和 “-b”选项合用在 top 命令的交互模式当中可以执行的命令：h：显示交互模式的帮助P：以CPU使用率排序，默认就是此项M：以内存的使用率排序N：以PID排序q：退出 toptop -b -n 1 &gt; /root/top.log #查看所有进程，因为直接使用top屏幕有限无法全部展示，所以放到文件中#将执行的top命令结果输出到log日志文件中#top命令耗费资源比较大，应及时关闭 输出详解 第一行为任务队列信息 12:26:46 系统当前时间 up 1 day,13:32 系统已运行的时长 2 users 当前登录的用户数量 load average 系统在之前1分钟，5分钟，15分钟的平均负载（与CPU核数相关，一般认为单核小于1时，负载较小，如果大于1,系统已经超出负荷，那么双核不超2，4核不超4） 第二行为进程信息 tasks:95 total 系统中的进程总数 1 running 正在运行的进程数 94 sleeping 睡眠的进程数 0,stopped 停止的进程数 1 zombie 僵尸进程（应该停止却没有停止的进程），如果不是0,需要手工检查僵尸进程 第三行为CPU信息 Cpu(s):0.1%us 用户模式占用的CPU百分比 0.1%sy 系统模式占用的CPU百分比 0.0%ni 改变过优先级的用户进程占用的CPU百分比 99.7%id 空闲CPU的CPU百分比 0.1%wa 等待输入/输出的进程的占用CPU百分比 0.0%hi 硬中断请求服务占用的CPU百分比 0.1%si 软中断请求服务占用的CPU百分比 0.0%st st(Steal time)虚拟时间百分比，就是当有虚拟CPU时，虚拟CPU占实际CPU的时间百分比 第四行为物理内存信息 Mem： 623434k total 物理内存的总量，单位kb 521313k free 空闲的物理内存 578322k used 已经使用的物理内存 623231 buff/cache 作为缓冲/缓存的内存数量 第五行是交换分区的信息 Swap: 8298492 total 交换分区的总量，单位kb 8292336 free 空闲的交换分区 6156 used 已经使用的交换分区 3129824 avail Mem 可用的交换分区 第六行类似ps PR 优先级 NI 任务nice值 VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES 物理内存用量 SHR 共享内存用量 TIME+ 累计cpu占用时间 cpu读写速度&gt;内存&gt;硬盘缓存cache是加速读取 减少对硬盘的读取缓冲buff是加速写入 减少对硬盘的写入 判断系统健康状况主要查看的参数： load average: 0.00, 0.00, 0.00 #表示系统在之前1分钟，5分钟，15分钟的平均负载。. Cpu（s）:…99.8%id #CPU空闲百分比 Mem：…6780k free #内存空闲率 Swap：…536723k free #swap空闲率 列出进程打开或使用的文件信息1234567891011121314151617181920lsof [选项]选项：-c 字符串 ：只列出以字符串开头的进程打开文件-u 用户名 ：只列出某个用户的进程打开的文件-p pid : 列出某个pid进程打开的文件示例：lsof | more#查询所有进程-分屏显示lsof /sbin/init#查询/sbin/init文件被哪个文件调用（只能查系统文件，其他自己建立的文件查没有意义）lsof -c httpd #查看httpd进程调用了哪个文件lsof -u root#按照用户名，查询某用户的进程所调用的文件名（数量可能很多） 参考： https://blog.csdn.net/qq_31666147/article/details/51557300]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux定时任务]]></title>
    <url>%2Fpost%2Fb3dc8f98.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 70% ; } at 一次性定时任务12345chkconfig --list |grep atd#确定at安装service atd restart#启动at服务 访问控制 如果系统中有/etc/at.allow文件(白名单)，那么只有在此文件的用户可以使用at命令（/etc/at.deny文件会被忽略）； 如果系统中没有/etc/at.allow文件，只有/etc/at.deny文件(黑名单)，那么在此名单下的用户不能使用at命令【对root不起作用】 如果系统这两个文件都不存在，那么只有root用户可以使用at命令 1234567891011121314151617181920at [选项] 时间选项：-m :执行工作后通知执行at命令的用户-c :显示该at工作的实际内容时间：HH:MMHH:MM YYYY-MM-DDHH:MM[am|pm] [month][date]HH:MM +[minutes|hours|days|weeks]at now + 5 minutes&gt;&gt;at /root/test.sh五分钟后执行/root/test.sh脚本，必须写绝对路径用ctrl+删除键删除，按ctrl + d 保存退出atatq #查询当前服务器上的at工作atrm [工作号] #删除指定的at任务 用户 crontab 循环定时任务访问控制 当系统中有/etc/cron.allow文件(白名单)，只有写入此文件的用户可以使用crontab命令，没有写入的用户不能使用crontab命令。同样如果有此文件，/etc/cron.deny文件会被忽略，/etc/cron.allow文件的优先级更高； 如果系统中没有/etc/cron.allow文件，只有/etc/cron.deny文件(黑名单)，那么在此名单下的用户不能使用cron命令【对root不起作用】 如果系统这两个文件都不存在，那么只有root用户可以使用cron命令 被周期性执行的任务称为Cron Job周期性执行的任务列表称为Cron Table 1234567891011121314151617181920212223242526272829crontab -l#查询是否安装systemctl status crond#检查是否启动yum install crontabssystemctl start crond#启动systemctl enable crond#开机自启crontab [选项]选项：-e #进入crontab编辑界面，当前用户vim方式编辑-l #查看当前用户的crontab任务-r #删除当前用户所有的定时的任务-u #指定用户* * * * * 执行的任务#crontab -e 输入格式#第一个 * 一小时的第几分钟 0-59#第二个 * 一天当中的第几小时 0-23#第三个 * 一月当中第几天 1-31#第四个 * 一年当中第几个月 1-12#第五个 * 一周中的第几天 0-7(0和7都代表星期日) 特殊符号 含义 * 代表任何时间,如第一个* 代表每分钟执行一次 ， 代表不连续的时间,如:0 8,12,16 *代表每天的8点0分/12点0分/16点0分执行 - 代表连续时间, “0 5 * 1-6”代表每周一到周六5点执行 */n 代表每个多久执行一次,”/10 *”表示每10钟执行一次 注意 星期几与几号最好不要连用，因为都以天作为单位，容易让管理员混乱 六个选项都不能为空,必须填写。如果不确定使用*代表任意时间 最小有效时间为分钟,最大有效时间为月，像2018年某时执行，3点30分30秒这样的时间都不能使用 定时任务中的命令最好使用绝对路径，定时任务有自己的PATH路径（/etc/crontab） 时间 含义 * 5 * * 1 /root/hello.sh 每周一的5点的每分钟执行一次 */1 * * * * date &gt;&gt; /tmp/log.txt 每分钟打印当前时间到日志文件中 */2 * * * * 1-59/2 * * * * 每隔两分钟 * 2 * * * 2点的每分钟 0 23-7/1 * * * * 晚上23点到早上7点，每隔一个小时 0,30 * * * * 0-59/30 * * * * 每隔30分钟 59 1 1-7 4 * test date +\%w -eq 0 &amp;&amp; /root/a.sh 四月的第一个星期日早晨1时59分运行a.sh 每半分钟执行一次12*/1 * * * * date &gt;&gt; /tmp/date.log*/1 * * * * sleep 30s;date &gt;&gt; /tmp/date.log 系统 crontab 循环定时任务contab -e是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务，可是有些定时任务需要系统执行，这里我们就需要编辑/etc/crontab这个配置文件了 /etc/crontab的功能逐渐被anacron取代/etc/cron.{hourly,daily,weekly,monthly}不再依赖/etc/crontab而是anacron主要说明CentOS 执行系统任务的方法 手工执行定时任务：crontab -e 系统定时任务 将定时任务脚本复制到/etc/cron.{hourly,daily,weekly,monthly}目录中，就能自动定时执行（推荐） 修改crontab配置文件 crontab相关文件 /etc/crontab #系统配置文件，只有root用户才会把这些内容载入到计任务表中 /var/spool/cron #最终生成的计划任务文件 /var/spool/cron/root #root用户的定时任务 /var/spool/cron/user1 #user1用户的定时任务 /var/log/cron #crontab日志，保存cron的任务执行记录，echo会打印到这里 /var/log/cron-日期 anacron配置anacron 是用来保证在系统关机的时候错过的定时任务，可以在系统开机之后再执行 检测周期 anacron会使用一天、七天、一个月作为检测周期 在系统的/var/spool/anacron目录中存在cron.{daily.weekly,monthly}文件，用于记录上次执行cron的时间 和当前时间做比较，如果两个时间的差值超过了anacron的指定时间差，证明有cron任务被漏执行 在老的CentOS版本中，/etc/cron.{daily.weekly,monthly}这些目录即会被cron调用，也会被anacron调用，容易重复执行在CentOS 6.x中则只会被anacron调用，避免了重复执行在CentOS 6.x中，anacron不再是服务，而是系统命令 配置文件目录/etc/anacrontab 方法只需要将需要定时执行的任务脚本放到 /etc/cron.(daily,weekly,monthly) 目录下，就能自动定时执行 特点方便，易管理，一定程度上防止意外情况，执行时间不确定]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux后台管理]]></title>
    <url>%2Fpost%2F1515ab08.html</url>
    <content type="text"><![CDATA[工作（后台）管理指的是在单个登录终端中（shell界面）同时管理多个工作行为 注意事项 当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行 top、vi之类放在后台也是暂停的，因为一个需要用户来查看进程健康状态，一个需要用户写入 压缩、解压缩、cp、mv、find之类可以放在后台所以，想要让这个命令在后台运行，首先，不能与用户有交互。其次，它要运行一段时间 把进程放入后台12345tar -zcf etc.tar.gz /etc &amp; #在命令后加个&amp;，把命令放在后台执行top#ctrl+z放在后台暂停 查看后台的工作123456jobs [-l]-l:显示工作的PIDjobs默认是绑定终端的+代表最后一个放入的进程，也是工作恢复时，默认恢复的工作-代表倒二个放入的进程 把后台暂停的工作回复到前台执行12fg %工作号# %可以省略，但要注意工作号和PID的区别 把后台暂停的工作回复到后台执行12bg %工作号# 后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行 后台命令脱离终端执行把命令放入后台，只能在当前登录终端执行。当用户logout时或关闭终端，会向该用户终端下所有，进程发送SIGHUP信号，后台程序就会停止 mysqld不会跟随关闭，d表示守护进程damon，守护进程damon进程开机运行，某一个用户退出终端不影响该程序的运行，但把所有需要脱离终端执行的命令都放到守护进程里不切实际 把需要后台执行的命令加入/etc/rc.local文件，自启动文件 使用系统定时任务，让系统在指定的时间执行某个后台命令 使用 nohup命令（常用）123nohup 命令 &amp;nohup /root/for.sh &amp;#可以是脚本 补充： https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/ https://linux.cn/article-7918-1.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox扩容]]></title>
    <url>%2Fpost%2F93ab716c.html</url>
    <content type="text"><![CDATA[这篇文章用于在VirtualBox虚拟机上的CentOS扩充根目录空间，区别于新增硬盘以及添加新的挂载点 主机环境为Ubuntu 17.04VirtualBox 5.2虚拟机为CentOS 7 VirtualBox 中虚拟硬盘有几种形式，VMDK、VDI、VHD、HDD等。 VMDK：是VMware开发并使用的，同时也被SUN的xVM、QEMU、SUSE Studio、.NET DiscUtils支持，所以兼容性会好些。 VDI：是Virtual Box 自己的处理格式，而且Virtual Box支持Windows和Linux，所以对于使用VirtualBox的用户比较好。 VHD：是Windows专有的处理格式，HDD是Apple专有的处理格式，所以不会支持跨平台，一般不会考虑。 扩容磁盘文件在主机上操作VBoxManage命令是安装VirtualBox时安装的，如果无法使用该命令，请指定完整路径，寻找VirtualBox的安装目录，我的在/usr/bin下centos.vdi和centos.vmdk是VirtualBox创建的系统磁盘文件，一般位于用户的VirtualBox VMs文件夹下 123456789101112#VDI#单位为MVBoxManage modifyhd centos.vdi --resize 16000#VMDK#单位为M#如果是VMDK就要先转换成VDI，然后再扩容#vmdk是转换前的文件，vdi是转换之后的文件VBoxManage clonehd &quot;centos.vmdk&quot; &quot;centos.vdi&quot; --format vdiVBoxManage modifyhd &quot;centos.vdi&quot; --resize 16000#如果想再转回为VMDK，用这个命令就可以了，直接使用vdi格式也可以VBoxManage clonehd &quot;centos.vdi&quot; &quot;resized.vmdk&quot; --format vmdk 指定新磁盘文件打开虚拟机，选择系统 &gt; 右击 &gt; 设置 &gt; 存储 &gt; 控制器SATA &gt; 右边的添加虚拟硬盘 &gt; 选择转换后的文件在虚拟机打开系统，通过df -h查看发现，根目录还是原样 使用LVM扩展空间在虚拟机上操作因为要修改现有分区，所以要用LVMLVM（Logic Volume Manager）逻辑卷管理，像RedHat系的默认分区管理方式，是建立在硬盘分区之上，文件系统之下的逻辑层，用来解决在最初分区时未正确的评估和和分配分区容量，而造成系统分区不够用。 12345678910111213141516171819202122#查看当前系统分区情况fdisk -l#进行分区fdisk /dev/sda#重读分区表partprobe#将分区格式化为ext4格式mkfs.ext4 /dev/sda3#开始LVM操作,查看卷组名，即VG Name，我这里是centosvgdisplay#创建新物理卷，sda3是之前分区分配的pvcreate /dev/sda3#扩展到卷组vgextend centos /dev/sda3#查看根分区lvdisplay /dev/centos/root就是根分区，也是我们要扩展的分区12345#扩展到容量逻辑分区lvextend /dev/centos/root /dev/sda3#刷新逻辑分区容量resize2fs /dev/centos/root 报错因为我的centos7的某些分区用的是xfs的文件系统（使用df -T查看即可知道）使用xfs_growfs /dev/centos/root代替resize2fs /dev/centos/root 12#查看df -h 参考： 扩充根目录空间：https://www.awaimai.com/1194.html 添加新的挂载点：https://blog.csdn.net/ganshuyu/article/details/17954733 http://www.imooc.com/qadetail/100002]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux配置WordPress]]></title>
    <url>%2Fpost%2F96cee6f3.html</url>
    <content type="text"><![CDATA[安装LAMPhttps://lamp.sh/install.html 创建WordPress数据库和一个用户123456mysql&gt;create database wordpress;//wordpress是数据库名mysql&gt;create user &apos;wordpress&apos;@&apos;localhost&apos; identified by &apos;password&apos;;//wordpress是数据库名，一般使用localhost，password为密码mysql&gt;grant all privileges on wordpress.* to &apos;wordpress&apos;@&apos;localhost&apos;;mysql&gt;FLUSH PRIVILEGES; 下载WordPress安装包并解压12wget http://wordpress.org/latest.tar.gztar -xzvf latest.tar.gz 上传文件默认的网站根目录： /data/www/default将解压好的wordpress文件复制到该目录下 设置wp-config.php文件（这一步可以略过，通过下一步的网页设置）将wordpress目录下的wp-config-sample.php重命名为wp-config.php，并修改以下选项1234567891011121314/** The name of the database for WordPress */define(&apos;DB_NAME&apos;, &apos;wordpress&apos;);/** MySQL database username */define(&apos;DB_USER&apos;, &apos;wordpress&apos;);/** MySQL database password */define(&apos;DB_PASSWORD&apos;, &apos;password&apos;);/** MySQL hostname */define(&apos;DB_HOST&apos;, &apos;localhost&apos;);/** Database Charset to use in creating database tables. */define(&apos;DB_CHARSET&apos;, &apos;utf8&apos;); 使用在浏览器访问：http://ip/wordpress，填写好信息一键安装，安装好后就可以是使用了 参考：https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PR剪辑视频基础操作]]></title>
    <url>%2Fpost%2Fa80ec780.html</url>
    <content type="text"><![CDATA[尝试用PR剪了一个抖音合辑，基本上是不同视频片段的拼接 ##新建选择自定义宽和高，29，往往由素材的大小决定 ##剪辑空白处右键，波纹删除切片工具 ##字幕菜单栏，Title &gt; 静态字幕ctrl+c ctrl+v复制字幕alt替换字幕 ctrl+~(波浪号) 全屏预览]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Mysql]]></title>
    <url>%2Fpost%2F42bdef23.html</url>
    <content type="text"><![CDATA[CentOS通过yum安装查看要对应的yum库，https://dev.mysql.com/downloads/repo/yum/每个安装包下会有一个类似mysql80-community-release-el6-n.noarch.rpm，替换wget对应的链接 添加源12wget https://dev.mysql.com/get/mysql80-community-release-el6-n.noarch.rpmrpm -Uvh mysql80-community-release-el6-n.noarch.rpm 选择mysql安装的版本如果只需要安装最新版mysql，可以跳过这一步12#列出可以安装的版本yum repolist all | grep mysql 可以通过yum-config-manager选择安装的版本12345#安装yum-config-manager，通过yum provides yum-config-manager可以查到在yum-utils包里yum install -y yum-utils#禁用最新的版本，开启需要的版本yum-config-manager --disable mysql80-communityyum-config-manager --enable mysql57-community 也可以直接配置/etc/yum.repos.d/mysql-community.repo将需要使用的版本的enabled设为1，将现在激活的版本设为0123456[mysql80-community]name=MySQL 8.0 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 验证1yum repolist enabled | grep mysql 安装默认选择安装最新的MySQL版本的MySQL，会安装mysql-community-server、client、libs、common1yum install mysql-server 启动12systemctl start mysqldsystemctl status mysqld 初始化因为版本不同，可能第一次登录没有密码，可以先查看以下文件，为空则没有密码，不为空则使用列出的密码1grep &apos;temporary password&apos; /var/log/mysqld.log 使用此命令运行安全脚本，设置root密码，删除匿名用户，禁止远程root用户登录，删除测试数据库并对其进行访问，并重新加载权限表MySQL的 validate_password 插件默认安装。这将要求密码至少包含一个大写字母，一个小写字母，一个数字和一个特殊字符，并且总密码长度至少为8个字符。1mysql_secure_installation Ubuntu安装MySQL1sudo apt install mysql-server mysql-client libmysqlclient-cev]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装PHP]]></title>
    <url>%2Fpost%2F629155b4.html</url>
    <content type="text"><![CDATA[无脑输命令， CentOS 7.2/PHP5.6 12345678910111213yum -y install wgetwget http://hk1.php.net/get/php-5.6.36.tar.bz2/from/this/mirrortar -jxvf php-5.6.36.tar.bz2cd php-5.6.36sudo yum -y install autoconf automake libtool re2c flex bison libxml2 libxml2-devel./configure --profix=/usr/local/php56makemake test#Bug #69958#Bug #70172make install 环境变量 12345678910#只对当前登录用户生效vi ~/.bashrcexport PATH=/usr/local/php56/bin:$PATHsource ~/.bashrc#所有系统用户生效vi /etc/profilePATH=$PATH:/usr/local/php56/binexport PATHsource /etc/profile]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】Hexo中用CSS控制Markdown各列表格宽度]]></title>
    <url>%2Fpost%2F25ce1142.html</url>
    <content type="text"><![CDATA[123456789101112131415161718&lt;style&gt;table th:nth-of-type(1)&#123;width: 10%;&#125;table th:nth-of-type(2)&#123;width: 20%;&#125;table th:nth-of-type(3)&#123;width: 30%;&#125;table th:nth-of-type(4)&#123;width: 40%;&#125;&lt;/style&gt;| 一 | 二 | 三 | 四 || :-: | :-: | :-: | :-: || 1 | 2 | 3 | 4 | table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 20% ; } table th:nth-of-type(3){ width: 30%; } table th:nth-of-type(4){ width: 40%; } 一 二 三 四 1 2 3 4 参考： https://www.jixian.io/2017/10/11/Hexo%E4%B8%AD%E7%94%A8CSS%E6%8E%A7%E5%88%B6Markdown%E5%90%84%E5%88%97%E8%A1%A8%E6%A0%BC%E5%AE%BD%E5%BA%A6/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见服务列表]]></title>
    <url>%2Fpost%2F2690dd73.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 60% ; } table th:nth-of-type(3){ width: 20%; } 服务名称 功能简介 建议 acpid 电源管理接口。如果是笔记本用户建议开启，可以监听内核层的相关电源事件。 开启 anacron 系统的定时任务程序。cron 的一个子系统，如果定时任务错过了执行时间，可以通过 anacron 继续唤醒执行。 关闭 alsasound Alsa 声卡驱动。如果使用 alsa 声卡，开启 关闭 apmd 电源管理模块。如果支持 acpid，就不需要 apmd，可以关闭 关闭 atd 指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用 crond 来进行循环定时任务。 关闭 auditd 审核子系统。如果开启了此服务，SELinux 的审核信息会写入/var/log/audit/audit.log 文件，如果不开启，审核信息会记录在 syslog 中 开启 autofs 让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载 NFS 服务。如果没有 NFS 服务建议关闭 关闭 avahi-daemon Avahi 是 zeroconf 协 议 的 实 现 。 它可以在没有 DNS 服务的局域网里发现基于 zeroconf 协议的设备和服务。除非有兼容设备或使用zeroconf 协议，否则关闭。 关闭 bluetooth 蓝牙设备支持。一般不会在服务器上启用蓝牙设备，关闭它 关闭 capi 仅对使用 ISND 设备的用户有用。 关闭 chargen-dgram 使用 UDP 协议的 chargen server。主要功能是提供类似远程打字的功能。 关闭 chargen-stream 同上。 关闭 cpuspeed 可以用来调整 CPU 的频率。当闲置时可以自动降低 CPU 频率来节省电量。 开启 crond 系统的定时任务，一般的 Linux 服务器都需要定时任务帮助系统维护。建议开启 开启 cvs 一个版本控制系统 关闭 daytime-dgram daytime 使用 TCP 协议的 Daytime 守护进程，该协议为客户机实现从远程服务器获取日期 和时间的功能。 关闭 daytime-stream 同上。 关闭 dovecot 邮件服务中 POP3/IMAP 服务的守护进程。主要用来接收信件， 如果启动了邮件服务则开启，否则关闭 关闭 echo-dgram 服务器回显客户服务的进程。 关闭 echo-stream 同上。 关闭 firstboot 系统安装完成之后，有个欢迎界面，需要对系统进程初始设定。就是这个进程的作用。既然不是第一次启动了，关闭吧 关闭 gpm 在字符终端(tty1-tty6)中可以使用鼠标复制和粘贴。就是这个服务的功能。 开启 haldaemon 检测盒支持 USB 设备。如果是服务器可以关闭，个人机建议开启。 关闭 hidd 蓝牙鼠标、键盘等蓝牙设备检测。必须启动 bluetooth 服务。 关闭 hplip HP 打印机支持，如果没有 HP 打印机关闭吧 关闭 httpd apache 服务的守护进程。如果需要启动 apache，就开启。 开启 ip6tables IPv6 的防火墙，目前 IPv6 协议并没有使用，可以关闭 关闭 iptables 防火墙功能，Linux 中防火墙是内核支持功能。这是服务器的主要防护手段，必须开启。 开启 irda IrDA 提供红外线设备(笔记本，PDA’s，手机，计算器等等) 关闭间的通讯支持。关闭吧 关闭 irqbalance 支持多核处理器，让 CPU 可以自动分配系统中断(IRQ)，提高系统性能。目前服务器多是多核 CPU，请开启。 开启 isdn 使用 ISDN 设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN 已经非常少见，请关闭 关闭 kudzu 该服务可以在开机时进行硬件检测，并会调用相关的设置软件。建议关闭，仅在需要时开启 关闭 lvm2-monitor 该服务可以让系统支持 LVM 逻辑卷组，如果分区采用的是 LVM方式，那么应该开启。建议开启 开启 mcstrans SELinux 的支持服务。建议启动 开启 mdmonitor 该服务用来监测 Software RAID 或 LVM 的信息。不是必须服务，建议关闭 关闭 mdmpd 该服务用来监测 Multi-Path 设备。不是必须服务 关闭 messagebus 这是 Linux 的 IPC(Interprocess Communication，进程间通讯)服务，用来在各个软件中交换信息。个人建议关闭 关闭 microcode_ctl Intel 系列的 CPU 可以通过这个服务支持额外的微指令集。 关闭 mysqld mysql 数据库服务器。如果需要就开启，否则关闭 开启 named DNS 服务的守护进程，用来进行域名解析。如果是 DNS 服务器则开启，否则关闭 关闭 netfs 该服务用于在系统启动时自动挂载网络中的共享文件空间，比如:NFS，Samba 等等。需要就开启，否则关闭 关闭 network 提供网络设置功能。通过这个服务来管理网络，所以开启 开启 nfs NFS(Network File System)服务，Linux 与 Linux 之间的文件共享服务。需要就开启，否则关闭 关闭 nfslock 在 Linux 中如果使用了 NFS 服务，为了避免同一个文件被不同的用户同时编辑，所有有这个锁服务。有 NFS 是开启，否则关闭 关闭 ntpd 该服务可以通过互联网自动更新系统时间，使系统时间永远都准确。需要则开启，但不是必须服务 关闭 pcscd 智能卡检测服务，可以关闭 关闭 portmap 用在远程过程调用(RPC)的服务，如果没有任何 RPC 服务时， 可以关闭。主要是 NFS 和 NIS 服务需要。 关闭 psacct 该守护进程支持几个监控进程活动的工具。 关闭 rdisc 客户端 ICMP 路由协议 关闭 readahead_early 在系统开机的时候，先将某些进程加载如内存整理，可以加快一点启动速度。 关闭 readahead_later 同上 关闭 restorecond 用于给 SELinux 监测和重新加载正确的文件上下文。如果开启 SELinux 则需要开启。 关闭 rpcgssd 与 NFS 有关的客户端功能。如果没有 NFS 就关闭吧。 关闭 rpcidmapd 同上 关闭 rsync 远程数据备份守护进程。 关闭 sendmail sendmail 邮件服务的守护进程。如果有邮件服务就开启，否则关闭 关闭 setroubleshoot 该 服 务 用 于 将 SELinux 相 关 信 息 记 录 在 日 志/var/log/messages 中。建议开启 开启 smartd 该服务用于自动检测硬盘状态。建议开启 开启 smb 网络服务 samba 的守护进程。可以让 Linux 和 Windows 之间共享数据。如果需要则开启 关闭 squid 代理服务的守护进程。如果需要则开启，否则关闭 关闭 sshd ssh 加密远程登陆管理的服务。服务器的远程管理必须使用此服务，不要关闭 开启 syslog 日志的守护进程。 开启 vsftpd vsftp 服务的守护进程。如果需要 FTP 服务则开启，否则关闭 关闭 xfs 这个是 X Window 的字体守护进程。为图形界面提供字体服务，如果不启动图形界面，就不用开启。 关闭 xinetd 超级守护进程。如果有依赖 xinetd 的服务就必须开启。 开启 ypbind 为 NIS(网络信息系统)客户机激活 ypbind 服务进程。 关闭 yum-updatesd yum 的在线升级服务。 关闭 链接: https://pan.baidu.com/s/13cuRwKQ24MmGciC0twAH0Q 密码: 4qg6]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下批量重命名]]></title>
    <url>%2Fpost%2Fe80d20d.html</url>
    <content type="text"><![CDATA[需要命名一些文件，在文件名的前缀加上序列，这些文件的文件包空格、中文思路如下：重命名使用mv命令（不讨论其它重命名命令），需要提供文件名，通过ls命令可以获得文件名，将ls命令得到的文件名分割为数组，在遍历中进行重命名 123456789101112131415161718192021#!/usr/bin/env bash#这样只有一条pathp=&apos;/home/lee/Templates/&apos;path=$(ls -Art $p)# echo $pathIFS=$&apos;\n&apos;#只有加单引号且使用$才是换行符# https://blog.csdn.net/apache0554/article/details/47006609array=($path)i=0while [ $i -lt $&#123;#array[@]&#125; ]do echo $&#123;array[$i]&#125; echo &apos;s&apos; var=$(printf &quot;%03d&quot; $i) # echo $var mv &quot;$&#123;p&#125;$&#123;array[$i]&#125;&quot; &quot;$&#123;p&#125;$&#123;var&#125;$&#123;array[$i]&#125;&quot; let i++done]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务管理]]></title>
    <url>%2Fpost%2F18938cd7.html</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 60% ; } table th:nth-of-type(3){ width: 20%; } 系统的运行级别 运行级别 含义 0 关机 1 单用户模式，主要用于系统修复 2 不完全的命令行,不含NFS服务 3 完全的命令行 4 系统暴露 5 图形模式 6 重启 123456789101112runlevel#查询系统运行级别#结果：N 3 (当前是3 N是上一次登陆级别)init 5 #修改运行级别vi /etc/inittab #修改系统默认运行级别id:3:initdefault:#修改系统默认运行级别，这里默认是3 服务的分类 独立服务：独立的运行在内存中，一直在运行的 基于xinetd的服务：服务由xinetd来管控，平时不运行，一有访问，先到xinetd，然后由xinetd去调用现在基本上不再使用xinetd。默认没有安装，可以通过yum方式安装xinetd服务，在安装之前使用chkconfig可以查看系统的服务状态，安装完整之后会出现一组xinetd管理的服务，默认都是关闭的。123chkconfig --list #查看xinetd是否安装yum -y install xinetd #安装xinetdchkconfig --list #查看xinetd服务 RPM安装服务和源码包安装服务的区别：安装位置不同 源码包安装在知道位置，一般是/usr/local RPM包安装在默认位置中 目录 说明 /etc/ 配置文件位置 /etc/init.d/ 启动脚本位置 /etc/sysconfig/ 初始化环境配置文件位置 /etc/xinetd.conf xinetd配置文件 /etc/xinetd/ 基于xinetd服务的启动脚本 /var/lib/ 服务产生的数据目录 /var/log/ 日志 查询已经安装的服务 RPM包安装的服务：chkconfig --list查看服务自启动状态，可以看到所有RPM包安装的服务 源码包安装的服务：查看服务安装位置，一般是/usr/local下 服务与端口端口：每个协议都有65536个端口，默认给某个协议提供了端口，那么此端口就不在为其他协议体统服务。在/etc/services中可以查看服务与端口对应关系因为服务与端口的这种一一对应的关系，所以可以通过查询端口来查看服务状态1ps aux #查看系统中运行了哪些服务（包含程序） 查询系统中开启的服务12345678netstat -tlunp -t:列出tcp数据 -u:列出udp数据 -l:列出正在监听的网络服务(不包含已连接的网络服务) -n:用端口号来显示服务，而不是服务名 -p：列出该服务的进程id（PID）netstat -an #查看系统中开了哪些程序和服务占用了端口 服务的启动与自启动服务启动：就是在当前系统中让服务运行，并提供功能。服务自启动：让服务在系统开机或者重启动之后，随着系统的启动而自动启动服务。 推荐统一用配置文件的方式，这样不容易冲突 chkconfig off不需要添加启动级别 xinetd自启动和启动是相通的，相互一致 源码包安装服务的启动使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，其中有启动脚本的方法 让源码包的服务能被service命令管理启动：在init.d目录中做个软链接`ln -s /usr/local/apache2/bin/apache /etc/init.d/ 让源码包服务能被 chkconfig 与 ntsysv 命令管理自启动 12345678vi /etc/init.d/apache# chkconfig:35 86 76#指定httpd脚本可以被chkconfig命令管理。#格式： chkconfig ： 运行级别 启动顺序 关闭顺序#description： source package apache #说明，内容随意。把这两句加到/etc/rc.d/init.d/apachetctl 保存(需要带#)然后chkconfig --add apache 源码安装的Apache输入IP地址默认打开的网页是/usr/local/apache2/htdocs/index.htmlrpm包安装的Apache默认打开的是/var/www/html/下的文件，但是默认是没有的，所以打开Apache测试页。当在这个目录下建一个网页后，打开的是新增的网页。 /etc/rc3.d/下面的文件是运行级别3时，系统开启与关闭分别要执行的服务文件，启动顺序与关闭顺序不能和现有的冲突]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Fiddler]]></title>
    <url>%2Fpost%2Fdd92ed66.html</url>
    <content type="text"><![CDATA[安装mono： 1sudo apt install mono-complete 下载Fiddlerhttps://www.telerik.com/download/fiddler 用mono安装它，从提取的目录中运行： 1234mono Fiddler.exe#或者运行mono /path/to/extracted/fiddler/Fiddler.exe]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装Tomcat并部署Java web项目]]></title>
    <url>%2Fpost%2F367a9328.html</url>
    <content type="text"><![CDATA[在Linux上安装JDK略 在Linux上安装FTP略 在Linux上安装Tomcat下载Tomcat，利用FTP上传到服务器上1234567891011121314#解压，位置随意tar -zxvf apache-tomcat-8.0.29.tar.gz#防火墙里面开放8080端口vim /etc/sysconfig/iptables#重启防火墙service iptables restart#启动Tomcat/usr/local/tomcat/bin/startup.sh#tomcat自启动 vim /etc/rc.d/rc.local/usr/local/tomcat/bin/startup.sh Idea打包Java web项目点击Idea左下角，在右侧出现maven project选项，单击maven project选项，出现菜单，选择其中的Lifecycle菜单项，展开，执行里面的package命令即可。在项目文件夹/target/下可以找到 *.war 文件。 将war文件部署到tomcat上 将war文件拷贝到tomcat安装目录的$TOMCAT_HOME/webapps文件夹下。 修改$TOMCAT_HOME/conf/server.xml，在Host配置段中添加类似于如下内容：1&lt;Context path=&quot;/&quot; docBase=&quot;appname.war&quot; debug=&quot;0&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt; docBase=”appname.war”中的appname.war 替换成自己的war的名字。 重启tomcat，然后访问http://localhost:8080/appname 即可。 参考： https://blog.csdn.net/to_baidu/article/details/52823402 https://blog.csdn.net/yums467/article/details/51660683]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装vsftpd]]></title>
    <url>%2Fpost%2Fc81fedea.html</url>
    <content type="text"><![CDATA[记，这篇文章实际是相当复杂的，主要原因是出于安全考虑增加了很多内容，如果只是局域网内使用不需要如此复杂，只需要安装、关闭匿名、指定目录和用户，参考https://fengrenxiaoli.github.io/2018/05/18/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AE%89%E8%A3%85ftp/ vsftpd 的全称是”very secure FTP daemon“，是一款在Linux发行版中最受推崇的FTP服务器程序。特点是小巧轻快，安全易用。 总结起来只有几步 安装 配置文件 防火墙 设置ftp用户 一、安装FTP服务器1234#查看是否已经安装vsftpdrpm -qa | grep vsftpdyum -y install vsftpd 二、手动启动，并使其能够从下次系统启动时自动启动123systemctl start vsftpdsystemctl enable vsftpd#chkconfig vsftpd on 三、允许从外部系统访问FTP服务123firewall-cmd --permanent --zone=public --add-port=21/tcpfirewall-cmd --permanent --zone=public --add-service=ftpfirewall-cmd --reload 四、备份配置文件12cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bakcp /etc/vsftpd.userlist /etc/vsftpd.userlist.bak 五、配置/etc/vsftpd/vsftpd.conf没有的请自行添加12345678910111213anonymous_enable = NO＃禁用匿名登录local_enable = YES＃允许本地登录write_enable = YES＃启用更改文件系统的FTP命令local_umask = 022＃用于本地用户创建文件的umask值dirmessage_enable = YES＃用户首次进入新目录时启用显示消息xferlog_enable = YES＃会保存一个日志文件，详细说明上传和下载connect_from_port_20 = YES＃使用服务器机器上的端口20（ftp-data）进行端口连接xferlog_std_format = YES＃保持标准的日志文件格式listen = NO＃阻止vsftpd在独立模式下运行listen_ipv6 = YES＃vsftpd将监听IPv6套接字而不是IPv4套接字pam_service_name = vsftpd＃vsftpd将使用的PAM服务的名称userlist_enable = YES＃启用vsftpd加载用户名列表tcp_wrappers = YES＃打开tcp FTP基于用户列表文件允许/拒绝对用户的FTP访问默认情况下，如果userlist_enable = YES 并且userlist_deny = YES，在userlist_file=/etc/vsftpd/user_list列出的用户都无法登录访问FTP。 如果userlist_deny = NO，这意味着只有userlist_file = /etc/vsftpd/user_list中明确列出的用户才能登录。 123userlist_enable = YES ＃vsftpd将加载从userlist_file给出的用户名列表userlist_file = /etc/vsftpd/user_list＃存储用户名userlist_deny = NO when users login to the FTP server, they are placed in a chroot’ed jail, this is the local root directory which will act as their home directory for the FTP session only.当用户登录到FTP服务器时，他们被放置在chroot jail里，chroot jail是本地根目录，会作为FTP会话的主目录 限制FTP用户到他们的主目录12chroot_local_user = YES allow_writeable_chroot = YES chroot_local_user = YES意味着本地用户通过默认设置登录后，他们的主目录将被放置在chroot jail中 并且默认情况下，vsftpd不允许chroot jail目录因安全原因而可写，但是，我们可以使用选项allow_writeable_chroot = YES来覆盖此设置。 保存该文件并关闭它 六、配置SELinux12setsebool -P ftp_home_dir on#会报错 set SELinux rule to allow FTP to read/write user’s home directory12345semanage boolean -m ftpd_full_access --on-bash: semanage: command not foundyum provides semanageyum install policycoreutils-pythonsystemctl restart vsftpd 七、测试FTP服务器创建一个FTP用户12useradd -d /home/ftptest -g ftp -s /sbin/nologin ftptestpasswd ftpuser 将用户添加到文件/etc/vsftpd/user_list中12echo ftptest &gt;&gt; /etc/vsftpd.userlistcat /etc/vsftpd.userlist 分别测试匿名用户anonymous、root、ftptest 1234567ftp 192.168.0.203anonymous 530root 530ftptest 230#root因为在/etc/ftpusers目录里所以无法登录，该目录为禁止登录的用户#ftptest进入后，执行ls，可以测试是否为ftptest用户自己的主目录 八、配置不同的FTP用户主目录 使用allow_writeable_chroot=YES具有某些安全隐患，特别是在用户具有上载权限或shell访问权限的情况下。只有当你确切地知道你在做什么时才激活这个选项。需要注意的是，这些安全性影响并不是vsftpd特有的，它们适用于所有提供将本地用户放入chroot jail的FTP守护进程。 注释掉之前的语句1＃allow_writeable_chroot = YES 为用户创建替代本地根目录的目录（ravi您的可能不同），并将所有用户的写入权限移除到此目录123mkdir /home/ftptest/ftpchown nobody：nobody /home/ftptest/ftpchmod a+w /home/ftptest/ftp 修改vsftpd配置文件12user_sub_token = $USER＃将用户名插入本地根目录local_root = /home/$USER/ftp＃定义任何用户本地根目录 重启vsftpd 注意上传命令需要指定目标文件名1ftp put /path/to/local_file remote_file_name 九、开放端口如果使用云服务器，还需要开放端口 FTP服务器使用被动模式，需要先进行配置12345vi /etc/vsftpd/vsftpd.confpasv_enable=YESpasv_min_port=40000pasv_max_port=41000 这里使用阿里云服务器打开控制台，云服务器ECS-&gt;安全组-&gt;配置规则添加21和40000-41000 参考： 重点https://www.kancloud.cn/chandler/bc-linux/52710 http://how2j.cn/k/deploy2linux/deploy2linux-openport/1604.html https://www.tecmint.com/install-ftp-server-in-centos-7/ https://wsgzao.github.io/post/vsftpd/ https://blog.csdn.net/aiynmimi/article/details/77012507]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装Apache]]></title>
    <url>%2Fpost%2Fe76285ac.html</url>
    <content type="text"><![CDATA[安裝Apache1sudo yum install httpd 启动Apache，并且设定为开机自动启动12sudo systemctl start httpdsudo systemctl enable httpd 允许http服务通过防火墙CentOS 7的内置防火墙默认设置为阻止网络流量12345sudo firewall-cmd --add-service=http --permanentsudo firewall-cmd --add-service=https --permanent#sudo firewall-cmd --permanent --add-port=80/tcp#sudo firewall-cmd --permanent --add-port=443/tcpsudo systemctl restart firewalld 重启Apache1sudo systemctl restart httpd.service 配置文件 /etc/httpd/conf/httpd.conf1234567891011DocumentRoot &quot;/var/www/html/example.com/public_html&quot;...&lt;IfModule prefork.c&gt; StartServers 5 MinSpareServers 20 MaxSpareServers 40 MaxRequestWorkers 256 MaxConnectionsPerChild 5500&lt;/IfModule&gt; /etc/httpd/conf.d/vhost.conf12345678910NameVirtualHost *:80&lt;VirtualHost *:80&gt; ServerAdmin webmaster@example.com ServerName example.com ServerAlias www.example.com DocumentRoot /var/www/html/example.com/public_html/ ErrorLog /var/www/html/example.com/logs/error.log CustomLog /var/www/html/example.com/logs/access.log combined&lt;/VirtualHost&gt; 创建上面引用的目录：1sudo mkdir -p /var/www/html/example.com/&#123;public_html,logs&#125; 检查Apache的状态1sudo systemctl status httpd 停止Apache1sudo systemctl stop httpd 参考： https://www.linode.com/docs/web-servers/apache/install-and-configure-apache-on-centos-7/https://www.liquidweb.com/kb/how-to-install-apache-on-centos-7/SELinux：https://www.brilliantcode.net/170/centos-7-install-apache-httpd/SELinux：https://www.brilliantcode.net/145/centos-7-check-selinux-status-enabled-or-not/]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux desktop entriy]]></title>
    <url>%2Fpost%2Fff74c6a5.html</url>
    <content type="text"><![CDATA[在 Windows 平台上，用户可以通过点击位于桌面或菜单上的快捷方式轻松打开目标应用程序。现代 Linux 桌面系统的应用程序是通过*.desktop文件管理的。 一个应用程序对应一个.desktop文件，根据是用户自己可见还是所有用户可见的不同而放在 ~/.local/share/applications或者 /usr/share/applications/ 目录中。 可以自己添加.desktop文件来增加应用程序到launcher里，*.desktop文件格式如下： 1234567891011[Desktop Entry]Encoding=UTF-8Name=火狐浏览器Name[en]=FirefoxName[en_US]=FirefoxComment=Firefox for jasonExec=/opt/firefox/firefoxIcon=/opt/firefox/browser/icons/mozicon128.pngTerminal=falseType=ApplicationCategories=Application;Network; 使用流程： 创建文件，以.desktop为后缀。 编写内容，修改权限 测试是否能双击启动程序 移动到/usr/share/applications/目录下 文件中不能有多余的全角或半角空格，否则会出错 参考： https://linux.cn/article-9199-1.html https://wiki.archlinux.org/index.php/Desktop_entries_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) https://www.ibm.com/developerworks/cn/linux/l-cn-dtef/index.html https://blog.csdn.net/lwjdgl/article/details/49204659]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux用户管理 用户和用户组及配置文件]]></title>
    <url>%2Fpost%2F4ac3f250.html</url>
    <content type="text"><![CDATA[Linux是一个多用户的系统，那么如何保证不同用户之间不冲突，也能保证各个用户的隐私呢，这涉及到了用户管理和权限管理，先讲用户管理 用户用户就是使用操作系统的人，用户分为两类，超级用户和普通用户，而每一个用户都会有一个id，叫UID，系统中实际使用的是UID。 超级用户：root，UID为0 普通用户：UID可以为1-65535（实际没到这么多） 系统用户：对守护进程获取资源进行权限分配，UID在1-499之间（实际是设置的，不一定是500，CentOS 6: ID&lt;500，CentOS 7: ID&lt;1000） 登录用户：能够交互式登录的用户，UID在500+ 虚拟用户：不能登录的用户，比如vsftp 用户组用户组就是具有相同系统权限的一组用户，用户组分为基本组（主组）和附加组（额外组），其中基本组的组名和用户名是一样的，是在创建用户的同时创建的，该组只包含该用户，为用户的私有组 用户可以同时属于多个组，一个是主要组，其他的为附属组 配置文件配置文件有这么四个，用户和组，用户密码和用户组密码 /etc/passwd：用户及其属性信息 /etc/group：组及其属性信息 /etc/shadow：用户密码及相关属性 /etc/gshadow：组密码及其相关属性 /etc/passwd这个文件存储当前系统中所有用户的信息，passwd命令可以修改用户密码，man 5 passwd可以查看对应的/etc/passwd格式 user : x : 123 ： 456 ： xxxx ：/home/user ： /bin/bash用户名 : 密码占位符 : 用户编号UID : 用户组编号GID : 注释信息 ：用户主目录 ： shell类型 /etc/group这个文件存储当前系统中所有用户组的信息，man 5 group可以查看该文件的说明 Group ： x ： 501 ： abc,def,xyz组名称 ：组密码占位符 : 组编号GID ：以当前组为附加组的用户列表(分隔符为逗号) /etc/shadow存储当前系统中所有用户的密码信息，使用命令man 5 shadow查看该文件的说明 用户名:加密了的密码:最近一次更改密码的日期:密码的最小使用期限:最大密码使用期限:密码警告时间段:密码禁用期:账户过期日期:保留字段 最后一次更改密码的日期 最近一次更改密码的时间，表示从1970年1月1日开始的天数。 0 有特殊意思，表示用户应该在下次登录系统时更改密码。 空字段表示密码年龄功能被禁用。 密码的最小年龄 最小密码年龄是指，用户一次更改密码之后，要等多长时间才再次被允许更改密码。 空字段或 0 表示没有最小密码年龄。 最大密码年龄 最大密码年龄是指，这写天之后，用户必须更改密码。 这写天之后，密码仍然可用。用户将会在下次登录的时候被要求更改密码。 空字段表示没有最大密码年龄，没有密码警告时间段，没有密码禁用时间段。 如果最大密码年龄小于最小密码年龄，用户将会不能更改密码。 密码警告时间段 密码过期之前，提前警告用户的的天数(请参考上边的密码的最大年龄)。 空字段或者 0 表示没有密码警告期。 密码禁用期 密码过期(查看上边的密码最大年龄)后，仍然接受此密码的天数(在此期间，用户应该在下次登录时修改密码)。 密码到期并且过了这个宽限期之后，使用用户的当前的密码将会不能登录。用户需要联系系统管理员。空字段表示没有强制密码过期。 账户过期日期 账户过期的日期，表示从1970年1月1日开始的天数。 注意，账户过期不同于密码过期。账户过期时，用户将不被允许登录；密码过期时，用户将不被允许使用其密码登录。 空字段表示账户永不过期。 应该避免使用 0，因为它既能理解成永不过期也能理解成在1970年1月1日过期。 !!表示禁止登录 加密机制加密：明文–&gt; 密文解密：密文–&gt; 明文 单向加密：提取数据指纹 md5: message digest, 128bits sha1: secure hash algorithm, 160bits sha224: 224bits sha256: 256bits sha384: 384bits sha512: 512bits 雪崩效应：初始的条件的微小改变，将会引起结果的巨大改变；定长输出：不同长度的密码会输出相同长度的密文如果密码相同也是不一样的，因为会在密码中添加一个随机的字符串 密码的复杂性策略： 使用数字、大写字母、小写字母及特殊字符中至少3种； 足够长； 使用随机密码； 定期更换；不要使用最近曾经使用过的密码； /etc/gshadow存储当前系统中用户组的密码信息Group： * ： ：abc,def,xyz组名称： 组密码 ：组管理者：组中用户名列表 参考： https://www.thegeekdiary.com/understanding-etclogin-defs-file/]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux用户管理 查看用户命令]]></title>
    <url>%2Fpost%2Fd4f799aa.html</url>
    <content type="text"><![CDATA[查看用户whoami 显示当前登录用户名1whoami who 查看系统当前所有的登录会话1234who 用户名登录名登陆终端登录时间（登陆来源IP地址） w 查看系统当前所有的登录会话及所做的操作12345678910w 用户名user 登陆的用户名tty 登陆终端from 从哪个IP地址登陆login@ 登陆时间idle 用户闲置时间jcpu 和终端连接所有进程占用的时间pcpu 当前进程所占用的时间what 正在运行的命令 id 查看用户相关的ID信息12345id [OPTION]... [USER]-u UID-g GID-G Groups-n Name 显示指定用户信息，包括用户编号、用户编号、主要组编号及名称、附属组列表 su 切换用户或以其他用户身份执行命令123456789101112131415su [options...] [-] [user [args...]]切换用户的方式：su UserName：非登录式切换，即不会读取目标用户的配置文件 echo $PATH显示自身的环境变量su - UserName：登录式切换，会读取目标用户的配置文件；完全切换 echo $PATH显示目标用户的环境变量Note：root su至其他用户无须密码；非root用户切换时需要密码；# 换个身份执行命令：su [-] UserName -c &apos;COMMAND&apos;选项：-l “su -l UserName”相当于“su - UserName” 其他12who am i #显示登录用户groups 用户名 #显示用户所在的所有组，包括主要组和附属组 last 查询当前和过去登录的用户信息123456last 默认读取var/log/wtmp用户名登录终端登陆IP登录时间退出时间（在线时间） lastlog 查看所有用户最后一次登录信息123456lastlog lastlog命令默认是读取/var/log/lastlog文件内容用户名登录终端登陆ip最后一次登陆时间 其他命令12345touch /etc/nologin #在etc目录下创建一个nologin文件(文件内容无关紧要)，暂时禁止除管理员外的用户登录wall [想说的话] 相当于喇叭广播的功能talk [用户名] 聊天框里聊天write [用户名] 相当于密聊]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux管理用户命令]]></title>
    <url>%2Fpost%2Fdcf68b37.html</url>
    <content type="text"><![CDATA[管理命令useradd 创建用户1234567891011121314useradd [options] LOGIN选项：-u UID [UID_MIN, UID_MAX], 定义在/etc/login.defs-g GID 指明用户所属基本组，可为组名，也可以GID，组必须存在-c &quot;COMMENT&quot; 用户的注释信息-d /PATH/TO/HOME_DIR 以指定的路径为家目录-s SHELL 指明用户的默认shell程序，可用列表在/etc/shells文件中-G GROUP1[,GROUP2,...[,GROUPN]]] 为用户指明附加组；组必须事先存在-r 创建系统用户-D 修改默认值，默认值设定在/etc/default/useradd文件中，也可以直接改文件useradd 用户名 #添加用户，所在用户组与用户名同名，uid默认为最近的一个+1useradd -g 组名 用户名 #添加用户，指定其所在的组useradd -d 目录 用户名 #添加用户，指定用户的家目录 注意：使用-d选项时，指定的目录不能是已经存在的，每次创建新用户都会在家目录下复制一些配置文件，比如.bashrc，如果使用已经存在的目录就没有相应的文件会出错，/etc/ske1/下即为需要复制的文件 /etc/login.defs文件中包含了以下信息： 用户邮箱的位置 密码时效控制 UID选择的最小值和最大值（1000到60000） GID选择的最小值和最大值（1000至60000） 添加新用户时是否应创建主目录 默认的umask 用于加密密码的加密方法 useradd和adduser的区别useradd是系统编译的本地二进制文件adduser是一个使用useradd制作的perl脚本 adduser比useradd更友好，所提供的功能没有区别 在使用adduser命令时，它会添加这个用户名，并创建和用户名名称相同的组名，并把这个用户名添加到自己的组里去，并在/home目录想创建和用户名同名的目录，并拷贝/etc/skel目录下的内容到/home/用户名/的目录下，并提示输入密码，并提示填写相关这个用户名的信息。用adduser这个命令创建的账号是普通账号，可以用来登陆系统。1adduser wo 在使用命令useradd时，它会添加这个用户名，并创建和用户名相同的组名，但它并不在/home目录下创建基于用户名的目录，也不提示创建新的密码。也就是说使用useradd mongo 创建出来的用户，将是默认的”三无“用户，无家目录，无密码，无系统shell，换句话说，它创建的是系统用户，无法用它来登陆系统。12345678910111213useradd wo#要用useradd创建的用户登陆系统则需要以下操作passwd womkdir wochown -R wo:wo /home/wo/#修改wo的登陆Shell为/bin/bashusermod -s /bin/bash wotail -1 /etc/passwd#将/etc/skel目录下的文件复制到该用户目录下cp -r /etc/skel /home/wo 也可以直接指定参数1234useradd -d /home/wo -m -s /bin/bash wo#-m 强制建立用户主文件夹-d 用户主文件夹 指定用户登录所进入的目录，并赋予用户对该目录的的完全控制权s shell 用户登录所使用的shell 实际中根据发行版的不同，配置的不同也会有区别 usermod 修改用户属性1234567891011121314151617181920usermod [OPTION] login选项：-u UID 新UID-g GID 新基本组-G GROUP1[,GROUP2,...[,GROUPN]]] 新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项，表示append-s SHELL 新的默认SHELL-c &apos;COMMENT&apos; 新的注释信息-d HOME 新的家目录；原有家目录中的文件不会同时移动至新的家目录；若要移动，则同时使用-m选项-l login_name 新的名字-L lock指定用户，会在密码前加一个!-U unlock指定用户-e YYYY-MM-DD 指明用户账号过期日期-f INACTIVE 设定非活动期限usermod -c 注释信息 用户名 #为指定用户名添加注释usermod -l 新用户名 旧用户名 #更改用户名usermod -d 目录 用户名 #更改用户个人文件夹的路径usermod -g 新用户组 用户名 #更改指定用户的基本组 userdel 删除用户12345userdel [OPTION]... login-r 删除用户家目录userdel 用户名 #删除用户，但是不删除用户个人文件夹里的文件userdel -r 用户名 #删除用户并且删除用户个人文件夹里的文件 passwd 给用户添加密码1234567891011121314passwd [OPTIONS] UserName: 修改指定用户的密码，仅root用户权限passwd: 修改自己的密码选项：-l 锁定指定用户-u 解锁指定用户-n mindays 指定最短使用期限-x maxdays 最大使用期限-w warndays 提前多少天开始警告-i inactivedays 非活动期限，一个用户账户密码已经过期inactivedays天之后，用户将不能再登录进账户--stdin：从标准输入接收用户密码 echo &quot;PASSWORD&quot; | passwd --stdin USERNAME pwck 检查密码的有效性groupadd 创建组1234groupadd [OPTION]... group_name选项：-g GID 指明GID号；[GID_MIN, GID_MAX]-r 创建系统组 groupmod 修改组属性1234567groupmod [OPTION]... group选项：-n group_name 新名字-g GID 新的GIDgroupmod -n 新组名 原组名 #更改用户组名称groupmod -g 组编号 组名 #设置用户组编号 groupdel 删除组前提是用户组内没有用户1groupdel GROUP gpasswd 管理/etc/gpasswd和/etc/gshadow123456789gpasswd [OPTION] GROUP选项：-a user 将user添加至指定组中-d user 删除用户user的以当前组为组名的附加组-A user1,user2,... 设置有管理权限的用户列表gpasswd -a 用户名 附属组 #给用户添加附属组gpasswd -d 用户名 附属组 #把用户从附属组中删除gpasswd 用户名 #更改组密码，回车会有相应的提示操作 newgrp 临时切换基本组1newgrp 组名 用户创建的文件默认为主要组；需要以附属组创建文件的，需将身份切换到附属组把用户的组切换到附属组，需要用户登录后，自己执行，切换组密码是在组切换时用的，如果有会要求输入组密码如果用户属于此组，则不需要组密码 chage 修改用户属性12345678chage [OPTION]... LOGIN选项：-d LAST_DAY-E, --expiredate EXPIRE_DATE-I, --inactive INACTIVE-m, --mindays MIN_DAYS-M, --maxdays MAX_DAYS-W, --warndays WARN_DAYS chsh 更改登录shell1234567chsh [Option] login选项：-l 列出可用的shell-s shell 指定shellchsh -l #列出所有shellchsh user1 #修改user1的登录shell chfn\finger 用户资料12chfn 用户名 #设置用户资料，依次输入用户资料finger 用户名 #显示用户详细资料，与chfn对应 参考： https://segmentfault.com/a/1190000007316406 https://askubuntu.com/questions/345974/what-is-the-difference-between-adduser-and-useradd https://my.oschina.net/lyp82nlf/blog/477319]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理06 swap分区]]></title>
    <url>%2Fpost%2F92783d86.html</url>
    <content type="text"><![CDATA[为磁盘添加SWAP交换分区 1.首先建立一个普通的Linux分区123fdisk /dev/sdb#参考MBR分区#输入p查看sdb的分区 2.修改分区类型的16进制编码12345输入t，输入要修改的磁盘编号 这里是 6（sdb6的6）；输入 L 来查看可以修改成的类型再输入82（Linux swap）,保存成功输入p来查看已经保存的情况输入w保存分区 3.格式化交换分区1mkswap（后面跟随设备名称） /dev/sdb6 完成格式化 4.启动交换分区123swapon /dev/sdb6 #启动交换分区free #查看加载状况swapoff /dev/sdb6 #关闭交换分区]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理05 挂载命令]]></title>
    <url>%2Fpost%2Ffd9a4071.html</url>
    <content type="text"><![CDATA[mount 命令123456789101112mount #查看系统中已挂载的设备mount -a #依据配置文件/etc/fstab内容，自动挂载 #光盘、U盘的数据不建议写入自动挂载中，否则开机时没有光盘和U盘的话，系统崩溃mount [-t 文件系统] [-o 特殊选项] [设备文件名] [挂载点]-t：加入文件系统类型来指定挂载的类型，ext3,ext4,iso9660等文件系统-o：可以指定挂载的额外选项mount -o remount，noexec /home#/home内的执行文件无法执行mount -o remount，exec /home ###挂载光盘1234mkdir /mnt/cdrom/ #建立挂载点mount -t iso9660 /dev/sr0 /mnt/cdrom #/dev/sr0是光盘设备名，也可以用/dev/cdrom（sr0的软连接，但需要系统完全启动才能用） -t iso9660 可以省略 因为系统知道sr0是iso9660 ###卸载1234umount [设备文件名或挂载点] umount /mnt/cdrom umount /dev/sr0 #都可以 卸载时位置不能在光盘目录下 ###挂载U盘123456789fdisk -l #查看U盘设备文件名 #U盘可以看成系统的第二块硬盘mount -t vfat /dev/sdb1 /mnt/usb/ #-t vfat windows的fat32文件系统注：linux默认不支持ntfs文件系统，所以移动硬盘正常没法挂载，能挂载后也只能读，不能写，所以用windows数据一般用网络传播#解决办法1. 编译内核 让linux 支持NTFS文件系统 2. 安装ntfs-3g 手动挂载分区手动挂载的分区，不具有永久性，系统重启后，挂载就会失效12345678910# 没有挂载无法使用，分区默认的挂载目录是/mnt目录sudo fdisk -l#查看系统的硬盘和硬盘分区情况，了解需要的设备，比如移动硬盘/U盘/windows下的分区/光盘sudo mkdir -p /media/usb#创建挂载目录sudo mount /dev/sdb /media/usb#挂载sudo umount /dev/sdb#卸载 永久挂载1vim /etc/fstab]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理04 格式化]]></title>
    <url>%2Fpost%2F5dc8807e.html</url>
    <content type="text"><![CDATA[格式化：又称逻辑格式化，它是指根据用户选定的文件系统（eg：FAT16（最大支持2GB分区），FAT32（单个文件大小不能超过4GB，最大支持16TB分区），NTFS，EXT2，EXT3，EXT4（centos6默认文件系统）等），在磁盘特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。 格式化的目的并不是清空数据，其根本目的是为了写入文件系统，能够更快查找读写数据，但是在进行格式化的操作时会先清空原有数据。 格式化具体进行的操作：将整个分区分割成等大小的数据块（Block），每个数据块默认4KB，存储文件的最小，可以手动选择1KB、2KB或4KB。假设存放10KB的文件，会使用3个数据块，三个数据块不一定是连续的，最后的一数据块中即使没有放满，也不能再存放其他文件。在分区列表中建立一个二维表格，记录了文件的id号（即文件放在那些数据库中，叫做iNode）、文件修改时间、文件的访问权限。操作文件时先访问此二维表进行权限匹配。 parted工具可以格式化，但是parted支持的文件系统有限无论使用MBR，还是GPT进行的分区，都可以使用”mkfs”进行分区格式化 123mkfs (-make for system)mkfs -t ext3 /dev/sda6 #将sda6分区格式化为ext3格式mkfs -t ext2 /dev/sda7 #将sda7分区格式化为ext2格式 MBR只有主分区和逻辑分区可以格式化， 扩展分区不可以格式化GPT类型格式化后，使用fdisk看不到各个分区的系统文件格式， 必须启动parted工具的print指令来查看 1ls -l /dev/sdb #查看sdb磁盘上的设备情况]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理03 GPT分区]]></title>
    <url>%2Fpost%2F5379c247.html</url>
    <content type="text"><![CDATA[MBR分区模式和GPT分区模式比较MBR 区容量最大2TB 分区命令fdisk /dev/sdxx 分区完毕，执行-w 写入分区表才能生效 分区表类型是：msdos 缺点：限制多，跟不上发展 GPT 主分区个数”几乎”没有限制（最多128个） 单个分区容量”几乎”没有限制(最大18EB) 使用parted命令工具（同时支持MBR,GPT分区） 分区表类型是：gpt 1EB=1024PB,1PB=1024TB,1TB=1024GB 缺点：GPT主分区中不适合安装x86的系统架构 使用parted进行分区fdisk只能给硬盘做MBR分区parted既能给硬盘做MBR分区，又能做GPT分区 123456789101112131415161718192021222324输入parted命令，启动parted分区工具，默认分区目标是系统的第一块硬盘输入help，查看帮助信息输入select /dev/sdc，切换分区目标磁盘输入mklable命令，给目标硬盘指定分区表的类型，然后才能给硬盘添加分区如果使用MBR分区，输入mklabel msdos；使用GPT分区，输入mklabel gpt输入print 查看当前分区详情；输入print all命令，查看所有分区详情parted分区操作模式：①交互模式（使用提问模式选择） ②命令模式**交互模式**输入mkpart #添加分区输入分区名称选择分区系统类型分区从第几MB开始，4K对齐对硬盘分区很重要，为了达到最佳性能，分出1MB空间，让数据块对齐结束位置**命令模式**命令模式下，分区名称不能省略mkpart test(分区名称) 2000(开始位置2000MB) 3000(结束位置MB)rm [分区编号] #删除分区unit GB #使用GB给分区指定开始和结束位置quit #退出分区工具 fdisk分区设计完成后 最后要通过w来写入硬盘,parted不需使用w保存]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理02 MBR分区]]></title>
    <url>%2Fpost%2F5a979475.html</url>
    <content type="text"><![CDATA[硬件设备都是由Linux系统自动识别的，必须对硬盘进行分区、格式化、挂载后才能使用 分区的意义：http://www.cnblogs.com/personnel/p/4584926.html Windows与Linux的磁盘使用流程 Windows：分区–&gt;格式化–&gt;分配盘符 Linux：分区–&gt;格式化–&gt;给每个分区起“设备文件名”–&gt;分配挂载点 MBRMBR=主引导区记录。硬盘的0磁道的第一个扇区称为MBR，它的大小是512字节，而这个区域可以分为三个部分。第一部分为pre-boot区（预启动区），占446字节；第二部分是Partition table区（分区表），占64个字节，硬盘中分区有多少以及每一分区的大小都记在其中。第三部分是magic number，占2个字节，固定为55AA。 MBR是针对整个硬盘而言的，而引导扇区是对单个分区而言的。每个分区的第一扇区就是引导扇区：像MBR一样，引导扇区里包含了一些引导操作系统所需要的相关信息。如果引导扇区被破坏了是个非常严重的问题，那就意味着这个分区不能被访问，安装在这个分区上的操作系统也不能被启动。所以说修复引导是使得每一个分区都能被正确识别引导。 ##MBR分区类型（所有系统都适用）： 主分区最多只能分4个，由硬盘的结构决定（硬盘分为一个个等大小的扇区，每个扇区512字节，其中446个字节用于记录启动信息， 剩下的64个字节进行分区表示，64个字节中每16个字节表示一个分区，所以最多只能表示4个分区，故而硬盘结构如果不变，主分区最多只能分4个）。每个主分区都有各自独立的引导块，可以用fdisk设定为启动区。 Windows下A、B作为软分区的盘符，C作为第一个主分区的盘符，所以最多还能分23个子分区。 ####扩展分区 一块硬盘中扩展分区只能有一个 主分区和扩展分区总数不能超过4个 可以将一个主分区作为扩展分区，即三个主分区，一个扩展分区，总计4个分区； 不能直接写入数据，只能用作包含逻辑分区。 区分扩展分区和逻辑分区，是突破主分区只能有4个的最主要的方法。 逻辑分区可以有多个，没有独立的引导块，不能用fdisk设定为启动区。 设备文件名Linux中一切皆文件，包括硬件、用户等。硬件的文件名即称作“硬件设备文件名”，硬件设备文件名作为硬件的标准称呼，是由Linux自动检测并分配的。硬件设备文件在目录中处于根目录（“/”代表根目录，最高级目录）下的dev文件夹（专用于放硬件设备文件）下，即“/dev”文件夹下。 分区的设备文件名分配规则hd代表IDE接口，sd代表SCSI接口或SATA接口；a代表第一块硬盘，如有多块硬盘b代表第二块硬盘，c代表第三块硬盘，以此类推；1代表一块硬盘上的第一个分区，2代表此硬盘的第二个分区，3代表此硬盘第三个分区，以此类推，其中1234编号只能代表主分区或扩展分区，逻辑分区的编号从5开始分配，最大分区编号16/dev/sda1 第一块SATA接口硬盘的第一个分区 挂载点Windows中使用字母标识符来指定在这个分区上的文件和目录，而Linux中使用目录作为挂载点（盘符）绝大多数目录都可以作为挂载点（部分必须和根目录放在同一个分区的目录除外，否则将导致系统不能启动）包括你手工创建的目录。 ##Linux 分区 ####必须分区： 根分区 /（挂载点根目录，根目录中要保存其他所有数据，根目录如果没有硬盘空间，根下的很多数据将没有地方存放）swap分区（交换分区，可理解为虚拟内存， 当真实内存不足时，可将swap分区中的硬盘空间作为内存使用，如果内存小于等于4GB，推荐swap分配内存的两倍，若内存大于4GB，建议swap空间与内存相等，不需要挂载点，swap分区不是给用户看的，是系统直接调用的所以无挂载点） 注：启动分区/boot需不需要创建要看实际情况，需要使用LVM时，由于/boot分区不支持lvmfs，所以要单独创建，这个目录是系统文件，一般不会动，但不要太小，如果升级内核可能就满了。个人使用没有必要 使用 “fdisk”命令进行硬盘分区123456789101112131415161718192021fdisk /dev/sdb 进入sdb硬盘分区模式输入m，查看命令帮助信息新建分区输入n，给硬盘添加一个新的分区输入p，主分区输入e，扩展分区，扩展分区不能直接使用，需要添加逻辑分区输入l，扩展分区只能有一个，不能再分扩展分区了，所以显示的是逻辑分区，5代表分区的编号从5开始给分区指定编号，1-4是预留给主分区或者扩展分区的Partition number( 1-4,defautl 1):给这个分区指定扇区发起始和终止位置扇区的起始位置： First sector (2048 - 16777215，default 2048):不输入默认2048扇区的终止位置：Last sector,+sectors or +size&#123;K,M,G&#125;&#123;2048-16777215,default 16777215&#125;:3000MCommand(m for help):输入p查看已经分好的区Command(m for help):输入n 继续添加分区删除分区： 输入d，随后输入删除的分区号逻辑分区是在拓展分区之内的，如果删除的拓展分区，随之而然的逻辑分区也被删除写入分区：输入w，直接就是保存并生效了； 参考： https://shengbao.org/691.html http://blog.51cto.com/13323775/2053921]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux磁盘管理01 基本命令]]></title>
    <url>%2Fpost%2Fe32f53bc.html</url>
    <content type="text"><![CDATA[df12345678df：查看磁盘分区使用状况-l：仅显示本地默认磁盘（默认）-a：显示所有文件系统的磁盘使用情况-h：以1024进制计算最合适的单位显示磁盘容量（默认KB显示）-H：显示以1000进制计算最合适的单位显示磁盘容量-T：显示磁盘分区类型-t：显示指定类型文件系统的磁盘分区 //如：df -t ext4-x：不显示指定类型文件系统的磁盘分区 du123456789du 统计磁盘上的文件大小-b 以byte为单位统计文件 //统计出来的都是四舍五入的大小-k 以KB为单位统计文件 //统计出来的都是四舍五入的大小-m 以MB为单位统计文件 //统计出来的都是四舍五入的大小-h 按照1024进制以最适合的单位统计文件-H 按照1000进制以最适合的单位统计文件-s 指定统计目标 du -s tmpdu -sb *.zip]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux su root和sudo su]]></title>
    <url>%2Fpost%2F6b4d1db7.html</url>
    <content type="text"><![CDATA[来自https://askubuntu.com/questions/86095/does-executing-sudo-su-and-su-root-do-the-same-thing?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa Does executing sudo su and su root do the same thing?What are the technical differences between the two? The only thing I noticed is that sudo surequires you to enter your own password (assuming you’re not root) su rootrequires you to enter root’s password. However both seem to log you into the root user account. The second command cannot be executed in a default Ubuntu installation, where the root account is not enabled. But supposing you have unlocked the root account giving him a password, the two commands could only differ in the environment and shell variable set, I think. Compare the output of env in the two situations, and maybe also the output of set to see the differences.]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 关机和重启]]></title>
    <url>%2Fpost%2F3ae572a2.html</url>
    <content type="text"><![CDATA[关机shutdown （建议使用）123456789101112131415161718shutdown [选项] 时间#相比其它命令更安全，在关机和重启时会正确保存正在运行的程序选项：-c 取消前一个关机命令-h 关机（halt）-r 重启时间: now 立刻+m 相对时间表示法，从命令提交开始多久之后，例如 +3hh:mm 绝对时间表示，指明具体时间shutdown -r 05:30 5:30重启shutdown -r 05:30 &amp; 后台运行shutdown -r now 立刻重启shutdown -r +30 30分钟后关机# 在服务器上尽量避免远程关机，因为再开机麻烦，所以远程重启就足够了# 服务器由于经常进行高速运算强制重启非常容易损坏硬件，也容易造成数据丢失，所以一定要小心 haltpoweroffinit 0 重启shutdown -r Timereboot123reboot-f: 强制，不调用shutdown-p: 切断电源 init 6退出登录命令123logout # LINUX默认同时256个登录，最大支持6万多# 每次使用后，建议退出当前用户，避免他人因账户占用无法使用！与windows中的注销相似！ 注意：如果关闭远程登录xshell时直接点X，该用户就卡在计算机里，因为没有正确退出，所以一定养成正确退出登录的习惯]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux文件管理01 文件和文件系统]]></title>
    <url>%2Fpost%2F9ffd3055.html</url>
    <content type="text"><![CDATA[文件linux中一切皆文件，目录为目录文件。普通文件用来保存数据，目录文件用来保存文件 文件有两类数据 元数据、metadata 元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode…)等等。 数据、data 数据是指普通文件中的实际数据。 文件名 文件名严格区分字符大小写；file1, File1, FILE1是不同的文件 文件名可使用除/以外的任意字符，不建议使用特殊字符 - /: 表示根目录，也用做路径分隔符 文件名长度最长不能超过255个字符 所以.开头的文件，均为隐藏文件 Linux下的文件类型 f 普通文件 d 目录文件 b 块设备 c 字符设备 l 符号链接文件 p 管道文件 s 套接字文件，socket 文件系统文件系统层次结构标准（Filesystem Hierarchy Standard，FHS）定义了Linux操作系统中的主要目录及目录内容。在大多数情况下，它是一个传统BSD文件系统层次结构的形式化与扩充。 设计FHS的目的是为了给Unix-like系统的管理员提供一个管理系统以及目录结构的参考。 由于利用Linux源码开发产品和发行版的企业或组织众多，如果每个组织都按照自己的喜好来组织系统中的文件结构，网络上必然出现各种各样的文件结构。这些产品的用户就不得不为每种不同的文件系统结构花费时间来学习。有了FHS之后，几乎所有的Unix-like系统的发行商或软件开发者都遵从该建议规范每个特定目录下分别只放哪些文件，方便了文件的组织和查找。 详细内容参考：https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf 根文件系统(rootfs)root filesystem /根目录是整个系统最重要的一个目录，因为在Linux系统中所有的目录都必须挂载在根目录下，也即所有的目录都是由根目录衍生出来。系统开机时所需要的开机软件、内核文件、函数库等都必须在根目录下。因此FHS也建议根目录不要安装在非常大、数据存取非常活跃的分区上，如此一来就能尽可能地降低系统不必要的错误。 FHS(Filesystem Hierarchy Standard) 目录 说明 /boot 引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader：grub)都存放于此目录 /bin 命令保存目录（普通用户就可以读取的命令）；不能关联至独立分区，OS启动即会用到的程序 /sbin 命令保存目录（超级用户才能使用的目录）；不能关联至独立分区，OS启动即会用到的程序 /lib 基本共享库文件，以及内核模块文件(/lib/modules)，为系统启动或根文件系统上的应用程序（/bin, /sbin）提供共享库（libc.so. ld），以及为内核提供内核模块（modules） /lib64 专用于x86_64系统上的辅助共享库文件存放位置 /etc 配置文件目录(纯文本文件，不能是二进制) /home/USERNAME 普通用户家目录 /root 管理员的家目录 /media 便携式移动设备挂载点(cdrom、usb) /mnt 临时文件系统挂载点 /dev 设备文件及特殊文件存储位置b: block device，随机访问 c: character device，线性访问 /opt 第三方应用程序的安装位置 /srv 系统上运行的服务用到的数据 /tmp 临时文件存储位置 /usr unix software resource，根据FHS建议软件安装后将他们的数据合理地分别放置到这个目 录下，而不要自行新建该软件自己的独立目录。 /usr/bin 保证系统拥有完整功能而提供的应用程序；供普通用户使用的系统命令 /usr/sbin 供超级用户使用的系统命令 /usr/lib /usr/lib64 /usr/include C程序的头文件(header files) /usr/share 结构化独立的数据，例如命令手册页man和自带文档doc等 /usr/src 程序的源码 /usr/local 第三方应用程序的安装位置/var/(bin, sbin, lib, lib64, etc, share) /var variable data files，可变数据文件，主要存储常变化的文件，包括缓存(cache)、登录 文件(logfile)以及某些软件运行所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等 /var/cache 应用程序产生的缓存文件 /var/lib 程序执行过程中，需要用到的数据文件放置的目录。此目录下各自的软件应该要有各自的目录 /var/local 专用于为/usr/local下的应用程序存储可变数据 /var/lock 锁文件，某些设备或者文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该 设备时，就可能产生一些错误，因此就得要将该设备或文件上锁(lock)，以确保该文件或设备只给一个程序使用 /var/log 日志目录及文件，/var/log/messages, /var/log/wtmp /var/mail 个人电子邮箱目录，通常与/var/spool/mail/目录互为链接 /var/opt 专用于为/opt下的应用程序存储可变数据 /var/run 运行中的进程相关的数据；通常用于存储进程的pid文件 /var/spool 应用程序数据池，存放等待其他程序使用的数据 /var/tmp 下次启动前会被删除的临时数据 /proc 用于输出内核与进程信息相关的虚拟文件系统，内核级进程存储其相关信息，多为内核参数，例 如net.ipv4.ipforward虚拟为net/ipv4/ipforward，存储于/proc/sys /sys 用于输出当前系统上硬件设备相关信息的虚拟文件系统，sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径；为管理内核提供了一种统一模型的接口 /selinux security enhanced Linux，selinux相关的安全策略等信息的存储位置 Linux上的应用程序的组成部分1234二进制程序：/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin库文件：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64配置文件：/etc, /etc/DIRECTORY, /usr/local/etc帮助文件：/usr/share/man, /usr/share/doc, /usr/local/share/man, /usr/local/share/doc 说明1234/usr/bin/ /usr/sbin/ /bin /sbin 这四个目录都是用来保存系统命令。其中，bin目录下的命令任何用户都可以执行，sbin目录下只有root才可以执行。linux使用此方式来区分用户权限。 FHS根据文件的可共享、不可共享、静态和动态等特点，将目录树架构分为/、/usr、/var三部分。参考这里 / (root, 根目录)：与开机系统有关 /usr (unix software resource)：与软件安装/执行有关 /var (variable)：与系统运作过程有关/usr放置的数据属于可分享的且不可变动的，/usr可分享给局域网内的其他主机来使用。 /proc、/sys，这两个目录保存的是内存的挂载点，不能直接操作。其中的数据直接写在内存中。避免数据丢失或由于内存溢出导致系统崩溃 参考： http://www.178linux.com/62805 https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86 http://wiki.jikexueyuan.com/project/learn-linux-step-by-step/directory-configuration-fhs.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 字符处理命令sort、wc、tr、uniq]]></title>
    <url>%2Fpost%2F616ff62c.html</url>
    <content type="text"><![CDATA[sort 排序命令对文本中的行进行排序1234567891011121314151617sort [OPTION]... [FILE]...选项：-f 忽略大小写-n 以数值型进行排序，默认使用字符串型排序-r 反向排序-t DELIMITER 指定分隔符,默认是制表符-k n[,m] 按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)-u uniq，排序后去重sort /etc/passwd # 按照字母顺序a-z排列文件内容sort -r /etc/passwd # 反向排序，即按z-a顺序排列文件内容sort -t&quot; &quot; -k3 users# 使用空格把users文件分割 使用第3列排序sort -n -t &quot;:&quot; -k 3 /etc/passwd # 以数值型进行排序，指定分隔符为“:”，使用第3列排序 wc 统计命令(word count)12345678wc [选项] 文件名选项:-l 只统计行数-w 只统计单词数-m 只统计字符数-c 只统计字节数# 若不加参数，则列出行数 词数 字符数 wc执行后 输入 ctrl+d结束 会统计输入行数 单词数 字符数 tr 字符替换123tr [选项] ... SET1 [SET2]从键盘输入转换或删除字符-d 删除 uniq 去重命令对文本中的连续的重复行进行操作 如果不连续就不无法使用该命令，所以可以先用sort排序，可以看出哪些重复了 1234567891011121314uniq [OPTION]... [FILE]...-c: 显示每行重复出现的次数-d: 仅显示重复过的行-u: 仅显示不曾重复的行uniq uniqtest.txt# 连续重复的行只显示一行uniq -d uniqtest.txt# 只显示重复的行uniq -D uniqtest.txt# 显示全部重复的行uniq -c uniqtest.txt# 显示重复次数 cut命令：文本分割 cut 字符截取命令grep行提取，cut列提取12345678910111213141516171819cut [OPTION]... [FILE]... 选项 -f 列号 提取第几列，从1开始-d 分隔符 按照指定分隔符分割列，默认为tabcut -f 1 /etc/passwdcut -f 1-3 /etc/passwdcut -f 1,3 /etc/passwdcut -f 1-3,7 /etc/passwdcut -d: -f 1,3-5 /etc/passwd# 使用冒号分割passwd文件，显示第1、3至5列cut -de -f 1 users# 使用e字符分割文件 取第1列cut -d&apos; &apos; -f 1-2 users &gt;user2# 使用空格分割文件，显示1-2列，将标准输出重定向到新的文件grep &quot;bin/bash&quot; /etc/passwd 可以登录的用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; 排除root的可登录用户grep &quot;bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -f 1 -d &quot;:&quot; 提取非root登录用户用户名 cut命令的局限性用cut截取比较规律的文件，用默认制表符或其他符号作为分隔符，可以方便截取，如果是用空格或多个空格做分隔符，就会有问题12df -h | cut -d &quot; &quot; -f 1,3无法正确分隔多个空格，只能以一个空格分隔 例子以冒号分隔，取出/etc/passwd文件的第6至第10行，并将这些信息按第3个字段的数值大小进行排序；最后仅显示的各自的第1个字段；1head -n 10 /etc/passwd | tail -n 4 | sort -n -t &quot;:&quot; -k 3 | cut -f 1 -d &quot;:&quot;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理06 查看文本文件内容]]></title>
    <url>%2Fpost%2F30ec04f2.html</url>
    <content type="text"><![CDATA[相关命令：cat, tac, head, tail, more, less cat12345678cat [OPTION]... [FILE]...选项：-E: 显示行结束符$-n: 对显示出的每一行进行编号# 读取一个或多个文件，然后复制它们到标准输出cat movie.mpeg.0* &gt; movie.mpeg# cat可以用来连接文件，通配符是有序的 如果没有给cat任何参数，它会从标准输入读入数据，因为标准输入在默认情况下连接到键盘，它正在等待我们输入数据当我们通过键盘输入数据并按Ctrl-d（表示EOF，作用相当于在终端中输入exit后回车）后，它会复制标准输入到标准输出 tac和cat类似，逆序查看 head 从文件头部开始读1234head [OPTION]... [FILE]...-c number 指定获取前number字节-n number-number 指定获取前number行 tail 从文件尾部开始读12345tail [OPTION]... [FILE]...-c number 从尾指定显示number个字符-n number -number 从尾指定显示number行，默认是10行-f 实时显示文件新追加的内容，Ctrl-c退出 more 分页12more [OPTIONS...] FILE...-d 显示翻页及退出提示 less 分页1less [OPTIONS...] FILE... man命令即是以less进行分页的 操作方法123456789101112131415161718192021Space 向文件尾翻屏b 向文件首部翻屏d 向文件尾部翻半屏u 向文件首部翻半屏e 向文件尾部翻一行y 向文件首部翻一行q 退出number 跳转至第number行1G 回到文件首部G 翻至文件尾部文本搜索：/KEYWORD: 以KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索；不区分字符大小写 n: 下一个 N：上一个?KEYWORD:以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索；不区分字符大小写 n: 跟搜索命令同方向，下一个 N：跟搜索命令反方向，上一个]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理04 链接命令]]></title>
    <url>%2Fpost%2F40d56de0.html</url>
    <content type="text"><![CDATA[命令123ln -s [原文件][目标文件] （link）#生成链接文件-s 创建软链接 硬链接 拥有相同的i节点和存储block块，可以看做是同一个文件。（在格式化时，1.将分区划分为等大小的block数据块，该数据块通常为4KB。2.建立分区表，并为每个文件建立一个相关数据。当用户搜索某个文件时，会先到分区表中查找文件所对应的block存储位置，接着到相应位置取出，并返回给用户。）硬链接与原文件拥有相同的i节点。因此，与原文件非常相似。当删除原文件或硬链接文件的任何一文件，不影响文件索引操作。可看做，同一个文件的不通进入点。它是同样的存储空间。 可通过i节点识别（相同的i） 不能跨分区建立 不能针对目录使用，只有文件才可以创建 1234ln ./source/abc ./target/bcd.hard# 创建后，引用计数+1ls -i ./source/abc ./target/bcd.hard# 可使用ls -i 来查看文件i节点号 不建议创建硬链接文件文件太过隐蔽，除了有i节点这样一个标识之外，很难区分它是不是硬链接硬链接限制较多，不能跨分区，不能针对目录，使用当中容易出现错误使用方法 ##软链接 类似于Windows快捷方式 软链接拥有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据。（拥有自己的分区表中索引数据,通过索引找到分区表中文件的目标索引数据，再通过目标索引数据，查找数据） lrwxrwxrwx l软链接， 软链接文件权限都为rwxrwxrwx, 虽然权限显示为777，但实际权限需要看原文件权限。 修改任意文件，另一个都改变 删除原文件，软链接不能使用 创建软链接，原文件一定要写绝对路径。否则，软链接会到它所在的同一目录去找原文件。 软链接的目的是：在不改变原目录/文件的前提下，起一个方便的别名。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理05 文件解压缩命令]]></title>
    <url>%2Fpost%2F3128504e.html</url>
    <content type="text"><![CDATA[常用压缩格式： .zip .gz .bz2 常用解压缩格式： .tar.gz .tar.bz2 .rar格式安装123456#yum无法安装#查看需要下载的版本，https://www.rarlab.com/download.htmwget https://www.rarlab.com/rar/rarlinux-x64-5.6.b4.tar.gztar -zxvf rarlinux-x64-5.6.b4.tar.gzcd rarmake 压缩12#将/etc 目录压缩为etc.rar rar a etc.rar /etc 解压缩12rar x etc.rar unrar -e etc.tar .zip格式安装1yum -y install zip unzip 压缩1234zip 压缩文件名 源文件 #压缩文件zip -r 压缩文件名 源目录 #压缩目录 解压缩12345unzip 压缩文件unzip 压缩文件 -d 指定目录unzip -O cp936 压缩文件#解决文件名乱码 .gz格式压缩123456789gzip 源文件#压缩为.gz格式的压缩文件，源文件消失gzip -c 源文件 &gt; 压缩文件#压缩为.gz格式，源文件保留gzip -c cangls &gt; cangls.gzgzip -r 目录#压缩目录下所有的子文件，但是不能压缩目录 解压缩12gzip -d 压缩文件 gunzip 压缩文件 .bz2格式12yum -y install bzip2#使用之前需要安装 没有安装会出现以下错误1234tar (child): lbzip2: Cannot exec: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now 压缩12345bzip2 源文件 #压缩文件，源文件消失bzip2 -k 源文件 #压缩之后保留源文件 #注意：bzip2命令不能压缩目录 解压缩12bzip2 -d 压缩文件 #解压缩，-k保留压缩文件bunzip2 压缩文件 #解压缩，-k保留压缩文件 打包命令tar123456789101112131415161718192021222324252627282930tar -cvf 打包文件名 源文件 # 压缩为tar格式tar -zcvf 压缩包名.tar.gz 源文件 # 压缩为.tar.gz格式tar -jcvf 压缩包名.tar.bz2 源文件 # 压缩为.tar.bz2格式**参数j、z要放在前边**#解压tartar -xvf 打包文件名 #解压tar格式文件tar -zxvf 压缩包名.tar.gz #解压.tar.gz格式文件tar -jxvf 压缩包名.tar.bz2 #解压.tar.bz2格式文件-c：打包-x：解打包-v：显示过程-f：指定打包后的文件名-z：压缩为.tar.gz格式-j：压缩为.tar.bz2格式其他用法tar -jxvf 打包文件名 -C 绝对路径 #指定解压缩位置tar -zcvf 绝对路径（/tmp/）+打包文件名 源文件 源文件 #将多个文件解压到指定路径tar -ztvf 压缩包文件名 #查看压缩包内文件 参考： https://blog.csdn.net/yonggeit/article/details/72190246]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理03 文件搜索命令]]></title>
    <url>%2Fpost%2F2bff0643.html</url>
    <content type="text"><![CDATA[文件搜索命令 locate123456789locate 文件名#在后台数据库中按文件名搜索，搜索速度更快/var/lib/mlocate (保存的搜索数据库)#locate 命令所搜索的后台数据库#数据库不是实时的，更新频率大概一天更新一次updatedb#更新数据库 对于新建的文件，由于数据库没有更新，使用locate不能查到。可以使用 updatedb强制更新数据库后即可查到。可使用 locate locate搜索locate相关文件，可看到locate数据库。在不同linux中，该数据库名字稍微不同，例如，locatedb、slocate、mlocate。 缺点：只能按照文件名进行搜索，但常用。 配置文件123456789101112131415161718touch /root/canglstouch /tmp/canglsupdatedblocate cangls#显示为 /root/cangls #只有一条，而/tmp下的cangls没有显示出来#原因在于locate搜索遵循配置文件 `/etc/updatedb.conf`#在PRUNEPATHS 中配置了/tmp/目录不进行搜索。所以没有进行查找/etc/updatedb.conf 配置文件PRUNE_BIND_MOUNTS = &quot;yes&quot;#开启搜索限制，yes为后面三项都生效。no为 后面三项都不生效PRUNEFS = #搜索时，不搜索的文件系统PRUNENAMES =#搜索时，不搜索的文件类型PRUNEPATHS =#搜索时，不搜索的路径 文件搜索命令 find.表示当前目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758find [搜索范围][搜索条件]#搜索文件find /home -name 文件名# find搜索默认是完全匹配# 避免大范围的搜索，会非常浪费系统资源# find是在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配find /home -name &quot;[12]*&quot;find /home -name &quot;test[12]&quot;#要加引号*匹配任意内容?匹配任意一个字符[]匹配任意一个中括号内的字符find /home -mtime +10 在home目录下，查找10天前修改的文件find /home -mtime 10 在home目录下，查找10天前当天修改的文件find . -mtime -10 在当前目录下，查找10天内修改的文件# atime 文件访问时间# ctime 改变文件属性# mtime 修改文件内容find . -type f#列出文件find /root -iname test # 不区分要搜索的test大小写格式find /root -user root # -user 按文件所有者搜索# 搜索root目录下的所有属于root用户的文件find /root -nouser #没有所属者的文件，liunx中，每个文件都有所属者，如果没有，那么一般都是垃圾文件，但还是有特例的，比如内核产生的文件，就没有所属者，一般在proc和sys目录下；还有外来文件，也就是U盘拷入的文件也会忽略所有者。find 目录 -size 25k# 查找文件大小是25KB的文件# 注意：文件大小用小写k和大写M# -25k 小于25k# 25k 等于25k# +25k 大于25kfind . -size 25M # 查询当前目录文件大小是25M的文件find /etc -size +20k -a -size -50k # 查找/etc下大于20k并且小于50k的文件# -a and,逻辑与，两个条件都满足# -o or,逻辑或，两个条件满足一个即可find . -type f -perm 644 -exec ls -l &#123;&#125; \;# 查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件find /etc -size +20k -a -size -50k -exec ls -lh &#123;&#125; \;-exec &#123;&#125; \; # 固定格式，表示直接对前面的搜索结果进行后面的命令处理# 注意，&#123;&#125;和\之间有空格，结尾有分号find . -inum 262422 # 查找inode是262422的文件# -inum 查询指定i节点的文件 字符串搜索命令 grep全目录全文搜索1234567891011grep [选项] 字符串 文件名# 在文件中匹配符合条件的字条串# 字符串使用 &quot;&quot; 包围，结果为行记录-i 忽略大小写-v 排除指定字符串/取反-n 显示行号-r 递归grep apple fruitlist.txtgrep -i apple fruitlist.txt #忽略大小写grep -nr apple * #搜索目录里所有文件，包括子目录，并且在结果中显示行号 find命令和grep命令的区别find：在 系统 中搜索符合条件的 文件名，使用 通配符（完全）匹配grep：在 文件 当中搜索符合条件的 字符串，使用 正则表达式 （包含）匹配 通配符（完全）匹配：搜索文件名正则表达式 （包含）匹配：搜索文件中的数据]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件管理02 文件的查看和处理]]></title>
    <url>%2Fpost%2F19cc11d8.html</url>
    <content type="text"><![CDATA[目录主目录，家目录：HOME123root /root普通用户 /home/USERNAME~ 用户的主目录 ls 显示指定路径下的文件列表12345678910ls [选项] [文件或目录]选项-a 显示所有文件，包括隐藏文件-l 显示详细信息-d 查看目录自身的相关属性，通常要与-l一起使用-h 人性化显示文件大小，单位换算-i 显示inode-r 逆序显示-R 递归ll命令表示ls -l tree 显示目录树12345tree选项：-d 只显示目录-L level 指定显示的层级数目-P pattern 只显示由指定pattern匹配到的路径 pwd 显示当前目录（print working directory）cd 切换目录（change directory）1234567891011cd [目录]cd\cd ~ 进入当前用户的家目录cd - 进入上次目录cd . 进入当前目录cd .. 进入上一级目录相关的环境变量：PWD 保存了当前目录路径OLDPWD 上一次所在目录路径 mkdir 建立目录（make directories）12345678mkdir [options] /path/to/somewhere选项：-p 存在时不报错，且可自动创建所需的各目录，当创建多级目录时需加-v 显示详细信息-m MODE 创建目录时直接指定权限mkdir lightmkdir -p imooc/linux/light 12345678# 创建/tmp/x/y1, /tmp/x/y2, /tmp/x/y1/a, /tmp/x/y1/b, /tmp/x/y2/a, /tmp/x/y2/bmkdir /tmp/x/&#123;y1,y2&#125;/&#123;a,b&#125; # 创建x_m, y_m, x_n, y_nmkdir &#123;x,y&#125;_&#123;m,n&#125;# 创建/tmp/bin, /tmp/sbin, /tmp/usr, /tmp/usr/bin, /tmp/usr/sbinmkdir -p /tmp/&#123;bin,sbin,usr/&#123;bin,sbin&#125;&#125; rmdir 删除空目录（remove empty directories）123rmdir [OPTION]... DIRECTORY...-v: 显示过程# 只能删除空目录 文件file 查看文件类型查看文件是文本还是二进制等12file rfc959.txtrfc959.txt: ASCII text stat 查看文件的元数据查看Linux 时间戳管理 rm 删除文件或目录（remove）1234567891011121314rm [选项] [文件或目录] 选项：-r 递归删除，用于删除目录-f 强制删除-i 交互式rm [文件名] 提示是否删除rm -r [目录] 删除目录需加 -r ，目录中含有子文件，将持续询问是否删除rm -rf [目录] 删除目录，不会询问是否删除而直接进行rm -rf /tmp/* 删除tmp目录下的内容rm -rf /tmp/ 删除tmp目录# 纯字符界面没有回收站。注意自杀指令：rm -rf /# 建议：删除文件或目录习惯使用命令 rm -rf [文件或目录] cp 复制命令（copy）12345678910111213141516cp [OPTION]... [-T] SOURCE DESTcp [OPTION]... SOURCE... DIRECTORYcp [OPTION]... -t DIRECTORY SOURCE...选项：-i 交互式-r\-R 递归复制目录及内部的所有内容-p 连带文件属性复制-d 若原文件是链接文件，则复制链接属性，单纯用-d也会报错，因为原文件链接使用相对路径-a 相当于 -pdr 全选--preserv[=ATTR_LIST] mode: 权限、ownership: 属主属组、timestamp: 、links、xattr、context、allcp abc /tmp/ 若目标目录不加文件名，则为原名复制cp abc /tmp/ana 若目标目录后加入文件名，则为改名复制cp -r japan/ /tmp/ 复制目录cp -a japan/ /tmp/ 完全复制，包括所有属性# 被复制文件的时间为执行复制命令的时间，若要使被复制的文件与原文件属性完全一致，需加 -a 源是文件结果一定是有一个文件产生，源是目录结果一定是有一个目录产生123456789101112131415161718cp SRC DEST SRC是文件： 如果目标不存在：新建DEST，并将SRC中内容填充至DEST中； 如果目录存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中； 此时建议为cp命令使用-i选项； 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填充至新文件中； SRC是目录： 此时使用选项：-r 如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中； 如果DEST存在： 如果DEST是文件：报错 如果DEST是目录：复制SRC目录和SRC目录中所有文件至DEST中cp SRC... DEST SRC...：多个文件 DEST必须存在，且为目录，其它情形均会出错； 目标目标文件不存在目标目录不存在文件目录不存在同名存在同名源文件创建目标文件，将源文件内容复制到目标文件报错，先使用mkdir创建目标目录覆盖新建同名文件覆盖目录(-r)报错创建目标目录，将源目录中的文件复制到目标目录报错新建同名目录覆盖 mv 剪切或改名命令（move）123456789mv [OPTION]... [-T] SOURCE DESTmv [OPTION]... SOURCE... DIRECTORYmv [OPTION]... -t DIRECTORY SOURCE...选项：-i 交互式-f 强制mv japan/ /tmp/ 剪切目录时不需加 -rmv abc longls 当原文件与目标目录，在同一目录下，则为改名命令]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装ssh]]></title>
    <url>%2Fpost%2Fed2580b6.html</url>
    <content type="text"><![CDATA[SSH（Secure Shell）安全外壳协议，建立在应用层基础上的安全协议，专为远程登录会话和其他网络服务提供安全性的协议 安装ssh1234567891011121314151617181920212223242526#查看ssh服务是否开启ps -e |grep ssh#安装ssh服务，openssh是ssh的开源实现方式#只要安装了ssh服务，本地linux可以当做服务器sudo apt install openssh-serversudo yum install openssh-server -y#本地安装ssh客户端，可能已经安装sudo apt install openssh-clientsudo yum install openssh-clients -y#配置sshsudo vi /etc/ssh/sshd_configPermitRootLogin yes 把注释去掉#开启ssh服务sudo service sshd startsudo systemctl start sshd.service#开机启动SSH服务sudo chkconfig sshd onsudo systemctl enable sshd.service#连接，端口默认为22，可以不写ssh -p 22 userName@192.168.1.100 使用别名登录ip打开~/.ssh/config，不存在就自己创建一个12345Host AAAAA #服务器主机名 HostName 192.168.0.222 #服务器地址 User work #work为登陆用户名，不是自己电脑的名字 Port 22 #主机端口，默认是22 IdentityFile /home/me/.ssh/id_rsa #自己生成的私钥的文件路径 12#使用别名登录ssh AAAAA 多对ssh管理指定不一样的私钥名1ssh-keygen -t rsa -f ~/.ssh/id_rsa.second 配置~/.ssh/config，在原有的基础上增加新的字段1234567891011# Default github user(first@mail.com) 默认配置，一般可以省略Host github Hostname github.com User git Identityfile ~/.ssh/github# second user(second@mail.com) 给一个新的Host称呼Host secondgithub #主机名字，不能重名 HostName github.com User git IdentityFile ~/.ssh/id_rsa.second #私钥路径 设置SSH免密码登录 生成ssh key 私钥放在本地~/.ssh目录 公钥放在服务器的~/.ssh/authorized_keys 1234567891011121314151617181920212223242526272829#1.客户端本地生成公钥和私钥，rsa是加密方式ssh-keygen -t rsa# ~/.ssh目录中创建两个名为id_rsa和id_rsa.pub的文件，id_rsa是私钥，id_rsa.pub是公钥#2.设置权限chmod -R 700 ~/.sshchmod 600 ~/.ssh/id_rsa #默认就是600#3. 复制公钥到服务器然后写入到~/.ssh/authorized_keys 方法一# 使用SSH远程登陆到服务器,发现家目录中还没有.ssh目录,使用mkdir创建mkdir .ssh# 发送公钥scp ./id_rsa.pub alice@192.168.0.10:/home/alice/.ssh# 将公钥追加写入~/.ssh/authorized_keys中，若authorized_keys不存在，则会创建并写入cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys#修改authorized_keys的权限为600,并删除公钥文件rm id_rsa.pub# 复制公钥到服务器然后写入到~/.ssh/authorized_keys 方法二# ssh-copy-id 命令可以把本地主机的公钥复制到远程主机的 authorized_keys 文件上ssh-copy-id -i ~/.ssh/id_rsa.pub user@serverchmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys#4.配置ssh，如果发现依旧无法连接，考虑是否打开配置sudo vi /etc/ssh/sshd_configRSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 清除SSH的私钥密码12345ssh-keygen -p# 选择需要修改的私钥，默认是/home/username/.ssh/id_rsa# 选好文件后按回车，会提示你输入旧密码。#输入好后会提示输入新密码。#直接回车，提示确认新密码再直接回车，此时指定的私钥的密码就被清除了 SSH相关命令参考 Linux网络管理 远程登录 补充：https://wiki.centos.org/HowTos/Network/SecuringSSH 参考： https://wiki.centos.org/HowTos/Network/SecuringSSH http://www.iosugar.com/2017/02/14/CentOS-remote-login-SSH-configuration/#SSH%E7%99%BB%E9%99%86 http://einverne.github.io/post/2016/06/ssh-copy-id.html https://www.ssh.com/ssh/copy-id https://linux.cn/article-6901-1.html]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理05 虚拟机网络配置详解(NAT、桥接、Hostonly)]]></title>
    <url>%2Fpost%2F67c33d98.html</url>
    <content type="text"><![CDATA[无论是vmware还是virtual box虚拟机软件，一般来说，虚拟机有三种网络模式: Bridged Adapter（桥接模式） NAT（网络地址转换模式） Host-only Adapter（主机模式） virtual box中还有lInternal 虚拟网卡在虚拟机安装好之后，会自动添加两张网卡(VMnet1和VMnet8)，VMnet1用Host-only网络连接，VMnet8用NAT方式的网络连接，原先的VMnet0用桥接网络连接。 桥接桥接网络是指宿主物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的IP地址也要设置为同一网段。会占用内网IP vmnet0实际上就是一个虚拟的网桥(2层交换机)，这个网桥有若干个接口，一个端口用于连接你的Host主机，其余端口可以用于连接虚拟机，他们的位置是对等的，谁也不是谁的网关。 主机A上的两个虚拟机1和虚拟机2，和主机A、B同处于一个网段，能够相互通信 虚拟机网卡配置，虚拟机上网需要IP/子网掩码/DNS/网关12345678DEVICE=&quot;eth0&quot;BOOTPROTO=“static&quot; #设置静态ip,动态为dhcpIPADDR=&quot;192.168.1.3&quot;GATEWAY=&quot;192.168.1.1&quot;HWADDR=&quot;08:00:27:C7:1B:22&quot;DNS1=&quot;8.8.8.8&quot;NETMASK=&quot;255.255.255.0&quot;ONBOOT=&quot;yes&quot; CentOS 7中ONBOOT默认为NO，需要打开 应用场景：虚拟机要求可以上网，且虚拟机完全模拟一台实体机 NATNAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。宿主能够联网，虚拟机也能联网(其他主机)。宿主没有联网，虚拟机也不能联网 vmnet1也是一个虚拟的交换机，交换机的一个 端口连接到你的Host上，另外一个端口连接到虚拟的DHCP服务器上（实际上是vmware的一个组件），另外剩下的端口就是连虚拟机了，主机A和虚拟机1和2能相互通信，虚拟机1和2能访问主机B和外网，主机B不能访问虚拟机1和2，虚拟机1和2能相互通信 虚拟机的配置:12345678DEVICE=&quot;eth0&quot;BOOTPROTO=“static&quot; #设置静态ip,动态为dhcpIPADDR=&quot;10.0.2.5&quot;GATEWAY=&quot;10.0.2.1&quot;HWADDR=&quot;08:00:27:C7:1B:22&quot;DNS1=&quot;10.0.2.1&quot;NETMASK=&quot;255.255.255.0&quot;ONBOOT=&quot;yes&quot; 应用场景：虚拟机只要求可以上网，无其它特殊要求，满足最一般需求 Host-Only所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的 虚拟系统和宿主机器系统是可以相互通信的。虚拟系统的TCP/IP配置信息(如IP地址、网关地址、DNS服务器等)，都是由VMnet1(host-only)虚拟网络的DHCP服务器来动态分配的。 主机和虚拟机之间的通信是通过 VMnet1虚拟网卡来实现的。虚拟机连接到VMnet1上，系统并不为其提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到真正的网络上。 Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。 虚拟机1和2之间可以相互通信，主机A能和虚拟机1和2通信，虚拟机1和2不能和主机通信(需要设置)，虚拟机不能和B主机以及外网通信 使用范围如果你想利用VMWare创建一个与网内其他机器相隔离的虚拟系统，进行某些特殊的网络调试工作，可以选择host-only模式。 内网模式内网模式，顾名思义就是内部网络模式：虚拟机与外网完全断开，只实现虚拟机于虚拟机之间的内部网络模式。 虚拟机与主机的关系：不能相互访问，彼此不属于同一个网络，无法相互访问。虚拟机与网络中其他主机的关系：不能相互访问，理由同上。虚拟机与虚拟机的关系：可以相互访问，前提是在设置网络时，两台虚拟机设置同一网络名称。如上配置图中，名称为intnet。 参考： http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html https://www.jianshu.com/p/305f7384cfe9 https://blog.csdn.net/bytxl/article/details/35569217 https://blog.csdn.net/clevercode/article/details/45934233 http://blog.51cto.com/wangchunhai/381225 https://github.com/waltcow/blog/issues/21 https://blog.csdn.net/guizaijianchic/article/details/72190394]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理04 远程登录]]></title>
    <url>%2Fpost%2Fb979e5b7.html</url>
    <content type="text"><![CDATA[参考 Linux 安装ssh SSH协议原理对称加密算法采用单钥密码系统的加密方法, 同一个秘钥可以同时用作信息的加密和解密, 这种加密方法称为对称加密, 也称为单秘钥加密. 缺点 : 加密解密使用相同密码, 需要告知对方密码, 等同于将自身多方习惯密码告知对方. 例如邮箱等密码, 造成威胁 非对称加密算法asymmetric cryptographic algorithm，又名 “公开秘钥加密算法” , 需要公开秘钥(publickey) 和私有秘钥(privatekey)linux 中为 gpg工具, windows 中为 pgp工具 过程原理, A 需要发送数据包给 B A 根据自己密码A 生成 公钥A 和私钥A B 根据自己密码B 生成 公钥B 和私钥B A 向 B 寻要 公钥B, 再结合自身的公钥A 对数据包进行加密, 并发送给B B 收到数据包之后, 可根据自身密码B 和 私钥B 对数据包进行解密且成功 此时, A 也可以根据自身密码A 结合 私钥A 对已加密的数据包进行解密 至此, 避免了泄露 A 自身的密码 SSH安全外壳协议在非对称加密算法之上演变而来密码足够复杂强壮可降低暴力破解的成功性SSH 保护数据传递过程中的安全, 但若在传递之前中病毒则不可避免通用的远程管理协议 过程原理, A 需要发送数据包给 B A 持有 公钥A 和 私钥A B 持有 公钥B 和 私钥B A 向 B 寻要 公钥B, 再结合自身的 公钥A 对数据包进行加密, 并发送给B B 收到数据包之后, 可根据自身 私钥B 对数据包进行解密 SSH 命令12345ssh 用户名@ip# 远程管理制定Linux服务器# 经过远程之后, 在家目录中的 .ssh 文件夹 know_hosts文件中保存着 连接成功的目标信息# 地址 加密算法 公钥#若目计算机进行了重装系统, 或地址被另一台机器占用, 此时 已下载的公钥无法使用, 使用vi 对改行进行删除, 当再次连接时, 会再次提示是否进行下载公钥 远程管理工具SecureCRT、Xshell WinSCP文件传输工具 FileZilla]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理03 网络配置]]></title>
    <url>%2Fpost%2Fab2af73b.html</url>
    <content type="text"><![CDATA[IP地址配置DHCP服务器可以自动分配IP ifconfig命令临时配置IP地址1234ifconfig查看当前网络状态ifconfig eth0 192.168.254.200 netmask 255.255.255.0临时设置eth0网卡的IP地址与子网掩码 setup工具永久配置IP地址 红帽专有图形化工具setup设置IP地址 CentOS系统中默认就没有setup命令，需要安装12345678910yum -y install setuptool 安装setup命令工具yum -y install ntsysv 安装setup工具配套的系统服务组件yum -y install system-config-securitylevel-tui安装setup工具配套的防火墙配置组件yum -y install system-config-network-tui 安装setup工具配套的网络配置组件yum -y install authconfig-gtk安装setup工具配套的验证配置组件 system-config-network-tui 无法安装，是因为网络设置改到nmtui命令中 修改网络配置文件因为配置文件不光可以配置IP，所以单独开一节 图形界面配置IP地址 修改网络配置文件网卡信息文件 主机名文件1234vi /etc/sysconfig/networkhostname [主机名]# 查看与临时设置主机名命令 DNS配置文件12vi /etc/resolv.conf# nameserver 名称服务器/DNS 虚拟机网络参数配置1.配置LinuxIP地址12setup#修改并配置IP地址 2.启动网卡1234vi /etc/sysconfig/network-scripts/ifcfg-eth0#把 ONBOOT = no改为 ONBOOT = yesservice network restart#重启网络服务 3.修改UUID(如果这是一台克隆/复制出来的机子则必须进行这个步骤，否则可以省去)12345vi /etc/sysconfig/network-scripts/ifcfg-eth0#删除MAC地址行rm -rf /etc/udev/rules.d/70-persistent-net.rules#删除网卡和MAC地址绑定文件#重启动系统 4.设置虚拟机网络连接方式 桥接模式：通过物理机的真实网卡进行通信，若选此项，则虚拟机需要配置与物理机相同的网关，缺点是需要占用真实网段的一个IP地址。这种模式更适用于实验，因为这种模式不仅可以与你的物理机可以通信还可以与同一局域网的其他主机通信，还可以访问公网。 NAT模式：在windows中（物理机中）是以VMware8虚拟网卡进行通信。这种模式只能与你自己的主机通信，不能与局域网的其他主机通信，但是可以通过物理的网卡访问公网。 仅主机模式：在windows中（物理机中）是以VMware1虚拟网卡进行通信。这种模式只能与你自己的主机通信，不能与局域网的其他主机通信，只能与自己的物理机通信，并且不能上公网。 切记：在选择桥接模式之后，需要选择桥接的网卡（即需要确定虚拟机需要通过哪个真实网卡连接网络），一般的虚拟机都是自动桥接，但是这种方式真的跟不靠谱**，所以你需要自己选择，如果你是通过有线接入网络，则选择有线桥接，若是通过无线接入网络，则通过无线接入。 5.修改桥接网卡]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理02 网络命令]]></title>
    <url>%2Fpost%2F9065ef14.html</url>
    <content type="text"><![CDATA[网络环境查看命令123456789101112131415161718192021222324252627282930313233343536373839404142ifconfig# 查看与临时配置网络状态，但无法查看网关和DNS#关闭与启动网卡ifdown 网卡设备名 #禁用该网卡设备ifup 网卡设备名 #启用该网卡设备#查询网络状态netstat 选项选项：一般为tuln或an-t：列出TCP协议端口-u：列出UDP协议端口-n：不使用域名与服务名，而使用IP地址和端口号-l：仅列出在监听状态的网络服务-a：列出所有的网络连接#统计计算机建立的远程连接数netstat -an | grep ESTABLISHED | wc -l#查看网关netstat -rn 选项：-r：列出路由表，功能和route命令一致。route -n #查看路由列表(可以看到网关)route add default gw 192.168.1.1#临时测定网关#域名解析命令nslookup [主机名或IP] #进行域名与IP地址解析，域名对应哪个IPnslookup&gt;server #本地设定的DNS的地址&gt;exit #退出 在一台服务器里，连接内网的网卡是不能设置网关的，只有连接外网的网卡才能设置，而且这个网关是由运营商设置好 它告诉我们的下一级网络地址。 随便设置一个网关是不行的，因为与外网通信时，要把消息转发到网关，网关负责把内网IP转换成功公网IP，随便设置则将找不到这个网关，导致呈现网络连接失败状态。 网络测试命令123456789101112131415161718192021222324252627282930ping [选项] ip或域名 #探测指定IP或域名的网络状况选项：-c 次数：指定ping包的次数telnet [域名或IP] [端口] #远程管理与端口探测命令，明文传递telnet 192.168.0.252 80#如果连接成功，将会进入连接状态，按ctrl+]退出到telnet，再键入quit返回命令行状态traceroute [选项] IP或域名 #路由跟踪命令，查看中间所经过的节点，故障定位。选项：-n 使用IP，不使用域名，速度更快#和ping一样都是利用的ICMP协议（Internet Control Message Protocol）Internet控制报文协议#家用网络大多数结点都禁止ping，就是*，可以根据路由来分析哪些结点出现了问题wget http://soft.vpser.net/lnmp/lnmp1.1-full.tar.gz #下载命令tcpdump -i eth0 -nnX port 21抓取eth0网卡上的数据包，以16进制拆分数据包(用port 21可以只拆分21端口)选项：-i：指定网卡接口-nn：将数据包中的域名与服务转为IP和端口-X：以十六进制和ASCII码显示数据包内容port：指定监听的端口 ftp也是明文：用来上传下载文件，默认是不允许用户登陆的 http都是明文，一旦截获了数据包，就能直接获取里面的数据 https才是加密的]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux网络管理01 网络基础]]></title>
    <url>%2Fpost%2F408bec44.html</url>
    <content type="text"><![CDATA[OSI模型开放系统互联模型，由ISO(国际标准化组织) 组织开发的 该模型为基础模型, 而实际中常用的TCP/IP模型是由七层模型演变的 上三层(应用层、表示层、会话层)是对用户提供服务, 下四层(传输层、网络层、数据链路层、物理层)对数据传输提供服务 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 70% ; } table th:nth-of-type(3){ width: 20%; } 层级 作用 传输单元 应用层 用户接口 APDU，应用协议数据单元 表示层 数据的表现形式（ASCII、GB2312、jpg）、 特定功能的实现如加密、压缩 PPDU，表示协议数据单元 会话层 对应用会话的管理、同步。 确定网络数据是否要经过远程会话 SPDU，会话协议数据单元 传输层 确定可靠与不可靠的传输（ TCP传输控制协议可靠不会丢、UDP用户数据报协议更快但可能会丢）、传输前的错误检测、 流量控制、 确立端口号, 便于通过IP确定主机后, 通过端口确定交互的服务 TPDU，传输协议数据单元 网络层 负责提供逻辑地址(IP地址, 需要写入发件人IP与收件人IP）、 选择通路。 （确定IP地址，原IP、目地IP） 报文 数据链路层 负责组成帧(组入MAC信息)，用MAC地址访问媒介（源地址&amp;目的地址）、错误的检测与修正。物理地址，就是计算机MAC地址，也就是计算机网卡地址。每一台电脑都有一个网卡地址，MAC地址负责局域网通信，IP地址负责外网通信。 帧 物理层 设备之间比特流的传输（ 最基本的数据传递）、物理接口（ 网线口、视频口、音频口）、电气特性（ 网线8根线中的1、3、2、6四根线传输数据） 比特流 举例场景 用户A需要给用户B发送一份邮件 应用层 : 浏览器进入邮箱, 写邮件, 点击发送, 数据将传递至 表示层 表示层 : 进行的数据的编码, 而后数据传递至会话层 会话层 : 判断数据的发送类型, 是进行网络传输还是进行本地保存, 若是进行传输 传递至传输层 传输层 : 确立协议TCP或UDP, 写入邮件的发送及目标端口号, 传递至网络层 网络层 : 写入自身及目标IP地址, 传递至数据链路层 数据链路层 : 写入源MAC地址与目标MAC地址, 由于IP地址找到局域网, 再通过MAC地址在局域网中找到目标, 传递至物理层 物理层 : 数据传输 TCP/IPTCP/IP 四层模型与 OSI 七层模型对应关系 应用层 : 应用层、表示层、会话层为用户提供所需的各种服务, 例如 FTP、Telnet、DNS、SMTP等 传输层 : 传输层负责为应用层实体提供端到端的通信功能, 保证了数据包的顺序传送及数据的完整性, 该层定义了两个主要的协议 : 传输控制协议(TCP)可靠的面向连接，不会丢失，类似打电话，网页、邮件 和 用户数据报协议(UDP)不可靠的面向无连接,有可能丢失, 类似发短信、QQ 网际互联层 : 网络层主要解决主机到主机的通信问题, 它所包含的协议涉及数据包在整个网络上的逻辑传输, 该层有三个主要协议 : 网际协议(IP), 互联网组管理协议(IGMP), 互联网控制报文协议(ICMP) 网络接口层 : 数据链路层、物理层负责监视数据在主机和网络之间的交换, 事实上, TCP/IP本身并未定义该层的协议, 而由参与互连的各网络使用自己的物理层和数据链路层协议, 然后与TCP/IP的网络接入层进行连接. 地址解析协议(ARP) 工作在此层, 即OSI参考模型的数据链路层.地址解析协议(ARP) : 将IP地址 翻译成物理地址 数据封装过程发送是由上至下进行打包, 接收是由下至上进行拆包 TCP/IP 模型与OSI 模型的比较共同点 OSI 参考模型和 TCP/IP参考模型都采用了层次结构的概念 都能够提供面向连接和无连接两种通信服务机制 不同点 OSI 七层, TCP/IP 四层 对可靠性要求不同(TCP/IP 更高) OSI 模型是在协议开发前设计的, 具有通用性. TCP/IP 是先有协议集, 然后建立模型, 不适用与非TCP/IP网络 实际市场应用不同( OSI 模型只是理论上的模型, 并没有成熟的产品, 而TCP/IP已经成为”实际上的国际标准”) IP地址IP包头(如图)横32位, 竖5行, 固定的共160位, 20字节, 另外有其他选项存在, 导致包头不固定, 因此每接收到包头, 需要进行检测包头长度才能够取出包头, 也是为何IPv4没有IPv6快的原因 包头中包含的IP地址只有32位, 即2的32次幂, 42亿9千万左右的IP IP地址分类IP分为A、B、C、D、E 五大类, 其中DE不对民用组织开放, 不可使用, 因此有效类只有ABC可根据第一位数值判断类别, 1-126 为A类, 128-172 为B类, 192-223 为C类 127.0.0.1 为本机 第一位表示不同网段, 不同网络, 不同网络之间的通信需要使用路由器，路由器是用来实现跨网络通信的, 同一网络下通信使用交换机即可. 第一位不变情况下, 后三位的变化都代表同一网络下的不同主机 A 类 : 每个网络中的第一个地址(X.0.0.0)代表网络本身,最后一个地址(X.255.255.255)代表当前网络的广播地址, 不能分配, 最大主机数 : 后三位的次幂, 减 第一和最后一个 , 2^24 -2 B 类 : 前两位代表网段, 后两位代表网段中的不同主机 C 类 : 前三位代表网段, 最后一位代表不同主机 私有IP : 不需要花钱买, 用来做内网IP, 可有效保护公网IP, 不能直接访问公网, 需要与公网之间进行转换才可访问互联网 子网掩码ABC类可以用不同的网段个数和主机个数, 是由子网掩码决定子网掩码用连续1的表示，例如255.0.0.0，255.255.0.0，255。255.255.255.0 子网掩码的作用：用来区分不同网段的IP—-子网掩码与IP相与，得到的结果相同则在同一网段。否则不在，需要经过路由器转发。 合理的子网掩码 : 所有的1必须连续, A 类地址可匹配B类子网掩码 IP和子网掩码必须一起配合使用。网络号=IP&amp;&amp;子网掩码 广播地址：主机号全为1,广播地址是专门用于同时向网络中所有工作站进行发送的一个地址 合理的子网掩码 : 所有的1必须连续, A 类地址可匹配B类子网掩码 端口 1234netstat -an# 查看本机启用的端口#-a:查看所有连接和监听端口#-n:显示IP地址和端口号，而不显示域名和服务名 TCP因为3次握手的机制所以需要监听，而UDP不需要监听 常见端口号 FTP（文件传输协议）：20、21； SSH（安全shell协议）：22； telnet（远程登录协议）：23； DNS（域名系统）：53； http（超文本传输协议）：80； SMTP（简单邮件传输协议）：25； POP3（邮局协议）：110； DNShosts和DNShosts文件：做静态IP和域名对应，优先于DNS.位置：C：\Windows\System32\drivers\etc\hosts/etc/hosthosts文件只可做临时解析用，名称解析效能下降，主机维护困难 DNS全称为——&gt;domain name system——&gt;域名系统 不配置DNS是不能联网的。 在互联网中，通过IP地址来进行通信。 IP地址是用数字来表示的，记忆起来太困难了(如116.213.120.232) 人对域名更加敏感，:http://www.imooc.com/ DNS服务的作用:将域名解析为IP地址过程：客户机向DNS服务器发送查询IP请求DNS服务器查询到web服务器的ip，告知用户用户访问web服务器 域名空间结构根域：.（13台服务器）——&gt;顶级域/一级域：包括组织域和地区域（组织域：gov政府/edu教育部门/com商业部门/org民间团体/net网络服务机构/mil军事部门 地区域：cn 中国 hk 香港 jp 日本 Uk 英国 au 澳大利亚）——&gt;二级域：企业或个人自行购买的（imooc /microsoft/ibm/sina）——&gt;主机名/3级域：申请完二级域后自己定义的（www/news） 三级域（www）+二级域（baidu）+顶级域（.com）组成完整域名空间 为什么要进行域名分级划分便于IP地址解析 DNS查询过程DNS客户机——&gt;本地域名服务器——&gt;根DNS服务器——&gt;cn服务器——&gt;com.cn服务器——&gt;imooc.com.cn——&gt;本地域名服务器——&gt;DNS客户机——&gt;web服务器www.imooc.com.cn DNS查询类型从查询方式上分 递归查询：客户机将请求发送给DNS服务器，服务器通过缓存或者询问其他服务器最后将一个准确的结果或者失败回复给客户机，客户机只负责问，所有事情都是服务器做。客户机对本地域名服务器查询的机制，必须反馈准确值（要么成功要么失败） 迭代查询：客户机像DNS服务器发送请求后，服务器向客户机返回另一个服务器的地址，客户机不停地向不同DNS服务器发送请求，所有事情都自己做。本地域名服务器分别对各级域名服务器的查询机制，不一定反馈准确值 从查询内容上分 正向：域名到IP ARP 反向：IP到域名 RARP 网关 网关（Gateway）又称网间连接器、协议转换器 网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层不同的网络互连 网关既可以用于广域网互连，也可以用于局域网互连 网关是一种充当转换重任的服务器或路由器 交换机不能识别ip，只能记录客户机的MAC地址。即只能在局域网中进行通信 访问不同网段，则需要引入网关。 网关：一个具有路由功能的设备，一般为路由器。 网关作用 网关在所有内网计算机访问的不是本网段的数据包时使用 把内网Ip转公网Ip，公网Ip转内网Ip]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 安装、卸载wine]]></title>
    <url>%2Fpost%2F8d5353b1.html</url>
    <content type="text"><![CDATA[安装1234sudo add-apt-repository ppa:wine/wine-buildssudo apt-get updatesudo apt-get install --install-recommends wine-stagingsudo apt-get install winehq-staging 卸载1234567sudo apt purge winerm -r ~/.winesudo apt-get autoremove#清理wine模拟运行的windows程序:sudo rm -r /home/username/.local/share/applications#清理残余的windows程序:sudo rm -r /home/username/.config/menus/applications-merged/wine* apt-get remove 会删除软件包而保留软件的配置文件 apt-get purge 会同时清除软件包和软件的配置文件]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用配置文件]]></title>
    <url>%2Fpost%2F6faff17a.html</url>
    <content type="text"><![CDATA[apt 源相关文件、目录12345/var/lib/apt/lists #ubuntu软件更新的源服务器的地址/etc/apt/sources.list#*.list文件在单独文件中写入源的地址，通常用来安装第三方的软件/etc/apt/sources.list.d yum 源1/etc/yum.repos.d/CentOS-Base.repo MySQL12/etc/mysql/my.cnf/etc/my.cnf 安装日志1234567/root/install.log #记录安装系统软件包以及其文件信息/root/install.log.syslog #记录安装过程留下来的事件记录/root/anacona-ks.cfg #以kickstart配置文件的格式记录安装过程中设置的选项信息#当要安装多台服务器时，可以先装一台，然后利用/root/anaconda-ks.cfg可以进行批量安装 网络配置123456/etc/sysconfig/network-scripts/ifcfg-eth0#网卡配置文件，IP/子网掩码/网关/DNS/ONBOOT/etc/sysconfig/network#设置主机名/etc/resolv.conf#DNS配置文件 用户管理12345678/etc/group #存储当前系统中所有用户组的信息/etc/gshadow #存储当前系统中用户组的密码信息/etc/passwd #存储当前系统中所有用户的信息/etc/shadow #存储当前系统中所有用户的密码信息 计划任务123456/etc/crontab #系统配置文件，只有root用户才会把这些内容载入到计任务表中/var/spool/cron #最终生成的计划任务文件/var/spool/cron/root #root用户的定时任务/var/spool/cron/user1 #user1用户的定时任务/var/log/cron #crontab日志，保存cron的任务执行记录，echo会打印到这里 /var/log/cron-日期 别名、历史123~/.bashrc/root/.bashrc/etc/bashrc 用户和用户组12/etc/login.defs #提供了几个用户帐户参数的缺省配置信息/etc/default/useradd #新建用户的默认配置]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下无法使用add-apt-repository命令]]></title>
    <url>%2Fpost%2F5ff43231.html</url>
    <content type="text"><![CDATA[Linux下无法使用add-apt-repository命令报错：add-apt-repository command not found 解决办法：12sudo apt install python-software-properties software-properties-common sudo apt update]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装JDK的两种方式]]></title>
    <url>%2Fpost%2F9df44923.html</url>
    <content type="text"><![CDATA[使用PPA源安装1234sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installersudo apt-get install oracle-java8-set-default oracle-java8-set-default：将jdk8设置为默认的Java运行版本 默认的安装路径是在/usr/lib/jvm/java-8-oracle中1echo $JAVA_HOME 使用源码包安装1uname -a #查询系统是32位还是64位 在http://www.oracle.com/technetwork/java/javase/downloads/index.html找需要的包下载 1234567891011sudo tar -zxvf ./jdk-8u171-linux-x64.tar.gz -C /usr/local/jdk1.8.0_171sudo vim /etc/profile#在文件的末尾追加下面行JAVA_HOME=/usr/local/jdk1.8.0_171PATH=$JAVA_HOME/bin:$PATH CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar export PATH JAVA_HOME CLASSPATH #使环境变量马上生效source /etc/profile #设置系统默认jdk 版本 卸载Java JDK12rpm -qa |grep jdkyum -y remove java java-1.6.0-openjdk-1.6.0.0-1.50.1.11.5.el6_3.x86_64 将上面查询出来的每个版本依次删掉即可。]]></content>
      <tags>
        <tag>Linux应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理05 脚本安装包]]></title>
    <url>%2Fpost%2F23683a56.html</url>
    <content type="text"><![CDATA[脚本安装包：准备工作1、本节以安装LNMP为例，所以需要先停止之前安装的apache和mysql服务（最好也将源码包安装的apache /usr/local/apache2删除） 2、保证yum源正常使用：可以使用yum list命令测试。（若是光盘yum源，记得挂载光盘） 3、关闭SELinux和防火墙： 永久关闭SELinux的方法：编辑文件/etc/selinux/config，将SELINUX=enforcing改为SELINUX=disabled，然后重启系统即可。 永久关闭防火墙的方法：chkconfig iptables off，开启为：chkconfig iptables on；临时关闭防火墙的方法：service iptables stop，开启为：service iptables start。 脚本安装1wget -c http://soft.vpser.net/lnmp.lnmp1.0-full.tar.gz &amp;&amp; tar zxvf lnmp1.0-full.tar.gz &amp;&amp; cd lnmp1.0-full &amp;&amp; ./centos.sh 脚本安装过程中，会将系统中已有的apache、mysql、php等卸载掉。 虚拟机中安装lnmp常常会卡在 starting php-fpm,真实环境中很少出现。其实安装已经完成，只需要杀掉php-fpm进程，再重新启动这个进程就好了 pkill -9 php-fpm : -9是强制杀死的意思，然后重新启动该进程【/etc/rc.d/init.d/php-fpm start】即可。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理04 源码包]]></title>
    <url>%2Fpost%2Fc064f8f9.html</url>
    <content type="text"><![CDATA[源码包和RPM包安装位置的不同：RPM包安装位置rpm包有安装的默认位置： /etc/ 配置文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib/ 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 当然RPM包可以指定安装位置，但是建议不要指定安装位置，就让它安装到默认位置，这样系统可以找到它，利用service XXX start的方式启动它，而且rpm提供-e选项来自动卸载，摆明了就是推荐你让它默认安装1rpm -ivh --profix=&lt;dir&gt; 源码包安装位置安装在指定位置当中，一般是/usr/local/软件名，源码包没有卸载命令 安装位置不同带来的影响rpm包安装的服务可以使用系统服务管理命令（service）来管理，例如： RPM包安装的apache的启动方法是：12/etc/rc.d/init.d/httpd start service httpd start 源码包安装的服务不能被服务管理命令管理，因为没有安装到默认路径中，所以只能用绝对路径进行服务的管理，不同软件请参考INSTALL或README，如：1/usr/local/apache2/bin/apachectl start 使用绝对路径启动程序的方法是通用的，通常软件包中会写上启动程序的方法的。 如果将源码包安装后的启动程序复制到/etc/rc.d/init.d目录中，则也是可以使用service命令执行的 源码包是不能使用service命令来启动服务，因为源码包的安装位置由用户指定，放在哪并不统一；rpm包安装后，通常都是放在/etc/rc.d/init.d目录中的，而service命令执行时，会自动搜索该目录，所以rpm包安装的服务可以使用service命令 安装安装准备 由于源码都是c语言写的，所以要先安装c语言编译器：gcc 从官方网站下载源码包，若是下载到了windows上面，可以使用ftp传到linux上 注：若已安装了二进制包，则源码包也是可以继续安装的，因为两者安装目录不一样。但是，并不建议这样做，因为端口会冲突。 对于要求效率的软件，要安装源码包版本，因为是本机编译，更具有兼容性和效率，而rpm包是软件开发者提供的大众版本，可用于不注重效率的应用。 netstat -tlun查找网络连接信息和系统开启的端口号使用 -t 选项列出 TCP 协议的连接使用 -l 选项列出正在监听的套接字使用 -u 选项列出 UDP 协议的连接使用 -n 选项禁用域名解析功能 安装注意事项 源代码一般保存位置：/usr/local/src 软件安装位置：`` 如何确定安装过程报错 安装过程停止 并出现error、warning、no的提示 安装步骤123456789101112#下载源码包wget http://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.33.tar.gz#解压缩tar -zxvf httpd-2.4.33.tar.gz#进入解压缩目录cd httpd-2.4.33#软件配置与检查，指定安装位置./configure --prefix=/usr/local/apache2#编译，根据当前目录下的Makefile内部信息编译make#编译安装，根据当前目录下的Makefile内部信息安装make install ./configure作用 定义需要的功能选项； 检测系统环境是否符合安装要求 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。 其中的apache2目录不需要提前创建，make install命令执行时会自动创建 解压的文件夹中有一个INSTALL或README文件，vi打开之就可以看到详细的安装说明了。 如果make环节出错，只需要make clean即可。如果make install安装环节出错，我们就得删除configure时制定的安装目录，因为其中生成的文件失效了。 源码包的卸载只需要把安装目录删除即可。因为安装过程中生成的所有文件都是存放在安装目录中的，所以将安装目录删除就不会留下任何垃圾。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理03 yum在线安装]]></title>
    <url>%2Fpost%2Fd361ed04.html</url>
    <content type="text"><![CDATA[yum源文件将所有软件包放到官方服务器上，当进行yum在线安装时，可以自动解决依赖性问题。（rpm缺点：安装过程中，rpm包依赖性太强） RedHat的yum是收费服务，而CentOS的yum是免费服务。 在/etc/yum.repos.d/目录中，默认有4个yum源文件，其中CentOS-Base.repo是基本yum源文件，如果我们能上网，那它是默认生效的，而其他的都是默认不生效的。 mirrorlist和baseurl一个是主站点，一个是辅助站点，代表内容一样，只写一个就行，可以修改为国内的源 gpgcheck：一般都要开启，开启后安装时会验证rpm包是否是官方的，以保证系统安全。 gpgkey：默认系统安装后，在目录/etc/pki/rpm-gpg下都会存在数字证书。 注：前面的file://表示文件协议，后面的/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6是数字证书的位置。1234567[root@CentOS6 ~]# cd /etc/pki/rpm-gpg[root@CentOS6 rpm-gpg]# ll总用量 16-rw-r--r--. 1 root root 1706 11月 27 2013 RPM-GPG-KEY-CentOS-6-rw-r--r--. 1 root root 1730 11月 27 2013 RPM-GPG-KEY-CentOS-Debug-6-rw-r--r--. 1 root root 1730 11月 27 2013 RPM-GPG-KEY-CentOS-Security-6-rw-r--r--. 1 root root 1734 11月 27 2013 RPM-GPG-KEY-CentOS-Testing-6 光盘搭建yum源如果没有网络，可以使用光盘 123456789101112131415161.挂载光盘mkdir /mnt/cdrom#建立挂载点mount /dev/cdrom /mnt/cdrom#挂载光盘2.使网络yum源失效 cd/etc/yum.repos.d/#进入yum源目录mv CentOS-Base.repo CentOS-Base.repo.bak#修改Yum源文件后缀名，使其失效；（判断yum源是根据后缀名repo来实现的，修改后缀名则可以使该yum源失效）3.使光盘yum源生效 yum命令查询1234567891011121314yum list# 查询所有可用软件包列表yum search 关键字# 搜索服务器上所有和关键字相关的包yum search ifconfig#可以得知ifconfig命令来自包net-tools.x86_64yum info xxx#软件包信息yum clean packages#清理缓存 安装12yum -y install 包名（只用包名即可）# -y 自动回答yes 升级12yum -y update 包名# -y 自动回答yes 卸载123yum -y remove 包名# -y 自动回答yes# 服务器使用最小化安装，用什么软件安装什么，尽量不卸载 yum软件组管理命令12345678910111213yum grouplist #列出所有可用的软件组列表 yum groupinstall 软件组名 #安装指定软件组，组名可以由grouplist查询出来 yum groupremove 软件组名 #卸载指定软件组 软件组名必须是英文LANG=en_US 临时更改语系为英文 LANG=zh_CN.utf8 临时生效 /etc/sysconfig/i18n中 修改配置文件永久生效 换源1234567mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupcd /etc/yum.repos.d/#https://mirrors.163.com/.help/centos.html，选择相应版本的centos源wget http://mirrors.163.com/.help/CentOS7-Base-163.repoyum makecacheyum -y update]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理02 RPM包管理]]></title>
    <url>%2Fpost%2F477f7d2e.html</url>
    <content type="text"><![CDATA[RPM包的来源所有RPM包都来自安装系统光盘的Packages目录中 RPM包命名规则 包全名：操作的包是没有安装的软件包时，使用包全名，而且要注意路径 包名：操作已安装的软件包时，使用包名，是搜索/var/lib/rpm/中的数据库 RPM包依赖性 树形依赖：a-&gt;b-&gt;c 解决方法：从后往前安装 环形依赖：a-&gt;b-&gt;c-&gt;a 解决方法：放在一条命令中安装即可 模块依赖：库文件依赖，库也叫模块，就是linux当中的函数，它有一个典型的特征，就是以.so.数字结尾，它依赖的其实是一个文件，而不是软件包。该文件藏身在某一个软件包当中。我们只要将该文件所在的软件包安装上，该文件也就安装了。解决方法：登录www.rpmfind.net 网站，输入库文件名称查询到对应的rpm包，然后安装即可。 RPM安装12345rpm -ivh 包全名# -i （install）安装# -v（verbose）显示详细信息# -h（hash）显示进度# --nodeps不检测依赖性（一般不用） RPM 升级12rpm -Uvh 包全名# -U（update）升级 需要包全名，而不是包名。可以如此理解：升级时的新包对于系统是新的，因此要包全名 如果这个包从来没有安装过，那么效果等同于rpm -ivh 包全名 RPM卸载123rpm -e 包名# -e（erase）卸载# --nodeps 不检查依赖性 rpm准备了这个卸载命令的原因是，我们安装时根本不知道这个包装了在哪里（要知道linux下的安装的软件的文件散布多个地方的，很难一一找），而rpm知道，所以干脆就为我们准备了这条便利的命令。 window下卸载软件，往往容易留很多垃圾数据难以除完，例如注册表等等。而linux中不会出现这个问题，只要把软件的安装目录所有都删除掉，就不会有残留。 RPM包查询1234567891011121314151617181920212223242526272829303132rpm -q 包名# 查询包是否安装# -q 查询（query）rpm -qa 包名# 查询所有已经安装的RPM包# -a 所有（all）# rpm -qa | grep httpdrpm -qi 包名# 查询软件包详细信息# -i (infomation) : 查询软件信息rpm -qip 包全名# -p (package) : 查询未安装报信息# 有时遇到问题, 可根据未安装包信息中所提供的网站进行查询资料rpm -ql 包名# 查询包中文件安装位置# -l (list) : 列表# -p (package) : 查询未安装包信息# 可查看包作者欲将包安装的位置rpm -qf 系统文件名# -f (file) : 查询系统文件属于哪个软件包# 查询系统文件属于哪个 RPM 包# 该文件必须是通过 RPM 包安装的rpm -qR 包名# 查询软件包的依赖性# -R (requires) : 查询软件包的依赖性 # -p (package) : 查询未安装包的信息 RPM包默认安装位置 RPM包校验1234rpm -V 已安装的包名# -V (verify) : 校验指定RPM包中的文件# 执行后, 无任何提示, 代表该文件没有被做任何修改# 判断本地的安装包与官方给出的是否一致, 从而判断是否被人修改 验证内容中的8个信息 S : 文件大小是否改变 M : 文件的类型或文件的权限( rwx )是否被改变 5 : 文件MD5 校验和是否改变( 可以看成文件内容是否改变 ) D : 设备的主从代码是否改变 L : 文件路径是否改变 U : 文件的属主( 所有者 ) 是否改变 G : 文件的属组是否改变 T : 文件的修改时间是否改变 验证内容中的文件类型 c (config file) : 配置文件 d (documentation) : 普通文档 g (ghost file) : “鬼”文件, 很少见, 就是该文件不应该被这个RPM包包含 L (license file) : 授权文件 r (read me) : 描述文件 MD5校验用来校验文件的完整性(文件内容是否被改变) 例如, 在官网下载的游戏, 官方会给出MD5校验码, 将下载的游戏通过专用的MD5校验工具校验后生成一份MD5校验码, 对比两份校验码是否一致, 不一致则说明，下载的文件可能丢包, 可能文件损坏, 可能被其他人动过手脚一直木马等 RPM包中的文件提取1rpm2cpio 包全名 | cpio -idv .文件绝对路径 前面的.代表当前路径，不能省略。 文件绝对路径和包里文件的绝对路径对应，也就是告诉了cpio要去包里提取哪个文件。 cpio只知道提取文件，并不知道要从什么地方提取文件，因此我们通常要使用|管道符或&lt;输入重定向告诉cpio我们应该从什么设备去取出文件。 12345cpio 选项 &lt; [文件|设备]# 使用输入重定向的cpio# -i：copy-in模式，还原# -d：还原时自动新建目录# -v：显示还原过程]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux安装管理01 软件包分类]]></title>
    <url>%2Fpost%2Ff062c1ba.html</url>
    <content type="text"><![CDATA[二进制包是经过源码包编译过的安装包，编译就是将源码解释为机器可以认识的二进制语言的过程，安装源码包比二进制包复杂，因为要经过一个编译的过程，这个过程容易出错，一旦出错，就要对源码进行修改。 在redhat中二进制包后缀是rpm，在debian系列里如ubuntu二进制包的后缀是deb，但是它们都是二进制包。Linux下安装软件只有俩种格式：二进制包和源代码包 源码包优点 开源，如果有足够的能力，可以修改源代码 可以自由选择所需的功能 软件是编译安装，所以更加适合自己的系统，更加稳定、效率更高 卸载方便（直接删除） 缺点 安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误 编译过程时间较长，安装比二进制安装时间长 因为是编译安装，安装过程中一旦报错新手很难解决 二进制包（RPM包、Deb包）二进制包安装速度快是它的优点，但是二进制包不是系统自己编译的，效率不如源码包。如果是生产环境，就要源码包安装，因为效率高。 优点 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 安装速度比源码包安装快的多 缺点 经过编译，不再可以看到源代码 功能选择不如源码包灵活 依赖性 脚本安装包把复杂的软件包安装过程写成了程序脚本，初学者可以执行脚本实现一键安装。但实际安装的还是源码包和二进制包,例如LAMP一键安装包 优点：安装简单、快捷 缺点：完全丧失了自定义性，不能定义安装软件的版本，不能定义所需要的软件功能，源码包的优势几乎完全丧失]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理06 chattr、lsattr]]></title>
    <url>%2Fpost%2F2ce6014e.html</url>
    <content type="text"><![CDATA[作用禁止修改某些重要的系统文件 使用条件 所支持的文件系统包括：ext2、ext3、ext4和xfs 一般要求内核版本不低于2.2(查看版本的命令如下：uname -a、lsb_release -a 不能保护 /、/tmp 、/dev、/var目录 chattr只能由root用户使用 chattr类似于chmod, chmod只是改变文件的读写、执行权限，更底层的属性控制是由chattr来改变的.1234567891011121314chattr [+-=] [选项] 文件或目录名* +：增加权限* -：减少权限 * =：等于某权限* a：即append * 如果对文件设置a属性，那么只能在文件中增加数据，不能删除也不能修改数据（不能使用vi，因为不能判断是增加还是修改，可以使用echo） * 如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除* i：即insert * 如果对文件设置i属性，那么不允许对文件进行删除、改名、设定链接关系，同时不能写入或新增内容 * 如果对目录设置i属性，那么只能修改目录下文件的数据，不允许建立和删除文件chattr +a abcchattr +i abc lsattr查看文件系统属性1234lsattr [选项] [文件名]* -a：列出目录下的所有文件，包括隐藏文件* -d：查看本目录自身的权限 参考： http://www.cnblogs.com/Jimmy1988/p/7265816.html https://www.imooc.com/video/9667]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理05 SUID、SGID、SBIT]]></title>
    <url>%2Fpost%2F271a6e14.html</url>
    <content type="text"><![CDATA[SUID(SetUID)使用户临时具有程序所有者（比如root）的权限来执行该程序，比如调用/usr/bin/passwd命令修改自己的密码 SetUID(或者 s 权限）：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然 “灵魂附体” 了，实际在以passwd命令所有者root的身份在执行，root当然可以将密码写入/etc/shadow文件，命令执行完成后该身份也随之消失。当然用户的passwd命令不能修改其他用户的密码，只能输入passwd来修改自己的密码 使用要求 只有可执行的二进制程序才可以设置SetUID 命令执行者必须对欲设置SetUID的文件具备可执行(x) 权限，没有x的文件会成为S，S不能正确使用，只有s可以正确使用 命令执行过程中，其它用户获取所有者的身份（灵魂附体） SetUID具有时间限制，即完成该程序执行后就消失 不能对目录使用 命令4代表SUID，s出现在文件所有者的x权限上 1234567#设置SetUIDchmod 4755 文件名chmod u+s 文件名（推荐，不影响其他权限）#取消SetUIDchmod 0755 文件名chmod u-s 文件名（推荐，不影响其他权限） 例程以普通用户执行12345678910ll /usr/bin/touchtouch test1sudo chmod u+s /usr/bin/touchll /usr/bin/touchtouch test2ll test1 test2#比较前后两次的属性差异-rw-rw-r--. 1 niesh niesh 0 7月 30 17:40 test1-rw-rw-r--. 1 root niesh 0 7月 30 17:42 test2 可以看到，在设置了SetUID之后，新建文件的所有者为root了，说明在执行touch的时候，用户自动升级为了所有者 危险性设置SetUID是具备很大危险性的，主要是设置权限过大而引起的问题我们需要定时查看系统中有哪些设置了SetUID权限 关键目录应严格控制写权限。比如 /、/usr 用户的密码设置要严格遵循密码三原则(#复杂性，易记忆性，时效性） 对系统中默认应该具有SetUID权限的文件做一个列表，然后定期检查有没有这之外的执行程序的命令文件被设置了SetUID 使用shell定期检查SetUID12345678910111213#!/bin/bashfind / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.checkfor i in $(cat /tmp/setuid.check)do grep $i /root/suid.log &gt; /dev/null if [ &quot;S?&quot; !=&quot;0&quot;] then echo &quot;$i isn&apos;t in listfile!&quot; &gt;&gt; /root/suid_log_$(date+%F) fidonerm -rf /tmp/setuid.check SGID(SetGID)SetGID基本与SetUID相同，SetUID是设置所有者的权限，SGID为设置所属组的权限区别点在于：SetGID也可以设置目录的相关SetGID权限 作用将用户所在组临时升级为某一个组，以执行只有该组才有相应权限进行的操作 使用要求 针对文件： 可执行的二进制文件 命令执行者（即所属组）对该文件具备 x 权限 命令执行者在执行程序的时候，组身份升级为该程序文件的属组 权限只在执行过程中有效 针对目录： 普通用户对目录具备r和x权限，才可以进入到该目录 普通用户在此目录中的有效组会变成此目录的所属组 如普通用户对该目录具备w权限，新建文件的所属组为该目录的所属组 命令2代表SGID，s出现在文件所属群组的x权限上1234567#设置SetGIDchmod 2xxx &lt;file/dir-name&gt;chmod g+s &lt;file/dir-name&gt; （推荐）#取消SetGIDchmod xxx &lt;file/dir-name&gt;chmod g-s &lt;file/dir-name&gt; 例程我们此处以locate命令进行讨论：locate查询命令，比find要快很多，为什么？因为其实搜索的数据库而非整个硬盘：12345[root@niesh ~]# ll /usr/bin/locate-rwx--s--x. 1 root slocate 40496 6月 10 2014 /usr/bin/locate[root@niesh ~]# ll /var/lib/mlocate/mlocate.db-rw-r-----. 1 root slocate 6306909 7月 30 19:15 /var/lib/mlocate/mlocate.db 我用普通用户进行locate查看：12[niesh@niesh root]$ locate mlocate.db/usr/share/man/man5/mlocate.db.5.gz 去掉locate的s权限：123456[root@niesh ~]# chmod g-s /usr/bin/locate[root@niesh ~]# ll /usr/bin/locate-rwx--x--x. 1 root slocate 40496 6月 10 2014 /usr/bin/locate[niesh@niesh root]$ locate mlocate.dblocate: 无法执行 stat () `/var/lib/mlocate/mlocate.db&apos;: 权限不够 也就是：当执行locate命令时，普通用户niesh自动升级为slocate的组成员。 /usr/bin/locate是可执行二进制程序，可以赋予SGID 执行用户niesh对/usr/bin/locate命令拥有执行权限 执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate命令查询mlocate.db数据库 命令结束，niesh用户的组身份返回为niesh组 SBIT(Sticky BIT)粘滞位 作用防止其他用户删除自己的文件，使用者在该目录下，仅自己与root才有权力删除新建的目录或文件 使用要求只对目录有效普通用户对该目录有w和x权限若没有粘滞位，则普通用户可以对目录下的文件/子目录进行删除操作（因为普通用户对目录具有w权限），包括其它用户建立的目录/文件；但若赋了SBIT，则普通用户只能删除自己创建的文件/目录，而不能删除不属于自己的文件/目录！ 命令1代表SBIT，t出现在文件其他用户的x权限上1234567#设置SBITchmod 1xxx &lt; dir-name &gt;chmod o+t &lt; dir-name &gt;#取消SBITchmod xxx &lt; dir-name &gt;chmod o-t &lt; dir-name &gt; 例程以/tmp为例：查看/tmp的权限：12[niesh@niesh tmp]$ ll -d /tmp/drwxrwxrwt. 8 root root 4096 7月 30 19:40 /tmp/ 会看到，/tmp目录的权限other部分为rwt,这个t就是我们设置的粘滞位接下来，我们用其它用户创建两个文件：123456[Jimmy@niesh tmp]$ touch test-file[Jimmy@niesh tmp]$ mkdir test-dir[Jimmy@niesh tmp]$ ll总用量 0drwxrwxr-x. 2 Jimmy Jimmy 6 7月 30 19:44 test-dir-rw-rw-r--. 1 root Jimmy 0 7月 30 19:44 test-file 切换到另外一个用户niesh:123456789[niesh@niesh tmp]$ ll总用量 0drwxrwxr-x. 2 Jimmy Jimmy 6 7月 30 19:44 test-dir-rw-rw-r--. 1 root Jimmy 0 7月 30 19:44 test-file在 niesh用户下，删除/tmp目录下的文件：[niesh@niesh tmp]$ rm -rf test-dir/ test-filerm: 无法删除&quot;test-dir/&quot;: 不允许的操作 无法删除！ 然后，我们切换到root，去掉/tmp的粘滞位：123456[niesh@niesh tmp]$ su -密码：上一次登录：日 7月 30 19:43:21 CST 2017pts/0 上[root@niesh ~]# chmod o-t /tmp/[root@niesh ~]# ll -d /tmp/drwxrwxrwx. 9 root root 4096 7月 30 19:48 /tmp/ 最后，切换到普通用户niesh，再次删除/tmp下的文件：123[niesh@niesh root]$ rm -rf /tmp/test-dir/ /tmp/test-file[niesh@niesh root]$ ll /tmp/总用量 0 参考： http://www.cnblogs.com/Jimmy1988/p/7260215.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理04 sudo权限]]></title>
    <url>%2Fpost%2F6ca02215.html</url>
    <content type="text"><![CDATA[目的赋予普通用户超级管理员的权限 使用12345678910111213141516visudo#实际修改的是/etc/sudoers文件#sudo的配置文件是/etc/sudoers。visudo会锁住sudoers文件，保存修改到临时文件/etc/sudoers.tmp，然后检查文件格式，确保正确后才会覆盖sudoers文件。必须保证sudoers格式正确，否则sudo将无法运行。root ALL=(ALL) ALL用户名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）%wheel ALL=(ALL) ALL%组名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）第二个all指，可以切换成任意身份，这个可以直接省略$sudo -l #查看可以执行的命令$sudo /sbin/shutdown -r now#普通用户执行超级命令的时候必须要加 sudo 命令的绝对路径 补充： http://www.cnblogs.com/Jimmy1988/p/7270881.html https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E6.9F.A5.E7.9C.8B.E5.BD.93.E5.89.8D.E8.AE.BE.E7.BD.AEhttp://man.linuxde.net/sudo?zwbizq=f0evo1]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理03 ACL权限]]></title>
    <url>%2Fpost%2F2b0963f2.html</url>
    <content type="text"><![CDATA[文件一般权限包括所有者权限、组权限和其他权限，有时候不能满足要求（一个不属于u/g/o的用户也要对文件有权限），这时候就需要ACL权限，用来解决用户身份不够的问题 CentOS不需要开启ACL权限，xfs文件系统默认开启了ACL权限，可以直接使用getfacl和setfacl命令 查看分区ACL权限是否开启123456789df ＃查看分区dumpe2fs -h /dev/sda5#dumpe2fs命令时查询指定分区详细文件系统信息的命令-h 仅显示超级块中信息，而不显示磁盘块的详细信息#仅适用于ext4等文件格式，xfs默认开启了acl权限文件信息里项：Default mount options: user_xattr acl那就说明分区是支持acl的 开启ACL权限临时开启分区ACL权限12mount -o remount,acl /#重新挂载根分区，并挂载加入acl权限 永久开启分区ACL权限1234567vi /etc/fstabUUID=c2ca6f57-b15c-43ea=bca0-f239083d8bd2 / ext4 defaults,acl 1（＃启动是否需要检测） 1(#启动是否需要备份)#加入aclmount -o remount /#重新挂载文件系统或重启系统，使修改生效 查看ACL权限1getfacl 文件名 会显示mask值 设置acl权限123456789101112131415setfacl 选项 文件名选项-m #设定acl权限-x #删除指定的acl权限-b #删除所有的acl权限-d #设定默认acl权限-k #删除默认acl权限-R #递归设定acl权限例：setfacl -m u:lw:rx /av#给用户lw赋予r-x权限，使用&quot;u:用户名:权限&quot;格式例：setfacl -m g:group2:rwx /av#给用户组group2赋予rwx权限，使用&quot;g:组名:权限&quot;格式 设定之后会在ls -al命令显示的权限末尾出现+号1drwxr-xr-x+ root root 最大有效权限maskmask是用来指定最大有效权限的。如果给用户赋予了acl权限，是需要和mask的权限“相与”才能得到用户的真正权限。相与是计算机中的术语，皆真方为真，有假便为假。 最大权限也会影响到组权限。例：某文件所有者为tony，chmod赋予的普通权限为7，而acl赋予tony的权限为5，则acl权限会高于chmod权限 修改mask值12setfacl -m m:rx 文件#设定mask权限为r-x。使用“m:权限”格式 删除acl权限12345678setfacl -x u:用户名 文件#删除指定用户的acl权限setfacl -x g:组名 文件#删除指定用户的acl权限setfacl -b 文件#删除文件所有的acl权限 递归ACL权限在给父目录赋予权限的同时，给已经存在于目录下的文件赋予相同的权限12setfacl -m u:用户名:权限 -R 目录名#R表示递归 注意 用递归的方式容易导致文件权限溢出(目录为r-x，子文件则也为r-x) 递归acl只能用在目录而不能用于普通文件 默认ACL权限给父目录下将来新建的文件默认赋予父目录的权限12setfacl -m d:u:用户名:权限 目录名#d表示default 设置后可以使用getfacl查看 补充：https://www.cnblogs.com/Jimmy1988/p/7249844.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理02 默认权限]]></title>
    <url>%2Fpost%2F815d598f.html</url>
    <content type="text"><![CDATA[Windows中的默认权限是从上级目录中继承的Linux的默认权限是通过umask设置的 查看默认权限123456umask #查看默认权限00220：文件特殊权限022：文件默认权限 修改默认权限12345# 临时修改umask 0002# 永久修改vi /etc/profile 文件的默认权限 文件默认最高权限为666 文件默认不能建立为执行文件，必须手工赋予执行权限,所以文件默认权限最大为666 默认权限需要推算成字母（rwx）再相减 建立文件之后的默认权限，为666减去umask值 目录的默认权限 目录的默认权限最大为777 默认权限需要换算成字母再相减 建立文件之后的默认权限，为777减去umask值 例如： 目录默认最大权限为777，umask值022 -rwxrwxrwx 减去 -----w--w-等于 -rwxr-xr-x]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux权限管理01 一般权限]]></title>
    <url>%2Fpost%2Fc2feff11.html</url>
    <content type="text"><![CDATA[查看权限1ls -al 第1位 2-4位 5-7位 8-10位 11位 - rwx r-x r-x . 文件类型 u所有者 g所属组 o其他人 ACL权限 r：读w：写x：执行 修改权限1234567chmod [选项] 模式 文件名选项：-R 递归（用于目录）模式：[u/g/o/a] [+ - =] [rwx] 或 [mode=421]chmod a=rwx filenamechmod u+w filename 权限的作用权限对文件的作用 r：读取文件内容（cat/more/head/tail） w：编辑、新增、修改文件内容（vi/echo），不包括新增文件和删除文件 x：可执行，判断是否为可执行文件 文件中的数据存储在文件数据block里，而文件名储存位置在目录block中，要删除文件，意味着要删除文件名，所以要想删除文件，必须对目录block进行操作 权限对目录的作用 r：查询目录下的文件（ls） w：具有修改目录结构的权限。如新建文件和目录，删除此目录下的文件和目录，重命名此目录下文件和目录，剪切（touch/rm/mv/cp） x：进入目录（cd） 对文件来说，最高权限是x对目录来说，最高权限是w目录只有0，5 ，7权限有意义。4、1、6权限没有意义文件的常用权限是644目录的常用权限是755 其他命令12345678#修改文件所有者chown 用户名 文件各#修改文件的所属组chgrp 所属组 文件名#同时修改文件的所有者和所属组chown 用户名:所属组 文件名 分配文件基本权限时，核心原则：在最小权限情况下能够实现要求即可]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 帮助命令]]></title>
    <url>%2Fpost%2F4a7c8c06.html</url>
    <content type="text"><![CDATA[针对内部命令和外部命令有不同的帮助命令 内部命令help：shell内部命令帮助1help shell内部命令 type \ whereis可以用来判断一个命令是否是shell内部命令ls在/bin/下面有可执行文件，说明ls命令不是shell内部命令cd命令在/bin/下面没有相应的可执行文件，所以是shell自带的命令man命令不能获取shell的内部命令help命令只能获取shell的内部命令 外部命令COMMAND –help/-h12345外部命令 --help # 获取命令选项的帮助# 一些命令不支持该选项ls --help man：使用手册(manual)许多希望被命令行使用的可执行程序提供了一个正式的文档，叫做man page，man是manual的缩写，最常用的帮助命令man使用less命令显示参考手册无法提供shell内建命令的参考手册 配置配置文件：/etc/manpath.config\ /etc/man_db.config，指定从哪里读取man文件，MANPATH，/usr/share/man就是其中的一个读取路径1man -M /PATH/TO/SOMEWHERE COMMAND # 到指定位置下搜索COMMAND命令的手册页并显示 man的级别man所显示的参考手册被分成几个章节，包括用户命令、系统管理员命令、程序接口、文件格式 用户命令 可被内核调用的函数，系统调用 C库函数程序接口 特殊文件（主要是/dev目录下的文件），比如设备结点和驱动程序 配置文件 游戏娱乐，如屏幕保护程序 其它杂项 系统管理员命令 内核相关 帮助手册中的段落说明：NAME 简短的命令，数据名称说明SYNOPSIS 简短的命令执行语法简介DESCRIPTION 较为完整的说明OPTIONS 针对SYNPATH部分中，有列举的所有可用的选项说明EXAMPLES 一些可以参考的范例AUTHOR 作者REPORTING BUGS 是否有相关的错误SEE ALSO 这个命令或数据其他说明 SYNOPSIS： []：可选内容 &lt;&gt;: 必选内容 a|b：二选一 …: 同一内容可出现多次 man命令的操作方法12345678910111213141516171819man command# 获取指定命令的帮助man -f 命令# 查看命令的所有帮助等级# 相当于 whatis 命令# 因为whereis命令可以看到命令的帮助文档目录，所以也可以查看目录的等级man 级别 命令# 查看相应等级的命令man -5 passwdman -4 nullman -8 ifconfigman -k 命令 # 相当于 apropos 命令# 搜索含有关键词“命令”的所有帮助文档man -k passwd# 搜索含有关键词“passwd”的所有命令的帮助文档 123456789101112131415161718192021Space 向文件尾翻屏b 向文件首部翻屏d 向文件尾部翻半屏u 向文件首部翻半屏j 向文件尾部翻一行k 向文件首部翻一行q 退出number 跳转至第number行1G 回到文件首部G 翻至文件尾部文本搜索：/KEYWORD: 以KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索；不区分字符大小写 n: 下一个 N：上一个?KEYWORD:以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索；不区分字符大小写 n: 跟搜索命令同方向，下一个 N：跟搜索命令反方向，上一个 info信息页12345678info 命令# info里面内容十分繁琐，是关于命令的一个巨大的帮助文档，里面有各个版本对于此命令的说明。Enter 进入带*号的说明，*表示是一个链接u 进入上层页面n 进入下一个帮助小节p 进入上一个帮助小节q 退出 程序自身的帮助文档READMEINSTALLChangeLog 许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc目录下。这些文件大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。一些文件是 HTML 格式，可用网页浏览器来阅读。我们可能遇到许多以 “.gz” 结尾的文件。这表示 gzip 压缩程序已经压缩了这些程序。gzip 软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip压缩的文本文件的内容。 程序官方文档官方站点的Documentation 发行版的官方文档https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/ Google]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 命令的分类]]></title>
    <url>%2Fpost%2Fbc48c0fa.html</url>
    <content type="text"><![CDATA[命令的分类 shell内部命令，由shell自带的，而且通过某命令形式提供 外部命令，在当前系统的某文件系统路径下有对应的可执行程序文件，C、C++、shell、perl、python、ruby等，二进制文件、脚本文件，shell程序搜寻可执行程序文件的路径定义在$PATH环境变量中，自左至右搜寻 shell函数，环境变量中 命令别名 外部命令外部命令都有一个可执行程序，位于文件系统某目录下，通过 which, whereis可以查看shell程序搜寻可执行程序文件的路径定义在PATH环境变量中12echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/xxl/.local/bin:/home/xxl/bin 以:分隔，自左至右搜寻 type 查看命令类型可以用来区别内部或外部命令1234type 命令名type pwd # pwd 是 shell 内嵌type mkdir # mkdir 是 /usr/bin/mkdir which 显示一个外部命令对应的程序文件路径123which [OPTION] COMMAND# 不能看到命令的别名# 不能看到shell内部命令 whereis 显示外部命令所在路径及帮助文档所在位置1234567whereis 命令名选项：-b:只查找可执行文件-m:只查找帮助文件# 只能搜索系统命令，不能搜索自己凭空创建的普通文件# whereis不能看到shell内部命令（如：cd），只能看到外部安装的命令 whatis 查询一个命令执行什么功能123whatis 命令名whatis ls # 显示ls的作用 apropos 通过关键字搜索命令123apropos 关键字# 和man -k一样]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 命令]]></title>
    <url>%2Fpost%2F9da1ef6b.html</url>
    <content type="text"><![CDATA[命令提示符 prompt12345678[root@localhost ~]#root 当前登录用户localhost 主机名~ 当前所在目录（家目录）# 超级用户的提示符$ 普通用户的提示符环境变量 $PS1 命令的格式1COMMAND [OPTIONS...] [ARGUMENTS...] OPTIONS：选项用于启用或关闭命令的某个或某些功能短选项：-c, -l, -h等多个短选项可以写在一起，例如-l -h, 可写作-lh 长选项：--word，例如：--long, --human-readable ARGUMENTS：参数命令的作用对象，向命令提供数据 注意 多选项，以及多参数和命令之间都应该使用空白字符分隔 取消命令执行：Ctrl+c 个别命令使用不遵循此格式 命令的执行过程输入命令，回车，请求shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。表现为一个或多个进程。 路径 相对路径：从当前位置起始的路径 绝对路径：从根目录起始的路径 当前位置的表示方式： ./： ./sysconfig/network-scripts 省略上述符号: sysconfig/network-scripts 当前目录：current directory, 也称作working directory；用.表示pwd: printing working directory 打印当前目录 当前目录的上一级目录：..：表示当前目录的上一级目录]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 发行版及开源协议]]></title>
    <url>%2Fpost%2Ffd342599.html</url>
    <content type="text"><![CDATA[Linux的发行版基于kernal，会有不同的Linux发行版，这里 列出了2012年时的所有发行版，这里 列出了各个发行版的排名 12345678910111213141516slackware: suse opensusedebian: ubuntu mintredhat： rhel: redhat enterprise linux，每18个月发行一个新版本 CentOS：兼容rhel的格式 fedora：每6个月发行一个新版本ArchLinuxGentooLFS: Linux From scratchAndroid: kernel+busybox+java虚拟机 CentOS和Linux是什么关系？CentOS和RHEL是什么关系？CentOS是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。CentOS 是Community ENTerprise Operating System（社区企业操作系统）的简称，是Linux发行版之一，它是来自于Red Hat EnterpriseLinux（即RHEL）依照开放源代码规定释出的源代码所编译而成。RHEL是很多企业采用的linux发行版本，需要向RedHat付费才可以使用， 并能得到付过费用的服务和技术支持和版本升级。而CentOS可以像REHL一样的构筑linux系统环境，但不需要向RedHat付任何的费用，同样也 得不到任何有偿技术支持和升级服务。 开源协议GNU GPLv2, GPLv3, LGPL(lesser)Apache apacheBSD bsd 其他相关协议：Public DomainCC0wtfpl 下面是wtfpl的协议12345678910111213DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004 Copyright (C) 2004 Sam Hocevar &lt;sam@hocevar.net&gt; Everyone is permitted to copy and distribute verbatim or modified copies of this license document, and changing it is allowed as long as the name is changed. DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 0. You just DO WHAT THE FUCK YOU WANT TO. 具体的说明可以参考【转】五种常见的开源协议整理 参考： http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html http://pbagwl.com/post/5078147450/description-of-popular-software-licenses https://coolshell.cn/articles/4657.html http://www.wtfpl.net/txt/copying/ https://blog.csdn.net/wadefelix/article/details/6384317]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux 计算机基础]]></title>
    <url>%2Fpost%2F2feeae2.html</url>
    <content type="text"><![CDATA[现代计算机设备的组成部分： 运算器、控制器、存储器、输入设备、输出设备 CPU bus：总线 memory: 编址存储设备 read ahead 高速缓存 IO: 与外部部件交互 磁盘 网卡 虚拟机：虚拟计算机 CPU：运算器、控制器 CPU指令，指令集； 特权指令：OS运行特权指令； 普通指令： 程序员： OS: Operating System 软件程序 通用目的 硬件驱动 进程管理 内存管理 网络管理 安全管理 System Call 系统调用 编程层次： 硬件规格：hardware specifiacation 系统调用： 库调用： library call UI: user interface 用户接口 GUI: Graphic User Interface 图形用户接口 CLI: Command Line Interface 命令行接口 ABI: Application Binary Interface 应用二进制接口API：Application Programming Interface 用用程序接口 CPU架构类型： x86 x64 arm m68000, m68k power powerpc ultrasparc alpha 安腾 WindowsLinux： Linus –&gt; Linux GNU/Linux Unix： System （Bell Lab） AIX （IBM） Solaris (SUN) HP-UX (HP) BSD: （BSRG）Berkeley System Distribution 伯克利软件套件 NetBSD OpenBSD FreeBSD MIT：Richard Stallman GNU: GNU is Not Unix； GPL：General Public LicenseCPU, memory, I/O 程序运行模式： 用户空间：user space, us 内核空间：system space POS: Portable Operating System 可移植操作系统 POSIX API: 编程接口； 运行程序格式： Windows: EXE, dll(dynamic link library 动态链接库文件) Linux: ELF, so(shared object 共享对象) 程序：指令+数据 指令：只读 数据：读写 程序：算法+数据结构 库调用，系统调用：允许被调用的程序； malloc(), free() 编程语言： 汇编语言：微码编程 系统中某些与硬件相关的特有代码、驱动程序开发； 高级语言C, C++： 系统级应用、驱动程序 高级应用java, python, php： 应用程序 unix-like LSB: Linux Standard Base Linux标准库 程序包管理器： rpm: RHEL, Fedora, S.u.S.E, CentOS dpt: Debian, Ubuntu 自由软件： 自由使用；自由学习和修改；自由分发；自由创建衍生版； Linux的哲学思想： 1、一切皆文件； 把几乎所有资源，包括硬件设备都组织为文件格式； 2、由众多单一目的小程序组成；一个程序只实现一个功能，而且要做好； 组合小程序完成复杂任务； 3、尽量避免跟用户交互； 目标：实现脚本编程，以自动完成某些功能； 4、使用纯文本文件保存配置信息； 目标：一款使用的文本编程器即能完成系统配置工作； 如何获取CentOS的发行版： http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com 登录： root/mageedu # startx &amp; 终端： 用户与主机交互，必然用到的设备； 物理终端：直接接入本机的显示器和键盘设备；/dev/console 虚拟终端：附加在物理终端之上的以软件方式虚拟实现的终端，CentOS 6默认启动6个虚拟终端 Ctrl+Alt+F#: [1,6] 图形终端：附加在物理终端之上的以软件方式虚拟实现的终端，但额外会提供桌面环境； 设备文件路径：/dev/tty# 模拟终端： 图形界面下打开的命令行接口，基于ssh协议或telnet协议等远程打开的界面 设备文件：/dev/pts/# [0,oo) 查看当前的终端设备：tty 交互式接口：启动终端后，在终端设备附加一个交互式应用程序 GUI： X protocol, window manager, desktop Desktop: GNOME (C, gtk) KDE (C++, qt) XFCE (轻量级桌面) CLI： shell程序： sh (bourn) csh tcsh ksh (korn) bash (bourn again shell), GPL zsh 显示当前使用的shell： # echo ${SHELL} 显示当前系统使用的所有shell： # cat /etc/shells 命令提示符：prompt [root@localhost ~]# [root@localhost ~]：PS1 prompt： 管理员：# 普通用户：$ 硬件系统主要有五大部分组成：运算器、控制器、存储器、输入设备、输出设备运算器：负责算术与逻辑运算。与控制器共同组成了中央处理器控制器：负责发送和接收指令存储器：用来存储正在进行程序、将要进行程序的数据及刚处理完的数据输入设备：用来进行输入的设备输出设备：用来进行输出的设备 硬件是基础，硬件需要通过系统软件控制来启动硬件，并让各个硬件之间相互协同工作，在系统软件的基础上是用户，用户操控的是系统软件，并在系统软件的基础上安装相应的应用软件，来完成用户所需要的工作，所以说最底层的是硬件，硬件上一层是系统软件，系统软件上一层是应用软件，而最上层的则是用户 计算机的工作原理算机的工作过程，就是执行程序的过程。怎样组织存储程序，涉及到计算机体系结构问题。现在的计算机都是基于“程序存储”概念设计末造出来的。了解了“程序存储”，再去理解计算机工作过程变得十分容易。如果想让计算机工作，就得先把程序编出来，然后通过输入设备送到存储器保存起来，即程序存储。根据冯·诺依的设计，计算机应能自动执行程序，而执行程序又归结为逐条执行指令。执行。执行一条指令可分为以下4个基本操作 取出指令：从存储器某个地址中取出要执行的指令送到CPU内部的指令寄存器暂存。 分析指令：把保存在指令寄存器中的指令送到指令译码器，译出该指令对应的微操作。 执行指令：根据指令译码，向各个部件发岀相应控制信号，完成指令規定的各种操作 为执行下一条指令作好准备，即取出下一条指令地址 计算机使用二进制的原因技术实现简单简化运算规则适合逻辑运算易于进行转换抗干扰能力强]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清华同方x46h开启Intel VT]]></title>
    <url>%2Fpost%2F8c4b67.html</url>
    <content type="text"><![CDATA[清华同方x46h是我在12年买的，在网上搜索的资料是说原本Intel VT技术是开启的，但是如果多次重装系统就会把它关闭，而且官方的BIOS是没有开启选项的，官方也没有提供BIOS更新，所以需要自己刷，结果我刷的代价就是主板被刷坏，花了350把主板修了，总之刷BIOS还是有风险的，这里只是提供具体方法 1、查看是否支持Intel VT技术以及是否开启下载leomoon-cpu-v，并安装 左边的对勾表示主板支持Intel VT右边的对勾表示主板已经开启Intel VT这张图片是已经开启的状态清华同方x46h的实际状态应该是左边对勾，右边叉 2、制作纯DOS启动U盘 下载MSDOS7.1解压 格式化U盘为FAT32分区格式 使用UltraIOS制作U盘启动盘和制作win7的启动U盘一样插入不用的U盘（因为需要格式化）在UltraIOS中文件》打开，选择解压后的MSDOS文件夹中的IOS镜像文件；点击启动》写入硬盘映像选择U盘，写入方式为USB-HDD+，点击写入 可以参考http://blog.sina.com.cn/s/blog_4ad042e50102eclt.html 3、下载需要刷的BIOS 在步骤2中制作好的U盘启动盘里新建文件夹，文件夹名叫12 下载X46H_BIOS，解压，将文件夹中的四个文件复制到12文件夹中 4、刷BIOS 重启电脑，按F2打开BIOS 将U盘设为电脑开启的第一启动项，保存，退出 插入U盘，重启电脑 会进入MSDOS界面，会先让你设置MSDOS，选择cancel取消设置 接下来输入以下命令 命令1： “C:” 回车 —将当前盘符切换到C:命令2： “CD 12” 回车 —将当前操作文件夹切换到C:\12下命令3： “fpt -bios -f GT_122.h09” 回车 —执行刷新命令 图4 刷新成功后 按开关机键 关机 ，将电池拔掉 ，电源线 移除 ，1分钟后安装好。 5、开启Intel VT开机，按F2进 BIOS 选择高级 Advanced 选项 会出现 虚拟化选项。打开后按F10保存并退出即可。 运行leomoon-cpu-v工具可以看到看到Intel VT已经开启 参考：http://benyouhui.it168.com/thread-1896445-1-1.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows配置JDK]]></title>
    <url>%2Fpost%2Fd6c16da1.html</url>
    <content type="text"><![CDATA[每次重装系统都要重新配置jdk每次都需要百度一下jdk的配置，毕竟也不是天天配java运行环境 1、下载jdk2、配置环境变量1234JAVA_HOME D:\Java\jdk1.6.0_39CLASSPATH .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jarPath %JAVA_HOME%\bin %JAVA_HOME%\jre\bin 注意CLASSPATH之前的点和分号 3、验证打开cmd，分别输入java -version，javac -version，如果可以看到版本号，说明成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】重装系统后hexo配置]]></title>
    <url>%2Fpost%2Fcb1fd277.html</url>
    <content type="text"><![CDATA[重装系统后需要重新配置Hexo，找了很多教程，结果不是这里出问题就是那里出问题，最后终于找到一个可以用的，所以记录下来 1、备份原Hexo文件夹下的source文件夹，以及站点目录下的_config.yml和主题目录下的_config.yml，后将整个Hexo文件夹删除 2、重装系统后，安装Node.js和Git for Windows，通过apt安装需要更新nodejs和npm1234sudo apt install nodejs npm gitsudo npm install -g nn stablesudo npm -g install npm@next 3、配置SSH key：在Git Bash敲入1ssh-keygen -t rsa -C “你的邮箱” 生成的密钥默认保存在C:\Users\XPS.ssh\id_rsa.pub，用笔记本打开该文件，复制里面的内容到Github&gt;Settings&gt;SSH and GPG keys&gt;New SSH key-Key一栏里，title可任意发挥1ssh -T git@github.com 测试是否成功 4、配置Git的个人信息：在Git Bash输入12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 5、在你要放置博客的文件夹打开Git Bash， 安装Hexo框架12sudo npm install hexo-cli -gsudo npm install hexo --save 6、hexo在指定文件夹中新建所需要的文件123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 7、Hexo3.0以上版本，需要安装hexo-deployer插件才能部署到Github1npm install hexo-deployer-git --save 8、在初始化完成后，将之前重装系统保存的Hexo文件夹下的这些文件夹拷贝至新的Hexo文件夹(即刚刚初始化完成的)内 9、执行以下命令来部署123hexo cleanhexo ghexo d 在重装系统完之后恢复Hexo初次部署需要一点时部署中如果弹出弹框，填yes即可。出现123To github.com:Aldrich-ayu/Aldrich-ayu.github.io.git+ cb4cda2...ec926bc HEAD -&gt; master (forced update)INFO Deploy done: git 即表示恢复Hexo并且部署成功！ 参考： http://yanziyu.tech/2017/04/04/reinstall-hexo/ https://hexo.io/zh-cn/docs/index.html https://aldrich-ayu.github.io/2017/07/31/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%81%A2%E5%A4%8D/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax工作原理]]></title>
    <url>%2Fpost%2F27441bd3.html</url>
    <content type="text"><![CDATA[12345678910111213141516172018年5月记，总结起来就几句话//创建xmlhttprequest对象var xhttp xhttp=new XMLHttpRequest();//使用xmlhttprequest对象的open()和send()方法发送资源请求给服务器xhttp.open(&quot;POST&quot;,&quot;ajax_info.txt&quot;,true);//调用onreadystatechange函数xhttp.onreadystatechange = function()&#123;&#125;;//获得服务器的响应document.getElementById(&quot;demo&quot;).innerHTML=xhttp.responseText;然后为了这四句能正确响应，添加必要的判断返回的响应也可能是各种形式，需要做各种处理是不是很简单 名称Asynchronous JavaScript and XML异步得JavaScript和XML 作用在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 同步与异步异步传输是面向字符的传输，它的单位是字符；异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致 同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。同步传输通常要比异步传输快速得多，同步传输的开销也比较少 包含的技术 使用CSS和XHTML来表示 使用DOM模型来交互和动态显示 使用XMLHttpRequest来和服务器进行异步通信 使用javascript来绑定和调用重点是3，理解XMLHttpRequest对象 XMLHttpRequest属性onreadystatechange 每次状态改变所触发事件的事件处理程序。responseText 从服务器进程返回数据的字符串形式。responseXML 从服务器进程返回的DOM兼容的文档数据对象。status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 使用ajax的步骤 创建xmlhttprequest对象，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。 使用xmlhttprequest对象的open()和send()方法发送资源请求给服务器 调用onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数 使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应 示例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;Let AJAX change this text.&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;loadDoc()&quot;&gt;Change Content&lt;/button&gt;&lt;script&gt;function loadDoc()&#123;// 1、创建xmlhttprequest对象var xhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;//var xhttp=new XMLHttpRequest();// 2、使用xmlhttprequest对象的open()和send()方法发送资源请求给服务器xhttp.open(&quot;POST&quot;,&quot;ajax_info.txt&quot;,true);//xhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);// 3、onreadystatechange函数xhttp.onreadystatechange = function()&#123; if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) &#123; // 4、使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应 document.getElementById(&quot;demo&quot;).innerHTML=xhttp.responseText;&#125;&#125;;xhttp.send();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 处理post表单post表单数据需要使用xmlhttprequest对象setRequestHeader方法增加一个HTTP头。post表单例子123xhttp.open(&quot;POST&quot;, &quot;ajax_test.aspx&quot;, true);xhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);xhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;); 处理xml需要放在if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) {}里面1234567xmlDoc = xhttp.responseXML;var txt = &quot;&quot;;x = xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i = 0; i &lt; x.length; i++) &#123; txt += x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;demo&quot;).innerHTML = txt; 处理json使用JSON.parse方法123456789101112131415xmlHttp.open(&quot;POST&quot;,&quot;tigongjson.php&quot;);//设置我们的请求头信息xmlHttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//需要放在if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) &#123;&#125;里面var data=xmlHttp.responseText;//json字符串转换成为json对象data=JSON.parse(data);var str=&quot;&quot;;for(var i=0;i&lt;data.length;i++)&#123; str+=&quot;姓名:&quot;+data[i].name+&quot;&lt;br&gt;&quot;; str+=&quot;年龄:&quot;+data[i].age+&quot;&lt;br&gt;&quot;; str+=&quot;性别:&quot;+data[i].sex+&quot;&lt;br&gt;&quot;;&#125;;div1.innerHTML=str; 其他请参考菜鸟教程 参考： AJAX 教程|菜鸟教程 Ajax的原理和应用(给公司做所的培训) Ajax的使用四大步骤 Ajax中解析Json的两种方法详解 使用原生ajax处理json组成的数组]]></content>
  </entry>
  <entry>
    <title><![CDATA[XML命名空间和XML Schema]]></title>
    <url>%2Fpost%2F7866b39f.html</url>
    <content type="text"><![CDATA[12018年5月记，看完之后相当懵逼，，我是为了什么写这个的 概念XML命名空间提供避免元素命名冲突的方法。标签可以放入命名空间中，不同的命名空间中的相同名称标签是不同的标签。 命名冲突在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。 这个 XML 携带 HTML 表格的信息：123456&lt;table&gt;&lt;tr&gt;&lt;td&gt;Apples&lt;/td&gt;&lt;td&gt;Bananas&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 这个 XML 文档携带有关桌子的信息（一件家具）：12345&lt;table&gt;&lt;name&gt;African Coffee Table&lt;/name&gt;&lt;width&gt;80&lt;/width&gt;&lt;length&gt;120&lt;/length&gt;&lt;/table&gt; 假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 元素，就会发生命名冲突。XML 解析器无法确定如何处理这类冲突。 语法在xml文件中，命名空间的定义如下：1&lt;d:student xmlns:d=&quot;http://www.develop.com/student&quot; &gt; 其中 student 是命名空间的标签。http://www.develop.com是命名空间的标识。d是命名空间的前缀。 命名空间标签由于命名空间采取元素属性的定义方式，所以需要一个标签。 xmlns 属性当在 XML 中使用前缀时，一个所谓的用于前缀的命名空间必须被定义。命名空间是在元素的开始标签的 xmlns 属性中定义的。xmlns:前缀=”URI”。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。命名空间 URI 不会被解析器用于查找信息。其目的是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。 命名空间标识命名空间标识是命名空间最重要的属性，重要到当输出一个命名空间时就直接转换为它的标识。标识有个规范的称呼:URI(统一资源定位符)。URI的最大特点是唯一性。如果不唯一就失去了辨识的意义。实际上相同URI不同的命名空间被看成同一个命名空间。 URI分为两种类型：URL(统一资源定位器):通俗的说URL就是网页地址。因为每个网页在internat上都是唯一的。 URN（统一资源名称)：可以不使用网页地址而使用唯一名称来定义。如：urn:2007-12-9/workgrop/xin/projiectname或 urn:E7f73B13-05FE-44ec-81CE-F898C4A6CDB4这个编号是在系统中注册的控件编号，因此是唯一的。 前缀前缀用于在XML中作为URI的简化引用。因为URI太长了。如：1234&lt;d:student xmlns:d=&quot;http://www.develop.com/student&quot;&gt;&lt;d:id&gt;3235329&lt;/d:id&gt;&lt;d:name&gt;Jeff Smith&lt;/d:name&gt;&lt;/d:student&gt; 使用前缀把标签放入对应的命名空间中。 有了命名空间区分后相同标签名可以不会被错误解析。实际上命名空间加上元素名叫做QName。QName有两个属性：uri和localName，分别获取命名空间名和本地名称。这个QName可以使用xml的name()方法得到。如上例子中的xml文件可以使用如下代码访问：12345var ns:Namespace=xml.namespace();var node:XMLList=xml.ns::id;var qNameName=node.name();trace(qName.uri);trace(qName.localName); 命名空间不一点要定义在根节点。可以在任何标签中定义，但只有定义了后才能使用。命名空间还可以嵌套或者被重定义。但这样会增加复杂性。一般用的比较少。一个xml文件中可以拥有多个命名空间。使用命名空间前缀可以轻松处理它们。如：12&lt;x:transform version=”1.0” xmlns:x=http://www.w3.org/1999/XSL/Transformxmlns:d=”urn:dm:student”&gt;&lt;x:template match=”student”/&gt;&lt;d:template match=”name”/&gt;&lt;/x:transform&gt; 默认的命名空间为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作xmlns=”namespaceURI”使用默认命名空间后，如果不加前缀则引用默认命名空间。使用默认命名空间会降低xml结构的清晰度。要慎用。 参考： http://m.blog.csdn.net/w938706428/article/details/41448821 http://www.runoob.com/xml/xml-namespaces.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[腐女与伪腐女]]></title>
    <url>%2Fpost%2F616e1358.html</url>
    <content type="text"><![CDATA[2017年2月2日写的。。 2018年5月重看，看完了之后有点觉得不知所云，不知道自己当初想说什么，或者说想要论证的太多，反而说不清了。。 腐是一种个人爱好，就和你喜欢喝茶，我喜欢喝咖啡，和别人无关，当然不能影响他人，就比如喜欢跳广场舞，但最好不要扰民，扰民了就不能怪别人说 没有必要区分伪腐和真腐，既然是一种个人爱好，你喜欢谁都无所谓的（不过不管伪腐还是真腐都喜欢帅哥吧哈哈），但是前面也说了，不能打扰别人，请不要贬低别人（大概是有人用这种方式炒作吧，毕竟这样就有人关注了） 腐和热心LGBT一点关系没有（好像有点绝对），也许有腐女会热心，但只能说是一种个人行为，有人也许会说我是因为喜欢腐圈才去了解LGBT，但你没法忽视一个问题：大部分腐女并没有这种意识，两个长的丑站在一起你不会萌，真的是一对你也不会萌的。那么是不是说我们一定要求腐女热心公益？当然不，各玩各的互不影响挺好 突然想写写这个话题，是因为最近上b站，老是看到评论里有一些人为了”腐女”和”伪腐女”而争执。 维基对于”腐女”的解释是： 腐女（日语：腐女子／ふじょし Fujoshi），主要是指喜欢BL，也就是喜欢男男爱情的女性。 百度百科和萌娘百科(ACG向wiki)类似，但是对于”伪腐”的概念有一些不同的地方。 维基百科中提到了”伪腐”，表示中国(其他国家没有这个概念，或者百科中没有提到)腐圈的一种概念 因为大众有时并不清楚“BL”与现实中的男同性恋的区别，误以为腐女就是“对男同友善的女性”。由此也衍生出“伪腐”一词用以形容“喜欢BL，但对男同性恋不友善”的腐女。 百度百科中有单独的”伪腐女”概念： 腐女群体里面一些不理智、疯狂、NC（脑残）的腐女，所谓的伪其实并非是假，只是其他理智的腐女对于这类腐女看不惯所采取的分类手段，为了不让人降低对腐女的印象，选择以“这些腐女并非是真正的腐女，是伪腐！”的借口来和NC腐女划分界限或推卸责任。 萌娘百科中这样定义： 喜欢BL只是因为二次元中的人物都十分美型，对于现实生活中真正的GAY群不一定持支持态度，甚至厌恶和嘲笑，像这样的“腐女”被称为“伪腐” 其实参考这些之后就可了解： 腐只能被看作一种爱好，无论你喜欢帅哥还是什么，都可以称作腐女，”伪腐女”并不是代表假的，而是用来形容那些不理智/疯狂/脑残的腐女。 结论1：腐只是一种个人爱好 结论2：伪腐女不等于不是腐女 “伪腐女”这个词的出现一方面不排除个别腐女的优越感，另一方面也说明一些腐女在行为方式上的让人感到反感，自己喜欢什么没人管，但是还请尊重他人(我想不论是不是腐女都应该尊重他人)，正如萌娘百科所说： 腐只是一种爱好，能否做到尊重他人、尊重他人隐私是做人的基本素养问题，与腐或不腐没有联系。 腐圈为了区分这些腐女所以创造了”伪腐女”这个词 常见的伪腐特征(来自萌娘百科，百度百科词条”伪腐女”有类似内容)： 仅喜欢长相俊秀、外貌美型的男子，对于现实中的GAY嗤之以鼻甚至深感厌恶。典型语句【长这么丑也好意思搞同性恋】。 喜欢偷窥、干涉现实中的GAY的生活，过度挖掘他人的隐私以满足自己的兴趣。 热衷于掰弯现实生活中的直男（如身边的男同学等），强迫周围的人搞基，令他人感到困扰，严重影响他人生活。 对不符合其审美观的男性，以及明确表示厌恶搞基的直男则采取敌视态度，进行贬损和污蔑。 无法接受LES（女同性恋），看不起她们。 对于GAY的交心信仅凭所看的耽美漫画、动画、小说等给予荒诞错误的建议，或将信件放在公共平台供大家讨论围观。 在大庭广众高调谈论腐相关，大有“我就是腐我真了不起”之意，令他人感到厌烦。 不接受男女之间的爱情故事，认为耽美就是小众就是清新就是高端大气上档次，男女之情都是庸俗三流泛滥成河，由此以为自己是文艺女青年而轻视看描写一般男女故事的人。 阅读更多：腐女（https://zh.moegirl.org/%E8%85%90%E5%A5%B3）本文引自萌娘百科（https://zh.moegirl.org/），文字内容遵守【知识共享 署名-非商业性使用-相同方式共享 3.0】协议。 结论3：一些腐女存在不尊重他人的行为，影响到了他人，一些行为真的让人反感，换句话说自己圈地自萌就好，请不要要求别人怎样，也别影响别人 那么也许会有疑问，是不是腐女都应该支持同性恋? 我个人觉得并不一定，腐毕竟只是作为一种个人的爱好，只要不影响他人就好，而不一定要把这种爱好强迫变成一种公益行为，一些做支持同性恋的腐女也请不要要求别的腐女一定要支持腐女，这就和你其他公益事业一样，你做公益事业，很不错，但是强迫别人也做就不好了。 结论4：腐不等于公益行为 结论5：腐圈和LGBT圈关系不大 参考资料：腐女-百度百科伪腐女-百度百科腐女-维基百科腐女-萌娘百科腐女与伪腐女之间的差别是什么？-知乎什么是腐女？-什么是腐女]]></content>
  </entry>
  <entry>
    <title><![CDATA[2016年突然想说的话]]></title>
    <url>%2Fpost%2F2667aef9.html</url>
    <content type="text"><![CDATA[2016年，感觉自己什么也没做，本来也不打算写年终博客的。 晚上和好友聊天，突然心情有点激动就想着，写写吧，写点什么，这大概只是有种想写的冲动吧，写出来的不见得有多好。 11月份的时候才意识到我放在SAE上的博客不在了，只备份了Wordpress的代码，没备份数据库，120篇博客找不回来了，上面写的都是一些问题怎么解决，以及自己在学习中的经验，印象最深的大概是如何在Elementaory OS系统上安装软件，直接把博客上的语句复制到shell里执行就好，最头疼的大概是安装输入法的问题，当时记得查了好多资料，最后每次重装都是因为update时输入法出问题，具体问题记不清楚了，好像是影响软件安装和更新。 考完研后一直在整理自己的东西，百度云、Onenote、印象笔记还有移动硬盘。 百度云里有很多资料和书籍，以前也整理过，大概地分离了各种资源，但条理并不是很清晰，索性需要的时候虎直接搜索就好，这次打算把以前备份的手机照片整理一下，顺便把很多很多的电子书整理分类，剔除重复，还有把图片和书籍备份到移动硬盘上，书籍还在下载中，还没有整理，图片已经整理好了，把大学四年的照片、保存的来自各种渠道的图片以及截图都理清了，回顾这些图片，把一些照片发给了相关的人，他们都很吃惊，哈哈。很多截图都是我在微信的聊天记录，我还找到了我和某人认识的大概时间。这些大概都算生活中的一点小乐趣了吧。 本来想将Onenote作为唯一的做笔记的应用，但是因为同步功能最后选择了印象笔记，充个标准会员，标签模式也不错，特别是用了Bear，可惜没有Mac，顺便一提，Bear真的好漂亮。 这一年确实过的浑浑噩噩，是我太幼稚，也是我在逃避，我真的没办法接受现实，可是人生不就是一步一步接受的过程吗？ 走吧，各人有各人的路要走，我既没法代替你，也没法陪你，甚至无法看着你 写的差不多了，确实只有写作的冲动，而没有写作的才华，哈哈哈。 2018年5月15日重看这篇文字，当时写完之后再也不敢看，现在因整理笔记打开觉得没什么，此时已经没有什么悲伤，我比较震惊我能写这么多文字哈哈，现在的感觉是每当我觉得突然明白了一些道理自己又长大了一点的时候，又觉得自己还是很幼稚]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo目录结构以及_config.yml配置文件]]></title>
    <url>%2Fpost%2Ff4cc7750.html</url>
    <content type="text"><![CDATA[目录结构1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 假设网站的根目录为D:/Hexo/，也称为站点目录站点配置文件 是指网站目录下的_config.yml文件，即D:/Hexo/_config.yml 主题配置文件 是指网站目录下对应的主题文件夹下的_config.yml文件，即D:/Hexo/themes/next/_config.yml. 站点配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap- # Deployment #部署，将 lmintlcx 改成用户名deploy: type: git repo: github创库地址.git branch: master 配置文件的冒号后面都有一个半角空格 主题配置文件12345678910111213141516171819202122232425262728293031menu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。 Home: / Archives: /archives About: /aboutwidgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。- search- category- tagcloudexcerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。plugins: twitter: #右边栏要显示twitter展示的话，需要在此设置 username: show_replies: false tweet_count: 5addthis: #分享设置 enable: true pubid: facebook: true twitter: true google: true pinterest: truefancybox: true #图片效果，默认google_analytics: #google_analytics统计IDrss: #生成RSS路径]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo中博客使用markdown格式约定]]></title>
    <url>%2Fpost%2F76175dd0.html</url>
    <content type="text"><![CDATA[1.tags标签使用[tag1,tag2,…]，注意冒号后需要一个半角空格 2.文章内标题使用###空格我是标题空格### 3.内嵌代码使用反引号1`我是代码` 4.其他代码使用125.文字加粗使用两个星号 我是文字16.文字斜体使用一个*星号 我是文字17.引用使用&gt; 我是文字18.链接使用以下方式 显示文字```]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo新建文章]]></title>
    <url>%2Fpost%2F2a1a4413.html</url>
    <content type="text"><![CDATA[新建文章进入博客站点目录1hexo n &quot;文章题目&quot; 执行完命令会在blog\sourse_posts目录中多出一个md文件，也可以直接在该目录下新建md文件 编辑文章使用markdown工具编辑_posts目录中的md文件，最后记得使用hexo g以及hexo d命令 删除文章直接删除目录下的md文件即可]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】hexo常用命令]]></title>
    <url>%2Fpost%2F80937937.html</url>
    <content type="text"><![CDATA[常用命令：12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹 简写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】使用hexo d无法上传问题解决办法]]></title>
    <url>%2Fpost%2F453dda43.html</url>
    <content type="text"><![CDATA[问题1在使用hexo d上传时，可能出现以下错误1ERROR Deployer not found:git 解决办法1.在博客目录下安装hexo-deployer-git1npm install hexo-deployer-git --save 2.在博客目录下的_config.yml文件中1234deploy: type: git repository: https://github.com/fengrenxiaoli/fengrenxiaoli.github.io.git branch: master type使用git，冒号后面需要一个半角空格 问题2使用hexo d中，出现：123bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: No error 解决办法1.不要使用Cygwin等cmd工具，使用自带的cmd工具（具体可以参考https://github.com/atom/atom/issues/8984 2.使用ssh(具体格式在github中有)代替_config.yml文件中的deploy 如果出现1INFO Deploy done: git 则说明上传成功]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】修改Hexo博客的主题]]></title>
    <url>%2Fpost%2F5d01d58.html</url>
    <content type="text"><![CDATA[1.从https://hexo.io/themes/挑选喜欢的主题 2.从Github下载相应的主题12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/your-theme 注意修改自己选择主题的对应名字 3.更改站点_config.yml（即博客目录下的该文件，不是主题文件中的文件）中的theme字段为your-theme（名字要和第二步的对应）1theme: your-theme（theme后面有一个半角空格）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hexo】使用Hexo搭建github博客]]></title>
    <url>%2Fpost%2Fa20da6f3.html</url>
    <content type="text"><![CDATA[1.创建github帐号，新建一个以用户名.github.io命名的仓库 2.安装git，创建ssh12345ssh-keygen -t rsa -C &quot;your_email@example.com&quot;#用于创建ssh，会有公钥和私钥，将公钥拷贝到github帐号设置&gt;ssh and gpg keys中ssh -T git@github.com#用于测试是否成功 输入yes，其他使用默认即可，配置git12git config --global user.name &quot;cnfeat&quot;//用户名git config --global user.email &quot;cnfeat@gmail.com&quot;//邮箱 3.下载并安装hexo 4.新建一个目录用于放置本地博客12345678mkdir hexocd hexonpm install hexo-cli -g hexo init blogcd blognpm installhexo ghexo s #可以在本地http://localhost:4000/查看 5.修改blog目录下的_config.yml文件中的deploy：1234deploy:type: gitrepository: git@github.com:xxxxxx/xxxxxxx.github.io.gitbranch: master 6.安装hexo中关于git的组件，上传部署（需要cd到hexo\node_modules\hexo\Hexo目录）12345npm install hexo-deployer-git --savehexo cleanhexo ghexo d 如果出现问题请参考使用hexo d无法上传问题解决办法然后再使用以上代码 参考： http://kiya.space/2015/11/10/use-Github-Pages-Hexo-duoshuo-to-set-up-a-blog-basic-steps/ http://sunwhut.com/2015/10/30/buildBlog/ https://my.oschina.net/ryaneLee/blog/638440 http://www.jianshu.com/p/ab21abc31153 https://www.haomwei.com/technology/maupassant-hexo.html]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带不走的，留不下的]]></title>
    <url>%2Fpost%2F4ebc062a.html</url>
    <content type="text"><![CDATA[2018年5月记，转眼快两年了，没想到现在看来写的还挺好，那就发出来吧 时间我修改过，写这篇文字是在2016年的6月25日 写这篇文章的时候是大学毕业，准备离开而呆在学校的最后一天。 和不算很多的人约出来吃了饭，也许以后与这些人不会再见，也许要见也是几年之后了，几年有时候感觉很短，但当两人见面寒暄时，感叹一番，发现原来已经这么久没有见过了。 这几天除了吃饭和约人吃饭什么也不想干，就好像一个临终的人静静等待最后时刻的到来，不愿意去欣赏这里最后的景，也不想多留下一丝回忆。所做的只是交代后事，把自己和这里的人这里的事了结一些因果。 或许真的等我踏上火车准备上路时，才会伤心，才会遗憾，往事会如回马灯一样跳入脑海，原来我和你之间还能更加好一点，原来我应当做这件事的，许许多多的想法出现了，可是，只剩下发呆，留下的只有空白。 回想大学，自己就好像一只飞蛾，目标就是那里的火，逐渐走向自我的毁灭，我对生活的热情，我对未来的斗志都没有了，也许你是我最后的寄托吧，只是我们要毕业了，以后隔着的不光会是空间，还有时间，我带不走你，也留不下什么。 大学四年，我就像一个旁观者，看着你们一直往前走，我却带着原地，不想动，又像是一个行尸走肉，重复着南校、新校、本部三个点，没有带着什么，也不曾留下值得纪念的东西。 近来沉迷游戏，渴望在游戏中获得慰藉，交了几个亲友，最后呢，都离开了，除了花费金钱、消磨时间，什么也留不下了。 离开了，便开始一段新的旅程了，很多人许多事都随风飞走吧，带走了，留下了只能徒留伤感。 希望自己以后能够保持清醒，依靠自己，好好活着。 没了。]]></content>
  </entry>
</search>
