<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Linux权限 SUID、SGID、SBIT | 太阳落下</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux权限 SUID、SGID、SBIT</h1><a id="logo" href="/.">太阳落下</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux权限 SUID、SGID、SBIT</h1><div class="post-meta">Apr 27, 2018</div><div class="post-content"><h3 id="SUID-SetUID"><a href="#SUID-SetUID" class="headerlink" title="SUID(SetUID)"></a>SUID(SetUID)</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>使用户临时具有程序所有者（比如root）的权限来执行该程序</p>
<p>试想一个场景：</p>
<p>Linux普通用户可以修改自己的密码，这个是一个合情合理的设置；修改密码其实修改的是 /etc/shadow 这个文件；然而不知道你有没看过这个文件的属性：</p>
<pre><code>[niesh@niesh ~]$ ll /etc/shadow
----------. 1 root root 1476 7月  30 16:15 /etc/shadow
</code></pre><p>我去，bug啊？很明显普通用户对 /etc/shadow 文件没有任何权限啊，那怎么可能修改该文件呢？</p>
<p>一方面我们需要修改自己的密码（就是修改/etc/shadow)，另一方面这个文件对普通用户没任何权限，自相矛盾啊？这么办呢？<br>其实，这里就牵扯到了 SetUID 权限：修改密码的流程其实就是通过 <code>/usr/bin/passwd</code> 命令对 <code>/etc/passwd</code>进行修改，那么先让我们看一下这个可执行文件的属性：</p>
<pre><code>[niesh@niesh ~]$ ll /usr/bin/passwd
-rwsr-xr-x. 1 root root 27832 6月  10 2014 /usr/bin/passwd
</code></pre><p>发现/usr/bin/passwd的权限为：-rwsr-xr-x. 在此“文件所有者”的第三位是s权限，也就是咱们即将要详细讲解的的setUID权限，也就是它在作怪了！<br>不相信，那行，我现在验证一下（和cat命令对比）：</p>
<pre><code>[niesh@niesh ~]$ passwd
更改用户 niesh 的密码 。
为 niesh 更改 STRESS 密码。
（当前）UNIX 密码：
新的 密码：

[niesh@niesh ~]$ ll /usr/bin/cat
-rwxr-xr-x. 1 root root 54048 11月 20 2015 /usr/bin/cat

[niesh@niesh ~]$ cat /etc/shadow
cat: /etc/shadow: 权限不够
</code></pre><p>SetUID(或者 s 权限）：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然 “灵魂附体” 了，实际在以passwd命令所有者root的身份在执行，root当然可以将密码写入/etc/shadow文件（root是一个bug的存在，在Linux中就没有它不能干的事），命令执行完成后该身份也随之消失。<br>当然用户的passwd命令不能修改其他用户的密码，只能输入<code>passwd</code>来修改自己的密码</p>
<h4 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h4><ul>
<li>只有可执行的二进制程序才可以设置SetUID</li>
<li>命令执行者必须对欲设置SetUID的文件具备可执行(x) 权限，没有x的文件会成为S，S不能正确使用，只有s可以正确使用</li>
<li>命令执行过程中，其它用户获取所有者的身份（灵魂附体）</li>
<li>SetUID具有时间限制，即完成该程序执行后就消失</li>
<li>不能对目录使用</li>
</ul>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>4代表SUID，s出现在文件所有者的x权限上<br>设置SetUID</p>
<pre><code>chmod 4755 文件名
chmod u+s 文件名（推荐，不影响其他权限）
</code></pre><p>取消SetUID</p>
<pre><code>chmod 0755 文件名
chmod u-s 文件名（推荐，不影响其他权限）
</code></pre><h4 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h4><p>首先，查看一下touch命令的属性：</p>
<pre><code>[niesh@niesh tmp]$ ll /usr/bin/touch
-rwxr-xr-x. 1 root root 62432 11月 20 2015 /usr/bin/touch
</code></pre><p>然后，用普通用户创建一个文件：</p>
<pre><code>[niesh@niesh tmp]$ touch test1
[niesh@niesh tmp]$ ll test1
-rw-rw-r--. 1 niesh niesh 0 7月  30 17:40 test1
</code></pre><p>接着，更改touch的属性，增加SetUID属性：</p>
<pre><code>[niesh@niesh tmp]$ sudo chmod u+s /usr/bin/touch
[sudo] password for niesh:
[niesh@niesh tmp]$ ll /usr/bin/touch
-rwsr-xr-x. 1 root root 62432 11月 20 2015 /usr/bin/touch
</code></pre><p>而后，用普通用户再新建一个文件：</p>
<pre><code>[niesh@niesh tmp]$ touch test2
</code></pre><p>最后，查看两个新建文件的属性：</p>
<pre><code>[niesh@niesh tmp]$ ll test1 test2
-rw-rw-r--. 1 niesh niesh 0 7月  30 17:40 test1
-rw-rw-r--. 1 root  niesh 0 7月  30 17:42 test2
[niesh@niesh tmp]$
</code></pre><p>可以看到，在设置了SetUID之后，新建文件的所有者为root了，说明在执行touch的时候，用户自动升级为了所有者，灵魂附体了！</p>
<h4 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h4><p>设置SetUID是具备很大危险性的，例如赋予 vim 这个权限：</p>
<p>首先，查找vim在哪里<br>    [root@niesh ~]# whereis vim<br>    vim: /usr/bin/vim /usr/bin/vim.tiny /usr/local/bin/vim /usr/local/vim /usr/share/vim</p>
<p>然后，查看vim的属性<br>    [root@niesh ~]# ll /usr/bin/vim<br>    lrwxrwxrwx. 1 root root 18 5月   1 21:02 /usr/bin/vim -&gt; /usr/local/bin/vim</p>
<p>再次，给vim增加SetUID权限<br>    [root@niesh ~]# chmod u+s /usr/bin/vim<br>    [root@niesh ~]# ll /usr/bin/vim<br>    lrwxrwxrwx. 1 root root 18 5月   1 21:02 /usr/bin/vim -&gt; /usr/local/bin/vim</p>
<p>最后，使用vim编辑/etc/shadow<br>    [niesh@niesh ~]# vim /etc/shadow</p>
<p>明显，我可以打开并进行编辑了，那万一，一个不懂的人或者而已破坏的人将自己的权限提升到了root或者干脆删除这里的内容，那后果将是灾难性的！<br>所以，我们需要定时查看系统中有哪些设置了SetUID权限</p>
<ul>
<li>关键目录应严格控制写权限。比如 <code>/</code>、<code>/usr</code></li>
<li>用户的密码设置要严格遵循密码三原则(#复杂性，易记忆性，时效性）</li>
<li>对系统中默认应该具有SetUID权限的文件做一个列表，然后定期检查有没有这之外的执行程序的命令文件被设置了SetUID</li>
</ul>
<p>使用shell定期检查SetUID</p>
<pre><code>#!/bin/bash

find / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.check
for i in $(cat /tmp/setuid.check)

do   
        grep $i /root/suid.log &gt; /dev/null
              if [ &quot;S?&quot; !=&quot;0&quot;]
              then
                  echo &quot;$i isn&apos;t in listfile!&quot; &gt;&gt; /root/suid_log_$(date+%F)
              fi
done
rm -rf /tmp/setuid.check
</code></pre><p><br></p>
<h3 id="SGID-SetGID"><a href="#SGID-SetGID" class="headerlink" title="SGID(SetGID)"></a>SGID(SetGID)</h3><p>SetGID基本与SetUID相同，SetUID是设置所有者的权限，GID为设置所属组的权限<br>区别点在于：SetGID也可以设置目录的相关SetGID权限！</p>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>将用户所在组临时升级为某一个组，以执行只有该组才有相应权限进行的操作</p>
<h4 id="使用要求-1"><a href="#使用要求-1" class="headerlink" title="使用要求"></a>使用要求</h4><ul>
<li>针对文件：<ul>
<li>可执行的二进制文件</li>
<li>命令执行者（即所属组）对该文件具备 x 权限</li>
<li>命令执行者在执行程序的时候，组身份升级为该程序文件的属组</li>
<li>权限只在执行过程中有效</li>
</ul>
</li>
<li>针对目录：<ul>
<li>普通用户对目录具备r和x权限，才可以进入到该目录</li>
<li>普通用户在此目录中的有效组会变成此目录的所属组</li>
<li>如普通用户对该目录具备w权限，新建文件的所属组为该目录的所属组</li>
</ul>
</li>
</ul>
<h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p>2代表SGID，s出现在文件所属群组的x权限上<br>设置SetGID</p>
<pre><code>chmod 2xxx &lt;file/dir-name&gt;
chmod g+s &lt;file/dir-name&gt; （推荐）
</code></pre><p>取消SetGID</p>
<pre><code>chmod xxx &lt;file/dir-name&gt;
chmod g-s &lt;file/dir-name&gt;
</code></pre><h4 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h4><p>我们此处以locate命令进行讨论：<br>locate查询命令，比find要快很多，为什么？因为其实搜索的数据库而非整个硬盘：</p>
<pre><code>[root@niesh ~]# ll /usr/bin/locate
-rwx--s--x. 1 root slocate 40496 6月  10 2014 /usr/bin/locate

[root@niesh ~]# ll /var/lib/mlocate/mlocate.db
-rw-r-----. 1 root slocate 6306909 7月  30 19:15 /var/lib/mlocate/mlocate.db
</code></pre><p>我用普通用户进行locate查看：</p>
<pre><code>[niesh@niesh root]$ locate mlocate.db
/usr/share/man/man5/mlocate.db.5.gz
</code></pre><p>去掉locate的s权限：<br>    [root@niesh ~]# chmod g-s /usr/bin/locate<br>    [root@niesh ~]# ll /usr/bin/locate<br>    -rwx–x–x. 1 root slocate 40496 6月 10 2014 /usr/bin/locate</p>
<pre><code>[niesh@niesh root]$ locate mlocate.db
locate: 无法执行 stat () `/var/lib/mlocate/mlocate.db&apos;: 权限不够
</code></pre><p>也就是：当执行locate命令时，普通用户niesh自动升级为slocate的组成员。</p>
<ul>
<li>/usr/bin/locate是可执行二进制程序，可以赋予SGID</li>
<li>执行用户niesh对/usr/bin/locate命令拥有执行权限</li>
<li>执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate命令查询mlocate.db数据库</li>
<li>命令结束，niesh用户的组身份返回为niesh组</li>
</ul>
<p><br></p>
<h3 id="SBIT-Sticky-BIT"><a href="#SBIT-Sticky-BIT" class="headerlink" title="SBIT(Sticky BIT)"></a>SBIT(Sticky BIT)</h3><p>粘滞位</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>防止其他用户删除自己的文件，使用者在该目录下，仅自己与root才有权力删除新建的目录或文件</p>
<h4 id="使用要求-2"><a href="#使用要求-2" class="headerlink" title="使用要求"></a>使用要求</h4><p>只对目录有效<br>普通用户对该目录有w和x权限<br>若没有粘滞位，则普通用户可以对目录下的文件/子目录进行删除操作（因为普通用户对目录具有w权限），包括其它用户建立的目录/文件；但若赋了SBIT,则普通用户只能删除自己创建的文件/目录，而不能删除不属于自己的文件/目录！</p>
<h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p>1代表SBIT，t出现在文件其他用户的x权限上<br>设置SBIT</p>
<pre><code>chmod 1xxx &lt; dir-name &gt;
chmod o+t &lt; dir-name &gt;
</code></pre><p>取消SBIT</p>
<pre><code>chmod xxx &lt; dir-name &gt;
chmod o-t &lt; dir-name &gt;
</code></pre><h4 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h4><p>以/tmp为例：<br>查看/tmp的权限：<br>    [niesh@niesh tmp]$ ll -d /tmp/<br>    drwxrwxrwt. 8 root root 4096 7月 30 19:40 /tmp/<br>会看到，/tmp目录的权限other部分为rwt,这个t就是我们设置的粘滞位<br>接下来，我们用其它用户创建两个文件：</p>
<pre><code>[Jimmy@niesh tmp]$ touch test-file
[Jimmy@niesh tmp]$ mkdir test-dir
[Jimmy@niesh tmp]$ ll
总用量 0
drwxrwxr-x. 2 Jimmy Jimmy 6 7月  30 19:44 test-dir
-rw-rw-r--. 1 root  Jimmy 0 7月  30 19:44 test-file
</code></pre><p>切换到另外一个用户niesh:</p>
<pre><code>[niesh@niesh tmp]$ ll
总用量 0
drwxrwxr-x. 2 Jimmy Jimmy 6 7月  30 19:44 test-dir
-rw-rw-r--. 1 root  Jimmy 0 7月  30 19:44 test-file
在 niesh用户下，删除/tmp目录下的文件：

[niesh@niesh tmp]$ rm -rf test-dir/ test-file
rm: 无法删除&quot;test-dir/&quot;: 不允许的操作  
无法删除！
</code></pre><p>然后，我们切换到root，去掉/tmp的粘滞位：</p>
<pre><code>[niesh@niesh tmp]$ su -
密码：
上一次登录：日 7月 30 19:43:21 CST 2017pts/0 上
[root@niesh ~]# chmod o-t /tmp/
[root@niesh ~]# ll -d /tmp/
drwxrwxrwx. 9 root root 4096 7月  30 19:48 /tmp/
</code></pre><p>最后，切换到普通用户niesh，再次删除/tmp下的文件：</p>
<pre><code>[niesh@niesh root]$ rm -rf /tmp/test-dir/ /tmp/test-file
[niesh@niesh root]$ ll /tmp/
总用量 0
</code></pre><p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/Jimmy1988/p/7260215.html" target="_blank" rel="external">http://www.cnblogs.com/Jimmy1988/p/7260215.html</a></li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/04/27/Linux权限-chattr、lsattr/">Linux权限 chattr、lsattr</a><a class="next" href="/2017/09/11/清华同方x46h开启Intel-VT/">清华同方x46h开启Intel VT</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">太阳落下.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>