<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>太阳落下</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-02T08:46:30.603Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 文件系统</title>
    <link href="http://yoursite.com/post/f525ac74.html"/>
    <id>http://yoursite.com/post/f525ac74.html</id>
    <published>2018-06-25T03:27:42.304Z</published>
    <updated>2018-06-02T08:46:30.603Z</updated>
    
    <content type="html"><![CDATA[<p>linux中一切皆文件。目录为目录文件。普通文件用来保存数据，目录文件用来保存文件<br>文件系统：<br>Windows里面是这样的：C:\Program files\office11\word\word.exe<br>Linux里面是这样的：/etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>文件有两类数据：<br>元数据：metadata  元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode…)等等。<br>数据：data  数据是指普通文件中的实际数据。</p>
<p>1、文件名严格区分字符大小写；file1, File1, FILE1是不同的文件；<br>2、文件名可使用除/以外的任意字符，不建议使用特殊字符；  /: 表示根目录，也用做路径分隔符；<br>3、文件名长度最长不能超过255个字符；<br>4、所以.开头的文件，均为隐藏文件；</p>
<p>LSB: Linux Standard Base Linux标准库</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux中一切皆文件。目录为目录文件。普通文件用来保存数据，目录文件用来保存文件&lt;br&gt;文件系统：&lt;br&gt;Windows里面是这样的：C:\Program files\office11\word\word.exe&lt;br&gt;Linux里面是这样的：/etc/sysconfig/network-scripts/ifcfg-eth0&lt;/p&gt;
&lt;p&gt;文件有两类数据：&lt;br&gt;元数据：metadata  元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode…)等等。&lt;br&gt;数据：data  数据是指普通文件中的实际数据。&lt;/p&gt;
&lt;p&gt;1、文件名严格区分字符大小写；file1, File1, FILE1是不同的文件；&lt;br&gt;2、文件名可使用除/以外的任意字符，不建议使用特殊字符；  /: 表示根目录，也用做路径分隔符；&lt;br&gt;3、文件名长度最长不能超过255个字符；&lt;br&gt;4、所以.开头的文件，均为隐藏文件；&lt;/p&gt;
&lt;p&gt;LSB: Linux Standard Base Linux标准库&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>How to use Github</title>
    <link href="http://yoursite.com/post/68d6df4b.html"/>
    <id>http://yoursite.com/post/68d6df4b.html</id>
    <published>2018-06-25T02:31:27.000Z</published>
    <updated>2018-06-25T12:22:33.754Z</updated>
    
    <content type="html"><![CDATA[<p>在写这篇文章的时候，Github已经被Microsoft收购，不过依然会使用Github，因为觉得对自己的影响不大。</p>
<p>最近重新学习Git发觉自己其实对Github了解甚少，star了不少，但是从来没有好好看过，我觉得<strong>学习一定要发挥自己的主动性</strong>，不能光收藏，还要尽可能提出issues、甚至代码，当前我最应该克服的是懒，破除嫌麻烦的这种思想，如果自己都懒，都嫌麻烦，如何去解决麻烦。</p>
<p>回到正题，Github是一个git版本库托管商，里面有各种开源项目。本篇文章尝试写清楚从Github的入门使用到参与开源项目的一般方法。</p>
<p>官网：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a><br><a id="more"></a></p>
<h2 id="账户的配置"><a href="#账户的配置" class="headerlink" title="账户的配置"></a>账户的配置</h2><p>如何注册账户就不介绍了</p>
<h3 id="SSH访问"><a href="#SSH访问" class="headerlink" title="SSH访问"></a>SSH访问</h3><p>配置SSH是为了能够在本地电脑上访问Github，识别出你推送的提交确实是你推送的，而不是别人冒充的</p>
<p>具体如何做，其实在<a href="https://fengrenxiaoli.github.io/post/a20da6f3.html" target="_blank" rel="external">【Hexo】使用Hexo搭建github博客</a>里面有过介绍，那篇文章是为了制作Github Pages，这里不再说明git的安装和配置，那么只有一行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_github</div></pre></td></tr></table></figure>
<p>该命令会在本地电脑（Linux）的<code>~/.ssh</code>下创建公钥和私钥，将公钥(<code>id_rsa_github.pub</code>)中的内容拷贝到github帐号<code>Settings</code>&gt;<code>SSH and GPG keys</code>中</p>
<p>此外还有头像的配置（Profile）、邮箱的配置（Emails）、两步验证（Security）等全部都在<code>Settings</code>里。</p>
<h2 id="创建项目仓库"><a href="#创建项目仓库" class="headerlink" title="创建项目仓库"></a>创建项目仓库</h2><p>创建项目仓库 首页 &gt; <code>New repository</code><br>如果勾选 <code>Initialize this repository with a README</code>，会创建一个<code>README.md</code>文件，</p>
<p>可以将本地已存在的项目上传到仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git remote add origin git@github.com:fengrenxiaoli/GitTest.git</div><div class="line">git add .</div><div class="line">git commit -m &quot;upload&quot;</div><div class="line">git push -u origin master</div><div class="line"># 第一次push需要-u参数，关联本地master和远程master，以后不用加-u</div></pre></td></tr></table></figure></p>
<p>也可以将Github上的项目复制到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:fengrenxiaoli/GitTest.git</div></pre></td></tr></table></figure></p>
<h2 id="Github协作流程"><a href="#Github协作流程" class="headerlink" title="Github协作流程"></a>Github协作流程</h2><ol>
<li>从 <code>master</code> 分支中创建一个新分支</li>
<li>创建，编辑，重命名，移动或删除文件</li>
<li>将这个分支推送到 GitHub 上</li>
<li>创建一个合并请求（Pull Request）</li>
<li>讨论，根据实际情况继续修改</li>
<li>项目的拥有者合并或关闭你的合并请求</li>
</ol>
<h3 id="给队友添加写权限"><a href="#给队友添加写权限" class="headerlink" title="给队友添加写权限"></a>给队友添加写权限</h3><p>到项目的 <code>Settings</code> 页面，点击 <code>collaborator</code> 选项，输入框中输入相应的用户名使用户具有写权限。</p>
<h3 id="Fork项目副本"><a href="#Fork项目副本" class="headerlink" title="Fork项目副本"></a>Fork项目副本</h3><p>对于大多数情况，参于开发者并不会被直接赋予写权限，开发者需要先Fork一份项目到自己的用户名下。</p>
<h3 id="创建一个新分支"><a href="#创建一个新分支" class="headerlink" title="创建一个新分支"></a>创建一个新分支</h3><p>开新分支一定要在刚刚更新过的 <code>master</code> 的基础上开。<br>分支的名字应该是描述性的（如<code>refactor-authentication</code>，<code>user-content-cache-key</code>，<code>make-retina-avatars</code>），越清楚越好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git pull</div><div class="line">git checkout -b &lt;branch-name&gt;</div><div class="line">vim &lt;file-name&gt;</div><div class="line">git add &lt;file-name&gt;</div><div class="line">git commit -m &quot;some commit&quot;</div><div class="line">git push origin &lt;branch-name&gt;</div></pre></td></tr></table></figure>
<h3 id="发起Pull-Request"><a href="#发起Pull-Request" class="headerlink" title="发起Pull Request"></a>发起Pull Request</h3><p>修改项目后，在Github上点击 <code>Compare &amp; pull request</code>，选择需要进行对比的分支，填写描述信息，需要图片可以直接拖进去，也可以点击<code>selecting them</code></p>
<p><code>Pull Request</code>会启动关于提交的讨论</p>
<p>如果需要新的改动，直接在分支上修改，然后同步即可在pull request页面看到</p>
<p><img src="/img/IMG145.png" alt=""><br><img src="/img/IMG146.png" alt=""></p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>拥有写权限的人可以点击 <code>Merge Pull Request</code><br>合并之后可以删除分支</p>
<h3 id="快速-Pull-Request"><a href="#快速-Pull-Request" class="headerlink" title="快速 Pull Request"></a>快速 Pull Request</h3><p>如果只是修改很小的一点，没有必要使用上述流程，直接在Github网页上点击编辑，然后选择<code>Create a new branch for this commit and start a pull request...</code></p>
<h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><p><a href="https://guides.github.com/features/issues/" target="_blank" rel="external">https://guides.github.com/features/issues/</a><br>Issue 中一般是放一些临时性的讨论(报Bug、提新需求等)，最终是要被关掉的。如果 Issue 里面有一些精华的内容，可以拷贝出来贴到 wiki 中，方便大家查阅。</p>
<p>打开项目页面，点击<code>issues</code>，点击<code>New issue</code><br>新建的issue会有一个编号，类似于<code># 1</code><br>issue支持MarkDown语法</p>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>使用三个反引号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\`\`\`js</div><div class="line">alert(&quot;hello worold&quot;)</div><div class="line">\`\`\`</div></pre></td></tr></table></figure>
<h3 id="快速引用"><a href="#快速引用" class="headerlink" title="快速引用"></a>快速引用</h3><p>MarkDown中使用<code>&gt;</code>作为引用<br>如果你想回答具体某个问题，可以用鼠标选中那段话，然后，敲 r 。这样这段话就自动出现在你的评论框中了。</p>
<h3 id="拉别人进来讨论"><a href="#拉别人进来讨论" class="headerlink" title="拉别人进来讨论"></a>拉别人进来讨论</h3><p>如果你在评论框中输入<code>@happypeter</code>那么不管我是不是你当然项目的参与者，我都会收到通知来进来参加讨论</p>
<h3 id="引用issue"><a href="#引用issue" class="headerlink" title="引用issue"></a>引用issue</h3><p>在评论框中输入<code>#</code>会提示相应的issue。<br>如果我在当前 Issue#10 的评论框中写 <code>#20</code> 就可以自动链接到 Issue#20 了。同时 Issue#20 那边也会显示出 Issue#10 。这种指向和关联的功能在实用中是非常重要的</p>
<h3 id="用版本留言关闭-Issue"><a href="#用版本留言关闭-Issue" class="headerlink" title="用版本留言关闭 Issue"></a>用版本留言关闭 Issue</h3><p>点击<code>Close issue</code>按钮可以关闭issue</p>
<h3 id="引用emoji"><a href="#引用emoji" class="headerlink" title="引用emoji"></a>引用emoji</h3><p>输入<code>:</code>,会提示输入emoji</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:dancer:</div></pre></td></tr></table></figure>
<h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p>
<p>Github Pages可以用于写博客，也可以用于制作项目网站，对应的网址是<code>http://username.github.io/repository</code></p>
<h2 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h2><p>用于发布版本<br>Github项目页，点击<code>release</code>&gt;<code>Draft a new release</code>，创建标签，填入字段</p>
<p>参考：</p>
<ul>
<li><a href="https://guides.github.com/introduction/flow/index.html" target="_blank" rel="external">Understanding the GitHub Flow</a></li>
<li><a href="http://gitbeijing.com/" target="_blank" rel="external">http://gitbeijing.com/</a></li>
<li><a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="external">Hello World</a></li>
<li><a href="https://www.jianshu.com/p/482b32716bbe" target="_blank" rel="external">Git 游戏通关流程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写这篇文章的时候，Github已经被Microsoft收购，不过依然会使用Github，因为觉得对自己的影响不大。&lt;/p&gt;
&lt;p&gt;最近重新学习Git发觉自己其实对Github了解甚少，star了不少，但是从来没有好好看过，我觉得&lt;strong&gt;学习一定要发挥自己的主动性&lt;/strong&gt;，不能光收藏，还要尽可能提出issues、甚至代码，当前我最应该克服的是懒，破除嫌麻烦的这种思想，如果自己都懒，都嫌麻烦，如何去解决麻烦。&lt;/p&gt;
&lt;p&gt;回到正题，Github是一个git版本库托管商，里面有各种开源项目。本篇文章尝试写清楚从Github的入门使用到参与开源项目的一般方法。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用方法</title>
    <link href="http://yoursite.com/post/ab888b92.html"/>
    <id>http://yoursite.com/post/ab888b92.html</id>
    <published>2018-06-24T01:29:39.000Z</published>
    <updated>2018-06-26T05:59:28.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p><strong>集中式版本控制系统</strong>（Centralized Version Control Systems,简称 CVCS）：have a single server that contains all the versioned files, and a number of clients that check out files from that central place.</p>
<p>集中式版本控制系统的缺点是中央服务器的单点故障。</p>
<p><strong>分布式版本控制系统</strong>（Distributed Version Control System,简称 DVCS）：clients don’t just check out the latest snapshot of the files; rather, they fully mirror the repository, including its full history.</p>
<p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p>集中式版本控制：CVS、SVN、ClearCase、VSS<br>分布式版本控制：Git、BitKeeper、Mercurial、Bazaar</p>
<p>git和其他版本控制工具存储数据的方式不同：</p>
<ul>
<li>其他版本控制工具存储一组文件以及基于这些文件随时间推移产生的差异</li>
<li>git存储更像快照，对当时的全部文件制作一个快照并保存这个快照的索引，如果没有修改则只保留一个指向之前存储文件的链接</li>
</ul>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息<br>SVN 中可以修改文件，但是无法向数据库提交修改</p>
<p>Git 中所有数据在存储前都计算<strong>校验和</strong>，然后以校验和来引用，<br>校验和由 40 个十六进制字符组成，通过SHA1计算得出。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<a id="more"></a>
<h2 id="Git的作用"><a href="#Git的作用" class="headerlink" title="Git的作用"></a>Git的作用</h2><ol>
<li>备份文件</li>
<li>记录历史</li>
<li>回到过去</li>
<li>多端共享</li>
<li>团队协作</li>
</ol>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt install git</div><div class="line">sudo yum install git</div></pre></td></tr></table></figure>
<h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git help &lt;verb&gt;</div><div class="line">git &lt;verb&gt; --help</div><div class="line">man git &lt;verb&gt;</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config</div></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol>
<li><code>/etc/gitconfig</code>，系统配置，<code>git config --system</code></li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>，当前用户，<code>git config --global</code></li>
<li>项目目录下的<code>.git/config</code>，当前仓库</li>
</ol>
<p>当前仓库会覆盖当前用户配置，当前用户配置会覆盖系统配置</p>
<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;Your Name&quot;</div><div class="line">git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure>
<p>全局配置只需设置一次<br>当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置</p>
<h3 id="列出所有配置"><a href="#列出所有配置" class="headerlink" title="列出所有配置"></a>列出所有配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --list</div></pre></td></tr></table></figure>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git config --global alias.st status</div><div class="line"># git st</div><div class="line">git config --global alias.co checkout</div><div class="line"># git co</div><div class="line">git config --global alias.ci commit</div><div class="line"># git ci</div><div class="line">git config --global alias.br branch</div><div class="line"># git br</div></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd &lt;dir-name&gt;</div><div class="line">git init</div></pre></td></tr></table></figure>
<h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:fengrenxiaoli/GitTest.git</div><div class="line"># 在当前目录下创建一个 GitTest 目录，并在 GitTest 目录下创建 .git 文件夹</div><div class="line"></div><div class="line">git clone git@github.com:fengrenxiaoli/GitTest.git mylibgit</div><div class="line"># 在当前目录下创建一个 mylibgit 目录，并在 mylibgit 目录下创建 .git 文件夹</div></pre></td></tr></table></figure>
<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<p><img src="/img/IMG149.png" alt=""></p>
<p>tracked：已跟踪，那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区<br>untracked：未跟踪，其他文件，使用<code>git add &lt;file-name&gt;</code>变为跟踪状态</p>
<h3 id="三种状态和三个工作区域"><a href="#三种状态和三个工作区域" class="headerlink" title="三种状态和三个工作区域"></a>三种状态和三个工作区域</h3><table>
<thead>
<tr>
<th>状态</th>
<th>工作区域</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>已修改modifed</td>
<td>Workspace</td>
<td></td>
</tr>
<tr>
<td>已暂存staged</td>
<td>Stage/Index</td>
<td><code>git add &lt;file-name&gt;</code></td>
</tr>
<tr>
<td>已提交commited</td>
<td>Local Repository/.git目录</td>
<td><code>git commit</code></td>
</tr>
</tbody>
</table>
<p><code>git add</code>既可以用该命令开始跟踪新文件，也可以把已跟踪的文件放到暂存区</p>
<h2 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git diff</div><div class="line">git diff readme.txt</div><div class="line"># 查看修改之后还没有暂存起来的修改内容(git add前)</div><div class="line"># 工作区(workspace)和暂存区(stage)的比较</div><div class="line"></div><div class="line">git diff HEAD --readme.txt</div><div class="line"></div><div class="line">git diff --cached</div><div class="line"># 查看已暂存的将要添加到下次提交里的内容(git add后)</div><div class="line"># 暂存区(stage)和分支(master)的比较</div></pre></td></tr></table></figure>
<h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git add readme.txt</div><div class="line"># 实际上是把文件修改添加到暂存区</div><div class="line"></div><div class="line">git commit</div><div class="line"># 提交更改，实际上是把暂存区的所有内容提交到当前分支</div><div class="line"># 会启动默认的编辑器输入注释信息</div><div class="line"># 没有git add但是已经修改的内容不会提交</div><div class="line">git commit -m &quot;增加文件&quot;</div><div class="line"># 直接声明注释信息</div><div class="line"></div><div class="line">git commit -m -a &apos;增加文件&apos;</div><div class="line"># git add + git commit</div></pre></td></tr></table></figure>
<h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>忽略某些文件时，需要编写<code>.gitignore</code><br><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理<br>参考模版：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></p>
<p>文件 <code>.gitignore</code> 的格式规范如下：<br>• 所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。<br>• 可以使用标准的 <code>glob</code> 模式（通配符模式）匹配。<br>• 以 <code>/</code> 开头防止递归。<br>• 以 <code>/</code> 结尾表示目录。<br>• 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。</p>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line"># 查看提交历史，以便确定要回退到哪个版本，时间从最近到最远</div><div class="line"># 列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明</div><div class="line"></div><div class="line"></div><div class="line">git log -p</div><div class="line"># 显示每次提交的内容差异，可以用于代码审查</div><div class="line">git log -2</div><div class="line"># 最近再次提交</div><div class="line">git log --since=2.weeks</div><div class="line"># 最近两周提交</div><div class="line"></div><div class="line">git log --author=&quot;John&quot;</div><div class="line"># 指定作者（负责修改的人）</div><div class="line">git log --grep=&quot;关键字&quot;</div><div class="line"># 搜索提交信息中的关键字</div><div class="line">git log --author=&quot;John&quot; --grep=&quot;关键字&quot; --all-match</div><div class="line"># --all-match 同时匹配</div><div class="line"></div><div class="line">git log -S &quot;key&quot;</div><div class="line"># 仅显示添加或移除了某个关键字的提交</div><div class="line"></div><div class="line">git log -- path</div><div class="line"># 指定路径，放在最后</div><div class="line"></div><div class="line">git log --stat</div><div class="line"># 包含简略的统计信息</div><div class="line">git log --pretty=oneline</div><div class="line"># 指定显示格式，oneline表示单选显示，其他包括short\full\fuller</div><div class="line">git log --format=&quot;%h - %an - %ar - %s&quot;</div><div class="line"># 指定显示格式，具体选项，参考git log --help，或参考Pro-git</div><div class="line">git log --format=&apos;%h %s&apos; --graph</div><div class="line"># 图形化显示分支、合并历史</div><div class="line"></div><div class="line"></div><div class="line">git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \</div><div class="line">  --before=&quot;2008-11-01&quot; --no-merges -- t/</div><div class="line"># 2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件</div></pre></td></tr></table></figure>
<h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD^</div><div class="line"># 回退到上个版本</div><div class="line"></div><div class="line">git reset --hard 1094adb</div><div class="line"># 回退到指定的commit id，commit id可以只写前几位</div><div class="line"></div><div class="line">git log</div><div class="line"># 这里无法查看指定的commit id之后的版本，可以使用git relog</div><div class="line"></div><div class="line">git relog</div><div class="line"># 查看命令历史，以便确定要回到未来的哪个版本commit id</div></pre></td></tr></table></figure>
<p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git checkout -- readme.txt</div><div class="line"># 未git add，回退到文件修改之前（丢弃工作区的修改），不需要直接修改文件</div><div class="line"></div><div class="line"> git reset HEAD readme.txt</div><div class="line"># 已经git add（添加到了暂存区），需要回退未git add 之前</div></pre></td></tr></table></figure>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">rm readem.txt</div><div class="line">git rm readme.txt</div><div class="line"># 未提交到暂存区域</div><div class="line"># 可以用git add代替</div><div class="line"></div><div class="line">git rm -f readme.txt</div><div class="line"># 删除已经添加到暂存区域的文件 </div><div class="line"></div><div class="line"></div><div class="line">git rm --cached readme.txt</div><div class="line"># 让文件保存在磁盘，但是禁止git继续跟踪</div><div class="line"># 适用于忘记添加 .gitignore 文件时</div></pre></td></tr></table></figure>
<h2 id="删除文件-1"><a href="#删除文件-1" class="headerlink" title="删除文件"></a>删除文件</h2><p>当你要删除文件的时候，可以采用命令：<code>rm test.txt</code></p>
<p>这个时候（也就是说这个时候只执行了rm test.txt）有两种情况</p>
<p>第一种情况:的确要把test.txt删掉，那么可以执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm test.txt</div><div class="line">git commit -m &quot;remove test.txt&quot;</div></pre></td></tr></table></figure></p>
<p>然后文件就被删掉了<br>第二种情况:删错文件了，不应该删test.txt，注意这时只执行了rm test.txt，还没有提交，所以可以执行<code>git checkout test.txt</code>将文件恢复。</p>
<p>并不是说执行完git commit -m “remove test.txt”后还能用checkout恢复，commit之后版本库里的文件也没了，自然没办法用checkout恢复，而是要用其他的办法</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>先有本地库，后有远程库的时候，如何关联远程库<br>1.在github上创建仓库<br>2.在本地的learngit仓库下运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:michaelliao/learngit.git</div></pre></td></tr></table></figure></p>
<p>添加后，远程库的名字就是<code>origin，这是Git默认的叫法
3.把本地库的内容推送到远程，用</code>git push`命令，实际上是把当前分支master推送到远程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div><div class="line"># 可以把 master 换成你想要推送的任何分支</div><div class="line"># origin可以换成你想用的名字，但是一般用origin</div></pre></td></tr></table></figure></p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，以后只要执行以下命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure></p>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>先创建远程库，然后，从远程库克隆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone git@github.com:michaelliao/gitskills.git</div></pre></td></tr></table></figure>
<p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p><code>master</code>主分支<br><code>HEAD</code>指向的就是当前分支<br>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点<br>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">git pull</div><div class="line"># 更新本地仓库至最新改动</div><div class="line"></div><div class="line">git checkout -b dev</div><div class="line"># 创建并切换分支</div><div class="line"></div><div class="line">git branch</div><div class="line"># 列出所有分支，当前分支前面会标一个*号</div><div class="line"></div><div class="line">git branch dev</div><div class="line"># 查看当前分支</div><div class="line"></div><div class="line">git checkout dev</div><div class="line"># 切换分支</div><div class="line"></div><div class="line">git add readme.txt</div><div class="line">git commit -m &quot;branch test&quot;</div><div class="line"></div><div class="line">git checkout master</div><div class="line">git merge dev</div><div class="line"># 把dev分支的工作成果合并到master分支上</div><div class="line"></div><div class="line">git branch -d dev</div><div class="line"># 删除分支</div></pre></td></tr></table></figure></p>
<p>直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并<br>删除<code>dev</code>分支就是把<code>dev</code>指针给删掉</p>
<p><code>git merge</code>命令用于合并指定分支到当前分支</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>不同的分支各自都分别有新的提交，当进行合并时就会发生冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件</p>
<p>修改文件中的冲突后可以再次提交</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图产品</p>
<p>git有个最佳实践，master是主分支，用来做正式发布版之后的保留历史，其他分支包括dev用来做正常开发，多个feature用来做某些特性功能，release用来做发布版历史，每次发布都是用release打包，hotfix用来做发布版之后的一些及时迭代修复bug的工作。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</div></pre></td></tr></table></figure></p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>假定需要在master分支上修复，就从master创建临时分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">git stash</div><div class="line"># 保存现场工作</div><div class="line"></div><div class="line">git checkout master</div><div class="line">git checkout -b issue-101</div><div class="line">git add readme.txt </div><div class="line">git commit -m &quot;fix bug 101&quot;</div><div class="line">git checkout master</div><div class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line"></div><div class="line">git checkout dev</div><div class="line"># 切换到之前的工作分支</div><div class="line">git stash list</div><div class="line"># 列出保存的工作现场</div><div class="line">git stash pop</div><div class="line"># 恢复的同时把stash内容也删了</div></pre></td></tr></table></figure></p>
<h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>添加一个新功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature-vulcan</div><div class="line"># 原来在dev分支</div><div class="line"></div><div class="line">git add vulcan.py</div><div class="line">git commit -m &quot;add feature vulcan&quot;</div><div class="line">git checkout dev</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch -D feature-vulcan</div><div class="line"># 强行删除分支，未合并之前删除使用</div></pre></td></tr></table></figure>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">git push origin master</div><div class="line">git push origin dev</div><div class="line"># 推送分支</div><div class="line"></div><div class="line">git clone git@github.com:michaelliao/learngit.git</div><div class="line">git branch</div><div class="line"># 默认是master分支</div><div class="line">git checkout -b dev origin/dev</div><div class="line"># 创建dev分支</div><div class="line"></div><div class="line">git pull</div><div class="line">git branch --set-upstream-to=origin/dev dev</div><div class="line"># 解决冲突</div></pre></td></tr></table></figure>
<p><img src="/img/IMG144.jpg" alt=""></p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">git checkout master</div><div class="line"># 切换到需要打标签的分支上</div><div class="line"></div><div class="line">git tag v1.0</div><div class="line"># 打一个新标签</div><div class="line"></div><div class="line">git tag</div><div class="line"># 查看所有标签</div><div class="line"></div><div class="line">git log --pretty=oneline --abbrev-commit</div><div class="line">git tag v0.9 f52c633</div><div class="line"># 针对某一commit id打标签</div><div class="line"></div><div class="line">git show v0.9</div><div class="line"># 查看标签信息</div><div class="line"></div><div class="line">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</div><div class="line"># -a指定标签名，-m指定说明文字</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git tag -d v0.1</div><div class="line"># 删除一个本地标签</div><div class="line"></div><div class="line">git push origin v1.0</div><div class="line"># 推送某个标签到远程</div><div class="line">git push origin --tags</div><div class="line"># 一次性推送全部尚未推送到远程的本地标签</div><div class="line"></div><div class="line">git tag -d v0.9</div><div class="line">git push origin :refs/tags/v0.9</div><div class="line"># 删除推送到远程的标签</div></pre></td></tr></table></figure>
<h2 id="一个本地库关联多个远程库"><a href="#一个本地库关联多个远程库" class="headerlink" title="一个本地库关联多个远程库"></a>一个本地库关联多个远程库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote -v</div><div class="line"># 查看远程库信息</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div><div class="line"># 先删除已关联的名为origin的远程库</div><div class="line"></div><div class="line"></div><div class="line">git remote add github git@github.com:michaelliao/learngit.git</div><div class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</div><div class="line"># 关联远程库，远程库的名称叫github、gitee</div></pre></td></tr></table></figure>
<h2 id="分支开发"><a href="#分支开发" class="headerlink" title="分支开发"></a>分支开发</h2><ol>
<li>基于主分支创建个开发分支   <code>git checkout -b dev1</code></li>
<li>在开发分支中拉取下主分支   <code>git pull origin master</code></li>
<li>开发完成后，提交到git服务器     <code>git add</code> . / <code>git commit -m &#39;1&#39;</code>/ <code>git push origin dev1</code></li>
<li>拉取下主分支，提前解决冲突 <code>git pull origin master</code></li>
<li>切回主分支(切记要提交后切回)     <code>git checkout master</code></li>
<li>拉取下最新代码  <code>git pull origin master</code></li>
<li>合并开发分支   <code>git merge dev1</code>(如果失败会提示失败文件，解决掉冲突)</li>
<li>提交到git服务器</li>
</ol>
<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>以下方式为通过ssh协议搭建的Git服务器，添加了公钥的用户可以进行读写操作</p>
<p>1.安装git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install git</div></pre></td></tr></table></figure></p>
<p>2.创建用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat /etc/shells</div><div class="line">which git-shell</div><div class="line">sudo vim /etc/shells</div><div class="line"># 添加git-shell的位置，git-shell可以禁止使用ssh登录shell</div><div class="line"></div><div class="line">sudo adduser git -s /usr/bin/git-shell</div></pre></td></tr></table></figure></p>
<p>3.管理公钥<br>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个<br>人多可以用<code>Gitosis</code>来管理公钥</p>
<p>注意权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">su git</div><div class="line">cd</div><div class="line">mkdir .ssh</div><div class="line">chmod 700 .ssh</div><div class="line">touch .ssh/authorized_keys</div><div class="line">chmod 600 .ssh/authorized_keys</div><div class="line"></div><div class="line">cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys</div><div class="line">cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p>
<p>4.初始化Git仓库<br>选定一个目录作为Git仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd /opt/git</div><div class="line">mkdir project.git</div><div class="line">cd project.git</div><div class="line">git init --bare</div><div class="line"></div><div class="line">chown -R git:git project.git</div></pre></td></tr></table></figure></p>
<p>需要有一个人推送第一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd myproject</div><div class="line">git init</div><div class="line">git add .</div><div class="line">git commit -m &apos;initial commit&apos;</div><div class="line">git remote add origin git@gitserver:/opt/git/project.git</div><div class="line">git push origin master</div></pre></td></tr></table></figure></p>
<p>5.克隆远程仓库<br>在各自的电脑上克隆远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@server:/srv/sample.git</div></pre></td></tr></table></figure></p>
<p>Git不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<code>Gitolite</code>就是这个工具。</p>
<p>还有其他方式，比如适合快速只读访问的Git守护进程，既可以进行授权访问又可以进行无授权访问的Smart HTTP，使用GitWeb搭建网页展示，参考Pro-git</p>
<p><img src="/img/IMG148.png" alt=""></p>
<p>利用工具提升工作效率，而不是去学习工具本身</p>
<ol>
<li>多用客户端和工具，少用命令行，除非在linux服务器上直接开发</li>
<li>每次提交前，diff自己的代码，以免提交错误的代码</li>
<li>下班回家前，整理好自己的工作区</li>
<li>并行的项目，使用分支开发</li>
<li>遇到冲突时，搞明白冲突的原因，千万不要随意丢弃别人的代码</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/entry/586eddf6a22b9d00587829ce" target="_blank" rel="external">比较全面的 Git 学习资料整理</a></li>
<li><a href="http://www.cylong.com/blog/2016/09/26/git-svn/" target="_blank" rel="external">http://www.cylong.com/blog/2016/09/26/git-svn/</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="external">http://rogerdudler.github.io/git-guide/</a></li>
<li><a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="external">https://guides.github.com/activities/hello-world/</a></li>
<li><a href="http://www.uml.org.cn/pzgl/201207264.asp" target="_blank" rel="external">分布式和集中式版本控制工具-svn,git,mercurial</a></li>
<li><a href="https://www.jianshu.com/p/86ef009e5c86" target="_blank" rel="external">Git在工作中的小总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本控制系统&quot;&gt;&lt;a href=&quot;#版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;版本控制系统&quot;&gt;&lt;/a&gt;版本控制系统&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;集中式版本控制系统&lt;/strong&gt;（Centralized Version Control Systems,简称 CVCS）：have a single server that contains all the versioned files, and a number of clients that check out files from that central place.&lt;/p&gt;
&lt;p&gt;集中式版本控制系统的缺点是中央服务器的单点故障。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式版本控制系统&lt;/strong&gt;（Distributed Version Control System,简称 DVCS）：clients don’t just check out the latest snapshot of the files; rather, they fully mirror the repository, including its full history.&lt;/p&gt;
&lt;p&gt;分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。&lt;/p&gt;
&lt;p&gt;集中式版本控制：CVS、SVN、ClearCase、VSS&lt;br&gt;分布式版本控制：Git、BitKeeper、Mercurial、Bazaar&lt;/p&gt;
&lt;p&gt;git和其他版本控制工具存储数据的方式不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他版本控制工具存储一组文件以及基于这些文件随时间推移产生的差异&lt;/li&gt;
&lt;li&gt;git存储更像快照，对当时的全部文件制作一个快照并保存这个快照的索引，如果没有修改则只保留一个指向之前存储文件的链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息&lt;br&gt;SVN 中可以修改文件，但是无法向数据库提交修改&lt;/p&gt;
&lt;p&gt;Git 中所有数据在存储前都计算&lt;strong&gt;校验和&lt;/strong&gt;，然后以校验和来引用，&lt;br&gt;校验和由 40 个十六进制字符组成，通过SHA1计算得出。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://yoursite.com/post/7a8ab919.html"/>
    <id>http://yoursite.com/post/7a8ab919.html</id>
    <published>2018-06-23T08:23:53.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件测试概要"><a href="#软件测试概要" class="headerlink" title="软件测试概要"></a>软件测试概要</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>软件测试是对程序能够按预期运行建立起一种信心  ——Bill Hetzel,1973</li>
<li>测试是为发现错误而执行程序的过程            ——Myers,1979</li>
<li>使用人工或自动的<strong>手段</strong>来运行或测量软件系统的过程，以检测软件系统是否满足<strong>规定的要求</strong>，并找出与<strong>预期定义</strong>之间的差异。        ——IOS/IEC/IEEE 29119</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>软件测试覆盖整个软件研发过程</p>
<ul>
<li>软件需求</li>
<li>概要设计</li>
<li>详细设计</li>
<li>源代码</li>
<li>可运行程序</li>
<li>可运行环境</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><img src="/img/IMG142.png" alt=""></p>
<h3 id="五大要素及两大目标"><a href="#五大要素及两大目标" class="headerlink" title="五大要素及两大目标"></a>五大要素及两大目标</h3><p>要素：</p>
<ul>
<li>质量(最为核心)</li>
<li>人员(决定因素)</li>
<li>技术(实现手段)【测试技术，方法，测试工具】</li>
<li>资源【测试所需的硬件，网络环境，测试生命周期，测试时间】</li>
<li>流程(测试标准)【测试计划，测试执行，报告】</li>
</ul>
<p>目标</p>
<ul>
<li>提升测试覆盖率</li>
<li>测试效率</li>
</ul>
<h3 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h3><ol>
<li>测试显示软件的存在，但不能证明系统不存在缺陷</li>
<li>穷极测试是不可能的，应设定及时终止的条件（无穷无尽的测试是不可能的，需很大代价；无论怎样测试，我们不可能发现软件的所有缺陷）</li>
<li>测试应该尽早进行</li>
<li>缺陷具备群集特性（发现越多错误的模块，越应该集中关注，可能该模块的编程人员的水平较低）</li>
<li>测试的杀虫剂悖论（用相同的用例多次测试时发现不了bug的，应该更新测试方法和用例）</li>
<li>测试的二八原则（80%的时间测试20%的重要模块）</li>
<li>测试活动依赖于测试背景（针对不同的软件的测试方法是不同的，比如电信软件看中性能、大批量；银行看中安全性）</li>
</ol>
<p>术语<strong>杀虫剂悖论</strong>（The Pesticide Paradox）用来描述这样一种现象，即你对软件进行越多的测试，那么该软件对你的测试就越具有免疫力。同样的事情发生在对昆虫使用杀虫剂上。如果你持续使用同样的杀虫剂，这些昆虫最终将建立起抵抗力，杀虫剂将不再发挥作用。<br>为了克服“杀虫剂悖论”，软件测试人员必须不断地编写新的不同的测试来检验程序的不同部分从而找出更多的bug。<br>让其他的人来测试你的程序将有助于打破“杀虫剂悖论”。</p>
<p><img src="/img/IMG143.png" alt=""></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;软件测试概要&quot;&gt;&lt;a href=&quot;#软件测试概要&quot; class=&quot;headerlink&quot; title=&quot;软件测试概要&quot;&gt;&lt;/a&gt;软件测试概要&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>nmap使用</title>
    <link href="http://yoursite.com/post/30bf2354.html"/>
    <id>http://yoursite.com/post/30bf2354.html</id>
    <published>2018-06-22T14:00:49.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nmap.org/" target="_blank" rel="external">Nmap</a>(Network Mapper)是一款用于网络发现（Network Discovery）和安全审计（Security Audting）的安全工具，采用C++语言编写，常用于<strong>端口扫描</strong>。<br>Nmap软件包带有一个名为GUI的包zenmap，使用Python编写。</p>
<h2 id="安装nmap"><a href="#安装nmap" class="headerlink" title="安装nmap"></a>安装nmap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nmap</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>最简单的形式是只传递地址或域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmap scanme.nmap.org</div><div class="line">nmap 74.207.244.221</div><div class="line">nmap 192.168.1.200</div></pre></td></tr></table></figure></p>
<h3 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h3><p>扫描结果中显示的商品状态</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>开放，探测报文到达了端口，端口有响应：我有应用程序监听 - SYN/ACK</td>
</tr>
<tr>
<td>closed</td>
<td>关闭，探测报文到达了端口，端口有响应：我没应用程序监听 - RST (复位)</td>
</tr>
<tr>
<td>filtered</td>
<td>被屏蔽，探测报文到不了端口，石沉大海</td>
</tr>
<tr>
<td>unfiltered</td>
<td>没有被屏蔽，还需要确认，探测报文到达了端口，没响应了</td>
</tr>
<tr>
<td>open &#124; filtered</td>
<td>开放或屏蔽，有可能报文过滤器丢弃了探测报文（filtered），或丢弃了端口的响应报文 (open)(原理请往下看 -sN，-sF，-sX)UDP，IP 协议， FIN，Null，和 Xmas 扫描可能把端口归入此类</td>
</tr>
<tr>
<td>closed &#124; unfiltered</td>
<td>关闭或屏蔽，IPID+1，但是 closed 和 unfiltered 都可能导致只 + 1，所以就不确定了。只可能出现在 IP ID Idle 扫描中（看下端口 TCP 空闲扫描的原理就知道为什么了）</td>
</tr>
</tbody>
</table>
<h3 id="扫描类型"><a href="#扫描类型" class="headerlink" title="扫描类型"></a>扫描类型</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sT　　</td>
<td>TCP 连接扫描，会在目标主机中记录大量的链接请求和错误信息</td>
</tr>
<tr>
<td>-sS　　</td>
<td>SYN 扫描，隐蔽扫描，不创建完整连接，只完成三次握手前两次，很少有系统记入日志，默认使用，需要 root(admin) 权限</td>
</tr>
<tr>
<td>-sP　　</td>
<td>Ping 扫描，默认使用，只有能 Ping 得通才会继续扫描</td>
</tr>
<tr>
<td>-P0　　</td>
<td>扫描之前不需要 Ping，用于绕过防火墙禁 Ping 功能</td>
</tr>
<tr>
<td>-sA　　</td>
<td>高级的扫描方式，用来穿过防火墙的规则集</td>
</tr>
<tr>
<td>-sV　　</td>
<td>服务的详细信息　</td>
</tr>
<tr>
<td>-sU　　</td>
<td>UDP 扫描，扫描主机开启的 UDP 的服务，速度慢，结果不可靠　</td>
</tr>
<tr>
<td>-sX -sN 　　</td>
<td>秘密的 FIN 数据包扫描，圣诞树 (Xmas Tree) 和空模式，针对 Unix 和 Linux 主机，系统要求遵循 TCP RFC 文档</td>
</tr>
</tbody>
</table>
<h3 id="扫描参数"><a href="#扫描参数" class="headerlink" title="扫描参数"></a>扫描参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v　　</td>
<td>显示扫描过程，推荐使用</td>
</tr>
<tr>
<td>-h　　</td>
<td>帮助文档</td>
</tr>
<tr>
<td>-p　　</td>
<td>指定端口号，如 [1-65535],[22,135,1433,3306,] 等格式</td>
</tr>
<tr>
<td>-O　　</td>
<td>探测操作系统，存在误报</td>
</tr>
<tr>
<td>-A　　</td>
<td>全面系统监测，使用脚本检测，扫描等</td>
</tr>
<tr>
<td>-T4　</td>
<td>针对 TCP 端口禁止动态扫描延迟超过 10ms</td>
</tr>
<tr>
<td>-iL　</td>
<td>　批量扫描，读取主机列表，如 [-iL C:\ip.txt]</td>
</tr>
<tr>
<td>-F</td>
<td>快速扫描</td>
</tr>
<tr>
<td>-V</td>
<td>确定指定端口对应的服务信息</td>
</tr>
<tr>
<td>-eclude</td>
<td>排除IP，多个IP用逗号分隔</td>
</tr>
<tr>
<td>-p</td>
<td>指定端口，多个端口用逗号分隔</td>
</tr>
</tbody>
</table>
<h3 id="扫描案例"><a href="#扫描案例" class="headerlink" title="扫描案例"></a>扫描案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># 扫描 C 段（局域网）存活主机</div><div class="line">nmap -sP www.XXX.com/24</div><div class="line">nmap -sP 192.168.1.*</div><div class="line"></div><div class="line"># 主机发现，通过ICMP ECHO扫描子网中的在线主机</div><div class="line">nmap -v -sn -PE 192.168.1.1/24</div><div class="line">nmap -v -sn -PE 192.168.1.1-5</div><div class="line"></div><div class="line"># 指定商品扫描</div><div class="line">nmap -v -p 135 192.168.1.1-5</div><div class="line"></div><div class="line"># 扫描指定 IP 开放端口号</div><div class="line"># -p-为全端口扫描，和[1-65535]一样，建议使用，不使用默认Nmap认为危险的100个端口号</div><div class="line">nmap -sS -p- -v 192.168.1.100</div><div class="line"></div><div class="line"># 扫描指定 IP 所开端口及对应的服务</div><div class="line">nmap -sV -v 192.168.1.100</div><div class="line"></div><div class="line"># 探测主机操作系统以及硬件信息，扫描准确度以百分比显示，未必准确</div><div class="line">nmap -O www.XXX.com</div><div class="line"></div><div class="line"># 穿透防火墙扫描</div><div class="line">nmap -P0  www.XXX.com</div><div class="line"></div><div class="line"># 全面探测，-A 包含 OS 探测，版本探测，脚本扫描，traceroute</div><div class="line">nmap -A www.XXX.com</div><div class="line"></div><div class="line"># 使用脚本扫描，脚本放在Nmap安装目录script下，官网可查各个脚本功能</div><div class="line">nmap --script=&quot;脚本名称&quot; www.XXX.com</div><div class="line"></div><div class="line"># 如在局域网上扫找 Conficker 蠕虫病毒</div><div class="line">nmap -PN -T4 -p139,445 -n -v --script=smb-check-vulns --script-args safe=1 192.168.0.1-254</div></pre></td></tr></table></figure>
<p>补充：</p>
<ul>
<li><a href="https://github.com/erasin/notes/blob/master/linux/safe/nmap.md" target="_blank" rel="external">https://github.com/erasin/notes/blob/master/linux/safe/nmap.md</a></li>
<li><a href="https://nmap.org/book/history-future.html" target="_blank" rel="external">https://nmap.org/book/history-future.html</a></li>
<li><a href="https://blog.csdn.net/emaste_r/article/details/17840465" target="_blank" rel="external">https://blog.csdn.net/emaste_r/article/details/17840465</a></li>
<li><a href="http://os.chinaunix.net/a2006/0619/956/000000956765.shtml" target="_blank" rel="external">http://os.chinaunix.net/a2006/0619/956/000000956765.shtml</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26676508" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26676508</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Nmap" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Nmap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://nmap.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Nmap&lt;/a&gt;(Network Mapper)是一款用于网络发现（Network Discovery）和安全审计（Security Audting）的安全
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看IP使用情况</title>
    <link href="http://yoursite.com/post/62edaad4.html"/>
    <id>http://yoursite.com/post/62edaad4.html</id>
    <published>2018-06-22T13:59:14.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt install fping</div><div class="line">fping -g -c 1 192.168.1.0/24</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -nsP 192.168.1.1-254</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Cisco Packet Tracer</title>
    <link href="http://yoursite.com/post/5aea5c58.html"/>
    <id>http://yoursite.com/post/5aea5c58.html</id>
    <published>2018-06-22T02:16:28.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.netacad.com/courses/packet-tracer" target="_blank" rel="external">https://www.netacad.com/courses/packet-tracer</a></p>
<p>注册下载</p>
<!-- ## 环境
需要java和32位包

```
sudo dpkg --add-architecture i386
sudo apt-get install libc6:i386
sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0
sudo apt-get install libnss3-1d:i386 libqt4-qt3support:i386 libssl1.0.0:i386 libqtwebkit4:i386 libqt4-scripttools:i386
``` -->
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将压缩文件解压缩到一个文件夹并打开一个终端。<br>使用sudo权限运行install.sh并按照说明进行安装<br>安装的默认路径是<code>/opt/pt</code></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在终端中键入<code>packettracer</code>来运行<br>如果没有反应，运行<code>/opt/pt/bin/PacketTracer7</code><br>会提示缺少库文件，安装相应库文件后再次运行</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>调整终端字体</strong><br>点击选项（options），点击首选项（Preferences），然后点击字体（Font），选CLI右侧就有大小的选择了。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.christospanoudis.com/how-to-install-packet-tracer-7-1-in-linux-and-resolve-any-dependency-issues/" target="_blank" rel="external">http://www.christospanoudis.com/how-to-install-packet-tracer-7-1-in-linux-and-resolve-any-dependency-issues/</a></li>
<li><a href="https://linux.cn/article-5576-1.html" target="_blank" rel="external">https://linux.cn/article-5576-1.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.netacad.com/courses/packet-tracer&quot; target=&quot;_blank
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 网络层</title>
    <link href="http://yoursite.com/post/5149561d.html"/>
    <id>http://yoursite.com/post/5149561d.html</id>
    <published>2018-06-21T14:50:39.000Z</published>
    <updated>2018-06-23T09:55:00.580Z</updated>
    
    <content type="html"><![CDATA[<p>TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，则将数据包丢弃。ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的，traceroute正是因为有了TTL才能正常工作</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>抓包工具tcpdump、wireshark</title>
    <link href="http://yoursite.com/post/8a478097.html"/>
    <id>http://yoursite.com/post/8a478097.html</id>
    <published>2018-06-21T06:44:38.000Z</published>
    <updated>2018-06-21T15:34:33.638Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux下，当我们需要<strong>抓取网络数据包分析</strong>时，通常是使用工具<strong>tcpdump</strong>。但是，有时我们需要将抓取的数据包保存在一个文件中，已备以后分析。而tcpdump保存的文件是<strong>二进制文件</strong>，使用cat 和vim 都无法打开查看。此时我们采取的措施是，下载到本地使用<strong>wireshark</strong>界面网络分析工具进行网络包分析。</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>需要管理员权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">tcpdump host www.baidu.com</div><div class="line">tcpdump host www.baidu.com and port 80</div><div class="line">tcpdump host www.baidu.com -w out.cap</div><div class="line"></div><div class="line"># 经过eth1</div><div class="line">tcpdump -i eth1 host 192.168.1.1</div><div class="line"># 指定源地址，抓取主机发送的所有数据</div><div class="line">tcpdump -i eth1 src host 192.168.1.1</div><div class="line"># 指定目的地址，抓取主机接收的所有数据</div><div class="line">tcpdump -i eth1 dst host 192.168.1.1</div><div class="line"></div><div class="line"># 经过eth1</div><div class="line">tcpdump -i eth1 port 25</div><div class="line"># 指定源端口</div><div class="line">tcpdump -i eth1 src port 25</div><div class="line"># 指定目的端口</div><div class="line">tcpdump -i eth1 dst port 25</div><div class="line"></div><div class="line">tcpdump -c100</div><div class="line"></div><div class="line">tcpdump host 10.37.63.255 and (10.37.63.61 or 10.37.63.95)</div><div class="line">tcpdump host 10.37.63.255 and !10.37.63.61</div><div class="line"></div><div class="line"></div><div class="line"># host 主机地址，后面可以带具体的IP或者地址</div><div class="line"># port 端口号</div><div class="line"># -w 保存到文件</div><div class="line"># -r 读取保存的文件</div><div class="line"># src源地址</div><div class="line"># dst目标地址</div><div class="line"># -c 指定捕获的报文数量</div><div class="line"># -i 指定接口 ifconfig -a查看有哪些接口</div></pre></td></tr></table></figure></p>
<h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>wireshark是一个图形化的工具</p>
<p><img src="/img/IMG138.png" alt=""><br><img src="/img/IMG139.png" alt=""><br><img src="/img/IMG140.png" alt=""></p>
<p>补充：</p>
<ul>
<li><a href="https://linuxwiki.github.io/NetTools/tcpdump.html" target="_blank" rel="external">https://linuxwiki.github.io/NetTools/tcpdump.html</a></li>
<li><a href="https://wizardforcel.gitbooks.io/network-basic/content/16.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/network-basic/content/16.html</a></li>
<li><a href="https://www.jianshu.com/p/8d9accf1d2f1" target="_blank" rel="external">https://www.jianshu.com/p/8d9accf1d2f1</a></li>
<li></li>
<li><a href="https://www.wireshark.org/docs/wsug_html_chunked/index.html" target="_blank" rel="external">https://www.wireshark.org/docs/wsug_html_chunked/index.html</a></li>
<li><a href="https://wizardforcel.gitbooks.io/wireshark-manual/content/1.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/wireshark-manual/content/1.html</a></li>
<li></li>
<li><a href="http://blog.51cto.com/zhaoyuqiang/1575315" target="_blank" rel="external">http://blog.51cto.com/zhaoyuqiang/1575315</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux下，当我们需要&lt;strong&gt;抓取网络数据包分析&lt;/strong&gt;时，通常是使用工具&lt;strong&gt;tcpdump&lt;/strong&gt;。但是，有时我们需要将抓取的数据包保存在一个文件中，已备以后分析。而tcpdump保存的文件是&lt;strong&gt;二进制文件&lt;/str
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python网络编程</title>
    <link href="http://yoursite.com/post/d317e8c4.html"/>
    <id>http://yoursite.com/post/d317e8c4.html</id>
    <published>2018-06-20T15:09:46.000Z</published>
    <updated>2018-06-20T23:56:23.097Z</updated>
    
    <content type="html"><![CDATA[<p>网络通信是两台计算机上的两个进程之间的通信</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络通信是两台计算机上的两个进程之间的通信&lt;/p&gt;

    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 数据链路层</title>
    <link href="http://yoursite.com/post/2f41be1.html"/>
    <id>http://yoursite.com/post/2f41be1.html</id>
    <published>2018-06-20T12:52:11.000Z</published>
    <updated>2018-06-22T12:10:03.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实本文中数据链路层讲了两部分，一部分是针对广域网的PPP，另一部分是针对局域网（以太网）的CSMA/CD</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h3><p>数据链路层使用的信道主要有以下两种类型<br><strong>点对点信道</strong>。这种信道使用 <strong>一对一</strong> 的点对点通信方式。用于<strong>广域网</strong>，使用<strong>PPP协议</strong><br><strong>广播信道</strong>。这种信道使用 <strong>一对多</strong> 的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。用于<strong>局域网</strong>，使用<strong>CSMA/CD协议</strong></p>
<a id="more"></a>
<h3 id="链路和数据链路"><a href="#链路和数据链路" class="headerlink" title="链路和数据链路"></a>链路和数据链路</h3><p><strong>链路</strong> (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。（物理层）</p>
<p><strong>数据链路</strong> (data link) 除了物理线路外，还必须有 <strong>通信协议</strong> 来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。（链路+协议）</p>
<p>现在最常用的方法是使用适配器（即<strong>网卡</strong>）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<p><img src="/img/IMG110.png" alt=""></p>
<h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br>确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。<br>帧=帧头+帧尾+物理层地址+校验值<br><img src="/img/IMG111.png" alt=""><br><img src="/img/IMG112.png" alt=""></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地 “找到帧的边界”。</p>
<p><img src="/img/IMG113.png" alt=""></p>
<p><strong>解决方法</strong>：<br><strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)。</p>
<ol>
<li>发送端的数据链路层在数据中出现控制字符 <code>SOH</code> 或<code>EOT</code>的前面插入一个转义字符<code>ESC</code> (其十六进制编码是 1B)。</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前插入一个转义字符，当接收端收到连续的两个转义字符时，就删除其中前面的一个</li>
</ol>
<p>之所以称为透明传输，是因为插入转义和删除转义是无法感受到的<br><img src="/img/IMG114.png" alt=""></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0 而 0 也可能变成 1。<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER (Bit Error Rate)</strong>。</p>
<p>误码率与信噪比有很大关系<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施<br>如果发现错误并<strong>不进行纠错而直接丢弃</strong>，目标发现没有接收到会要求重发，这是传输层的事情</p>
<h4 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a>循环冗余检验 CRC</h4><p>CRC是差错检测中最常见的方法</p>
<p>在发送端，先把数据划分为组。假定每组 k 个比特。<br>假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。<br>冗余码的计算举例<br><img src="/img/IMG115.png" alt=""><br><img src="/img/IMG116.png" alt=""><br>加法没有进位，减法没有借位，等同于异或运算<br>余数的位数等于n，不足补零</p>
<p><strong>FCS</strong><br>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。<br>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法</p>
<p><strong>检验</strong><br><strong>接收端</strong>对收到的每一帧进行CRC检验<br>若得出的余数R=0，则判定这个帧没有差错，就接受<br>若余数R不等于0,则判定这个帧有差错，就丢弃</p>
<p><strong>特点</strong><br>这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错<br>除数P越大，检错能力越强<br>只要经过严格的挑选，并使用位数足够多的除数P，那么出现检测不到的差错的概率就很小</p>
<p>仅用循环冗余检验CRC差错检测技术只能做到<strong>无差错接受</strong>，”无差错接受” 是指：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。<br>要做到“可靠传输”（即发送什么就收到什么）就必须加上<strong>确认</strong>和<strong>重传</strong>机制</p>
<p>在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p>
<h2 id="点对点信道的数据链路层——PPP协议"><a href="#点对点信道的数据链路层——PPP协议" class="headerlink" title="点对点信道的数据链路层——PPP协议"></a>点对点信道的数据链路层——PPP协议</h2><p>PPP协议 点对点协议 Point-to-Point Protocal<br>用于点到点通信<br>现在全世界使用得最多的数据链路层协议<br>用户使用拨号电话线接入因特网时，一般都是使用PPP协议</p>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><p>用户通过拨号连入ISP（电信、联通），点对点的。ISP给用户分配IP地址。PPP协议作用于之间，为用户和ISP提供规则：在连上网线的基础上还需要遵守拨号和利用IP地址才能上网的规则。PPP能够计费，能够显示上网时间和上网流量等等<br><img src="/img/IMG117.png" alt=""></p>
<h3 id="PPP-协议满足的需求："><a href="#PPP-协议满足的需求：" class="headerlink" title="PPP 协议满足的需求："></a>PPP 协议满足的需求：</h3><ul>
<li>简单——这是首要的要求，对帧不需要纠错，不需要流量控制，在接收方收到帧后用CRC检测，正确接收，错误就丢弃</li>
<li>封装成帧：从PPP协议的帧格式可以看出PPP协议封装成帧。在数据链路层以帧为单位进行传输</li>
<li>透明性：为了防止信息部分出现帧定界序列7E，而使网络误以为帧结束</li>
<li>差错检测：能够利用CRC进行差错检测 </li>
<li>多种网络层协议：能够支持多种高层协议的运行，比如IP协议等</li>
<li>多种类型链路：支持在光线等不同物理链路</li>
<li>检测连接状态：当拨号密码错误、连接错误时，PPP协议会提示错误信息</li>
<li>最大传送单元：一般要传输的数据不能超过1500个字节</li>
<li>网络层地址协商：拨号成功后，PPP协议能给用户分配网络层的IP地址</li>
<li>数据压缩协商：比如要传0000000011111111，16个比特。经过压缩算法后，只需要告诉对方要传8个0，8个1。接收方收到后再根据算法将16个0，16个1解压成0000000011111111。这样能够节省带宽</li>
</ul>
<h3 id="PPP-协议不需要的功能："><a href="#PPP-协议不需要的功能：" class="headerlink" title="PPP 协议不需要的功能："></a>PPP 协议不需要的功能：</h3><ul>
<li>纠错 </li>
<li>流量控制 </li>
<li>序号 </li>
<li>多点线路 </li>
<li>半双工或单工链路 </li>
</ul>
<h3 id="PPP-协议的组成："><a href="#PPP-协议的组成：" class="headerlink" title="PPP 协议的组成："></a>PPP 协议的组成：</h3><ol>
<li>数据链路层协议（HDLC）可以用于异步串行或同步串行方法</li>
<li>链路控制协议 LCP (Link Control Protocol)建立并维护数据链路连接，身份验证，流量统计</li>
<li>网络控制协议 NCP (Network Control Protocol)允许在点到点连接上使用多种网络层协议</li>
</ol>
<p><img src="/img/IMG118.png" alt=""></p>
<p>如果拨号身份验证成功了，则LCP负责建立数据链路，当LCP建立好了链路后，那么NCP就可以通了，NCP就分配一个IP给我们上网</p>
<h3 id="PPP-协议的帧格式："><a href="#PPP-协议的帧格式：" class="headerlink" title="PPP 协议的帧格式："></a>PPP 协议的帧格式：</h3><p><img src="/img/IMG119.png" alt=""></p>
<ul>
<li>标志字段<code>F=0x7E</code>(符号<code>0x</code>表示后面的字符是用十六进制表示，十六进制的7E用二进制表示是<code>01111110</code>)</li>
<li>地址字段A只置为<code>0xFF</code>。地址字段实际上并不起作用</li>
<li>控制字段C通常置为<code>0x03</code></li>
<li>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</li>
<li>PPP有一个2字节的协议字段用来表示信息字段的内容类型<ul>
<li>0x0021：PPP帧的信息字段是IP数据段</li>
<li>0xC021：PPP链路控制数据</li>
<li>0x8021：网络控制数据 </li>
<li>0xC023：安全性认证PAP</li>
<li>0xC025：LQR</li>
<li>oxC223：安全性认证CHAP</li>
</ul>
</li>
</ul>
<h3 id="PPP-协议的透明传输问题："><a href="#PPP-协议的透明传输问题：" class="headerlink" title="PPP 协议的透明传输问题："></a>PPP 协议的透明传输问题：</h3><p>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。<br><strong>字节填充</strong><br>以字节为单位，应用于异步网络中</p>
<ul>
<li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)</li>
<li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)</li>
<li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li>
</ul>
<p><strong>零比特填充</strong><br>以比特为单位，应用于同步网络中<br>在同步网络中传的比特流，所以不一定是8的倍数了。需要解决比特流的透明传输<br>PPP 协议用在<code>SONET/SDH</code>链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p>
<ul>
<li>在发送端，只要发现有 <strong>5 个连续 1</strong>，则立即填入一个 0。</li>
<li>接收端对帧中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除。</li>
</ul>
<p><img src="/img/IMG120.png" alt=""></p>
<p>PPP 协议不提供序号和确认的可靠传输。<br>原因：</p>
<ol>
<li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li>
<li>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列 FCS 字段可保证无差错接受。</li>
</ol>
<h3 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h3><ol>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ol>
<p>PPP 是一种<strong>验证方式</strong>，验证成功后会分配给用户一个 IP 地址。<br>PPP 协议<strong>已不是纯粹的数据链路层的协议</strong>，它还包含了物理层和网络层的内容。</p>
<h2 id="广播信道的数据链路层——CSMA-CD协议"><a href="#广播信道的数据链路层——CSMA-CD协议" class="headerlink" title="广播信道的数据链路层——CSMA/CD协议"></a>广播信道的数据链路层——CSMA/CD协议</h2><h3 id="局域网的拓扑"><a href="#局域网的拓扑" class="headerlink" title="局域网的拓扑"></a>局域网的拓扑</h3><p><img src="/img/IMG121.png" alt=""></p>
<ul>
<li><strong>星型拓扑结构</strong>：每个结点都由一条单独的通信线路与中心结点连结<ul>
<li>优点：结构简单、容易实现、便于管理，连接点的故障容易监测和排除</li>
<li>缺点：中心结点出现故障会导致网络的瘫痪</li>
</ul>
</li>
<li><strong>环形拓扑结构</strong>：各结点通过通信线路组成闭合回路，环中数据只能单向传输<ul>
<li>优点：结构简单、容易实现，适合使用光纤，传输距离远，传输延迟确定</li>
<li>缺点：任意结点出现故障都会造成网络瘫痪，另外故障诊断也较困难</li>
</ul>
</li>
<li><strong>总线拓扑结构</strong>：是将网络中的所有设备通过相应的硬件接口直接连接到公共总线上，结点之间按广播方式通信，一个结点发出的信息，总线上的其它结点均可 “收听” 到<ul>
<li>优点：结构简单、布线容易、可靠性较高，易于扩充，是局域网常采用的拓扑结构</li>
<li>缺点：所有的数据都需经过总线传送，出故障诊断较为困难</li>
</ul>
</li>
<li><strong>树型拓扑结构</strong>：一种层次结构，结点按层次连结，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换<ul>
<li>优点：连结简单，维护方便，适用于汇集信息的应用要求</li>
<li>缺点：资源共亨能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行</li>
</ul>
</li>
</ul>
<h3 id="局域网最主要的特点"><a href="#局域网最主要的特点" class="headerlink" title="局域网最主要的特点"></a>局域网最主要的特点</h3><p>网络为一个单位所拥有，且地理范围和站点数目均有限</p>
<h3 id="局域网的优点"><a href="#局域网的优点" class="headerlink" title="局域网的优点"></a>局域网的优点</h3><ol>
<li>具有广播功能，从一个站点可佷方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li>
<li>提高了系统的可靠性、可用性和生存性</li>
</ol>
<h3 id="局域网中的冲突域与广播域"><a href="#局域网中的冲突域与广播域" class="headerlink" title="局域网中的冲突域与广播域"></a>局域网中的冲突域与广播域</h3><p>最初的以太网是将许多计算机都连接到一根总线上，当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（有电源的器件）<br><img src="/img/IMG122.png" alt=""></p>
<p>总线上的每一个工作的计算机都能检测到B发送的数据信号<br>由于只有计算机D的地址（mac地址）与数据帧首部写入的地址一致，因此只有D才接收这个数据帧<br>其他所有的计算机（A，C和E）都检测到一是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来<br>具有广播特性的总线上实现了一对一的通信</p>
<p><strong>广播域</strong>： 一台计算机发送数据，连接在总线上的所有计算机都能收到数据，所有的计算机在同一个广播域中。<br><strong>冲突域</strong>： 当一台计算机发送数据时，总线被占用，此时所有连接在总线上的其他计算机都不能再发送数据了。<br>所有的计算机又处于同一个冲突域中。</p>
<h3 id="局域网各终端共享通信媒体（线路介质）的方法"><a href="#局域网各终端共享通信媒体（线路介质）的方法" class="headerlink" title="局域网各终端共享通信媒体（线路介质）的方法"></a>局域网各终端共享通信媒体（线路介质）的方法</h3><ul>
<li>静态划分信道<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
</li>
<li>动态媒体接入控制（多点接入）<ul>
<li>随机接入：用户想什么时候在线路上发送数据就什么时候发，什么都不用管。如果恰好有多个用户同时刻发送，则在线路上发生碰撞，需要 <strong>CSMA/CD 协议协调</strong>（主要被以太网采用）这是以太网最需要解决的问题。</li>
<li>受控接入，如多点线路探询（polling），或轮询（目前已不被采用）</li>
</ul>
</li>
</ul>
<p>静态划分的主要问题是增加新的计算机不方便，需要重新分配信道</p>
<h3 id="CSMD-CD-载波监听多点接入-碰撞检测"><a href="#CSMD-CD-载波监听多点接入-碰撞检测" class="headerlink" title="CSMD/CD 载波监听多点接入/碰撞检测"></a>CSMD/CD 载波监听多点接入/碰撞检测</h3><p>CSMA/CD 表示Carrier Sense Multiple Access with Collision Detection</p>
<p><strong>多点接入</strong> 表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听</strong> 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么 “载波”。因此， “载波监听” 就是用电子技术检测总线上有没有其他计算机发送的数据信号。<br><strong>碰撞检测</strong> 就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的<strong>信号电压</strong>摆动值超过一定的<strong>门限值</strong>时，就认为总线上至少有两个站同时在发送数据，表明产生了<strong>碰撞</strong>。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。<br><strong>检测到碰撞后</strong>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p>
<h4 id="载波监听后仍然出现碰撞的可能"><a href="#载波监听后仍然出现碰撞的可能" class="headerlink" title="载波监听后仍然出现碰撞的可能"></a>载波监听后仍然出现碰撞的可能</h4><p>电磁波在总线上的有限传播速率的影响当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A 向 B 发出的信息，要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。</p>
<p><img src="/img/IMG123.png" alt=""></p>
<h3 id="CSMA-C的D重要特性"><a href="#CSMA-C的D重要特性" class="headerlink" title="CSMA/C的D重要特性"></a>CSMA/C的D重要特性</h3><p>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信（<strong>半双工通信</strong>）<br>每个站在发送数据之后的一小段时间内，存在遭遇碰撞的可能性。所以不能保证在一定时间内一定能把数据发送出去。<br>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率（因为碰撞会降低效率）</p>
<p>可以看出，如果A到B之间的<strong>线路越长</strong>（传播时延τ受传播媒介长度影响），那么<strong>接受到碰撞信息的时间也会越长</strong>，所以<strong>CSMA/CD协议适合用在线路较短的局域网和以太网</strong>中。这也是局域网范围受限的原因之一。</p>
<h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><p>A能收到碰撞的最长时间为，当数据到达B后，B刚好发送数据，在主机B上发生了碰撞。最先发送数据帧的站，在发送数据帧后至多经过时间 <code>2τ</code>就可知道发送的数据帧是否遭受了碰撞。如果这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<h4 id="以太网的争用期"><a href="#以太网的争用期" class="headerlink" title="以太网的争用期"></a>以太网的争用期</h4><p>以太网的端到端往返时延<strong>2τ</strong>称为争用期，或碰撞窗口。通常，取 51.2 ms 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节未发生冲突，则后续的数据就不会发生冲突。</p>
<h4 id="最短有效帧长"><a href="#最短有效帧长" class="headerlink" title="最短有效帧长"></a>最短有效帧长</h4><p>如果发生冲突，就一定是在发送的前 64 字节之内。<br>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。<br>以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p>
<h3 id="强化碰撞"><a href="#强化碰撞" class="headerlink" title="强化碰撞"></a>强化碰撞</h3><p>当发送数据的站一旦发现发生了碰撞时：</p>
<ol>
<li>立即停止发送数据；</li>
<li>再继续发送若干比特的人为干扰信号 (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。</li>
</ol>
<h3 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h3><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。尽量避免再次发生碰撞</p>
<p>确定基本退避时间，一般是取为争用期 2t。<br>定义参数 k，k = Min[重传次数n, 10]<br>从整数集合[0,1,…, (2的K次方-1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。<br>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网两个标准"><a href="#以太网两个标准" class="headerlink" title="以太网两个标准"></a>以太网两个标准</h3><ol>
<li>DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。</li>
<li>IEEE 的 802.3 标准。</li>
</ol>
<p>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。说白了： <strong>以太网就是局域网</strong>。<br>严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</p>
<p>10M以太网使用CSMA/CD协议</p>
<h3 id="以太网与数据链路层的两个子层"><a href="#以太网与数据链路层的两个子层" class="headerlink" title="以太网与数据链路层的两个子层"></a>以太网与数据链路层的两个子层</h3><p>为了使数据链路层能更好地适应多种局域网标准，802 委员会就将局域网的数据链路层拆成两个子层：</p>
<ol>
<li><strong>逻辑链路控制 LLC</strong> (Logical Link Control)子层</li>
<li><strong>媒体接入控制 MAC</strong> (Medium Access Control)子层</li>
</ol>
<p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的。</p>
<p>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了，即现在LLC子层几乎不提了。</p>
<p>很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。</p>
<h3 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h3><p>以太网提供的服务是<strong>不可靠的交付</strong>，即尽最大努力的交付。<br>当接收站收到<strong>有差错的数据帧时就丢弃</strong>此帧，其他什么也不做。差错的纠正由传输层来决定。<br>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p>
<p><img src="/img/IMG124.jpg" alt=""><br>如图所示，PC1发送数据给PC0，在以太网上，ＲＡ接收到有差错的数据帧时就直接丢弃。如果PC0的高层（网络层以上）发现数据在途中丢失了，就会要求PC1重新发送一份。 </p>
<h3 id="传统以太网的拓扑——使用集线器的星形拓扑结构"><a href="#传统以太网的拓扑——使用集线器的星形拓扑结构" class="headerlink" title="传统以太网的拓扑——使用集线器的星形拓扑结构"></a>传统以太网的拓扑——使用集线器的星形拓扑结构</h3><p>传统以太网最初是使用<strong>粗同轴电缆</strong>，后来演进到使用比较便宜的<strong>细同轴电缆</strong>，最后发展为使用更便宜和更灵活的<strong>双绞线</strong>。不用电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong>(hub) 。</p>
<p>需要注意的是： 现在中间的可靠设备一般不用集线器了，现在组网去市场花个便宜的钱都是用交换机组网的。</p>
<p><img src="/img/IMG125.jpg" alt=""><br>100m以内</p>
<h3 id="集线器（hub）"><a href="#集线器（hub）" class="headerlink" title="集线器（hub）"></a>集线器（hub）</h3><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。<br>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。<br>集线器很像一个多接口的转发器，工作在<strong>物理层</strong>。 集线器是傻瓜式的，它没有智能作用，看不见什么信号。只知道机械的传输，也不管目的地址什么的，反正就是有信号就传。</p>
<p><img src="/img/IMG126.jpg" alt=""></p>
<p>接在工作站网卡上的8根双脚线有两根是发送数据的，有两根是接收数据的。A发送数据数据到集线器后，B和C都能收到，C发送数据到集线器后，A和B也能收到。发送者自己是收不到自己发出去的数据的。</p>
<p>需要注意的是： 这是早期的集线器，在芯片电路还没有出来之前的，集线器里面都是线连接的。现在的集线器都是芯片电路板了。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。</p>
<h3 id="以太网速度标准"><a href="#以太网速度标准" class="headerlink" title="以太网速度标准"></a>以太网速度标准</h3><p>10BASE-T（10Mb/s）的通信距离稍短，每个站到集线器的距离不超过 100 m。这种 10 Mb/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 </p>
<p>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</p>
<p>其他：100Base-FX(百兆快速以太网，使用光纤)、100Base-T和100Base-T4….</p>
<p>10：10M/s<br>BASE：基带信号<br>T：双绞线<br>FX：光纤</p>
<h3 id="以太网信道利用率"><a href="#以太网信道利用率" class="headerlink" title="以太网信道利用率"></a>以太网信道利用率</h3><p>因为每个站点发送数据时可能产生碰撞的可能，所以此时的信道不会被利用，所以利用率就会变低。</p>
<p>以太网的信道被占用的情况：<br>我们知道争用期长度为 2τ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。<br>如果帧长为 L (bit)，数据发送速率为 C (b/s)，因而帧的发送时间为 L/C = T0 (s)。</p>
<p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过τ时间使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p>
<p><img src="/img/IMG127.jpg" alt=""></p>
<p>要提高以太网的信道利用率，就必须减小τ 与 T0 之比。在以太网中定义了参数 a，它是以太网单程端到端时延τ与帧的发送时间 T0 之比： a=τ/T0      </p>
<p>a→0 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。<br>a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。</p>
<p>a并不是信道利用率，只是为了描述信道利用率的一个参数而已<br>从式子可以得出，要想a变小，则τ尽量变小，而T0尽量要大。<br>当数据率C一定时，T0=L（帧长）/C 。所以以太网的帧长L尽量要长些，这样T0会增大，a会变小。<br>当然也不能太长，太长后信道利用率过高会引起信道延迟成倍增加（ 信道利用率越高，数据线路上拥堵的可能性就越大，当高到一定程度后，会增加数据在线路上的延时）。<br>同时，以太网的连线的长度尽量短些，这样端到端的传播时间τ会变小，a会减小。当然也不能太短，太长后信道利用率过高会引起信道延迟成倍增加。</p>
<h4 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h4><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。</p>
<p>发送一帧占用线路的时间是 T0 +τ，而帧本身的发送时间是 T0。于是我们可计算出理想情况下的极限信道利用率 Smax为：  </p>
<p><img src="/img/IMG128.jpg" alt=""></p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>在局域网中，硬件地址又称为<strong>物理地址</strong>，或<strong> MAC 地址</strong>。 （<strong>48位地址</strong>）</p>
<p>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。 其实我们教材中说的地址并不是很确切，但是我们习惯将这种 48 位的“名字”称为“地址”，所以本书也采用这种习惯用法。</p>
<ul>
<li>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即<strong>高位 24 位</strong>)。</li>
<li>地址字段中的后三个字节(即低位 24 位)由厂家自行指派，称为<strong>扩展标识符</strong>，必须保证生产出的适配器<strong>没有重复地址</strong>。</li>
<li>一个地址块可以生成224个不同的地址。这种 48 位地址称为 <strong>MAC-48</strong>，它的通用名称是<strong>EUI-48</strong>。</li>
<li>“MAC地址”实际上就是适配器地址或适配器标识符EUI-48。在出厂前就烧录在了我们的网卡中。</li>
</ul>
<p>如果在一个局域网内（同一个交换机连接下）有相同的MAC地址，则会引起冲突，导致一方不能正常上网。<br>我们说MAC地址是刻在网卡适配器中的，是不可以更改的，但是我们可以指定一个MAC地址，让计算机应用指定的MAC地址，而不用网卡上固定的MAC地址。<br>windows修改mac地址方法：本地连接—更改适配器设置—本地连接属性—配置—-高级—网络地址（本地管理的地址）</p>
<h3 id="适配器检查-MAC-地址"><a href="#适配器检查-MAC-地址" class="headerlink" title="适配器检查 MAC 地址"></a>适配器检查 MAC 地址</h3><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址<br>如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p>
<p>“发往本站的帧”包括以下三种帧： </p>
<ul>
<li>单播(unicast)帧（一对一）</li>
<li>广播(broadcast)帧（一对全体）（源mac地址：FF:FF:FF:FF:FF:FF）</li>
<li>多播(multicast)帧（一对多）</li>
</ul>
<h3 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h3><p>常用的以太网MAC帧格式有两种标准 ：</p>
<ol>
<li>DIX Ethernet V2 标准</li>
<li>IEEE 的 802.3 标准</li>
</ol>
<p>最常用的 MAC 帧是以太网 V2 的格式。</p>
<p>MAC帧V2 格式<br><img src="/img/IMG129.jpg" alt=""><br>最小长度64字节（最短有效帧长，参考争用期）-18字节的首部和尾部（6+6+2+4）=数据字段的最小长度<br>为了达到比特同步在传输媒体上实际传送的要比 MAC 帧还多 8 个字节</p>
<h3 id="无效的-MAC-帧"><a href="#无效的-MAC-帧" class="headerlink" title="无效的 MAC 帧"></a>无效的 MAC 帧</h3><p>当适配器收到MAC帧后，会检查是否是有效的MAC帧。</p>
<ul>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 </p>
<h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><p>帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。<br>一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 </p>
<p>9.6 μs × 10Mb/s = 96bit</p>
<h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><p>扩展可以在物理层上也可在链路层上，但从网络层看依然是一个局域网。<br>以太网主机之间的距离不能太远（10BASE-T规定200米）</p>
<h3 id="在物理层扩展局域网"><a href="#在物理层扩展局域网" class="headerlink" title="在物理层扩展局域网"></a>在物理层扩展局域网</h3><p>主机使用光纤和一对光纤调制解调器连接到集线器<br><img src="/img/IMG130.png" alt=""><br><img src="/img/IMG131.png" alt=""><br>用多个集线器可连成更大的局域网</p>
<p><strong>优点</strong><br>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。<br>扩大了局域网覆盖的地理范围。（使用光纤可以扩大到几千米）<br>数量增加</p>
<p><strong>缺点</strong><br>碰撞域增大了，但总的吞吐量并未提高。<br>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。<br>三个碰撞域连起来后，最大吞吐率仍然是一个系的最大吞吐率。因为其中任何一台主机通信，其他主机都不能通信。</p>
<h3 id="在数据链路层扩展局域网"><a href="#在数据链路层扩展局域网" class="headerlink" title="在数据链路层扩展局域网"></a>在数据链路层扩展局域网</h3><p>在数据链路层扩展局域网是使用<strong>网桥</strong>。<br>网桥工作在数据链路层，它<strong>根据 MAC 帧的目的地址对收到的帧进行转发</strong>。</p>
<p>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。</p>
<h4 id="网桥的内部结构"><a href="#网桥的内部结构" class="headerlink" title="网桥的内部结构"></a>网桥的内部结构</h4><p>网桥具有多个接口<br>每个接口连接一个网段</p>
<p>若网桥从接口1收到从主机1向主机5的帧，则把帧发到接口2转发出去。<br>若网桥从接口1收到从主机2发到主机3的帧，则丢弃。因为主机2和3位于同一桥段，不用转发。<br><img src="/img/IMG132.png" alt=""></p>
<h4 id="使用网桥带来的好处"><a href="#使用网桥带来的好处" class="headerlink" title="使用网桥带来的好处"></a>使用网桥带来的好处</h4><p>过滤通信量，增大吞吐率。<br>扩大了物理范围。主机数量<br>提高了可靠性。只影响个别网段<br>可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。</p>
<p>网桥使各网段成为隔离开的碰撞域</p>
<h4 id="使用网桥带来的缺点"><a href="#使用网桥带来的缺点" class="headerlink" title="使用网桥带来的缺点"></a>使用网桥带来的缺点</h4><p>存储转发增加了时延。存储、查表、碰撞检测<br>在MAC 子层并没有流量控制功能。 网桥的缓存可能溢出，帧丢失。<br>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。<br>路由器可以阻断网络风暴</p>
<h4 id="网桥和集线器（或转发器）不同"><a href="#网桥和集线器（或转发器）不同" class="headerlink" title="网桥和集线器（或转发器）不同"></a>网桥和集线器（或转发器）不同</h4><p>集线器在转发帧时，不对传输媒体进行检测。<br>网桥在转发帧之前必须执行 CSMA/CD 算法。<br>若在发送过程中出现碰撞，就必须停止发送和进行退避。</p>
<h4 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h4><p>目前使用得最多的网桥是透明网桥(transparent bridge)。<br>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。<br>透明网桥是一种即插即用设备，其标准是 IEEE 802.1D。</p>
<h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><p>网桥使用自学习算法处理收到的帧和建立转发表，网桥并不是一开始就知道所连接网络的所有mac地址的，而是通过自学习算法建立转发表</p>
<p><img src="/img/IMG133.png" alt=""><br><img src="/img/IMG134.png" alt=""><br><img src="/img/IMG135.png" alt=""><br><img src="/img/IMG136.png" alt=""></p>
<ol>
<li>若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A。</li>
<li>网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。</li>
<li>在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面</li>
<li>在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li>
</ol>
<p>如果一个接口有多个mac说明，这个接口连接的是网桥或者交换机</p>
<h4 id="网桥在转发表中登记以下三个信息"><a href="#网桥在转发表中登记以下三个信息" class="headerlink" title="网桥在转发表中登记以下三个信息"></a>网桥在转发表中登记以下三个信息</h4><p>网桥转发表中的信息：<strong>地址</strong>、<strong>接口</strong>和<strong>帧进入该网桥的时间</strong>。</p>
<p>这是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。<br>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。 </p>
<h4 id="网桥的自学习和转发帧的步骤归纳"><a href="#网桥的自学习和转发帧的步骤归纳" class="headerlink" title="网桥的自学习和转发帧的步骤归纳"></a>网桥的自学习和转发帧的步骤归纳</h4><p>网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。<br>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<br>如有，则按转发表中给出的接口进行转发。<br>如没有，则通过所有其他接口（但进入网桥的接口除外）进行转发。<br>若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。</p>
<h4 id="透明网桥使用了生成树算法"><a href="#透明网桥使用了生成树算法" class="headerlink" title="透明网桥使用了生成树算法"></a>透明网桥使用了生成树算法</h4><p>这是为了避免产生转发的帧在网络中不断地兜圈子</p>
<p><img src="/img/IMG137.png" alt=""></p>
<p>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。 </p>
<p>为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</p>
<h3 id="多接口网桥——以太网交换机"><a href="#多接口网桥——以太网交换机" class="headerlink" title="多接口网桥——以太网交换机"></a>多接口网桥——以太网交换机</h3><p>1990 年问世的交换式集线器(switching hub)，可明显地提高局域网的性能。交换式集线器常称为<strong>以太网交换机</strong>(switch)或<strong>第二层交换机</strong>（表明此交换机工作在数据链路层）。以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，可见交换机工作在数据链路层。</p>
<h4 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h4><p>以太网交换机的每个接口都直接与主机相连，并且一般都工作在<strong>全双工方式</strong>。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。</p>
<p><strong>独占传输媒体的带宽</strong><br>对于普通 10 Mb/s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽(10 Mb/s)的 N 分之一。使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 对接口的交换机的总容量为 N×10 Mb/s。这正是交换机的最大优点。</p>
<p>对于普通共享式HUB 若N个用户 总带宽：10Mb/s 每个用户占有平均带宽= 10M/N</p>
<h3 id="以太网交换机的交换方式"><a href="#以太网交换机的交换方式" class="headerlink" title="以太网交换机的交换方式"></a>以太网交换机的交换方式</h3><p>存储转发方式<br>把整个数据帧先缓存后再进行处理。<br>直通 (cut-through) 方式<br>接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。<br>缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</p>
<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。<br>在缺省配置的情况下，交换机的所有端口属于同一 VLAN。连接在不同交换机上的、属于同一 VLAN 的数据帧必须通过 Trunk 链路传输。</p>
<p><img src="/img/IMG138.png" alt=""></p>
<h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p>速率达到或超过 100 Mbit/s 的以太网称为高速以太网。100BASE-T 以太网又称为快速以太网 (Fast Ethernet)。</p>
<p>可在全双工方式下工作而无冲突发生。在全双工方式下工作时，不使用 CSMA/CD 协议。<br>MAC 帧格式仍然是 802.3 标准规定的。<br>保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 m。<br>帧间时间间隔从原来的 9.6 μs 改为现在的 0.96 μs。</p>
<h2 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h2><p>允许在 1 Gbit/s 下全双工和半双工两种方式工作。<br>使用 IEEE 802.3 协议规定的帧格式。<br>在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。</p>
<p><a href="http://blog.51cto.com/zhaoyuqiang/1575315" target="_blank" rel="external">http://blog.51cto.com/zhaoyuqiang/1575315</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实本文中数据链路层讲了两部分，一部分是针对广域网的PPP，另一部分是针对局域网（以太网）的CSMA/CD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;信道类型&quot;&gt;&lt;a href=&quot;#信道类型&quot; class=&quot;headerlink&quot; title=&quot;信道类型&quot;&gt;&lt;/a&gt;信道类型&lt;/h3&gt;&lt;p&gt;数据链路层使用的信道主要有以下两种类型&lt;br&gt;&lt;strong&gt;点对点信道&lt;/strong&gt;。这种信道使用 &lt;strong&gt;一对一&lt;/strong&gt; 的点对点通信方式。用于&lt;strong&gt;广域网&lt;/strong&gt;，使用&lt;strong&gt;PPP协议&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;广播信道&lt;/strong&gt;。这种信道使用 &lt;strong&gt;一对多&lt;/strong&gt; 的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的&lt;strong&gt;共享信道协议&lt;/strong&gt;来协调这些主机的数据发送。用于&lt;strong&gt;局域网&lt;/strong&gt;，使用&lt;strong&gt;CSMA/CD协议&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-物理层</title>
    <link href="http://yoursite.com/post/b709c2f1.html"/>
    <id>http://yoursite.com/post/b709c2f1.html</id>
    <published>2018-06-19T13:09:35.000Z</published>
    <updated>2018-06-20T23:59:15.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各种计算机的 <strong>传输媒体</strong>（光纤、无线等）上传输 <strong>数据比特流</strong>，而不是指具体的传输媒体<br>物理层的主要任务描述为：确定传输媒体的接口的一些特性，即：</p>
<ol>
<li><strong>机械特性</strong>：例如接口形状，大小，引线数目</li>
<li><strong>电气特性</strong>：例如规定电压范围（-5V到+5V）</li>
<li><strong>功能特性</strong>：例如规定-5V表示0，+5V表示1</li>
<li><strong>过程特性</strong>：也称为规程特性，规定建立连接时各个相关部件的工作步骤</li>
</ol>
<a id="more"></a>
<p><br></p>
<h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><p><img src="/img/IMG72.png" alt=""><br>广域网：公共电话网<br>局域网：通过交换机直接使用数字比特流</p>
<p>数据通信不只包括计算机通信，也包括电视、电话、传真等通信方式</p>
<p>通信的目的是传送消息</p>
<ul>
<li>数据data：运送消息的实体</li>
<li>信号signal：数据的电气或电磁表现<ul>
<li>模拟信号：代表消息的参数的取值是连续的</li>
<li>数字信号：代表消息的参数的聚会是离散的</li>
</ul>
</li>
<li>码元code：在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元(在波形中单个0和1就代表码元)，在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度，1码元可以携带nbit的信息量</li>
</ul>
<p><img src="/img/IMG73.png" alt=""><br>右图表示一码元可以携带3bit的信息，可以通过不同的电压表示 </p>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道一般表示向一个方向传送信息的媒体（A到B是一条，B到A是一条），所以平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道</p>
<ul>
<li><strong>单向通信</strong>（单工通信）：只能有一个方向的通信而没有反方向的交互，电视、收音机</li>
<li><strong>双向交替通信</strong>（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送（当然也不能同时接收），对讲机</li>
<li><strong>双向同时通信</strong>（全双工通信）：通信的双方可以同时发送和接收信息</li>
</ul>
<h3 id="基带信号和带通信号、调制"><a href="#基带信号和带通信号、调制" class="headerlink" title="基带信号和带通信号、调制"></a>基带信号和带通信号、调制</h3><ul>
<li>基带信号/baseband/基本频带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号</li>
<li>带通信号/band pass：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）</li>
</ul>
<p>基带信号传播衰减太严重，这就是为什么需要带通信号的原因，带通信号能够在空气中传播较远的范围</p>
<p>由于在传输距离较近时，基带信号的衰减不大，信号内容不会发生变化，当在较近范围内传输时计算机网络会采用基带传输方式。如从计算机到监视器、打印机等外设的信号就是基带信号</p>
<p>把基带信号调制为带通信号的常见方式有三种：</p>
<ol>
<li><strong>调幅</strong>（AM）：载波的振幅随基带数字信号而变化</li>
<li><strong>调频</strong>（FM）：载波的频率随基带数字信号而变化</li>
<li><strong>调相</strong>（PM）：载波的初始相位随基带数字信号而变化</li>
</ol>
<p><img src="/img/IMG74.png" alt=""></p>
<h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><ol>
<li>单极性不归零码：只使用一个电压值，用高电平表示1，没电压表示0</li>
<li>双极性不归零码：用正电平和负电平分别表示二进制数据的1和0，正负幅值相等</li>
<li>单极性归零码（RZ）：即是高电平和零电平分别表示二进制码1和0，而且在发送码1时高电平在整个码元期间T只持续一段时间t，其余时间返回零电平</li>
<li>双极性归零码：正负零三个电平，信号本身携带同步信号</li>
<li>曼彻斯特编码</li>
<li>差分曼彻斯特编码</li>
</ol>
<p>单极性和双极性：区别在于0用没电压表示还量用负电平表示<br>归零和不归零：每一bit结束时是否归零，不归零这种方式无法区分到底是0还是没有信号<br><img src="/img/IMG75.png" alt=""></p>
<p><strong>曼彻斯特编码</strong></p>
<p><img src="/img/IMG76.png" alt=""><br>采样两次是指每bit开始一次，结束一次，比较开始和结束是从高电平转低电平还是从低电平转高电平</p>
<p><strong>差分曼彻斯特编码</strong><br><img src="/img/IMG77.png" alt=""><br>注意，看的是bit与bit之间是否有跳变，不是bit内<br><img src="/img/IMG78.png" alt=""></p>
<h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p>有失真，但可以识别<br><img src="/img/IMG79.png" alt=""></p>
<p>失真大，无法识别<br><img src="/img/IMG80.png" alt=""></p>
<p><strong>奈氏准则</strong><br>1924年，奈奎斯特（Nyquist)就推导出了著名的奈氏准则，他给出了在 <strong>假定的理想条件</strong>下，为了避免码间串扰，码元的传输速率的上限值。<br>在任何信道中，<strong>码元传输的速率是有上限的</strong>，否则就会出现 <strong>码间串扰</strong>的问题，使接收端对码元的识别成为不可能。<br>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰。</p>
<p><strong>香农理论</strong><br>在奈氏准则的基础上，香农用信息论的理论推导出了 <strong>带宽受限</strong>且有 <strong>噪声干扰</strong>的信道的极限、<strong>无差错的信息传输速率</strong>。</p>
<p>信道的极限信息传输速率C可表达为：<code>C=W lg(1+S/N)/lg2 b/s</code></p>
<ul>
<li>W为信道的带宽（以Hz为单位）</li>
<li>S为信道内所传信号的平均功率</li>
<li>N为信道内部的高斯噪声功率</li>
<li>S/N为信噪比</li>
</ul>
<ol>
<li>信道的带宽或信道中的<strong>信噪比越大</strong>，则信息的<strong>极限传输速率就越高</strong></li>
<li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输</li>
<li>若信道带宽 W 或信噪比<code>S/N</code>没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率C也就没有上限</li>
<li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少</li>
</ol>
<p><img src="/img/IMG81.png" alt=""></p>
<p><br></p>
<h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><h3 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h3><p>导向传输媒体中，电磁波沿着固体媒体传播</p>
<ul>
<li>双绞线<ul>
<li>屏蔽双绞线STP：屏蔽网线，优点屏蔽性好，抗干扰能力强。缺点价格昂贵，与UTP相比，直径较大，更重以及不易安装</li>
<li>无屏蔽双绞线UTP：非屏蔽网线，优点是价格便宜，直径较小，易安装。缺点是抗干扰能力较弱</li>
</ul>
</li>
<li>同轴电缆<ul>
<li>50Ω 同轴电缆用于数字传输，由于多用于基带传输，也叫基带同轴电缆</li>
<li>75Ω 同轴电缆用于模拟传输，即宽带同轴电缆</li>
</ul>
</li>
<li>光缆</li>
</ul>
<p><img src="/img/IMG82.png" alt=""></p>
<h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>LAN网络中最常见的数据传输铜介质是双绞线。铜介质优点是可以非常好的传导电信号，缺点是易受外界干扰而产生畸形和信号衰减，导致长距离传输过程中能量损失。为解决上述不足，提高数据传输稳定性，IEEE制定了LAN线缆标准，主要有两种：屏蔽双绞线(STP)和非屏蔽双绞线(UTP)。</p>
<p>所谓双绞线，实际上是将线缆中细铜缆成对出现。之所以这样设计，原因是在数据传输过程中，电线中电流流过时产生电磁场，干扰线缆中其它细铜缆。为解决这个问题，将电缆中细铜线 <strong>两两配对</strong>，使得传输过程中两两配对的细铜缆产生的 <strong>电磁场互相抵消</strong>，减少串扰。</p>
<p>随着UTP单位长度中的双绞次数的增多，抗干扰能力也得到加强,是目前使用最广泛的双绞线，而STP因需要接地，安装不易反而没有得到大范围应用。在实际工作中可以察看双绞线的双绞频率判断双绞线的伪劣。</p>
<h5 id="双绞线线缆引脚顺序"><a href="#双绞线线缆引脚顺序" class="headerlink" title="双绞线线缆引脚顺序"></a>双绞线线缆引脚顺序</h5><p>双绞线要正常稳定工作，需要在两端将细铜缆按一定的顺序接在连接器中。双绞线使用的连接器标准是 <strong>RJ-45连接器</strong>。要理解线缆的引脚顺序本质，实际上需要理解硬件设备接收发送电信号的规则：</p>
<ol>
<li>以太网设备使用一对铜细缆来传输数据</li>
<li>以太网设备使用一对铜细缆来接收数据</li>
<li>以太网设备不能使用同一对铜细缆来同时传输和接收数据。</li>
</ol>
<p>结论：<strong>在以太网中，以太网设备需要使用两对细铜缆分别用来进行数据的接收和发送</strong>。</p>
<p>理解了以上规则后，我们再来了解下不同的硬件设备用于发送和接收数据的工作规则：</p>
<ol>
<li>网卡NIC：1、2引脚发送数据，3、6引脚接收数据</li>
<li>集线器：3、6引脚发送数据，1，2引脚接收数据</li>
<li>交换机：3、6引脚发送数据，1，2引脚接收数据</li>
<li>网桥：3、6引脚发送数据，1，2引脚接收数据</li>
<li>路由器：1，2引脚发送数据，3，6引脚接收数据</li>
</ol>
<p>了解了不同硬件设备的接收发送信号的引脚编号后，再看来直通线和交叉线的使用场景就会清晰很多。</p>
<p>以最常见的PC机与交换机通信为例</p>
<ol>
<li>PC机网卡发送信号给交换机，对于NIC端是发送数据，NIC的发送引脚是1，2引脚，对于交换机是接收数据，参照上述规则，交换机接收数据使用的是1，2引脚。</li>
<li>交换机发送信号到PC机网卡，对于交换机是发送数据，使用3，6引脚，对于NIC端是接收数据，同样使用3，6引脚。</li>
</ol>
<p>所以PC机与交换机通过网线相连，用于通信的线缆1、2、3、6引脚两端顺序保持一致，简称直通线。<br>同理，PC机与集线器、网桥相连，也使用直通线。</p>
<p>结论：<br><strong>互相通信的网络设备使用的传输引脚规则一致时，使用交叉线</strong><br><strong>互相通信的网络设备使用的传输引脚规则不同时，使用直通线</strong></p>
<h5 id="TIA-EIA-586A与TIA-EIA-586B引脚顺序"><a href="#TIA-EIA-586A与TIA-EIA-586B引脚顺序" class="headerlink" title="TIA/EIA-586A与TIA/EIA-586B引脚顺序"></a>TIA/EIA-586A与TIA/EIA-586B引脚顺序</h5><p>从上述双绞线线缆引脚顺序的描述中，可以看出两台设备要能正常通信，只需要根据具体设备发送和接收数据的工作规则来排列正确的引脚次序。比如说PC机与交换机通信，只要将网线两端的引脚顺序保持一致就可以，那么可以通信的引脚顺序组合有：8<em>7</em>6<em>5</em>4<em>3</em>2*1种可能性。为避免不同人员随意性的引脚顺序排列，TIA/EIA制定了两个网线引脚顺序标准，分别是<code>TIA/EIA-586A</code>与<code>TIA/EIA-586B</code>，强制要求所有的网线引脚顺序必须遵循以上两种标准之一。</p>
<p>TIA/EIA-586A引脚顺序：1-绿白 2-绿 3-橙白 4-蓝 5-蓝白 6-橙 7棕白 8棕<br>TIA/EIA-586B引脚顺序：1-橙白 2-橙 3-绿白 4-蓝 5-蓝白 6-绿 7棕白 8棕</p>
<p>观察586A和586B引脚顺序，实质上就是 <strong>1，2引脚和3，6引脚互换了位置</strong>，其它位置的引脚保持不变。<br>1、2、3、6是10M和100M网线使用的线路，1000M使用全部8根线</p>
<p>根据标准的586A和586B标准，再来明确一下直通线和交叉线的定义：</p>
<ul>
<li>直通线：两端使用相同引脚顺序，同时使用586A标准或同时使用586B标准。用于不同类的网络设备连接，如电脑与交换机、交换机与路由器等。</li>
<li>交叉线：两端使用不同的引脚顺序，一端使用586A顺序，一端使用586B顺序，主要用于同类网络设备的连接，如交换机与交换机、电脑与电脑等。</li>
</ul>
<p>当前大部分网络设备、网络终端的网线接口均支持 <strong>自动翻转</strong>功能。</p>
<h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="/img/IMG83.png" alt=""><br><img src="/img/IMG84.png" alt=""><br><img src="/img/IMG85.png" alt=""></p>
<h3 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h3><p>非导向传输媒体就是指 <strong>自由空间</strong>，其中的电磁波传输被称为无线传输<br>无线传输所使用的频段很广<br>短波通信主要是靠电离层的反射，但短波信道的通信质量较差<br>微波在空间主要是直线传播<br>    地面微波接力通信<br>    卫星通信</p>
<p><img src="/img/IMG86.png" alt=""></p>
<h3 id="物理层设备———集线器"><a href="#物理层设备———集线器" class="headerlink" title="物理层设备———集线器"></a>物理层设备———集线器</h3><p>工作范围：它在网络中只起信号放大和重发作用，其目的是扩大网络的传输范围，而 <strong>不具备信号的定向传送能力</strong>（不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点）<br>最大传输距离：100m<br>集线器是一个大的冲突域（带宽共用）</p>
<p><br></p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p><img src="/img/IMG87.png" alt=""></p>
<h3 id="频分复用FDM-Frequency-Division-Multiplexing"><a href="#频分复用FDM-Frequency-Division-Multiplexing" class="headerlink" title="频分复用FDM Frequency Division Multiplexing"></a>频分复用FDM Frequency Division Multiplexing</h3><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带<br>频分复用的所有用户在同样的时间占用不同的频率</p>
<p><img src="/img/IMG88.png" alt=""><br><img src="/img/IMG89.png" alt=""><br><img src="/img/IMG90.png" alt=""><br><img src="/img/IMG91.png" alt=""></p>
<h3 id="时分利用TDM-Time-Division-Multiplexing"><a href="#时分利用TDM-Time-Division-Multiplexing" class="headerlink" title="时分利用TDM Time Division Multiplexing"></a>时分利用TDM Time Division Multiplexing</h3><p>时分复用是将时间划分为一段段等长的时分复用帧（TDM帧），每一个时分复用的用户在每个TDM帧中占用固定序号的时隙<br>每个用户所占用的时隙是周期性（其周期性就是TDM帧的长度对应的时间）<br>TDM信号也称为等时（isochronous)信号</p>
<p>时分复用的所有用户是在不同的时间占用同样的频带宽度</p>
<p><img src="/img/IMG92.png" alt=""><br><img src="/img/IMG93.png" alt=""><br><img src="/img/IMG94.png" alt=""></p>
<h4 id="统计时分复用STDM-Statistic-TDM"><a href="#统计时分复用STDM-Statistic-TDM" class="headerlink" title="统计时分复用STDM Statistic TDM"></a>统计时分复用STDM Statistic TDM</h4><p>时分复用可能会造成线路资源的浪费<br>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的，所以出现了统计时分复用</p>
<p><img src="/img/IMG95.png" alt=""><br><img src="/img/IMG96.png" alt=""></p>
<h3 id="波分复用WDM-Wavelength-Division-Multiplexing"><a href="#波分复用WDM-Wavelength-Division-Multiplexing" class="headerlink" title="波分复用WDM Wavelength Division Multiplexing"></a>波分复用WDM Wavelength Division Multiplexing</h3><p>波分复用就是光的频分复用</p>
<p><img src="/img/IMG97.png" alt=""><br><img src="/img/IMG98.png" alt=""></p>
<p><br></p>
<h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>脉冲编码调制PCM最初是为了在电话局之间的中继线上传送多路的电话。由于历史的原因，PCM有两个互一兼容的标准，即北美24路PCM（简称为T1）和欧洲的30路PCM（简称为E1）。我国采用的是欧洲的E1标准。<br>E1的速率是 2.048Mb/s，而T1的速率是 1.544Mb/s<br>当需要有更高的数据率时，可采用复用的方法</p>
<p>PCM 是要把声音从 <strong>模拟转换成数字信号</strong>的一种技术，他的原理简单地说就是利用一个固定的频率对模拟信号进行采样，采样后的信号在波形上看就像一串连续的幅值不一的脉冲，把这些脉冲的幅值按一定的精度进行量化，这些量化后的数值被连续地输出、传输、处理或记录到存储介质中，所有这些组成了数字音频的产生过程。</p>
<p><img src="/img/IMG99.png" alt=""></p>
<p>电话的采样采样频率通常为8000次/s，量化精度是 8bit（每一个波形/码元用8位二进制表示）<br>8000×8 = 64Kb/s<br>PCM产生的数字信号称为 <strong>数字基带信号</strong></p>
<p><img src="/img/IMG100.png" alt=""><br><img src="/img/IMG101.png" alt=""></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/hanmengaidudu/article/details/78854264" target="_blank" rel="external">https://blog.csdn.net/hanmengaidudu/article/details/78854264</a></li>
<li><a href="https://baike.baidu.com/item/PCM/1568054" target="_blank" rel="external">https://baike.baidu.com/item/PCM/1568054</a></li>
</ul>
<p><br></p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>究其本质，没有太多区别，它们都是接入网络（Access Network），先认证用户合法，分配 IP 地址等上网必备的参数，将用户电脑接入互联网 Internet。运营商在将用户接入网络的同时，启动用户流量统计/用户在线时长统计，以生成用户账单，用户掏钱。</p>
<p>但由于采用的传输介质（physical media）大不同，有模拟电话线、数字铜线、光纤，以及成帧方式的不同，有 PPP，PPPoE +PPP，IPoE，在上网速率上体现出数量级的差别，从模拟电话线 56Kbps，ISDN 144Kbps，ADSL 512Kbps-10Mbps，FTTH 2-1000Mbps。</p>
<h3 id="拨号上网"><a href="#拨号上网" class="headerlink" title="拨号上网"></a>拨号上网</h3><h4 id="模拟线电话拨号"><a href="#模拟线电话拨号" class="headerlink" title="模拟线电话拨号"></a>模拟线电话拨号</h4><p>使用电话线，用户可以在自己的电脑上安装一个内置（插在电脑 PCI 插槽）modem，或外置（插在 RS-232 接口）modem官方的名字：调制解调器，民间的名字：猫！它负责将电脑的数字信号转换为可以在电话线上传输的模拟信号。在局端，也有对应的 modem，再将模拟信号转换为数字信号。</p>
<h4 id="数字线电话拨号-ISDN"><a href="#数字线电话拨号-ISDN" class="headerlink" title="数字线电话拨号 ISDN"></a>数字线电话拨号 ISDN</h4><p>此为数字线，所以不需要模数转换的 modem，提供 B +2D 接入方式，即一条 16Kbps 信令通道 B，两条各 64 Kbps 数据通道 D，可以一条线路打电话，同时另一条上网；也可以两条 D 通道都用于上网，即 64 + 64=128 Kbps 的上网带宽。</p>
<h3 id="xDSL方式"><a href="#xDSL方式" class="headerlink" title="xDSL方式"></a>xDSL方式</h3><p>xDSL：用数字技术对现有的模拟电话用户线进行改造。标准模拟电话信号的频带限制在300～3400Hz的范围内，但用户线本身实际可通过的信号频率超过1MHz。xDSL就把0～4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱给用户上网使用。</p>
<ul>
<li>DSL：数字用户线路</li>
<li>ADSL：不对称数字用户线路</li>
<li>VDSL：甚高比特率数字用户线路</li>
<li>R-ADSL：速率适应数字用户线</li>
<li>IDSL：ISDN DSL</li>
<li>HDSL：高速数字用户线</li>
<li>SDSL：单线用户数字线</li>
</ul>
<p><img src="/img/IMG102.png" alt=""><br><img src="/img/IMG103.png" alt=""></p>
<p>中间还是一根电话线，你这头是一个ADSL宽带猫，运营商机房那头是对应的宽带设备。</p>
<p>ADSL的特点</p>
<ol>
<li>上行和下行带宽做成不对称的</li>
<li>ADSL在用户线的两端各安装一个ADSL调制解调器</li>
<li>我国目前采用的方案是离散多间调DMT（Discrete Multi-Tone）调制技术</li>
</ol>
<p><strong>DMT技术</strong><br>DMT调制技术采用频分复用的方法，把40kHz以上一直到1.1MHz的高端频谱划分为许多的子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道<br>每个子信道占据4kHz带宽，并使用不同的载波（即不同的音调）进行数字调制，这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据</p>
<p><img src="/img/IMG104.png" alt=""></p>
<p>Serial/parallel converter 串/并行转换</p>
<p><img src="/img/IMG105.png" alt=""><br><img src="/img/IMG106.png" alt=""></p>
<h3 id="HFC"><a href="#HFC" class="headerlink" title="HFC"></a>HFC</h3><p>光纤同轴混合网，Hybrid Fiber Coax</p>
<p>HFC网是在目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。<br>HFC网除可传送CATV外，还提供电话、数据和其他宽带交互型业务。<br>现有的CATV网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而HFC网则需要对CATV进行改造。</p>
<p>HFC的主要特点：</p>
<ul>
<li>HFC网的主干线路采用光纤。HFC网将原CATV网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。在模拟光纤中采用光的振幅调制AM，这比使用数字光纤更为经济。模拟光纤从头端连接到光纤结点（fiber node），即光分配结点OND（Optical Distribution Node）。在光纤结点光信号被转换为电信号，在光纤结点以下就是同轴电缆。</li>
<li>HFC网具有比CATV网更宽的频谱，且具有双向传输功能</li>
<li>每个家庭要安装一个用户接口盒</li>
</ul>
<p><img src="/img/IMG107.png" alt=""><br><img src="/img/IMG108.png" alt=""><br><img src="/img/IMG109.png" alt=""></p>
<p>HFC的优点<br>具有很宽的频带<br>能够利用已经有相当大的覆盖面的有线电视网</p>
<h3 id="FTTx"><a href="#FTTx" class="headerlink" title="FTTx"></a>FTTx</h3><p>FTTx（光纤到……），这里字母x可代表不同意思</p>
<ul>
<li>光纤到家FTTH（Fiber To The Home）：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法（155Mb/s）</li>
<li>光纤到大楼FTTB（Fiber To The Building）：光纤进入大楼后就接入交换机，然后用电缆或双绞线分配到各用户</li>
<li>光纤到路边FTTC（Fiber To The Curb）：从路边到各用户可使用星形结构双绞线作为传输媒体（155Mb/s）</li>
</ul>
<p><br></p>
<p>参考：</p>
<ul>
<li><a href="http://blog.51cto.com/alligator/910667" target="_blank" rel="external">http://blog.51cto.com/alligator/910667</a></li>
<li><a href="http://www.admin10000.com/document/3946.html" target="_blank" rel="external">http://www.admin10000.com/document/3946.html</a></li>
<li><a href="https://www.zhihu.com/question/48988005" target="_blank" rel="external">https://www.zhihu.com/question/48988005</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;物理层的基本概念&quot;&gt;&lt;a href=&quot;#物理层的基本概念&quot; class=&quot;headerlink&quot; title=&quot;物理层的基本概念&quot;&gt;&lt;/a&gt;物理层的基本概念&lt;/h2&gt;&lt;p&gt;物理层解决如何在连接各种计算机的 &lt;strong&gt;传输媒体&lt;/strong&gt;（光纤、无线等）上传输 &lt;strong&gt;数据比特流&lt;/strong&gt;，而不是指具体的传输媒体&lt;br&gt;物理层的主要任务描述为：确定传输媒体的接口的一些特性，即：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;机械特性&lt;/strong&gt;：例如接口形状，大小，引线数目&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;电气特性&lt;/strong&gt;：例如规定电压范围（-5V到+5V）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能特性&lt;/strong&gt;：例如规定-5V表示0，+5V表示1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过程特性&lt;/strong&gt;：也称为规程特性，规定建立连接时各个相关部件的工作步骤&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络性能指标</title>
    <link href="http://yoursite.com/post/da722289.html"/>
    <id>http://yoursite.com/post/da722289.html</id>
    <published>2018-06-19T08:35:24.000Z</published>
    <updated>2018-06-20T23:56:53.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>连接在计算机网络上的主机在 <strong>数字信道</strong> 上传送 <strong>数据位数</strong> 的速率，也称为 <code>data rate</code> 或 <code>bit rate</code><br>单位：<code>b/s</code>、<code>kb/s</code>、<code>Mb/s</code>、<code>Gb/s</code></p>
<p>注意两点：</p>
<ol>
<li>速率是指一个信道</li>
<li>计算的是<code>bit</code>，而不是<code>byte</code>，实际网速多用<code>K/s</code>、<code>M/s</code>都是计算<code>byte</code>，而我们说的带宽有100M指的是<code>bit</code>，故而实际网速是带宽除以8</li>
</ol>
<p><br></p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>数据通信领域中，数字信道所能传送的最高数据率，单位是<code>b/s</code>、<code>kb/s</code>、<code>Mb/s</code>、<code>Gb/s</code><br>所有信道传输和的最大值</p>
<p><br></p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>在单位时间内通过某个网络的数据量，单位是<code>b/s</code>、<code>kb/s</code>、<code>Mb/s</code>、<code>Gb/s</code><br>单位时间内所有信道传输的和</p>
<p><br></p>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>又叫延迟。<br>时延是指一个报文或分组从一个网络的一端传送到另一个端所需要的时间。它包括了发送时延，传播时延，处理时延，排队时延。主要时延是发送时延和传播时延</p>
<ul>
<li>发送时延：数据块长度(bit)/信道带宽(b/s)。主机或路由器发送数据帧所需要的时间，也就是从发送数据的第一个比特算起，到该帧的最后一个比特发送（到网线上）完毕所需的时间。发送时延也称为传输时延。</li>
<li>传播时延：数据在网络上传输开始到接收端完全接收数据结束。电磁波在信道中传播一定的距离需要花费的时间</li>
<li>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，就这产生了处理时延。</li>
<li>排队时延：分组在经过网络传输时，会经过许多路由器。分组在进入路由器之前要先在输入队列中排队等待处理（因为可能无法一次处理完成）。在路由器确定了转发接口后，还要在输出队列中排队等待转发（因为可能无法一次发送完成）。这就产生了排队时延。</li>
</ul>
<p>带宽决定了发送时延，带宽越大，时延越低，但是不能无限增大，数据太密集后，可能无法识别高电压和低电压，也就无法识别数据，这时就要考虑传播介质，传播介质决定传播时延，铜介质因为信号太密集就无法识别，而光纤可以</p>
<p><br></p>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 = 带宽×传播时延</p>
<p><br></p>
<h2 id="往返时间-RTT-Round-Trip-Time"><a href="#往返时间-RTT-Round-Trip-Time" class="headerlink" title="往返时间 RTT Round-Trip Time"></a>往返时间 RTT Round-Trip Time</h2><p>从发送方发送数据开始，到发送方收到接收方确认<br><code>ping</code>命令查看的时间就是往返时间</p>
<p><br></p>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：有数据通过时间/(有+无)数据通过时间<br>网络利用率：信道利用率加权平均值</p>
<p><img src="/img/IMG71.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;速率&quot;&gt;&lt;a href=&quot;#速率&quot; class=&quot;headerlink&quot; title=&quot;速率&quot;&gt;&lt;/a&gt;速率&lt;/h2&gt;&lt;p&gt;连接在计算机网络上的主机在 &lt;strong&gt;数字信道&lt;/strong&gt; 上传送 &lt;strong&gt;数据位数&lt;/strong&gt; 的速率，也称为 
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>gns3使用</title>
    <link href="http://yoursite.com/post/1f37d955.html"/>
    <id>http://yoursite.com/post/1f37d955.html</id>
    <published>2018-06-19T04:43:47.000Z</published>
    <updated>2018-06-19T08:35:53.966Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://gns3.com/" target="_blank" rel="external">https://gns3.com/</a></p>
<p>ubuntu下安装gns3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:gns3/ppa</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install gns3-gui</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官网：&lt;a href=&quot;https://gns3.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gns3.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ubuntu下安装gns3&lt;br&gt;&lt;figure class=&quot;highlight plai
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python播放视频</title>
    <link href="http://yoursite.com/post/fb7a8e23.html"/>
    <id>http://yoursite.com/post/fb7a8e23.html</id>
    <published>2018-06-18T14:14:32.000Z</published>
    <updated>2018-06-19T08:32:40.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装opencv"><a href="#安装opencv" class="headerlink" title="安装opencv"></a>安装opencv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install opencv-python</div></pre></td></tr></table></figure>
<p>如果使用以下方式安装，则安装opencv2，只能在python2.7下使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-opencv</div></pre></td></tr></table></figure></p>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">&gt;&gt;&gt; cv2.__version__</div><div class="line">&apos;3.4.1&apos;</div></pre></td></tr></table></figure>
<h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><p>这样只有声音<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import pyglet</div><div class="line">import os</div><div class="line"></div><div class="line">window=pyglet.window.Window(caption=&apos;my player&apos;)</div><div class="line"></div><div class="line">player=pyglet.media.Player()</div><div class="line"></div><div class="line">source=pyglet.media.load(&apos;./sound/movie.flv&apos;,streaming=False)</div><div class="line">player.play()</div><div class="line"></div><div class="line">@window.event</div><div class="line">def on_draw():</div><div class="line">    window.clear()</div><div class="line">    player.get_texture().blit(0,0)</div><div class="line"></div><div class="line">pyglet.app.run()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装opencv&quot;&gt;&lt;a href=&quot;#安装opencv&quot; class=&quot;headerlink&quot; title=&quot;安装opencv&quot;&gt;&lt;/a&gt;安装opencv&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python变量和常量</title>
    <link href="http://yoursite.com/post/7f049186.html"/>
    <id>http://yoursite.com/post/7f049186.html</id>
    <published>2018-06-16T23:16:15.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>命名</strong></p>
<ol>
<li>第一个字符必须是字母表中的字母(大写ASCII字符或小写ASCII字符或Unicode字符)或下划线(<code>_</code>)。</li>
<li>标识符的其它部分可以由字符(大写 ASCII 字符或小写 ASCII 字符或 Unicode字符)、下划线(<code>_</code>)、数字(0~9)组成。</li>
<li>标识符名称区分大小写</li>
</ol>
<p>实际上是把变量b指向变量a所指向的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">ABC</div><div class="line">&gt;&gt;&gt; b=a</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">ABC</div><div class="line">&gt;&gt;&gt; a=&apos;XYZ&apos;</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">XYZ</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">ABC</div></pre></td></tr></table></figure></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>通常用全部大写的变量名表示常量，但无法保证不会被改变，<strong>本质还是变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PI = 3.14159265359</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一个字符必须是字母表中的字母(大写ASCII字符或小写ASCII字符或U
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型</title>
    <link href="http://yoursite.com/post/9f07ae5c.html"/>
    <id>http://yoursite.com/post/9f07ae5c.html</id>
    <published>2018-06-15T12:12:21.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据类型</strong></p>
<ul>
<li>整数：<code>-1</code>，<code>100</code>，<code>0</code>，<code>0xff00</code>（十六进制整数）</li>
<li>浮点数：<code>1.23</code>，<code>-9.01</code>，<code>1.23e9</code>，<code>1.23-5</code></li>
<li>字符串：<code>&#39;12c&#39;</code>，<code>&quot;ab&quot;</code>，<code>&quot;I&#39;m OK&quot;</code>，<code>&#39;I\&#39;m OK&#39;</code></li>
<li>布尔值：<code>True</code>，<code>False</code>（首字母大写）</li>
<li>空值：<code>None</code></li>
</ul>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的），而浮点数运算则可能会有四舍五入的误差。</p>
<ul>
<li>转义字符：<code>\n</code>，<code>\\</code>，<code>\t</code>，<code>\&#39;</code>，<code>\&quot;</code></li>
<li>用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</li>
<li>用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(r&apos;&apos;&apos;hello,\n</div><div class="line">... world&apos;&apos;&apos;)</div><div class="line">hello,\n</div><div class="line">world</div></pre></td></tr></table></figure>
<p><code>and</code>，<code>or</code>，<code>not</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; True and True</div><div class="line">True</div><div class="line">&gt;&gt;&gt; True and False</div><div class="line">False</div><div class="line">&gt;&gt;&gt; True or True</div><div class="line">True</div><div class="line">&gt;&gt;&gt; True or False</div><div class="line">True</div><div class="line">&gt;&gt;&gt; not True</div><div class="line">False</div><div class="line">&gt;&gt;&gt; not False</div><div class="line">True</div><div class="line">&gt;&gt;&gt; not 1&gt;2</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p><strong>数据类型转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s=&apos;123&apos;</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&apos;123&apos;</div><div class="line">&gt;&gt;&gt; int(s)</div><div class="line">123</div><div class="line">&gt;&gt;&gt; a=123</div><div class="line">&gt;&gt;&gt; a</div><div class="line">123</div><div class="line">&gt;&gt;&gt; str(a)</div><div class="line">&apos;123&apos;</div><div class="line">&gt;&gt;&gt; bool(1)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; bool(&apos;&apos;)</div><div class="line">False</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数：&lt;code&gt;-1&lt;/code&gt;，&lt;code&gt;100&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;0xff00&lt;/code&gt;（十六进制整数）&lt;/li&gt;
&lt;li&gt;浮点数：&lt;code&gt;1.23
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python输入输出及基础</title>
    <link href="http://yoursite.com/post/32cf0123.html"/>
    <id>http://yoursite.com/post/32cf0123.html</id>
    <published>2018-06-15T12:12:09.000Z</published>
    <updated>2018-06-19T08:32:40.788Z</updated>
    
    <content type="html"><![CDATA[<p><strong>输出</strong><br>自动添加空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;print(&apos;hello world&apos;)</div><div class="line">hello world</div><div class="line">&gt;&gt;&gt;print(&apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;)</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">&gt;&gt;&gt;print(&apos;1024 * 768 =&apos;,1024*768)</div><div class="line">1024 * 768 = 786432</div></pre></td></tr></table></figure>
<p><strong>输入</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;name=input(&apos;please input your name:&apos;)</div><div class="line">&gt;&gt;&gt;print(&apos;name:&apos;,name)</div></pre></td></tr></table></figure></p>
<p>采用缩进方式<br>当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块<br>Python程序是大小写敏感的<br>使用4个空格的缩进<br>以<code>#</code>开头的语句是注释</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;br&gt;自动添加空格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python编码</title>
    <link href="http://yoursite.com/post/d6d2cac9.html"/>
    <id>http://yoursite.com/post/d6d2cac9.html</id>
    <published>2018-06-15T00:44:39.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul>
<li>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</li>
<li>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件</li>
<li>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</li>
<li>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</div><div class="line">65</div><div class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</div><div class="line">20013</div><div class="line">&gt;&gt;&gt; chr(66)</div><div class="line">&apos;B&apos;</div><div class="line">&gt;&gt;&gt; chr(25991)</div><div class="line">&apos;文&apos;</div><div class="line">&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;</div><div class="line">&apos;中文&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="str和bytes"><a href="#str和bytes" class="headerlink" title="str和bytes"></a>str和bytes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x=b&apos;ABC&apos;</div><div class="line">y=&apos;ABC&apos;</div></pre></td></tr></table></figure>
<p>y是<code>str</code>，x是<code>bytes</code>，内容显示一样，但<code>bytes</code>每个字符都只占用一个字节</p>
<ul>
<li>Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>(各个平台的编码不一定都相同，socket 传递的数据都是<code>bytes</code>类型的，避免乱码)</li>
<li>Python 3 不会以任意隐式的方式混用<code>str</code>和<code>bytes</code></li>
<li>Bytes 对象是由单个字节作为基本元素（8 位，取值范围 0-255）组成的序列，为不可变对象。</li>
<li><code>Bytes</code>对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。我们可以通过调用<code>bytes()</code> 类（没错，它是类，不是函数）生成<code>bytes</code>实例，其值形式为<code>b&#39;xxxxx&#39;</code>，其中<code>&#39;xxxxx&#39;</code>为一至多个转义的十六进制字符串（单个 x 的形式为：<code>\xHH</code>，其中 <code>\x</code> 为小写的十六进制转义字符，HH 为二位十六进制数）组成的序列，每个十六进制数代表一个字节（八位二进制数，取值范围 0-255），对于同一个字符串如果采用不同的编码方式生成 <code>bytes</code> 对象，就会形成不同的值</li>
</ul>
<p><code>str</code>编码为指定的<code>bytes</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</div><div class="line">b&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf8&apos;)</div><div class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</div><div class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</div></pre></td></tr></table></figure></p>
<p>纯英文的<code>str</code>可以用ASCII编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p>
<p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p>
<p><code>bytes</code>编码为<code>str</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</div><div class="line">&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf8&apos;)</div><div class="line">&apos;中文&apos;</div><div class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;ascii&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 0: ordinal not in range(128)</div></pre></td></tr></table></figure></p>
<h3 id="len函数"><a href="#len函数" class="headerlink" title="len函数"></a>len函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; len(&apos;中文&apos;)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; len(b&apos;abc&apos;)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf8&apos;))                          </div><div class="line">6</div></pre></td></tr></table></figure>
<h3 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># encoding=utf-8</div></pre></td></tr></table></figure>
<p>第一行会告诉系统使用的python路径，不建议使用<code>#!/usr/bin/python</code>，灵活性降低</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">sys.getdefaultencoding()</div><div class="line"></div><div class="line">&apos;utf-8&apos;</div></pre></td></tr></table></figure>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello,%s&apos;%&apos;world&apos;</div><div class="line">&apos;Hello,world&apos;</div><div class="line">&gt;&gt;&gt; &apos;Hi,%s,you have $%d.&apos;%(&apos;Michael&apos;,10000)</div><div class="line">&apos;Hi,Michael,you have $10000.&apos;</div><div class="line">&gt;&gt;&gt; print(&apos;$%2d-$%02d&apos; % (3,1))</div><div class="line">$ 3-$01</div><div class="line">&gt;&gt;&gt; print(&apos;%.2f&apos; % 3.1415926)</div><div class="line">3.14</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;growth rate:%d %%&apos; % 7</div><div class="line">&apos;growth rate:7 %&apos;</div></pre></td></tr></table></figure>
<p>%d 整数<br>%f 浮点数<br>%s 字符串<br>%x 十六进制整数</p>
<p>如果不太确定应该用什么，%s永远起作用</p>
<h3 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello,&#123;0&#125;,成绩提升了&#123;1:.1f&#125;&apos;.format(&apos;小明&apos;,17.125)</div><div class="line">&apos;Hello,小明,成绩提升了17.1&apos;</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="http://www.ituring.com.cn/article/1116" target="_blank" rel="external">http://www.ituring.com.cn/article/1116</a></li>
<li><a href="https://www.kancloud.cn/lanyulei/python/357700" target="_blank" rel="external">https://www.kancloud.cn/lanyulei/python/357700</a></li>
<li><a href="https://segmentfault.com/a/1190000004450876" target="_blank" rel="external">https://segmentfault.com/a/1190000004450876</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;/li&gt;
&lt;li&gt;用记
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Anaconda</title>
    <link href="http://yoursite.com/post/634c672f.html"/>
    <id>http://yoursite.com/post/634c672f.html</id>
    <published>2018-06-14T01:38:50.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda 是一种Python语言的包管理工具，用于进行大规模数据处理, 预测分析, 和科学计算, 致力于简化包的管理和部署。 Anaconda使用软件包管理系统Conda进行包管理。</p>
<p>实际上我使用Anaconda是为了避免Python2和Python3的冲突，我既想使用Python3又不想改变Python2原来的东西</p>
<p>官网：<a href="https://anaconda.org/" target="_blank" rel="external">https://anaconda.org/</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>选择对应的Python版本和系统进行下载安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bash Anaconda3-5.2.0-Linux-x86_64.sh</div><div class="line">conda upgrade --all</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装包管理"><a href="#安装包管理" class="headerlink" title="安装包管理"></a>安装包管理</h2><p>列出已经安装的包：<code>pip list</code>或<code>conda list</code><br>安装新包：<code>pip install 包名</code>或<code>conda install 包名</code><br>更新包： <code>conda update package_name</code><br>升级所有包：<code>conda upgrade --all</code><br>卸载包：<code>conda remove package_names</code><br>搜索包：<code>conda search search_term</code></p>
<h2 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h2><p>安装nb_conda，用于notebook自动关联nb_conda的环境<code>conda install cb_conda</code><br>创建环境：<code>conda create -n env_name package_names[=ver]</code><br>指定Python版本：<code>conda create -n py3 python=3.6</code><br>可以切换不同的Python版本<br>使用环境：<code>activate env_name</code><br>离开环境：<code>deactivate</code><br>导出环境设置：<code>conda env export &gt; environmentName.yaml</code> 或 <code>pip freeze &gt; environmentName.txt</code><br>导入环境设置：<code>conda env update -f=/path/environmentName.yaml</code> 或 <code>pip install -r /path/environmentName.txt</code><br>导出和导入可以用于共享环境，在 GitHub 上共享代码时，最好同样创建环境文件并将其包括在代码库中。这能让其他人更轻松地安装你的代码的所有依赖项。<br>列出环境清单：<code>conda env list</code><br>删除环境： <code>conda env remove -n env_name</code></p>
<p>参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88</a>)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Anaconda 是一种Python语言的包管理工具，用于进行大规模数据处理, 预测分析, 和科学计算, 致力于简化包的管理和部署。 Anaconda使用软件包管理系统Conda进行包管理。&lt;/p&gt;
&lt;p&gt;实际上我使用Anaconda是为了避免Python2和Python3的冲突，我既想使用Python3又不想改变Python2原来的东西&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://anaconda.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://anaconda.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;下载：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&lt;/a&gt;&lt;br&gt;选择对应的Python版本和系统进行下载安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;bash Anaconda3-5.2.0-Linux-x86_64.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;conda upgrade --all&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
