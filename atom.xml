<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>太阳落下</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-04T04:29:14.474Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018-08-04-从零开始的异世界摘抄</title>
    <link href="http://yoursite.com/post/9262a4e5.html"/>
    <id>http://yoursite.com/post/9262a4e5.html</id>
    <published>2018-08-04T04:28:18.000Z</published>
    <updated>2018-08-04T04:29:14.474Z</updated>
    
    <content type="html"><![CDATA[<p>昴：我早就烦恼过了，思索过了，痛苦过了，所以 我放弃了<br>雷姆：说放弃很简单，所以……<br>昴：说放弃..很简单？<br>雷姆：昴君？<br>昴：开什么玩笑，说放弃怎么可能很简单啊！我什么都不愿做，什么都不愿想，轻易地丢下一切，把所有事统统抛到脑后，这就是你所谓的放弃吗？说放弃一点都不简单。拼死战斗吧，想尽办法解决吧，这些想法轻松得多啊，但是，这样根本没用啊，根本不存在解决之道啊，剩下的只有放弃这条路了啊，如果有办法解决的话，我也…我也…<br>雷姆：昴君，说放弃很简单，但是，那样不适合昴君。昴君心里有多难过，是什么事让你这么痛苦，雷姆都不知道，我也清楚“我明白”这种话不能轻易说出口，但是，即使如此，有些事雷姆也是明白的，昴君不是那种能够中途放弃的人，雷姆知道，昴君谈论他所期盼的未来之时是会露出笑容的，雷姆知道，昴君是不会放弃未来的人</p>
<p>……</p>
<p>昴：我的手掌太小了，全都漏光了，全都没留下<br>雷姆：不，没有那回事，昴君…你…<br>昴：你了解我…..你了解我什么啊！！我就是这种程度的男人，明明没有力量，却问题奢望太高，明明没有知识，却老是白日做梦，明明无能为力，却还是无谓挣扎，我…我…最讨厌我自己了啊。总是嘴上说得好听，明明没什么能耐还那么自以为是，明明靠自己什么都做不到，埋怨别人的功夫倒是一流，你当你是谁啊！这种人竟然不能不知羞耻地苟活于世！对吧！空空如也啊，我就是一具空壳，不会错的，嗯，那当然了，当然不会错，你知道我来这里之前，在与你们相遇的事发生之前，你知道我来这里之前，在与你们相遇的事发生之前，我都做了些什么了吗？我什么都没做，我完全没有做任何事。明明有大把的时间，明明那么自由，明明可以做到任何事，可是却什么都没做，而结果就是这样，结果就是现在的我，我的无力、无能、全部的全部，我的烂到根里的本性就是理由。明明没做过什么努力，还想要有所作为，痴心妄想也该有个限度吧，是我懒惰怠慢的报应，是我了不起的人生浪费癖，杀死了我们俩。是啊，我的本性根本没变，即使我下决心在这里活下去，也没有任何改变，那个爷爷把我的这种本性看得一清二楚，对吧？并不是为了变强，也不是为了解决问题，我的努力，只是为了表明自己并非无所事事，像那样摆出显眼的卖力姿势，只是为了帮自己开脱，只想说明自己的无奈，只想让大家认同自己的无奈，只是为了得到这种效果，我才装作自己好像很拼命的样子，让你陪我一起用功，也是为了掩饰这种尴尬而摆出的姿态啊。我的本性，那种自私自利又特别在乎他人眼光的渺小卑鄙肮脏的本性一点没变，完全没有改变！其实我明白的，全部都是我的错，我最差劲了，我最讨厌我自己了。<br>雷姆：雷姆知道，无论在多么前程暗淡的黑暗之中，昴君都有勇气伸出自己的手。我喜欢被昴君摸头，经过手和头发，我好像能与昴君心灵相通；我喜欢昴君的声音，每听一个字，心里就多一份温暖；我喜欢昴君的眼神，虽然平时很锐利，但是对别人温柔时，柔和下来的那种眼神我很喜欢；我喜欢昴君的手指，明明是男孩子，手指却那么漂亮，但是握住之后又能感受到男子汉气息的有力而纤细的手指；我喜欢昴君的走路的方式，一起相伴而行的时候，偶尔会回头，好像在确认我有没有跟上的，那种走路方式我很喜欢。<br>昴：别说了。<br>雷姆：我喜欢昴君的睡脸，像婴儿一样毫无防备，睫毛有点长长的，默默脸颊你就会平静下来，恶作剧地碰碰嘴唇你却浑然不觉，让你非常地揪心，非常喜欢。<br>昴：为什么？<br>雷姆：如果昴君说讨厌自己的话，雷姆忽然也想让昴君知道，你有着这么多的优点呢。<br>昴：那只是假象而已，知识你不知道而已，我自己的事，我自己最清楚。<br>雷姆：昴君只知道你自己，而雷姆所看到的昴君，你又知道多少呢？<br>昴：为什么…对我…这么…我又弱又渺小，只会逃避，跟之前的我一样，只会逃避，即便如此为什么你…<br>雷姆：因为，昴君是雷姆的英雄啊。在那昏暗的森林里，在那个连自己都认不得的世界里，赶来拯救只知道到处肆虐的雷姆的人是你；对于清醒过来却动弹不得的雷姆，对于魔法使用过度而疲惫不堪的姐姐，不逃不避并且担当诱饵面对魔兽的人是你；即便没有胜算，即便真的有生命危险，最后还是活下来，热乎乎的回到雷姆手中的人是你； 张开眼睛，露出微笑，由最完美的人在最完美的时机，对雷姆说出最完美的话，做到这点的人是你。雷姆的时间，一直是停止的，自从那个烈焰燃烧的夜晚，自从那个让我失去一切的只剩下姐姐的夜晚，雷姆的时间一直是停止的，停止的时间，冻结的内心，是被昴君的甜蜜溶化的，是被昴君的温柔打动的。 在那个瞬间，在那个早晨，雷姆获得了多大的救赎，雷姆获得了多强的喜悦，一定连昴君都不会知道，所以，雷姆相信，无论遇到多么艰辛困苦的事，无论昴君的胜算多么渺茫，哪怕世界上没有一个人相信昴君，哪怕连昴君都不再相信自己，雷姆，也相信着，相信着拯救了雷姆的昴君是真正的英雄。<br>昴：无论多么努力，都没能拯救任何人。<br>雷姆：有雷姆在，被昴君拯救的雷姆，现在就在这里。<br>昴：什么都没做，一具空壳的我，没有人会听我的话。<br>雷姆：有雷姆在。只要是昴君的话，我什么都会听，我想听。<br>昴：没有人期待我，没有人相信我，我最讨厌我自己。<br>雷姆：雷姆，爱着昴君。<br>昴：我这种人，可以吗？<br>雷姆：我要的就是昴君，不是昴君的话，我不要。空空如也，一无所有，如果你不能原谅这样的自己，那么就从现在，从这里开始吧。就像昴君让雷姆静止的时间重新转动一样，昴君要让自己心中静止的时间，从现在开始转动，从这里开始吧。从一开始，不…从零开始。如果独自前行太艰难的话，雷姆会支持你的。分摊彼此身上的包袱，互相扶持着走下去吧。那天早上，你是这么对我说的吧？展现出你的帅气之处吧，昴君。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昴：我早就烦恼过了，思索过了，痛苦过了，所以 我放弃了&lt;br&gt;雷姆：说放弃很简单，所以……&lt;br&gt;昴：说放弃..很简单？&lt;br&gt;雷姆：昴君？&lt;br&gt;昴：开什么玩笑，说放弃怎么可能很简单啊！我什么都不愿做，什么都不愿想，轻易地丢下一切，把所有事统统抛到脑后，这就是你所谓的放弃
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据校验码</title>
    <link href="http://yoursite.com/post/a55639d7.html"/>
    <id>http://yoursite.com/post/a55639d7.html</id>
    <published>2018-07-25T01:29:05.000Z</published>
    <updated>2018-07-25T09:21:04.779Z</updated>
    
    <content type="html"><![CDATA[<p>数据在计算机系统内形成、存取和传送过程中，可能会因为某种原因而产生错误，如将0误传为1等。为减少和避免这类错误，一方面需要从电路、电源、布线等硬件方面采取措施，提高计算机硬件本身的抗干扰能力和可靠性；另一方面可以在数据编码上采取检错纠错的措施，即采用某种编码方法，使得机器能够发现、定位乃至纠正错误。</p>
<p>具有检测某些错误或带有自动纠正错误能力的数据编码称为<strong>数据校验码</strong>。数据校验码的实现原理是<strong>在正常编码中加入一些冗余位</strong>，即在正常编码组中加入一些非法编码，当合法数据编码出现某些错误时，就成为非法编码，因此就可以通过检测编码是否合法来达到自动发现、定位乃至改正错误的目的。在数据校验码的设计中，需要根据编码的码距合理地安排非法编码的数量和编码规则。</p>
<p>错误纠正编码的现代发展在1947年由理查德·卫斯里·汉明带来，即海明码/汉明码。</p>
<a id="more"></a>
<p><strong>海明距离</strong>：一组编码中任何两个编码之间代码不同的位数，换句话说，就是将一个编码变换成另外一个编码所需要替换的字符个数。（在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。 ————维基百科）<br><strong>码距</strong>：在一组编码中任何两个编码之间最小的距离</p>
<p>例如编码0011与0001，仅有一位不同，称其海明距离为1。如果采用四位二进制编码表示16种状态，因为从0000到1111这16种编码都用到了，所以这组编码的码距为1。也就是说，在这组编码中任何一个状态的四位码中的一位几位出错，都会变成另一个合法编码，所以这组编码没有查错和纠错能力。但是，如果采用四位二进制表示8个状态，例如只将其中的8种编码0000、0011、0101、0110、1001、1010、1100、1111用作合法编码，而将另外8种编码作为非法编码，此时这组编码的码距为2，即从一个合法编码改为另一个合法编码需要修改2位。如果在数据传输过程中，任何一个合法编码有一位发生了错误，就会出现非法编码。例如编码0000的任意一位发生错形成的编码都不是合法编码，因此系统只要检查编码的合法性，就可以发现错误。</p>
<p>校验码通常是在正常编码的基础上按特别规定增加一些附加的校验位形成的，即通过增大编码的码距来实现检查和纠正错误的目的。一般来说，<strong>合理地增加校验位</strong>、<strong>增大码距</strong>，就能提高校验码发现错误的能力。如上所述，要检查1位错误，编码的码距需要1+1=2。而要检查e位错，编码的码距需要e+1，因为对于这样的编码，一个码字e位出错就无法将一个合法编码变为另外一个合法编码。类似地，如果出错的位置能够确定，将出错位的内容取反，就能够自动纠正错误。而要纠正t位错，编码的码距需要2t+1。这是因为当码距达到2t+1时，即使合法编码中有t位出错，它与原合法编码的编码距离还是比与其他任何合法码字的编码距离要小，这样就可以惟一地确定它的合法编码，即可以自动纠正错误。</p>
<p>例如，考虑下面只有四个合法编码0000000000、0000011111、1111100000、1111111111的编码组。可以看出这个编码组的码距为5，意味着它能纠两位错。如果在数据传输过程中，接收方接收到一个编码0000000111，就能够知道原来的正确编码应0000011111（必须假定不出现两位以上的错误）。当然，如果错了3位，即0000000000变成了0000000111就无法确定0000000000出现了错误，还0000011111出现错误，因而无法纠正错误，即码距为5时，只能够纠两位错<br>由此可见校验位越多，码距越大，编码的检错和纠错能力越强。设码距为d，码距与校验码的检错和纠错能力的关系是:<br>d≥e+1，可检验e个错<br>d≥2t+1，可纠正t个错<br>d≥e+t+1，且e&gt;t，可检验e个错并能纠正t个错</p>
<p><img src="/img/IMG170.png" alt=""></p>
<p>由于数据校验码所使用的二进制位数比常数据编码要多，所以在使用过程中，将增加数据存储的容量或数据传送的数量。因此在确定与使用数据校验码的时候，必须考虑在不过多增加硬件开销的情况下，尽可能发现或改正更多的错误。常用的数据校验码有<strong>奇偶校验码</strong>、<strong>海明校验码</strong>和<strong>循环冗余校验码</strong></p>
<h3 id="奇偶校验码PCC"><a href="#奇偶校验码PCC" class="headerlink" title="奇偶校验码PCC"></a>奇偶校验码PCC</h3><p>奇偶校验码是一种最简单、最常用的校验码。奇偶校验码广泛用于<strong>主存的读写校验</strong>或 <strong>ASCII码字符传送</strong>过程中的检查。<br>奇偶校验码的最小码距是2</p>
<p>组成奇偶校验码的基本方法是：在n位有效信息位上增加一个二进制位作为校验位P，构成n+1位的奇偶校验码。校验位P的位置可以在有效信息位的最高位之前，也可以在有效信息位的最低位之后。奇偶校验码可分为<strong>奇校验</strong>和<strong>偶校验</strong></p>
<p>奇校验（Odd）：使n+1位的奇偶校验码中1的个数为奇数<br>偶校验（Even）：使n+1位的奇偶校验码中1的个数为偶数</p>
<p>采用奇偶校验的编码在传输过程中需要进行奇偶校验，以判断信息传输是否出错，如果接收方接收到一奇校验码中1的个数为偶数，或接收到一偶校验码中1的个数为奇数，则表示接收到的编码中有一位出错</p>
<p>奇偶校验码只能发现一位或奇数位个错误，而无法现偶数位个错误，而且即使发现奇数位个错误也无法确定出错的位置，因而无法自动纠正错误。由于现代计算机可靠性比较高，出错概率很低，而出错时只有一位出错的概率比多位出错的概率高得多，因此用奇偶校验检测一位出错，能够满足一般可靠性的要求。在CPU与主存的信息传送过程中，奇偶校验被广泛应用。</p>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>如前所述，合理地增加校验位、增大码距，能够提高校验码发现错误的能力。因此如果在奇偶校验的基础上，增加校验位的位数，构成多组奇偶校验，就能够发现更多位的错误并可自动纠正错误。这就是海明校验码的实质所在。</p>
<p>海明校验码是 Richard Hamming 于1950年提出来的。它的实现原理是:在数据编码中加入几个校验位，并把数据的每一个二进制位分配在几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验组的值发生变化，这样不但可以发现出错，还能指出是哪一位出错，为自动纠错提供了依据。那么海明校验码究竟应该设置多少个校验位呢？</p>
<p>设有效信息位的位数为n，校验位的位数为k，则组成的海明校验码共长n+k位校验时，需进行k组奇偶校验，将每组的奇偶校验结果组合，可以组成一个k位的二进制数，共能够表示2种状态。在这些状态中，必有一个状态表示所有奇偶校验都是正确的，用于判定所有信息均正确无误，剩下的（2^k-1）种状态可以用来判定出错代码的位置。因为海明校验码共长n+k位，所以校验位的位数k与有效信息位的位数n应满足关系：2^k-1≥n+k</p>
<p>如果出错代码的位置能够确定，将出错位的内容取反，就能够自动纠正错误，因此，满足上式的海明校验码能够<strong>检测出一位错误并且能自动纠正一位错误</strong>。</p>
<p><img src="/img/IMG171.png" alt=""></p>
<p><img src="/img/IMG172.png" alt=""><br><img src="/img/IMG173.png" alt=""></p>
<p><img src="/img/IMG174.png" alt=""></p>
<p>扩展的海明校验码的编码方式是:在检一纠一错的海明校验码的基础上，增加一个校验位P0，构成长度为n+k+1的编码。P0的取值是使长度为n+k+1的编码中1的个数为偶数（偶校验）或奇数（奇校验）</p>
<h3 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h3><p>目前在<strong>磁介质存储器与主机之间的信息传输</strong>、<strong>计算机之间的通信</strong>以及<strong>网络通信</strong>等采用串行传送方式的领域中，广泛采用循环冗余校验码（ Cyclic Redundancy Check，CRC）。循环冗余校验码是在n位有效信息位后拼接k位校验位构成的，它通过除法运算来建立有效信息和校验位之间的约定关系，是一种具有很强检错纠错能力的校验码。</p>
<h4 id="CRC的编码思想"><a href="#CRC的编码思想" class="headerlink" title="CRC的编码思想"></a>CRC的编码思想</h4><p><img src="/img/IMG175.png" alt=""></p>
<h4 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h4><p><img src="/img/IMG176.png" alt=""></p>
<h4 id="CRC码的编码方法"><a href="#CRC码的编码方法" class="headerlink" title="CRC码的编码方法"></a>CRC码的编码方法</h4><p><img src="/img/IMG177.png" alt=""></p>
<h4 id="CRC码的校验"><a href="#CRC码的校验" class="headerlink" title="CRC码的校验"></a>CRC码的校验</h4><p><img src="/img/IMG178.png" alt=""></p>
<h4 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h4><p><img src="/img/IMG179.png" alt=""></p>
<p>参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%BA%A0%E6%AD%A3" target="_blank" rel="external">wiki-错误检测与纠正</a></li>
<li>《计算机组成原理》,张功萱,P53-P65</li>
<li>《计算机组成原理》,唐朔飞,P100</li>
<li><a href="http://blog.51cto.com/winda/1063951" target="_blank" rel="external">最通俗的CRC校验原理剖析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据在计算机系统内形成、存取和传送过程中，可能会因为某种原因而产生错误，如将0误传为1等。为减少和避免这类错误，一方面需要从电路、电源、布线等硬件方面采取措施，提高计算机硬件本身的抗干扰能力和可靠性；另一方面可以在数据编码上采取检错纠错的措施，即采用某种编码方法，使得机器能够发现、定位乃至纠正错误。&lt;/p&gt;
&lt;p&gt;具有检测某些错误或带有自动纠正错误能力的数据编码称为&lt;strong&gt;数据校验码&lt;/strong&gt;。数据校验码的实现原理是&lt;strong&gt;在正常编码中加入一些冗余位&lt;/strong&gt;，即在正常编码组中加入一些非法编码，当合法数据编码出现某些错误时，就成为非法编码，因此就可以通过检测编码是否合法来达到自动发现、定位乃至改正错误的目的。在数据校验码的设计中，需要根据编码的码距合理地安排非法编码的数量和编码规则。&lt;/p&gt;
&lt;p&gt;错误纠正编码的现代发展在1947年由理查德·卫斯里·汉明带来，即海明码/汉明码。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java判断输入是否为数字，若不是数字，则重新输入</title>
    <link href="http://yoursite.com/post/2b4d69da.html"/>
    <id>http://yoursite.com/post/2b4d69da.html</id>
    <published>2018-07-10T12:21:12.000Z</published>
    <updated>2018-07-11T07:15:35.003Z</updated>
    
    <content type="html"><![CDATA[<p>Java判断输入是否为数字，若不是数字，则重新输入</p>
<p>第一开始使用while true实现，但是会导致无限循环，原因是输入流缓存没有被清空，<code>scanner.nextInt()</code>得到的值还是上次进入catch中的值，所以需要使用<code>scanner.nextLine();</code>或<code>scanner.next();</code>换行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Scanner scanner = new Scanner(System.in);</div><div class="line"></div><div class="line">while(true)&#123;</div><div class="line">    System.out.println(&quot;输入ID&quot;);</div><div class="line">    try&#123;</div><div class="line">        int playerId = scanner.nextInt();</div><div class="line">        break;</div><div class="line">    &#125;catch (InputMismatchException e)&#123;</div><div class="line">        System.out.println(&quot;请输入整数类型的ID&quot;);</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>类似的比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int j=0;</div><div class="line">Scanner input=new Scanner(System.in);</div><div class="line">while(true)&#123;</div><div class="line">    if(input.hasNextInt())&#123;</div><div class="line">        j=input.nextInt();</div><div class="line">        break;</div><div class="line">    &#125;else&#123;</div><div class="line">        System.out.println(&quot;请输入整数类型的ID&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Scanner scanner = new Scanner(System.in);</div><div class="line"></div><div class="line">while(true)&#123;</div><div class="line">    System.out.println(&quot;输入ID&quot;);</div><div class="line">    try&#123;</div><div class="line">        int playerId = scanner.nextInt();</div><div class="line">        break;</div><div class="line">    &#125;catch (InputMismatchException e)&#123;</div><div class="line">        System.out.println(&quot;请输入整数类型的ID&quot;);</div><div class="line">        scanner.nextLine();</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int playerId = 0;</div><div class="line">Scanner scanner = new Scanner(System.in);</div><div class="line">System.out.println(&quot;输入ID&quot;);</div><div class="line">while(!scanner.hasNextInt())&#123;</div><div class="line">    scanner.next();</div><div class="line">    System.out.println(&quot;请输入整数类型的ID&quot;);</div><div class="line">&#125;</div><div class="line">playerId = scanner.nextInt();</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/lhp210205/article/details/52062588" target="_blank" rel="external">关于JAVA的Scanner（System.in）循环输入的一些问题与解决</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java判断输入是否为数字，若不是数字，则重新输入&lt;/p&gt;
&lt;p&gt;第一开始使用while true实现，但是会导致无限循环，原因是输入流缓存没有被清空，&lt;code&gt;scanner.nextInt()&lt;/code&gt;得到的值还是上次进入catch中的值，所以需要使用&lt;code&gt;scanner.nextLine();&lt;/code&gt;或&lt;code&gt;scanner.next();&lt;/code&gt;换行。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Scanner scanner = new Scanner(System.in);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;while(true)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&amp;quot;输入ID&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    try&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        int playerId = scanner.nextInt();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        break;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;catch (InputMismatchException e)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&amp;quot;请输入整数类型的ID&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        continue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="http://yoursite.com/post/b4224212.html"/>
    <id>http://yoursite.com/post/b4224212.html</id>
    <published>2018-07-08T04:30:53.000Z</published>
    <updated>2018-07-11T07:18:05.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>如果直接复制文本内容会自动转换编码<br>ANSI并不是某一种特定的字符编码，而是在不同的系统中，ANSI表示不同的编码。比如在中文系统中使用gbk</p>
<p>当你的字节序列是某种编码时，这个时候想把字节序列变成字符串，也需要用这种编码方式，否则会出现乱码<br>文本文件本身可以是任意编码的字节序列，但在utf-8下创建的文本文件只能识别为utf-8的编码，复制文件到其他编码环境下会识别为乱码，复制文本内容会自动转换</p>
<p>在<code>.java</code>文件中指定的各种编码格式，无论指定成哪种格式，最后在编译成<code>.class</code>时统统经过了 unicode 编码转换成双字节</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">String s = &quot;你好word&quot;;</div><div class="line"></div><div class="line">//Linux默认使用utf-8，locale命令查看</div><div class="line">//IDE使用utf-8</div><div class="line">//在UTF-8编码中，英文字符占一个字节，中文字符占用3个字节。</div><div class="line">byte[] bytes = s.getBytes();</div><div class="line">for(byte b :bytes)&#123;</div><div class="line">    //默认使用十进制</div><div class="line">    //System.out.print(b+&quot; &quot;);</div><div class="line">    //把字节转换成了int以16进制的方式显示，并去掉前24位（byte只占8位，转换为int，变为32位</div><div class="line">    System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);</div><div class="line">&#125;</div><div class="line">System.out.println();</div><div class="line"></div><div class="line">byte[] bytes1 = s.getBytes(&quot;utf-8&quot;);</div><div class="line">System.out.print(&quot;utf-8:\t\t&quot;);</div><div class="line">for(byte b :bytes1)&#123;</div><div class="line">    System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);</div><div class="line">&#125;</div><div class="line">System.out.println();</div><div class="line"></div><div class="line">//gbk中，英文字符占用一个字节，中文占用两个字节</div><div class="line">byte[] bytes2 = s.getBytes(&quot;gbk&quot;);</div><div class="line">System.out.print(&quot;gbk:\t\t&quot;);</div><div class="line">for(byte b :bytes2)&#123;</div><div class="line">    System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);</div><div class="line">&#125;</div><div class="line">System.out.println();</div><div class="line"></div><div class="line">//utf-16be中，英文字符占用两个字节，中文占用两个字节</div><div class="line">byte[] bytes3 = s.getBytes(&quot;utf-16be&quot;);</div><div class="line">System.out.print(&quot;utf-16be:\t&quot;);</div><div class="line">for(byte b :bytes3)&#123;</div><div class="line">    System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);</div><div class="line">&#125;</div><div class="line">System.out.println();</div><div class="line"></div><div class="line">// 当你的字节序列是某种编码时，这个时候想把字节序列变成字符串</div><div class="line">// 也需要用这种编码方式，否则会出现乱码</div><div class="line">String string1 = new String(bytes3);</div><div class="line">System.out.println(string1);</div><div class="line">String string2 = new String(bytes3,&quot;utf-16be&quot;);</div><div class="line">System.out.println(string2);</div></pre></td></tr></table></figure>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>java.io.File类用于表示文件或目录的信息（名称、大小等），不能用于文件内容的访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">File file = new File(&quot;/home/lee/Downloads/Temple&quot;);</div><div class="line">//分隔符</div><div class="line">System.out.println(File.separator);</div><div class="line">System.out.println(File.separatorChar);</div><div class="line"></div><div class="line">//判断文件或目录是否存在</div><div class="line">System.out.println(file.exists());</div><div class="line">if(!file.exists())&#123;</div><div class="line">    //创建文件，包括所有必需但不存在的父目录</div><div class="line">    file.mkdirs();</div><div class="line">    //创建文件</div><div class="line">    //file.mkdir();</div><div class="line">&#125;else&#123;</div><div class="line">    //删除文件</div><div class="line">    file.delete();</div><div class="line">&#125;</div><div class="line">//是否是一个目录，如果是目录返回true，如果不是目录或者目录不存在返回的是false</div><div class="line">System.out.println(file.isDirectory());</div><div class="line">//是否是一个文件，如果是文件返回true，如果不是文件或者文件不存在返回的是false</div><div class="line">System.out.println(file.isFile());</div><div class="line"></div><div class="line">File file1 = new File(&quot;/home/lee/Downloads/log1.txt&quot;);</div><div class="line">//File file1 = new File(&quot;/home/lee/Downloads/&quot;,&quot;log1.txt&quot;)</div><div class="line">if(!file1.exists())&#123;</div><div class="line">    try &#123;</div><div class="line">        //创建文件</div><div class="line">        file1.createNewFile();</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">System.out.println(file);//file.toString的内容</div><div class="line">//文件或目录名</div><div class="line">System.out.println(file.getName());</div><div class="line">System.out.println(file1.getName());</div><div class="line"></div><div class="line">System.out.println(file.getPath());</div><div class="line">System.out.println(file.getAbsolutePath());</div><div class="line">System.out.println(file.getAbsoluteFile());</div><div class="line">System.out.println(file.getParentFile());</div><div class="line">System.out.println(file.getParent());</div><div class="line"></div><div class="line">System.out.println(file1.getPath()); //路径名字符串，包括文件名</div><div class="line">System.out.println(file1.getAbsolutePath());//绝对路径名，返回类型为File</div><div class="line">System.out.println(file1.getAbsoluteFile());//绝对路径名，返回类型为String</div><div class="line"></div><div class="line">//返回父目录的路径</div><div class="line">System.out.println(file1.getParentFile()); //返回值为File</div><div class="line">System.out.println(file1.getParent());     //返回值为String</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 遍历目录，包括子目录</div><div class="line"> */</div><div class="line">public static void listDirectory(File file) throws IOException, IllegalAccessException &#123;</div><div class="line">    if(!file.exists())&#123;</div><div class="line">        throw new IllegalAccessException(&quot;目录&quot;+file+&quot;不存在&quot;);</div><div class="line">    &#125;</div><div class="line">    if(!file.isDirectory())&#123;</div><div class="line">        throw new IllegalAccessException(file+&quot;不是目录&quot;);</div><div class="line">    &#125;</div><div class="line">    //下列两个方法都是列出路径名表示的目录中的文件和目录，但返回值不同</div><div class="line">    String[] strings = file.list();</div><div class="line">    File[] files = file.listFiles();</div><div class="line"></div><div class="line">    if(files != null &amp; files.length != 0)&#123;</div><div class="line">        for(File f:files)&#123;</div><div class="line">            if(f.isDirectory())&#123;</div><div class="line">                listDirectory(f);</div><div class="line">            &#125;else&#123;</div><div class="line">                System.out.println(f.getPath());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><p>RandomAccessFile类提供对文件内容的访问，既可以读文件，也可以写文件。支持随机访问文件，可以访问文件的任意位置。</p>
<ul>
<li>在硬盘上的文件是以 <code>byte byte byte</code>形式存储的，是数据的集合</li>
<li>RandomAccessFile打开文件有两种模式：<code>rw</code>（读写），<code>r</code>（只读）</li>
<li>文件指针，打开文件时指针在开头 <code>pointer = 0</code>；</li>
<li>写方法：<code>raf.write(int)</code>只写一个字节（后8位），同时指针指向下一个位置，准备再次写入</li>
<li>读方法：<code>int b = raf.read()</code>—&gt;读一个字节</li>
<li>文件读写完成以后一定要关闭<code>raf.close()</code></li>
<li>不存在追加，如果需要追加，将位置定位到文件末尾，使用<code>long fileLen = raf.length(); raf.seek(fileLen);</code></li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>IO流分为输入流、输出流，又分为字节流、字符流</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>InputStream和OutputStream是抽象类</p>
<ol>
<li>InputStream：抽象了应用程序<strong>读取</strong>数据的方式</li>
<li>OutputStream：抽象了应用程序<strong>写出</strong>数据的方式</li>
<li>EOF = End 读到-1就读到结尾</li>
</ol>
<h4 id="输入流基本方法"><a href="#输入流基本方法" class="headerlink" title="输入流基本方法"></a>输入流基本方法</h4><p><code>int b = in.read();</code><br>读取一个字节无符号填充到int低八位，如果已到达文件末尾，则返回 -1。<br><code>in.read(byte[] buf)</code><br>读取数据填充到字节数组buf<br><code>in.read(byte[] buf,int start, int size);</code><br>读取数据到字节数组buf从buf的start位置开始存放size长度的数据</p>
<h4 id="输出流基本方法"><a href="#输出流基本方法" class="headerlink" title="输出流基本方法"></a>输出流基本方法</h4><p><code>out.write(int b)</code><br>写出一个byte到流，b的低8位<br><code>out.write(byte[] buf)</code><br>将buf字节数组都写到流<br><code>out.write(byte[] buf, int start,int size)</code><br>字节数组buf从start位置开始写size长度的字节到流</p>
<h4 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h4><p>InputStream的子类，具体实现了在文件上读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 读取指定文件内容，按照16进制输出到控制台</div><div class="line">* 并且每输出10个byte换行</div><div class="line">* 一个字节一个字节读取文件内容</div><div class="line">*/</div><div class="line">public static void printHex(String filename) throws IOException &#123;</div><div class="line">    FileInputStream fis = new FileInputStream(filename);</div><div class="line">    int b;</div><div class="line">    int i = 0;</div><div class="line">    while((b=fis.read()) != -1)&#123;</div><div class="line">        System.out.print(Integer.toHexString(b &amp; 0xff)+&quot; &quot;);</div><div class="line">        i++;</div><div class="line">        if(i% 10 == 0)&#123;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 读取指定文件内容，按照16进制输出到控制台</div><div class="line">* 并且每输出10个byte换行</div><div class="line">* 一次性读取20 * 1024个字节读取文件内容</div><div class="line">*/</div><div class="line">public static void printHex1(String filename) throws FileNotFoundException,IOException &#123;</div><div class="line">    FileInputStream fis = new FileInputStream(filename);</div><div class="line">    byte[] bytes = new byte[20 * 1024];</div><div class="line">    </div><div class="line">    int b=0;</div><div class="line">    int j = 0;</div><div class="line">    while((b = fis.read(bytes,0,bytes.length)) != -1)&#123;</div><div class="line">        for(int i =0;i&lt;bytes.length;i++)&#123;</div><div class="line">            System.out.print(Integer.toHexString(bytes[i] &amp; 0xff)+&quot; &quot;);</div><div class="line">            j++;</div><div class="line">            if(j%10 == 0)&#123;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h2 id="对象的序列化和反序列化"><a href="#对象的序列化和反序列化" class="headerlink" title="对象的序列化和反序列化"></a>对象的序列化和反序列化</h2><ul>
<li><a href="https://www.cnblogs.com/malecrab/p/5300486.html" target="_blank" rel="external">ANSI是什么编码？</a></li>
<li><a href="https://www.jianshu.com/p/c23f3ea5443d" target="_blank" rel="external">字符编码Unicode、UTF-8和ANSI</a></li>
<li><a href="https://www.guokr.com/blog/763017/" target="_blank" rel="external">遇到乱码不怕不怕啦——计算机字符编码详尽讲解</a></li>
<li><a href="https://www.cnblogs.com/skywang12345/p/io_26.html" target="_blank" rel="external">java io系列26之 RandomAccessFile</a></li>
<li><a href="https://blog.csdn.net/akon_vm/article/details/7429245" target="_blank" rel="external">Java RandomAccessFile用法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件编码&quot;&gt;&lt;a href=&quot;#文件编码&quot; class=&quot;headerlink&quot; title=&quot;文件编码&quot;&gt;&lt;/a&gt;文件编码&lt;/h2&gt;&lt;p&gt;如果直接复制文本内容会自动转换编码&lt;br&gt;ANSI并不是某一种特定的字符编码，而是在不同的系统中，ANSI表示不同的编码。比如在中文系统中使用gbk&lt;/p&gt;
&lt;p&gt;当你的字节序列是某种编码时，这个时候想把字节序列变成字符串，也需要用这种编码方式，否则会出现乱码&lt;br&gt;文本文件本身可以是任意编码的字节序列，但在utf-8下创建的文本文件只能识别为utf-8的编码，复制文件到其他编码环境下会识别为乱码，复制文本内容会自动转换&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;.java&lt;/code&gt;文件中指定的各种编码格式，无论指定成哪种格式，最后在编译成&lt;code&gt;.class&lt;/code&gt;时统统经过了 unicode 编码转换成双字节&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="http://yoursite.com/post/c2ca7a91.html"/>
    <id>http://yoursite.com/post/c2ca7a91.html</id>
    <published>2018-07-08T04:30:31.000Z</published>
    <updated>2018-07-11T07:17:17.995Z</updated>
    
    <content type="html"><![CDATA[<p>利用Java多线程可以简化模型，编写强大的代码，但也可能会因为考虑不周而面临bug</p>
<p>进程是程序的执行过程，持有资源（共享内存，共享文件）和线程，是线程的载体<br>线程是系统中最小的执行单元，同一进程中有多个线程，线程共享进程的资源</p>
<p>线程的交互分为互斥和同步</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用Java多线程可以简化模型，编写强大的代码，但也可能会因为考虑不周而面临bug&lt;/p&gt;
&lt;p&gt;进程是程序的执行过程，持有资源（共享内存，共享文件）和线程，是线程的载体&lt;br&gt;线程是系统中最小的执行单元，同一进程中有多个线程，线程共享进程的资源&lt;/p&gt;
&lt;p&gt;线程的交互分为互斥和同步&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://yoursite.com/post/adc18de0.html"/>
    <id>http://yoursite.com/post/adc18de0.html</id>
    <published>2018-07-07T02:22:31.000Z</published>
    <updated>2018-07-11T07:11:34.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class类的使用"><a href="#Class类的使用" class="headerlink" title="Class类的使用"></a>Class类的使用</h2><p>除了基本的数据类型、静态成员不是对象，万事万物皆对象，而基本的数据类型可封装为包装类。<br>类是java.lang.Class类的实例对象，任何一个类都是Class的实例对象。</p>
<p>类的实例化表示方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Food food = new Food();</div><div class="line">//第一种</div><div class="line">Class c1 = food.getClass();</div><div class="line">//第二种，任何一个都有一个隐含的静态成员class</div><div class="line">Class c2 = Food.class;</div><div class="line"></div><div class="line">//第三种</div><div class="line">Class c3 = null;</div><div class="line">try &#123;</div><div class="line">    c3 = Class.forName(&quot;com.Reflectest.Food&quot;);</div><div class="line">    //需要加上类的包名</div><div class="line">&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line">//c1、c2、c3表示Food类的类类型（class type）</div><div class="line">//一个类只可能是Class类的一个实例对象</div><div class="line">System.out.println(c1 == c2);//true</div><div class="line">System.out.println(c2 == c3);//true</div></pre></td></tr></table></figure></p>
<p>c1、c2、c3表示Food类的<strong>类类型</strong>（class type）<br>一个类只可能是Class类的一个实例对象</p>
<p>通过类类型实例化对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Food food1 = (Food) c1.newInstance();</div><div class="line">//注意异常</div><div class="line">//返回值为Object类型，需要转换</div></pre></td></tr></table></figure></p>
<p>基本数据类型、包装类、void关键字等都存在类类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Class cl1 = int.class;</div><div class="line">Class cl2 = String.class;</div><div class="line">Class cl3 = void.class;</div><div class="line">Class cl4 = Double.class;</div><div class="line">Class cl5 = double.class;//cl4和cl5不一样</div><div class="line"></div><div class="line">System.out.println(cl1.getName()); //int</div><div class="line">System.out.println(cl2.getName()); //java.lang.String</div><div class="line">System.out.println(cl3.getName()); //void</div><div class="line">System.out.println(cl4.getName()); //java.lang.Double</div><div class="line">System.out.println(cl5.getName()); //double</div></pre></td></tr></table></figure></p>
<h2 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h2><p>编译时刻加载类是静态加载类，运行时刻加载类是动态加载类</p>
<ul>
<li>new创建对象：是静态加载类，在编译时刻就需要加载所有的可能使用到的类。有一个类有问题（如不存在），都不能通过编译，会报错。</li>
<li><code>Class.forName(&quot;类的全称&quot;);</code>不仅代表了类的类型，还代表了动态加载类。<code>Class.forName()</code>通过动态加载类，用到一个类时，才进行加载。动态加载类，编译时不会出错，只有运行时可能出错 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 静态加载类</div><div class="line"> * 如果Word类和Excel类不存在，则编译的时候会报错，IDE直接报错</div><div class="line"> */</div><div class="line">public class Office&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Word word = new Word();</div><div class="line">        word.start();</div><div class="line"></div><div class="line">        Excel excel = new Excel();</div><div class="line">        excel.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 动态加载类</div><div class="line"> * 编译时不会抛出异常</div><div class="line"> */</div><div class="line">public class OfficeBetter&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            Class cl = Class.forName(args[0]);</div><div class="line">            Excel e = (Excel)cl.newInstance();</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>功能性的类尽量使用动态加载，并对新添的类实现功能性接口（标准），这样就不用重新编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public interface OfficeAble &#123;</div><div class="line">    public void start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Word implements OfficeAble &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;Word&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Excel implements OfficeAble &#123;</div><div class="line">    @Override</div><div class="line">    public void start() &#123;</div><div class="line">        System.out.println(&quot;Excel&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OfficeBetter&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            Class cl = Class.forName(args[0]);</div><div class="line">            OfficeAble oa = (OfficeAble) cl.newInstance();</div><div class="line">            oa.start();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h2><p>通过反射可以获取类的方法、属性、构造函数、包等信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">public class MethodClass &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        MethodClass.printClassMethodMessage(animal);</div><div class="line">        MethodClass.printClassFieldMessage(animal);</div><div class="line">        MethodClass.printClassConstructorMessage(animal);</div><div class="line"></div><div class="line">        Integer i = 1;</div><div class="line">        MethodClass.printClassMethodMessage(i);</div><div class="line">        MethodClass.printClassFieldMessage(i);</div><div class="line">        MethodClass.printClassConstructorMessage(i);</div><div class="line"></div><div class="line">        String s = &quot;Hello&quot;;</div><div class="line">        MethodClass.printClassMethodMessage(s);</div><div class="line">        MethodClass.printClassFieldMessage(s);</div><div class="line">        MethodClass.printClassConstructorMessage(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取类的方法信息</div><div class="line">     * 通过反射获取类的方法名称、返回值类型、参数列表</div><div class="line">     * 所有方法都是java.lang.reflect.Method类的对象</div><div class="line">     * 一个成员方法就是一个Method对象</div><div class="line">     */</div><div class="line">    public static void printClassMethodMessage(Object obj)&#123;</div><div class="line">        //获取obj对象的类类型</div><div class="line">        Class cl = obj.getClass();</div><div class="line">        //获取类的名称，包含包名</div><div class="line">        System.out.println(&quot;类的名称，包含包名:\t&quot;+cl.getName());</div><div class="line">        //获取类的名称，不包含包名</div><div class="line">        System.out.println(&quot;类的名称，不包含包名:\t&quot;+cl.getSimpleName());</div><div class="line"></div><div class="line">        //获取所有public的方法，包括继承来的</div><div class="line">        Method[] ms = cl.getMethods();</div><div class="line">        //获取该类所有自己声明的方法，不论访问权限</div><div class="line">        Method[] ms1 = cl.getDeclaredMethods();</div><div class="line"></div><div class="line">        System.out.println(&quot;Method类的方法:&quot;);</div><div class="line">        for (Method m:ms1) &#123;</div><div class="line">            //获取方法的返回值类型的类类型（int.clss\String.class，而不是int\String）</div><div class="line">            Class returnType = m.getReturnType();</div><div class="line">            System.out.print(returnType.getSimpleName()+&quot;\t&quot;);</div><div class="line">            //获取方法的名称</div><div class="line">            System.out.print(m.getName()+&quot;\t&quot;);</div><div class="line">            //获取参数类型（和返回值一样，得到的都是类类型）</div><div class="line">            Class[] paramTypes = m.getParameterTypes();</div><div class="line">            for(Class c:paramTypes)&#123;</div><div class="line">                System.out.print(c.getSimpleName()+&quot;,&quot;);</div><div class="line">            &#125;</div><div class="line">        System.out.println();</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取类的成员变量信息</div><div class="line">     * 通过反射获取类的属性名称、属性类型</div><div class="line">     * 成员变量是java.lang.reflect.Field的对象</div><div class="line">     */</div><div class="line">    public static void printClassFieldMessage(Object obj)&#123;</div><div class="line">        Class cl = obj.getClass();</div><div class="line">        //获取所有public的成员变量信息，包括继承</div><div class="line">        Field[] fields = cl.getFields();</div><div class="line">        //获取该类所有自己声明的成员变量信息，不论访问权限</div><div class="line">        Field[] fields1 = cl.getDeclaredFields();</div><div class="line"></div><div class="line">        for(Field field:fields)&#123;</div><div class="line">            //得到成员变量类型的类类型（int.clss\String.class）</div><div class="line">            Class fieldType = field.getType();</div><div class="line">            String typeName = fieldType.getName();</div><div class="line">            //得到成员变量的名称</div><div class="line">            String fieldName = field.getName();</div><div class="line">            System.out.println(typeName+&quot;\t&quot;+fieldName);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取类的构造方法信息</div><div class="line">     * 通过反射获取构造函数的名称、参数列表</div><div class="line">     * 构造函数是java.lang.Constructor类的对象</div><div class="line">     */</div><div class="line"></div><div class="line">    public static void printClassConstructorMessage(Object obj)&#123;</div><div class="line">        Class cl = obj.getClass();</div><div class="line">        //获得所有公有构造方法信息，包括继承</div><div class="line">        Constructor[] constructors = cl.getConstructors();</div><div class="line">        //获取自己声明的构造方法，不论访问权限</div><div class="line">        Constructor[] constructors1 = cl.getDeclaredConstructors();</div><div class="line"></div><div class="line">        for(Constructor constructor:constructors1)&#123;</div><div class="line">            //获取构造函数的名称</div><div class="line">            String constructorName = constructor.getName();</div><div class="line">            System.out.print(constructorName + &quot; &quot;);</div><div class="line">            //获取构造函数的参数</div><div class="line">            Class[] parameterTypes = constructor.getParameterTypes();</div><div class="line">            for(Class parameterType:parameterTypes)&#123;</div><div class="line">                System.out.print(parameterType.getSimpleName()+&quot;,&quot;);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法的反射"><a href="#方法的反射" class="headerlink" title="方法的反射"></a>方法的反射</h2><p>通过方法的反射调用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class ClassDemo5 &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        A a = new A();</div><div class="line">        Class cl = a.getClass();</div><div class="line">        try &#123;</div><div class="line">            //无参无返回值</div><div class="line">            //1. 获取方法，也可以使用getDeclaredMethod()</div><div class="line">            Method m1 = cl.getMethod(&quot;print&quot;);</div><div class="line">            //Method m1 = cl.getDeclaredMethod(&quot;print&quot;);</div><div class="line">            //2. 调用方法，method.invok(对象,参数列表); 以下两种方式效果一样</div><div class="line">            m1.invoke(a);</div><div class="line">            a.print();</div><div class="line"></div><div class="line">            //有参有返回值</div><div class="line">            //参数列表为可变参数，使用以下两种方式均可</div><div class="line">            Method m2 = cl.getMethod(&quot;add&quot;,new Class[]&#123;int.class,int.class&#125;);</div><div class="line">            //Method m1 = cl.getMethod(&quot;add&quot;,int.class,int.class);</div><div class="line"></div><div class="line">            //参数列表为可变参数，使用以下两种方式均可</div><div class="line">            //方法如果没有返回值则返回null，有返回值则返回具体的返回值，需要类型转换</div><div class="line">            int i = (int)m2.invoke(a,1,2);</div><div class="line">            //int i = (int)m2.invoke(a,new Object[]&#123;1,2&#125;);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">    public void print()&#123;</div><div class="line">        System.out.println(&quot;hello&quot;);</div><div class="line">    &#125;</div><div class="line">    public int add(int a,int b)&#123;</div><div class="line">        int c = a+b;</div><div class="line">        System.out.println(c);</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h2><p>Java中集合的泛型是防止错误输入的，只在编译阶段有效，如果绕开编译就无效了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ClassDemo6 &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        //list1可以添加任意类型，list2只能添加String类型</div><div class="line">        ArrayList list1 = new ArrayList();</div><div class="line">        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        //反射的操作过都是编译之后的操作</div><div class="line">        //c1 == c2 返回true说明编译之后集合的泛型是去泛型化的</div><div class="line">        Class c1 = list1.getClass();</div><div class="line">        Class c2 = list2.getClass();</div><div class="line">        System.out.println(c1 == c2); //true</div><div class="line"></div><div class="line">        //Java中集合的泛型是防止错误输入的，只在编译阶段有效，如果绕开编译就无效了</div><div class="line">        //验证：通过方法的反射绕过编译</div><div class="line">        Method m = null;</div><div class="line">        try &#123;</div><div class="line">            m = c2.getMethod(&quot;add&quot;,Object.class);</div><div class="line">            m.invoke(list2,100);</div><div class="line">            System.out.println(list2);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Class类的使用&quot;&gt;&lt;a href=&quot;#Class类的使用&quot; class=&quot;headerlink&quot; title=&quot;Class类的使用&quot;&gt;&lt;/a&gt;Class类的使用&lt;/h2&gt;&lt;p&gt;除了基本的数据类型、静态成员不是对象，万事万物皆对象，而基本的数据类型可封装为包装类
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2018-07-06-Java与二进制</title>
    <link href="http://yoursite.com/post/6e78d28e.html"/>
    <id>http://yoursite.com/post/6e78d28e.html</id>
    <published>2018-07-06T15:06:48.000Z</published>
    <updated>2018-07-11T07:11:34.939Z</updated>
    
    <content type="html"><![CDATA[<p>关于二进制参考<a href="https://fengrenxiaoli.github.io/post/2feeae2.html" target="_blank" rel="external">【Linux】Linux 计算机基础</a></p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//十进制转为其他进制</div><div class="line">Integer.toBinaryString(112)</div><div class="line">//二进制</div><div class="line">Integer.toHexString(112)</div><div class="line">//十六进制</div><div class="line">Integer.toOctalString(112)</div><div class="line">//八进制</div><div class="line"></div><div class="line">//其他进制转为十进制</div><div class="line">Integer.parseInt(&quot;110101&quot;,2)</div><div class="line">Integer.parseInt(&quot;F6889&quot;,16)</div><div class="line">Integer.parseInt(&quot;76541&quot;,8)</div><div class="line">//其他进制转为十进制</div><div class="line">Integer.valueOf(&quot;110101&quot;,2)</div><div class="line">Integer.valueOf(&quot;F6889&quot;,16)</div><div class="line">Integer.valueOf(&quot;76541&quot;,8)</div></pre></td></tr></table></figure>
<h2 id="Java数据类型和字节的转换"><a href="#Java数据类型和字节的转换" class="headerlink" title="Java数据类型和字节的转换"></a>Java数据类型和字节的转换</h2><p>在平时的Java开发中，进制转换和位操作用的不多，但是在跨平台中用的较多，比如文件读写、数据通信</p>
<p>如果Java客户端和Java服务器通信，可以使用序列和反序列<code>serializable</code>，而如果Java客户端和C服务器通信则需要转换为字节</p>
<p>Java的基本数据类型包括：</p>
<ol>
<li>int数据类型：byte(8bit,-128~127)、short(16bit)、int(32bit)、long(64bit)</li>
<li>float数据类型：单精度(32bit,float)、双精度(64bit,double)</li>
<li>boolean数据类型(true、false)</li>
<li>char数据类型：unicode字符 16位</li>
</ol>
<h3 id="基本数据类型和字节的转换"><a href="#基本数据类型和字节的转换" class="headerlink" title="基本数据类型和字节的转换"></a>基本数据类型和字节的转换</h3><p><img src="/img/IMG168.png" alt=""></p>
<p>小端法(LIttle-Endian)：低位字节排放在内存的低地址端即该值的起始地址，高位字节排放在内存的高地址端<br>大端法(Big-Endian)：高位字节排放在内存的底地址端即该值的起始地址，低位字节排放在内存的高地址端</p>
<p><img src="/img/IMG169.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* int 转 字节数组</div><div class="line">* @param x</div><div class="line">* @return</div><div class="line">*/</div><div class="line">public static byte[] int2byte(int x)&#123;</div><div class="line">    byte[] bytes = new byte[4];</div><div class="line">    //int型长度为4个字节</div><div class="line">    for(int i = 0;i&lt;bytes.length;i++)&#123;</div><div class="line">        bytes[i] = (byte)((x&gt;&gt;i*8) &amp; 0xff);</div><div class="line">    &#125;</div><div class="line">    return bytes;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* long 转 字节数组</div><div class="line">* @param x</div><div class="line">* @return</div><div class="line">*/</div><div class="line">public static byte[] long2byte(long x)&#123;</div><div class="line">    byte[] bytes = new byte[8];</div><div class="line">    //long型长度为8个字节</div><div class="line">    for(int i = 0;i&lt;bytes.length;i++)&#123;</div><div class="line">        bytes[i] = (byte)((x&gt;&gt;i*8) &amp; 0xff);</div><div class="line">    &#125;</div><div class="line">    return bytes;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 字节数组 转 int</div><div class="line">* @param bytes</div><div class="line">* @return</div><div class="line">*/</div><div class="line">public static int byte2int(byte[] bytes)&#123;</div><div class="line">    int result = 0;</div><div class="line">    for(int i=0;i&lt;bytes.length;i++)&#123;</div><div class="line">        result += (bytes[i] &amp; 0xff) &lt;&lt; i*8;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串和字节的转换"><a href="#字符串和字节的转换" class="headerlink" title="字符串和字节的转换"></a>字符串和字节的转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//字符串转字节数组</div><div class="line">String s = &quot;hello&quot;;</div><div class="line">byte[] bs = s.getBytes();</div><div class="line"></div><div class="line">for(int i =0;i&lt;bs.length;i++)&#123;</div><div class="line">    System.out.println(bs[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//字节数组转字符串</div><div class="line">String ss = new String(bs);</div><div class="line">String sss = new String(bs,encode);//encode指编码方式，比如 gb2312 utf-8</div><div class="line">System.out.println(ss);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于二进制参考&lt;a href=&quot;https://fengrenxiaoli.github.io/post/2feeae2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【Linux】Linux 计算机基础&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;进制转换
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://yoursite.com/post/4509351.html"/>
    <id>http://yoursite.com/post/4509351.html</id>
    <published>2018-07-06T08:23:53.000Z</published>
    <updated>2018-07-10T08:00:39.263Z</updated>
    
    <content type="html"><![CDATA[<p>Java集合框架：Collection接口，Map接口，Collections工具类，Comparable接口，Comparator接口</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java中的集合类是一种工具类，用于存储任意数量的具有共同属性的对象</p>
<p>集合的作用：</p>
<ol>
<li>在类的内部，对数据进行组织</li>
<li>简单而快速的搜索大数量的条目</li>
<li>有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素</li>
<li>有的集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型</li>
</ol>
<p>集合和数组的区别：</p>
<ol>
<li>数组的长度固定，集合长度可变</li>
<li>数组只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象</li>
</ol>
<p><img src="/img/Java019.jpg" alt=""><br>Collection(接口)</p>
<ul>
<li>List(接口)（特点：有序，可重复）<ul>
<li>ArrayList（实现类）</li>
<li>LinkedList（实现类）</li>
</ul>
</li>
<li>Query(接口)（特点：有序，可重复）<ul>
<li>LinkedList（实现类）</li>
</ul>
</li>
<li>Set(接口)（特点：无序，不可重复）<ul>
<li>HashSet（实现类）<br>Map(接口)（特点：Entry(Key,Value) – 键值对：)注：Entry是Map的内部类</li>
</ul>
</li>
<li>HashMap（实现类）</li>
</ul>
<p>Collection接口是List、Set和Queue接口的父接口，定义了可用于操作List、Set和Queue的方法————增删改查</p>
<a id="more"></a>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List是元素有序并且可以重复的集合，被称为序列<br>List可以精确的控制每个元素的插入位置，或删除某个位置元素</p>
<p>ArrayList(数组列表)是List的一个重要实现类，底层是由数组实现的</p>
<p>list.add(对象)把一个对象添加到另一个集合的队尾位置<br>list.add(index, 对象) 把一个集合添加到另一个集合的指定位置<br>list.addAll(集合对象) 把一个集合添加到另一个集合的队尾位置<br>list.addAll(index, 集合对象) 把一个集合添加到另一个集合的指定位置<br>Arrays.asList(数组) 把一个数组转换成List集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line">public class Course &#123;</div><div class="line">    public String id;</div><div class="line">    public String name;</div><div class="line"></div><div class="line">    public Course()&#123;&#125;</div><div class="line"></div><div class="line">    public Course(String id, String name) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Course&#123;&quot; +</div><div class="line">                &quot;id=&apos;&quot; + id + &apos;\&apos;&apos; +</div><div class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        if (this == o) return true;</div><div class="line">        if (o == null || getClass() != o.getClass()) return false;</div><div class="line">        Course course = (Course) o;</div><div class="line">        return Objects.equals(name, course.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 模拟学生选课功能</div><div class="line"> * 1. 添加课程</div><div class="line"> * 2. 删除课程</div><div class="line"> * 3. 查看所选课程</div><div class="line"> * 4. 修改所选选课程</div><div class="line"> */</div><div class="line">public class ListTest &#123;</div><div class="line">    public List coursesList;</div><div class="line"></div><div class="line">    public ListTest()&#123;</div><div class="line">        this.coursesList = new ArrayList();</div><div class="line">        //List是接口，所以在构造方法中不能直接实例化，而通过ArrayList()实例化</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加课程</div><div class="line">     */</div><div class="line">    public void courseAdd()&#123;</div><div class="line">        Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);</div><div class="line">        Course course2 = new Course(&quot;2&quot;,&quot;离散数学&quot;);</div><div class="line">        Course course3 = new Course(&quot;3&quot;,&quot;高等数学&quot;);</div><div class="line">        Course course4 = new Course(&quot;4&quot;,&quot;计算机组成原理&quot;);</div><div class="line">        Course course5 = new Course(&quot;5&quot;,&quot;计算机网络&quot;);</div><div class="line">        Course course6 = new Course(&quot;6&quot;,&quot;大学英语&quot;);</div><div class="line"></div><div class="line">        coursesList.add(course1);</div><div class="line">        coursesList.add(course1);</div><div class="line">        //支持重复数据</div><div class="line">        //coursesList.add(2,course2);</div><div class="line">        //会报异常IndexOutOfBoundsException: Index: 2, Size: 1</div><div class="line">        coursesList.add(1,course2);</div><div class="line">        Course[] courses1 = &#123;course3,course4&#125;;</div><div class="line">        coursesList.addAll(Arrays.asList(courses1));</div><div class="line">        Course[] courses2 = &#123;course5,course6&#125;;</div><div class="line">        coursesList.addAll(2,Arrays.asList(courses2));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 遍历课程</div><div class="line">     */</div><div class="line">    public void coursesGetAll()&#123;</div><div class="line">        for(int i = 0;i&lt;coursesList.size();i++)&#123;</div><div class="line">            Course course = (Course) coursesList.get(i);</div><div class="line">            //get()方法获得的对象是Object类型，需要转换</div><div class="line">            System.out.println(course);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;-----------------&quot;);</div><div class="line"></div><div class="line">        //foreach遍历方法</div><div class="line">        for(Object object : coursesList)&#123;</div><div class="line">            System.out.println((Course)object);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;-----------------&quot;);</div><div class="line"></div><div class="line">        //迭代器遍历</div><div class="line">        Iterator iterator = coursesList.iterator();</div><div class="line">        while(iterator.hasNext())&#123;</div><div class="line">            System.out.println((Course)iterator.next());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(&quot;-----------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 修改课程</div><div class="line">     */</div><div class="line">    public void courseSet()&#123;</div><div class="line">        Course course = new Course(&quot;7&quot;,&quot;Java web&quot;);</div><div class="line">        coursesList.set(0,course);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除课程</div><div class="line">     */</div><div class="line">    public void courseRemove()&#123;</div><div class="line">        coursesList.remove(coursesList.get(1));</div><div class="line">        coursesList.remove(2);</div><div class="line">        Course[] courses = &#123;(Course) coursesList.get(3),(Course) coursesList.get(4)&#125;;</div><div class="line">        coursesList.removeAll(Arrays.asList(courses));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 索引课程位置</div><div class="line">     * indexOf()方法返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</div><div class="line">     */</div><div class="line"></div><div class="line">    public int courseIndex(Course course)&#123;</div><div class="line">        return coursesList.indexOf(course);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断课程是否存在</div><div class="line">     */</div><div class="line">    public boolean courseContain(Course course)&#123;</div><div class="line">        /**</div><div class="line">         * ArrayList中contains() 如果此列表中包含指定的元素，则返回 true。</div><div class="line">         * 更确切地讲，当且仅当此列表包含至少一个满足 (o==null ? e==null : o.equals(e)) 的元素 e 时，则返回 true。</div><div class="line">         * 因此比较的是o.equals(e)，这是比较两个对象内在地址是否相同</div><div class="line">         * 这里只需要比较课程的名称是否相同，重写Course类的equals方法</div><div class="line">         */</div><div class="line">        return this.coursesList.contains(course);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        ListTest listTest = new ListTest();</div><div class="line">        listTest.courseAdd();</div><div class="line">        listTest.coursesGetAll();</div><div class="line">//        listTest.courseRemove();</div><div class="line">//        listTest.coursesGetAll();</div><div class="line">        listTest.courseSet();</div><div class="line">        listTest.coursesGetAll();</div><div class="line"></div><div class="line">        Course course = (Course)listTest.coursesList.get(0);</div><div class="line">        System.out.println(listTest.courseContain(course));</div><div class="line">        Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);</div><div class="line">        //重写Course类的equal方法前为false，重写后为true</div><div class="line">        System.out.println(listTest.courseContain(course1));</div><div class="line"></div><div class="line">        System.out.println(listTest.courseIndex(course1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>集合中的元素可以是任意类型的对象，如果把某个对象放入集合，则会忽略它的类型，而把它当做Object对象处理。泛型则规定了某个集合只可以存放特定类型的对象，会在<strong>编译期间</strong>进行类型检查<br>比如上例中的List未规定泛型，则coursesList除了可以添加Course对象外，还可以添加String类型等其他类型，而且在取出其中的元素时，需要进行类型转换</p>
<p>用泛型改进上例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class ListGenericTest &#123;</div><div class="line">    public List&lt;Course&gt; courseList;</div><div class="line">    public ListGenericTest()&#123;</div><div class="line">        this.courseList = new ArrayList&lt;Course&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void courseAdd()&#123;</div><div class="line">        Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);</div><div class="line">        Course course2 = new Course(&quot;2&quot;,&quot;离散数学&quot;);</div><div class="line">        Course course3 = new Course(&quot;3&quot;,&quot;高等数学&quot;);</div><div class="line">        Course course4 = new Course(&quot;4&quot;,&quot;计算机组成原理&quot;);</div><div class="line">        Course course5 = new Course(&quot;5&quot;,&quot;计算机网络&quot;);</div><div class="line">        Course course6 = new Course(&quot;6&quot;,&quot;大学英语&quot;);</div><div class="line"></div><div class="line">        courseList.add(course1);</div><div class="line">        courseList.add(course1);</div><div class="line">        courseList.add(1,course2);</div><div class="line">        Course[] courses1 = &#123;course3,course4&#125;;</div><div class="line">        courseList.addAll(Arrays.asList(courses1));</div><div class="line">        Course[] courses2 = &#123;course5,course6&#125;;</div><div class="line">        courseList.addAll(2,Arrays.asList(courses2));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void coursesGetAll()&#123;</div><div class="line">        for(Course course:courseList)&#123;</div><div class="line">            System.out.println(course);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;-----------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 修改课程</div><div class="line">     */</div><div class="line">    public void courseSet()&#123;</div><div class="line">        Course course = new Course(&quot;7&quot;,&quot;Java web&quot;);</div><div class="line">        courseList.set(0,course);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void courseRemove()&#123;</div><div class="line">        courseList.remove(courseList.get(1));</div><div class="line">        courseList.remove(2);</div><div class="line">        Course[] courses = &#123;courseList.get(3),courseList.get(4)&#125;;</div><div class="line">        courseList.removeAll(Arrays.asList(courses));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        ListGenericTest listTest = new ListGenericTest();</div><div class="line">        listTest.courseAdd();</div><div class="line">        listTest.coursesGetAll();</div><div class="line">        listTest.courseRemove();</div><div class="line">        listTest.coursesGetAll();</div><div class="line">        listTest.courseSet();</div><div class="line">        listTest.coursesGetAll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>泛型不还可以接受泛型类的子类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ChildCourse extends Course &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void childCourseAdd()&#123;</div><div class="line">	ChildCourse childCourse = new ChildCourse();</div><div class="line">	courseList.add(childCourse);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>泛型集合中的限定类型不能使用基本数据类型，可以通过包装类使用基本数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; lists = new ArrayList&lt;&gt;();</div></pre></td></tr></table></figure></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是元素无序并且不可以重复的集合，被称为集</p>
<p>HashSet(哈希集)是Set的一个重要实现类。</p>
<ol>
<li>Set没有像List中set()方法一样就修改，因为List是有序的，可以指定位置，而Set是无序的。</li>
<li>查询遍历时，Set不能用get()方法去获取，因为无序没有指定索引ID，但可以使用foreach和iterator来遍历，但是每次遍历出来可能顺序都不一样，还是因为无序造成的。</li>
<li>Set中的size(),add(),addAll(),remove(),removeAll()与List类似。</li>
<li>Set还可以添加null，<code>new HashSet&lt;&gt;().add(null);</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">    public String id;</div><div class="line">    public String name;</div><div class="line">    public Set&lt;Course&gt; courses;</div><div class="line"></div><div class="line">    public Student(String id, String name) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.name = name;</div><div class="line">        this.courses = new HashSet&lt;&gt;();//初始化集合</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SetTest2 &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Student student = new Student(&quot;1&quot;,&quot;小明&quot;);</div><div class="line">        Course course1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);</div><div class="line">        Course course2 = new Course(&quot;2&quot;,&quot;离散数学&quot;);</div><div class="line">        Course course3 = new Course(&quot;3&quot;,&quot;高等数学&quot;);</div><div class="line"></div><div class="line">        //增加课程</div><div class="line">        student.courses.add(course1);</div><div class="line">        List&lt;Course&gt; courseList = new ArrayList&lt;&gt;();</div><div class="line">        courseList.add(course2);</div><div class="line">        courseList.add(course3);</div><div class="line">        student.courses.addAll(courseList);</div><div class="line"></div><div class="line">        //遍历课程</div><div class="line">        //不能使用get方法遍历，因为Set是无序的</div><div class="line">        for(Course course:student.courses)&#123;</div><div class="line">            System.out.println(course);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //移除课程</div><div class="line">        student.courses.remove(course3);</div><div class="line">        for(Course course:student.courses)&#123;</div><div class="line">            System.out.println(course);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //判断Set中是否包含课程</div><div class="line">        //使用contains方法</div><div class="line">        System.out.println(student.courses.contains(course1));//true</div><div class="line">        Course  course4 = new Course(&quot;1&quot;,&quot;数据结构&quot;);</div><div class="line">        //返回false，HashSet类的contain方法，需要比较hashcode方法和equals方法</div><div class="line">        //重写hashcode方法和equals方法后，才为true</div><div class="line">        System.out.println(student.courses.contains(course4));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li>Map接口提供了一种映射关系，其中的元素是键值对（key-value）的形式存储的，能够实现根据Key快速查找value。Key-value可以是任何对象，是以Entry类型的对象实例存在的。<br>2.Key是不可以重复的，Value是可以重复的。Key-value都可以为null，不过只能有一个key是null。<br>3.map支持泛型，Map<k,v><br>4.每个键最多只能映射到一个值<br>5.Map接口提供了分别返回key值集合（keySet()）、value值集合（values()）以及Entry（键值对）集合（entrySet() ）的方法</k,v></li>
</ol>
<p>HashMap是Map的一个实现类，基于哈希表实现，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。  </p>
<ul>
<li>Key值和value值都可以为null，但是一个HashMap只能有一个key值为null的映射（key值不可重复）</li>
<li>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。  </li>
<li>如果需要同步，可以用Collections.synchronizedMap(HashMap map)方法使HashMap具有同步的能力。  </li>
<li>Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；</li>
<li>HashMap中的Entry对象是无序排列的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 通过Map&lt;String,Student&gt;进行学生信息管理，其中key为学生ID，value为学生对象</div><div class="line"> * 对集合中的学生信息进行增、删、改、查操作</div><div class="line"> */</div><div class="line"></div><div class="line">public class MapTest &#123;</div><div class="line">    public Map&lt;String,Student&gt; studentMap;</div><div class="line">    public MapTest()&#123;</div><div class="line">        this.studentMap = new HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 增加学生信息</div><div class="line">     * @param student</div><div class="line">     */</div><div class="line">    public void studentAdd(Student student)&#123;</div><div class="line">        Student student1 = studentMap.get(student.id);</div><div class="line">        if(student1 != null)&#123;</div><div class="line">            System.out.println(&quot;学生id已存在&quot;);</div><div class="line">            return ;</div><div class="line">        &#125;</div><div class="line">        studentMap.put(student.id,student);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 查找学生信息</div><div class="line">     * @param id</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public Student studentGet(String id)&#123;</div><div class="line">        Student student = studentMap.get(id);</div><div class="line">        if(student != null)&#123;</div><div class="line">            return student;</div><div class="line">        &#125;else &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 遍历学生信息</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">//    public Map&lt;String,Student&gt; studentGetAll()&#123;</div><div class="line">//        return this.studentMap;</div><div class="line">//    &#125;</div><div class="line">    public void studentGetAll()&#123;</div><div class="line">        Set&lt;Map.Entry&lt;String,Student&gt;&gt; entrySet = studentMap.entrySet();</div><div class="line">        for(Map.Entry&lt;String,Student&gt; entry:entrySet)&#123;</div><div class="line">            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 修改学生信息</div><div class="line">     * @param student</div><div class="line">     */</div><div class="line">    public void studentModify(Student student)&#123;</div><div class="line">        Student student1 = this.studentGet(student.id);</div><div class="line">        if(student1 == null)&#123;</div><div class="line">            System.out.println(&quot;学生id不存在&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        studentMap.put(student.id,student);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 测试Map中是否包含某个key或者value值</div><div class="line">     * 在Map中，用containsKey方法，来判断是否包含某个key值</div><div class="line">     * 在Map中，用containsValue方法，来判断是否包含某个Value值，需要重写equals方法和hashCode方法</div><div class="line">     * @param id</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public void studentContainsById(String id)&#123;</div><div class="line">        if(studentMap.containsKey(id))&#123;</div><div class="line">            System.out.println(&quot;该学生存在&quot;);</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(&quot;该学生不存在&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //注意，Map的值为Student类</div><div class="line">    public void studentContainsByName(String name)&#123;</div><div class="line">        if(studentMap.containsValue(new Student(null,name)))&#123;</div><div class="line">            System.out.println(&quot;该学生存在&quot;);</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(&quot;该学生不存在&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除学生信息</div><div class="line">     * @param id</div><div class="line">     */</div><div class="line">    public void studentDelete(String id)&#123;</div><div class="line">        Student student1 = this.studentGet(id);</div><div class="line">        if(student1 == null)&#123;</div><div class="line">            System.out.println(&quot;学生id不存在&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        studentMap.remove(id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        MapTest mapTest = new MapTest();</div><div class="line">        mapTest.studentAdd(new Student(&quot;1&quot;,&quot;John&quot;));</div><div class="line">        mapTest.studentAdd(new Student(&quot;2&quot;,&quot;John&quot;));</div><div class="line">        mapTest.studentAdd(new Student(&quot;3&quot;,&quot;Mei&quot;));</div><div class="line">        mapTest.studentGetAll();</div><div class="line"></div><div class="line">        System.out.println(mapTest.studentGet(&quot;3&quot;));</div><div class="line">        System.out.println(mapTest.studentGet(&quot;5&quot;));</div><div class="line"></div><div class="line">        Student student = new Student(&quot;2&quot;,&quot;Halen&quot;);</div><div class="line">        mapTest.studentModify(student);</div><div class="line">        Student student1 = new Student(&quot;5&quot;,&quot;Halen&quot;);</div><div class="line">        mapTest.studentModify(student1);</div><div class="line">        mapTest.studentGetAll();</div><div class="line"></div><div class="line">        mapTest.studentDelete(&quot;1&quot;);</div><div class="line">        mapTest.studentGetAll();</div><div class="line">        mapTest.studentDelete(&quot;4&quot;);</div><div class="line"></div><div class="line">        System.out.println();</div><div class="line">        mapTest.studentGetAll();</div><div class="line">        mapTest.studentContainsById(&quot;1&quot;);</div><div class="line">        mapTest.studentContainsById(&quot;2&quot;);</div><div class="line">        mapTest.studentContainsByName(&quot;Mei&quot;);</div><div class="line">        mapTest.studentContainsByName(&quot;Halen&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h2><p><code>contains</code>方法用于判断集合中是否包含某个值</p>
<p>不论是List中的 <code>contains</code> 方法，Set中的 <code>contains</code> 方法，以及Map中的 <code>containsKey</code> 和<code>containsValue</code> ，都是遍历寻找第一个匹配的项，因为使用的是<code>equals</code> 方法，所以比较的是对象的引用是否相同，即是否是同一个对象，需要重写类的<code>equals</code> 方法，另外Set的<code>contains</code> 方法和Map中的 <code>containsValue</code> 需要重写 <code>hashCode</code> 方法</p>
<h2 id="Conllections工具类"><a href="#Conllections工具类" class="headerlink" title="Conllections工具类"></a>Conllections工具类</h2><p>java.util.Collections工具类是Java集合框架中用来操作集合对象的工具类</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>根据元素的自然顺序对指定列表按升序进行排序。列表中的所有元素都必须实现 <code>Comparable</code> 接口。</p>
<p>两个接口都可以使用泛型</p>
<h4 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h4><p>定义了默认的比较规则<br>实现该接口表示：这个类的实例可以比较大小，可以进行自然排序</p>
<p>实现 <code>Comparable</code> 接口必须实现 <code>compareTo</code> 方法，该方法比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p>
<h4 id="Comparator接口—–比较工具接口"><a href="#Comparator接口—–比较工具接口" class="headerlink" title="Comparator接口—–比较工具接口"></a>Comparator接口—–比较工具接口</h4><p>定义了临时的比较规则</p>
<p>其实现类需要实现 <code>compare()</code>方法，该方法比较用来排序的两个参数。根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div></pre></td><td class="code"><pre><div class="line">public class Student implements Comparable&lt;Student&gt;&#123;</div><div class="line">    public String id;</div><div class="line">    public String name;</div><div class="line">    public Set&lt;Course&gt; courses;</div><div class="line"></div><div class="line">    public Student(String id, String name) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.name = name;</div><div class="line">        this.courses = new HashSet&lt;&gt;();//初始化集合</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Student&#123;&quot; +</div><div class="line">                &quot;id=&apos;&quot; + id + &apos;\&apos;&apos; +</div><div class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(Student o) &#123;</div><div class="line">        return this.id.compareTo(o.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class StudentComparator implements Comparator&lt;Student&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(Student o1, Student o2) &#123;</div><div class="line">        return o1.name.compareTo(o2.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CollectionsTest &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 通过Collections.sort()方法对Integer泛型的List进行排序</div><div class="line">     */</div><div class="line">    public static void IntegerSort()&#123;</div><div class="line">        List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();</div><div class="line">        for(int i=0; i&lt;10;i++)&#123;</div><div class="line">            integerList.add((int)(Math.random()*100));</div><div class="line">        &#125;</div><div class="line">        for(Integer i :integerList)&#123;</div><div class="line">            System.out.print(i+&quot;\t&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">        Collections.sort(integerList);</div><div class="line">        for(Integer i :integerList)&#123;</div><div class="line">            System.out.print(i+&quot;\t&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 对String泛型的List进行排序</div><div class="line">     * 字符串的排列顺序为 1.0-9  2.A-Z  3.a-z</div><div class="line">     */</div><div class="line">    public static void StringSort()&#123;</div><div class="line">        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();</div><div class="line">        for(int i=0;i&lt;5;i++)&#123;</div><div class="line">            stringList.add(randomString1(10));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for(String s :stringList)&#123;</div><div class="line">            System.out.print(s+&quot;\t&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">        Collections.sort(stringList);</div><div class="line">        for(String s :stringList)&#123;</div><div class="line">            System.out.print(s+&quot;\t&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 创建给定长度的随机字符串</div><div class="line">     * @param i</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String randomString(int i)&#123;</div><div class="line">        String s = &quot;&quot;;</div><div class="line">        short start = &apos;0&apos;;</div><div class="line">        short end = &apos;z&apos; + 1;</div><div class="line">        while (s.length() != i) &#123;</div><div class="line">            char c = (char) (Math.random() * (end - start) + start);</div><div class="line">            if (Character.isDigit(c) || Character.isLetter(c)) &#123;</div><div class="line">                s += c;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 创建给定长度以内的随机字符串</div><div class="line">     * 每条字符串的长度为i以内的随机整数</div><div class="line">     * 每条字符串的每个字符都为随机生成的字符，字符可以重复</div><div class="line">     * @param i</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String randomString1(int i)&#123;</div><div class="line">        String s = &quot;&quot;;</div><div class="line">        short start = &apos;0&apos;;</div><div class="line">        short end = &apos;z&apos; + 1;</div><div class="line">        //避免字符串长度为0</div><div class="line">        int x = (int)(Math.random()*(i-1)+1);</div><div class="line">        while (s.length() != x) &#123;</div><div class="line"></div><div class="line"></div><div class="line">            char c = (char) (Math.random() * (end - start) + start);</div><div class="line">            if (Character.isDigit(c) || Character.isLetter(c)) &#123;</div><div class="line">                s += c;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 实现Comparatable接口，根据字符串id比较</div><div class="line">     */</div><div class="line">    public static void StudentSort()&#123;</div><div class="line">        List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();</div><div class="line">        studentList.add(new Student(&quot;3&quot;,&quot;Halen&quot;));</div><div class="line">        studentList.add(new Student(&quot;2&quot;,&quot;John&quot;));</div><div class="line">        studentList.add(new Student(&quot;1&quot;,&quot;JJ&quot;));</div><div class="line"></div><div class="line">        for(Student s:studentList)&#123;</div><div class="line">            System.out.print(s);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println();</div><div class="line">        Collections.sort(studentList);</div><div class="line">        for(Student s:studentList)&#123;</div><div class="line">            System.out.print(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 实现Comparator接口，根据名字比较</div><div class="line">     */</div><div class="line">    public static void StudentSort2()&#123;</div><div class="line">        List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();</div><div class="line">        studentList.add(new Student(&quot;3&quot;,&quot;Halen&quot;));</div><div class="line">        studentList.add(new Student(&quot;2&quot;,&quot;John&quot;));</div><div class="line">        studentList.add(new Student(&quot;1&quot;,&quot;JJ&quot;));</div><div class="line"></div><div class="line">        for(Student s:studentList)&#123;</div><div class="line">            System.out.print(s);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println();</div><div class="line">        Collections.sort(studentList,new StudentComparator());</div><div class="line">        for(Student s:studentList)&#123;</div><div class="line">            System.out.print(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        CollectionsTest.IntegerSort();</div><div class="line">        System.out.println();</div><div class="line">        CollectionsTest.StringSort();</div><div class="line">        System.out.println();</div><div class="line">        CollectionsTest.StudentSort();</div><div class="line">        System.out.println();</div><div class="line">        CollectionsTest.StudentSort2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java集合框架：Collection接口，Map接口，Collections工具类，Comparable接口，Comparator接口&lt;/p&gt;
&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;Java中的集合类是一种工具类，用于存储任意数量的具有共同属性的对象&lt;/p&gt;
&lt;p&gt;集合的作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类的内部，对数据进行组织&lt;/li&gt;
&lt;li&gt;简单而快速的搜索大数量的条目&lt;/li&gt;
&lt;li&gt;有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素&lt;/li&gt;
&lt;li&gt;有的集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;集合和数组的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组的长度固定，集合长度可变&lt;/li&gt;
&lt;li&gt;数组只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/img/Java019.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Collection(接口)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List(接口)（特点：有序，可重复）&lt;ul&gt;
&lt;li&gt;ArrayList（实现类）&lt;/li&gt;
&lt;li&gt;LinkedList（实现类）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Query(接口)（特点：有序，可重复）&lt;ul&gt;
&lt;li&gt;LinkedList（实现类）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Set(接口)（特点：无序，不可重复）&lt;ul&gt;
&lt;li&gt;HashSet（实现类）&lt;br&gt;Map(接口)（特点：Entry(Key,Value) – 键值对：)注：Entry是Map的内部类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HashMap（实现类）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Collection接口是List、Set和Queue接口的父接口，定义了可用于操作List、Set和Queue的方法————增删改查&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件系统</title>
    <link href="http://yoursite.com/post/f525ac74.html"/>
    <id>http://yoursite.com/post/f525ac74.html</id>
    <published>2018-06-25T03:27:42.304Z</published>
    <updated>2018-06-02T08:46:30.603Z</updated>
    
    <content type="html"><![CDATA[<p>linux中一切皆文件。目录为目录文件。普通文件用来保存数据，目录文件用来保存文件<br>文件系统：<br>Windows里面是这样的：C:\Program files\office11\word\word.exe<br>Linux里面是这样的：/etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>文件有两类数据：<br>元数据：metadata  元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode…)等等。<br>数据：data  数据是指普通文件中的实际数据。</p>
<p>1、文件名严格区分字符大小写；file1, File1, FILE1是不同的文件；<br>2、文件名可使用除/以外的任意字符，不建议使用特殊字符；  /: 表示根目录，也用做路径分隔符；<br>3、文件名长度最长不能超过255个字符；<br>4、所以.开头的文件，均为隐藏文件；</p>
<p>LSB: Linux Standard Base Linux标准库</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux中一切皆文件。目录为目录文件。普通文件用来保存数据，目录文件用来保存文件&lt;br&gt;文件系统：&lt;br&gt;Windows里面是这样的：C:\Program files\office11\word\word.exe&lt;br&gt;Linux里面是这样的：/etc/sysconfig/network-scripts/ifcfg-eth0&lt;/p&gt;
&lt;p&gt;文件有两类数据：&lt;br&gt;元数据：metadata  元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode…)等等。&lt;br&gt;数据：data  数据是指普通文件中的实际数据。&lt;/p&gt;
&lt;p&gt;1、文件名严格区分字符大小写；file1, File1, FILE1是不同的文件；&lt;br&gt;2、文件名可使用除/以外的任意字符，不建议使用特殊字符；  /: 表示根目录，也用做路径分隔符；&lt;br&gt;3、文件名长度最长不能超过255个字符；&lt;br&gt;4、所以.开头的文件，均为隐藏文件；&lt;/p&gt;
&lt;p&gt;LSB: Linux Standard Base Linux标准库&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>How to use Github</title>
    <link href="http://yoursite.com/post/68d6df4b.html"/>
    <id>http://yoursite.com/post/68d6df4b.html</id>
    <published>2018-06-25T02:31:27.000Z</published>
    <updated>2018-06-25T12:22:33.754Z</updated>
    
    <content type="html"><![CDATA[<p>在写这篇文章的时候，Github已经被Microsoft收购，不过依然会使用Github，因为觉得对自己的影响不大。</p>
<p>最近重新学习Git发觉自己其实对Github了解甚少，star了不少，但是从来没有好好看过，我觉得<strong>学习一定要发挥自己的主动性</strong>，不能光收藏，还要尽可能提出issues、甚至代码，当前我最应该克服的是懒，破除嫌麻烦的这种思想，如果自己都懒，都嫌麻烦，如何去解决麻烦。</p>
<p>回到正题，Github是一个git版本库托管商，里面有各种开源项目。本篇文章尝试写清楚从Github的入门使用到参与开源项目的一般方法。</p>
<p>官网：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a><br><a id="more"></a></p>
<h2 id="账户的配置"><a href="#账户的配置" class="headerlink" title="账户的配置"></a>账户的配置</h2><p>如何注册账户就不介绍了</p>
<h3 id="SSH访问"><a href="#SSH访问" class="headerlink" title="SSH访问"></a>SSH访问</h3><p>配置SSH是为了能够在本地电脑上访问Github，识别出你推送的提交确实是你推送的，而不是别人冒充的</p>
<p>具体如何做，其实在<a href="https://fengrenxiaoli.github.io/post/a20da6f3.html" target="_blank" rel="external">【Hexo】使用Hexo搭建github博客</a>里面有过介绍，那篇文章是为了制作Github Pages，这里不再说明git的安装和配置，那么只有一行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_github</div></pre></td></tr></table></figure>
<p>该命令会在本地电脑（Linux）的<code>~/.ssh</code>下创建公钥和私钥，将公钥(<code>id_rsa_github.pub</code>)中的内容拷贝到github帐号<code>Settings</code>&gt;<code>SSH and GPG keys</code>中</p>
<p>此外还有头像的配置（Profile）、邮箱的配置（Emails）、两步验证（Security）等全部都在<code>Settings</code>里。</p>
<h2 id="创建项目仓库"><a href="#创建项目仓库" class="headerlink" title="创建项目仓库"></a>创建项目仓库</h2><p>创建项目仓库 首页 &gt; <code>New repository</code><br>如果勾选 <code>Initialize this repository with a README</code>，会创建一个<code>README.md</code>文件，</p>
<p>可以将本地已存在的项目上传到仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git remote add origin git@github.com:fengrenxiaoli/GitTest.git</div><div class="line">git add .</div><div class="line">git commit -m &quot;upload&quot;</div><div class="line">git push -u origin master</div><div class="line"># 第一次push需要-u参数，关联本地master和远程master，以后不用加-u</div></pre></td></tr></table></figure></p>
<p>也可以将Github上的项目复制到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:fengrenxiaoli/GitTest.git</div></pre></td></tr></table></figure></p>
<h2 id="Github协作流程"><a href="#Github协作流程" class="headerlink" title="Github协作流程"></a>Github协作流程</h2><ol>
<li>从 <code>master</code> 分支中创建一个新分支</li>
<li>创建，编辑，重命名，移动或删除文件</li>
<li>将这个分支推送到 GitHub 上</li>
<li>创建一个合并请求（Pull Request）</li>
<li>讨论，根据实际情况继续修改</li>
<li>项目的拥有者合并或关闭你的合并请求</li>
</ol>
<h3 id="给队友添加写权限"><a href="#给队友添加写权限" class="headerlink" title="给队友添加写权限"></a>给队友添加写权限</h3><p>到项目的 <code>Settings</code> 页面，点击 <code>collaborator</code> 选项，输入框中输入相应的用户名使用户具有写权限。</p>
<h3 id="Fork项目副本"><a href="#Fork项目副本" class="headerlink" title="Fork项目副本"></a>Fork项目副本</h3><p>对于大多数情况，参于开发者并不会被直接赋予写权限，开发者需要先Fork一份项目到自己的用户名下。</p>
<h3 id="创建一个新分支"><a href="#创建一个新分支" class="headerlink" title="创建一个新分支"></a>创建一个新分支</h3><p>开新分支一定要在刚刚更新过的 <code>master</code> 的基础上开。<br>分支的名字应该是描述性的（如<code>refactor-authentication</code>，<code>user-content-cache-key</code>，<code>make-retina-avatars</code>），越清楚越好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git pull</div><div class="line">git checkout -b &lt;branch-name&gt;</div><div class="line">vim &lt;file-name&gt;</div><div class="line">git add &lt;file-name&gt;</div><div class="line">git commit -m &quot;some commit&quot;</div><div class="line">git push origin &lt;branch-name&gt;</div></pre></td></tr></table></figure>
<h3 id="发起Pull-Request"><a href="#发起Pull-Request" class="headerlink" title="发起Pull Request"></a>发起Pull Request</h3><p>修改项目后，在Github上点击 <code>Compare &amp; pull request</code>，选择需要进行对比的分支，填写描述信息，需要图片可以直接拖进去，也可以点击<code>selecting them</code></p>
<p><code>Pull Request</code>会启动关于提交的讨论</p>
<p>如果需要新的改动，直接在分支上修改，然后同步即可在pull request页面看到</p>
<p><img src="/img/IMG145.png" alt=""><br><img src="/img/IMG146.png" alt=""></p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>拥有写权限的人可以点击 <code>Merge Pull Request</code><br>合并之后可以删除分支</p>
<h3 id="快速-Pull-Request"><a href="#快速-Pull-Request" class="headerlink" title="快速 Pull Request"></a>快速 Pull Request</h3><p>如果只是修改很小的一点，没有必要使用上述流程，直接在Github网页上点击编辑，然后选择<code>Create a new branch for this commit and start a pull request...</code></p>
<h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><p><a href="https://guides.github.com/features/issues/" target="_blank" rel="external">https://guides.github.com/features/issues/</a><br>Issue 中一般是放一些临时性的讨论(报Bug、提新需求等)，最终是要被关掉的。如果 Issue 里面有一些精华的内容，可以拷贝出来贴到 wiki 中，方便大家查阅。</p>
<p>打开项目页面，点击<code>issues</code>，点击<code>New issue</code><br>新建的issue会有一个编号，类似于<code># 1</code><br>issue支持MarkDown语法</p>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>使用三个反引号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\`\`\`js</div><div class="line">alert(&quot;hello worold&quot;)</div><div class="line">\`\`\`</div></pre></td></tr></table></figure>
<h3 id="快速引用"><a href="#快速引用" class="headerlink" title="快速引用"></a>快速引用</h3><p>MarkDown中使用<code>&gt;</code>作为引用<br>如果你想回答具体某个问题，可以用鼠标选中那段话，然后，敲 r 。这样这段话就自动出现在你的评论框中了。</p>
<h3 id="拉别人进来讨论"><a href="#拉别人进来讨论" class="headerlink" title="拉别人进来讨论"></a>拉别人进来讨论</h3><p>如果你在评论框中输入<code>@happypeter</code>那么不管我是不是你当然项目的参与者，我都会收到通知来进来参加讨论</p>
<h3 id="引用issue"><a href="#引用issue" class="headerlink" title="引用issue"></a>引用issue</h3><p>在评论框中输入<code>#</code>会提示相应的issue。<br>如果我在当前 Issue#10 的评论框中写 <code>#20</code> 就可以自动链接到 Issue#20 了。同时 Issue#20 那边也会显示出 Issue#10 。这种指向和关联的功能在实用中是非常重要的</p>
<h3 id="用版本留言关闭-Issue"><a href="#用版本留言关闭-Issue" class="headerlink" title="用版本留言关闭 Issue"></a>用版本留言关闭 Issue</h3><p>点击<code>Close issue</code>按钮可以关闭issue</p>
<h3 id="引用emoji"><a href="#引用emoji" class="headerlink" title="引用emoji"></a>引用emoji</h3><p>输入<code>:</code>,会提示输入emoji</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:dancer:</div></pre></td></tr></table></figure>
<h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p>
<p>Github Pages可以用于写博客，也可以用于制作项目网站，对应的网址是<code>http://username.github.io/repository</code></p>
<h2 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h2><p>用于发布版本<br>Github项目页，点击<code>release</code>&gt;<code>Draft a new release</code>，创建标签，填入字段</p>
<p>参考：</p>
<ul>
<li><a href="https://guides.github.com/introduction/flow/index.html" target="_blank" rel="external">Understanding the GitHub Flow</a></li>
<li><a href="http://gitbeijing.com/" target="_blank" rel="external">http://gitbeijing.com/</a></li>
<li><a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="external">Hello World</a></li>
<li><a href="https://www.jianshu.com/p/482b32716bbe" target="_blank" rel="external">Git 游戏通关流程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写这篇文章的时候，Github已经被Microsoft收购，不过依然会使用Github，因为觉得对自己的影响不大。&lt;/p&gt;
&lt;p&gt;最近重新学习Git发觉自己其实对Github了解甚少，star了不少，但是从来没有好好看过，我觉得&lt;strong&gt;学习一定要发挥自己的主动性&lt;/strong&gt;，不能光收藏，还要尽可能提出issues、甚至代码，当前我最应该克服的是懒，破除嫌麻烦的这种思想，如果自己都懒，都嫌麻烦，如何去解决麻烦。&lt;/p&gt;
&lt;p&gt;回到正题，Github是一个git版本库托管商，里面有各种开源项目。本篇文章尝试写清楚从Github的入门使用到参与开源项目的一般方法。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用方法</title>
    <link href="http://yoursite.com/post/ab888b92.html"/>
    <id>http://yoursite.com/post/ab888b92.html</id>
    <published>2018-06-24T01:29:39.000Z</published>
    <updated>2018-07-03T06:01:03.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p><strong>集中式版本控制系统</strong>（Centralized Version Control Systems,简称 CVCS）：have a single server that contains all the versioned files, and a number of clients that check out files from that central place.</p>
<p>集中式版本控制系统的缺点是中央服务器的单点故障。</p>
<p><strong>分布式版本控制系统</strong>（Distributed Version Control System,简称 DVCS）：clients don’t just check out the latest snapshot of the files; rather, they fully mirror the repository, including its full history.</p>
<p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p>集中式版本控制：CVS、SVN、ClearCase、VSS<br>分布式版本控制：Git、BitKeeper、Mercurial、Bazaar</p>
<p>git和其他版本控制工具存储数据的方式不同：</p>
<ul>
<li>其他版本控制工具存储一组文件以及基于这些文件随时间推移产生的差异</li>
<li>git存储更像快照，对当时的全部文件制作一个快照并保存这个快照的索引，如果没有修改则只保留一个指向之前存储文件的链接</li>
</ul>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息<br>SVN 中可以修改文件，但是无法向数据库提交修改</p>
<p>Git 中所有数据在存储前都计算<strong>校验和</strong>，然后以校验和来引用，<br>校验和由 40 个十六进制字符组成，通过SHA1计算得出。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<a id="more"></a>
<h2 id="Git的作用"><a href="#Git的作用" class="headerlink" title="Git的作用"></a>Git的作用</h2><ol>
<li>备份文件</li>
<li>记录历史</li>
<li>回到过去</li>
<li>多端共享</li>
<li>团队协作</li>
</ol>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt install git</div><div class="line">sudo yum install git</div></pre></td></tr></table></figure>
<h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git help &lt;verb&gt;</div><div class="line">git &lt;verb&gt; --help</div><div class="line">man git &lt;verb&gt;</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config</div></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol>
<li><code>/etc/gitconfig</code>，系统配置，<code>git config --system</code></li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>，当前用户，<code>git config --global</code></li>
<li>项目目录下的<code>.git/config</code>，当前仓库</li>
</ol>
<p>当前仓库会覆盖当前用户配置，当前用户配置会覆盖系统配置</p>
<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;Your Name&quot;</div><div class="line">git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure>
<p>全局配置只需设置一次<br>当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置</p>
<h3 id="列出所有配置"><a href="#列出所有配置" class="headerlink" title="列出所有配置"></a>列出所有配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --list</div></pre></td></tr></table></figure>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git config --global alias.st status</div><div class="line"># git st</div><div class="line">git config --global alias.co checkout</div><div class="line"># git co</div><div class="line">git config --global alias.ci commit</div><div class="line"># git ci</div><div class="line">git config --global alias.br branch</div><div class="line"># git br</div><div class="line"></div><div class="line">git config --global alias.last &apos;log -1 HEAD&apos;</div><div class="line"># git last 最后一次提交</div></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd &lt;dir-name&gt;</div><div class="line">git init</div></pre></td></tr></table></figure>
<h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:fengrenxiaoli/GitTest.git</div><div class="line"># 在当前目录下创建一个 GitTest 目录，并在 GitTest 目录下创建 .git 文件夹</div><div class="line"></div><div class="line">git clone git@github.com:fengrenxiaoli/GitTest.git mylibgit</div><div class="line"># 在当前目录下创建一个 mylibgit 目录，并在 mylibgit 目录下创建 .git 文件夹</div></pre></td></tr></table></figure>
<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<p><img src="/img/IMG149.png" alt=""></p>
<p>tracked：已跟踪，那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区<br>untracked：未跟踪，其他文件，使用<code>git add &lt;file-name&gt;</code>变为跟踪状态</p>
<h3 id="三种状态和三个工作区域"><a href="#三种状态和三个工作区域" class="headerlink" title="三种状态和三个工作区域"></a>三种状态和三个工作区域</h3><table>
<thead>
<tr>
<th>状态</th>
<th>工作区域</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>已修改modifed</td>
<td>Workspace</td>
<td></td>
</tr>
<tr>
<td>已暂存staged</td>
<td>Stage/Index</td>
<td><code>git add &lt;file-name&gt;</code></td>
</tr>
<tr>
<td>已提交commited</td>
<td>Local Repository/.git目录</td>
<td><code>git commit</code></td>
</tr>
</tbody>
</table>
<p><code>git add</code>既可以用该命令开始跟踪新文件，也可以把已跟踪的文件放到暂存区</p>
<h2 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git diff</div><div class="line">git diff readme.txt</div><div class="line"># 查看修改之后还没有暂存起来的修改内容(git add前)</div><div class="line"># 工作区(workspace)和暂存区(stage)的比较</div><div class="line"></div><div class="line">git diff HEAD --readme.txt</div><div class="line"></div><div class="line">git diff --cached</div><div class="line"># 查看已暂存的将要添加到下次提交里的内容(git add后)</div><div class="line"># 暂存区(stage)和分支(master)的比较</div></pre></td></tr></table></figure>
<p><img src="/img/IMG164.png" alt=""></p>
<h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git add readme.txt</div><div class="line"># 实际上是把文件修改添加到暂存区</div><div class="line"></div><div class="line">git commit</div><div class="line"># 提交更改，实际上是把暂存区的所有内容提交到当前分支</div><div class="line"># 会启动默认的编辑器输入注释信息</div><div class="line"># 没有git add但是已经修改的内容不会提交</div><div class="line">git commit -m &quot;增加文件&quot;</div><div class="line"># 直接声明注释信息</div><div class="line"></div><div class="line">git commit -m -a &apos;增加文件&apos;</div><div class="line"># git add + git commit</div><div class="line"></div><div class="line">git commit --amend</div><div class="line"># 更改一次提交</div></pre></td></tr></table></figure>
<p><img src="/img/IMG165.png" alt=""></p>
<h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>忽略某些文件时，需要编写<code>.gitignore</code><br><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理<br>参考模版：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></p>
<p>文件 <code>.gitignore</code> 的格式规范如下：<br>• 所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。<br>• 可以使用标准的 <code>glob</code> 模式（通配符模式）匹配。<br>• 以 <code>/</code> 开头防止递归。<br>• 以 <code>/</code> 结尾表示目录。<br>• 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。</p>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line"># 查看提交历史，以便确定要回退到哪个版本，时间从最近到最远</div><div class="line"># 列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明</div><div class="line"></div><div class="line"></div><div class="line">git log -p</div><div class="line"># 显示每次提交的内容差异，可以用于代码审查</div><div class="line">git log -2</div><div class="line"># 最近再次提交</div><div class="line">git log --since=2.weeks</div><div class="line"># 最近两周提交</div><div class="line"></div><div class="line">git log --author=&quot;John&quot;</div><div class="line"># 指定作者（负责修改的人）</div><div class="line">git log --grep=&quot;关键字&quot;</div><div class="line"># 搜索提交信息中的关键字</div><div class="line">git log --author=&quot;John&quot; --grep=&quot;关键字&quot; --all-match</div><div class="line"># --all-match 同时匹配</div><div class="line"></div><div class="line">git log -S &quot;key&quot;</div><div class="line"># 仅显示添加或移除了某个关键字的提交</div><div class="line"></div><div class="line">git log -- path</div><div class="line"># 指定路径，放在最后</div><div class="line"></div><div class="line">git log --stat</div><div class="line"># 包含简略的统计信息</div><div class="line">git log --pretty=oneline</div><div class="line"># 指定显示格式，oneline表示单选显示，其他包括short\full\fuller</div><div class="line">git log --format=&quot;%h - %an - %ar - %s&quot;</div><div class="line"># 指定显示格式，具体选项，参考git log --help，或参考Pro-git</div><div class="line">git log --format=&apos;%h %s&apos; --graph</div><div class="line"># 图形化显示分支、合并历史</div><div class="line"></div><div class="line"></div><div class="line">git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \</div><div class="line">  --before=&quot;2008-11-01&quot; --no-merges -- t/</div><div class="line"># 2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件</div></pre></td></tr></table></figure>
<h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">git checkout -- &lt;fiel-name&gt;</div><div class="line"># 未git add，回退到文件修改之前（丢弃工作区的修改），还原成上次提交时的样子</div><div class="line"># 对文件做的任何修改都会消失</div><div class="line"></div><div class="line">git reset </div><div class="line"># 默认为HEAD，索引会回滚到最后一次提交</div><div class="line"># 如果用--hard选项，工作目录也同样回滚</div><div class="line"></div><div class="line">git reset -- &lt;file-name&gt;</div><div class="line"># 撤销最后一次git add</div><div class="line"></div><div class="line">git reset HEAD &lt;file-name&gt;</div><div class="line"># 已经git add（添加到了暂存区），需要回退未 git add 之前</div><div class="line"></div><div class="line">git reset HEAD &lt;file-name&gt;</div><div class="line">git checkout -- &lt;fiel-name&gt;</div><div class="line"># 已经git add（添加到了暂存区），还未git commit，需要回退到文件修改之前（丢弃工作区的修改）</div><div class="line"></div><div class="line">git reset --hard HEAD^</div><div class="line"># 已经git commit，还未git push，想要撤销本次提交，回退到上个版本</div><div class="line"></div><div class="line"></div><div class="line">git log</div><div class="line"># 查看提交历史，以便确定要回退到哪个版本</div><div class="line">git relog</div><div class="line"># 查看命令历史，以便确定要回到未来的哪个版本</div><div class="line">git reset --hard 1094adb</div><div class="line"># 回退到指定的commit id，commit id可以只写前几位</div></pre></td></tr></table></figure>
<p><img src="/img/IMG166.png" alt=""><br>如果用–hard选项，那么工作目录也更新，如果用–soft选项，那么都不变</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">rm readem.txt</div><div class="line">git rm readme.txt</div><div class="line"># 未提交到暂存区域</div><div class="line"># 可以用git add代替</div><div class="line"></div><div class="line">git rm -f readme.txt</div><div class="line"># 删除已经添加到暂存区域的文件 </div><div class="line"></div><div class="line"></div><div class="line">git rm --cached readme.txt</div><div class="line"># 让文件保存在磁盘，但是禁止git继续跟踪</div><div class="line"># 适用于忘记添加 .gitignore 文件时</div></pre></td></tr></table></figure>
<p>如果误删除了文件且没有<code>git add</code>，需要撤消<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- test.txt</div></pre></td></tr></table></figure></p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git remote</div><div class="line"># 列出指定的每一个远程服务器的简写</div><div class="line">git remote -v</div><div class="line"># 列出所有远程服务器的简写与其对应的 URL</div><div class="line"></div><div class="line">git remote show &lt;remote-name&gt;</div><div class="line"># 远程仓库详细信息</div></pre></td></tr></table></figure>
<p>origin是远程仓库的默认名字</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git remote add &lt;remote-name&gt; &lt;url&gt;</div><div class="line">git remote add origin git@github.com:michaelliao/learngit.git</div><div class="line"># 可以使用默认名 origin ，也可以使用自定义的名字</div></pre></td></tr></table></figure>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:michaelliao/gitskills.git</div></pre></td></tr></table></figure>
<p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。<br><strong>自动</strong>设置本地 master 分支<strong>跟踪</strong>克隆的远程仓库的 master 分支</p>
<h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git fetch &lt;remote-name&gt;</div><div class="line">git fetch origin</div><div class="line"># 抓取克隆(或上一次抓取)后新推送的所有分支数据</div><div class="line"># 即远程仓库中有但本地没有的数据</div><div class="line"># 不会自动合并或修改你当前的工作。必须手动将其合并入你的工作</div><div class="line"></div><div class="line"></div><div class="line">git pull</div><div class="line"># 有一个分支设置为跟踪一个远程分支</div><div class="line"># 从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支</div></pre></td></tr></table></figure>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git push &lt;remote-name&gt; &lt;branch-name&gt;</div><div class="line">git push origin master</div><div class="line"># 要求对远程仓库有写入权限</div><div class="line"># 如果别人先推送到上游然后你再推送到上游，你的推送就会被拒绝</div><div class="line"># 必须先将他们的工作拉取下来（git pull）并将其合并（git merge）进你的工作后才能推送</div><div class="line"></div><div class="line">git push -u origin master</div><div class="line"># 如果本地分支没有关联远程分支，需要加上-u进行关联，以后就不需要了</div><div class="line"></div><div class="line">git push -u origin featureB:featureB</div></pre></td></tr></table></figure>
<h3 id="远程仓库的重命名"><a href="#远程仓库的重命名" class="headerlink" title="远程仓库的重命名"></a>远程仓库的重命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rename origin hexo</div></pre></td></tr></table></figure>
<h3 id="远程仓库的删除"><a href="#远程仓库的删除" class="headerlink" title="远程仓库的删除"></a>远程仓库的删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div></pre></td></tr></table></figure>
<h3 id="一个本地库关联多个远程库"><a href="#一个本地库关联多个远程库" class="headerlink" title="一个本地库关联多个远程库"></a>一个本地库关联多个远程库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div><div class="line"># 先删除已关联的名为origin的远程库</div><div class="line"></div><div class="line"></div><div class="line">git remote add github git@github.com:michaelliao/learngit.git</div><div class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</div><div class="line"># 关联远程库，远程库的名称叫github、gitee</div></pre></td></tr></table></figure>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p>
<h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">git tag</div><div class="line"># 查看所有标签</div><div class="line"></div><div class="line">git tag -l &apos;v1.8.5*&apos;</div><div class="line"># 查看特定标签</div><div class="line"></div><div class="line">git show &lt;tag-name&gt;</div><div class="line">git show v1.4</div><div class="line"># 某个标签的详细信息</div></pre></td></tr></table></figure>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>只是特定提交的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git master</div><div class="line"># 切换到相应分支</div><div class="line">git tag v1.4-lw</div></pre></td></tr></table></figure></p>
<h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard (GPG)签名与验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a v1.4 -m &apos;some message&apos;</div></pre></td></tr></table></figure>
<p>-a 表示是附注标签<br>-m 表示存储在标签中的信息</p>
<h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git tag -a v0.9 f52c633</div><div class="line"># 针对某一commit id打标签</div></pre></td></tr></table></figure>
<h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><p>推送标签到远程服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git push &lt;remote-name&gt; &lt;tag-name&gt;</div><div class="line">git push origin v1.5</div><div class="line"></div><div class="line">git push origin --tags</div><div class="line"># 把所有不在远程仓库服务器上的标签全部传送到远程服务器</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git tag -d v0.1</div><div class="line"># 删除一个本地标签</div><div class="line"></div><div class="line">git push origin v1.0</div><div class="line"># 推送某个标签到远程</div><div class="line">git push origin --tags</div><div class="line"># 一次性推送全部尚未推送到远程的本地标签</div><div class="line"></div><div class="line">git tag -d v0.9</div><div class="line">git push origin :refs/tags/v0.9</div><div class="line"># 删除推送到远程的标签</div></pre></td></tr></table></figure>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git的分支，本质上仅仅是指向提交对象的可变指针<br><code>master</code>：Git的默认分支名<br><code>HEAD</code>是一个指针，指向<strong>当前</strong>所在的本地分支<br>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点<br>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长</p>
<p><img src="/img/IMG150.png" alt=""></p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">git branch testing</div><div class="line"># 只是为你创建一个可以移动的新的指针，不会自动切换</div><div class="line"></div><div class="line">git branch -b testing </div><div class="line"># 创建并切换分支</div><div class="line"></div><div class="line">git log --oneline --decorate </div><div class="line"># 查看各个分支当前所指的对象</div><div class="line"># master和dev指向同一对象</div><div class="line"></div><div class="line">git branch develop master    </div><div class="line"># 从master分支上新建develop分支</div></pre></td></tr></table></figure>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout testing</div><div class="line"># 已经存在的分支</div><div class="line"># HEAD 指向 testing 分支</div></pre></td></tr></table></figure>
<p><img src="/img/IMG151.png" alt=""></p>
<p>在 <code>testing</code> 分支提交文件之后的变化</p>
<p><img src="/img/IMG152.png" alt=""></p>
<p>切换回 <code>master</code> 分支后的变化，工作目录的内容会变成 <code>master</code> 最全后一次提交的情况</p>
<p><img src="/img/IMG153.png" alt=""></p>
<p>在 <code>master</code> 分支提交文件</p>
<p><img src="/img/IMG154.png" alt=""></p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">git log --oneline --decorate</div><div class="line"># 查看各个分支当前所指的对象</div><div class="line"></div><div class="line">git log --oneline --decorate --graph --all</div><div class="line"># 查看分叉历史</div><div class="line"></div><div class="line"></div><div class="line">git branch</div><div class="line"># 列出所有分支，* 表示当前分支</div><div class="line">git branch -v</div><div class="line"># 每一个分支的最后一次提交</div><div class="line">git branch --merged</div><div class="line"># 看哪些分支已经合并到当前分支</div><div class="line">git branch --no-merged</div><div class="line"># 查看所有包含未合并工作的分支，无法使用 -d 选项删除，可以使用 -D 选项强制删除</div></pre></td></tr></table></figure>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">git commit -a -m &quot;...&quot;</div><div class="line"># 先提交</div><div class="line"></div><div class="line"></div><div class="line"># 三方合并</div><div class="line">git checkout master</div><div class="line"># 切换回需要合并到的分支 </div><div class="line">git merge hotfix</div><div class="line"># 合并分支到当前分支</div><div class="line"># 直接把 master 指向 hotfix 的当前提交，就完成了合并</div><div class="line"></div><div class="line"></div><div class="line"># 分支合并可能会遇到冲突，需要手动解决并提交</div><div class="line">git status</div><div class="line"># 查看冲突</div><div class="line">vim &lt;conflict-file-name&gt;</div><div class="line">git add &lt;conflict-file-name&gt;</div><div class="line">git commit -m &quot;....&quot;</div><div class="line"># 不需要再次 merge</div></pre></td></tr></table></figure>
<ul>
<li><code>fast-forward</code>：没有需要解决的冲突，直接将 <code>HEAD</code> 指向分支</li>
<li>一次合并提交：三方合并，你的开发历史从一个更早的地方开始分叉开来<br><img src="/img/IMG155.png" alt=""><br><img src="/img/IMG156.png" alt=""></li>
<li><code>non-fast-forward</code>：存在需要解决的冲突，需要先拉取到本地并进行合并才能推送</li>
</ul>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除不再需要的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch -d hotfix</div><div class="line"># 删除 hotfix 分支就是把 hotfix 指针给删掉</div></pre></td></tr></table></figure></p>
<h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中<br>比如只在 <code>master</code> 分支上保留完全稳定的代码</p>
<h4 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h4><p>短期分支，它被用来实现单一特性或其相关工作</p>
<h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>假定需要在master分支上修复，就从master创建临时分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">git stash</div><div class="line"># 保存现场工作</div><div class="line"></div><div class="line">git checkout master</div><div class="line">git checkout -b issue-101</div><div class="line">git add readme.txt </div><div class="line">git commit -m &quot;fix bug 101&quot;</div><div class="line">git checkout master</div><div class="line">git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line"></div><div class="line">git checkout dev</div><div class="line"># 切换到之前的工作分支</div><div class="line">git stash list</div><div class="line"># 列出保存的工作现场</div><div class="line">git stash pop</div><div class="line"># 恢复的同时把stash内容也删了</div></pre></td></tr></table></figure></p>
<h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>添加一个新功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature-vulcan</div><div class="line"># 原来在dev分支</div><div class="line"></div><div class="line">git add vulcan.py</div><div class="line">git commit -m &quot;add feature vulcan&quot;</div><div class="line">git checkout dev</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch -D feature-vulcan</div><div class="line"># 强行删除分支，未合并之前删除使用</div></pre></td></tr></table></figure>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>之前的分支操作都是在本地执行的。</p>
<p>远程跟踪分支是远程分支状态的引用。以 <code>(remote)/(branch)</code> 形式命名，比如 <code>origin/master</code> 表示远程的master分支</p>
<p><img src="/img/IMG157.png" alt=""><br><img src="/img/IMG158.png" alt=""><br><img src="/img/IMG159.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line"># 更新本地数据</div></pre></td></tr></table></figure>
<h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git push origin serverfix</div><div class="line"># 推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支</div><div class="line"></div><div class="line">git push origin serverfix:awesomebranch</div><div class="line"># 本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支</div></pre></td></tr></table></figure>
<p>其他协作者通过 <code>git fetch origin</code> 会下载新的分支，但不能修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git merge origin/serverfix</div><div class="line"># 合并分支</div><div class="line"></div><div class="line">git checkout -b serverfix origin/serverifx</div><div class="line"># 跟踪远程分支，这样本地可以修改 serverfix 分支</div></pre></td></tr></table></figure></p>
<h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>跟踪分支是与远程分支有直接关系的本地分支<br>当克隆一个仓库时,它通常会自动地创建一个跟踪 origin/master 的 master 分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">git checkout -b &lt;branch&gt; &lt;remote-branch&gt;</div><div class="line"></div><div class="line">git checkout -b sf origin/serverfix</div><div class="line"># 本地分支名和远程分支名不同</div><div class="line"></div><div class="line">git branch -u orgin/serverfix</div><div class="line"># 创建分支，跟踪远程分支</div><div class="line"></div><div class="line">git fetch --all</div><div class="line">git branch -vv</div><div class="line"># 查看设置的所有跟踪分支，需要先更新</div><div class="line"># 可以确定本地分支与远程分支是否是领先（ahead）、落后（ahead）或是都有（说明远程有其他提交，本地也有提交）</div></pre></td></tr></table></figure>
<h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git pull</div><div class="line"># 更新本地仓库至最新改动并尝试合并</div></pre></td></tr></table></figure>
<p>也就是 <code>git fetch</code> 和 <code>git merge</code>，建议显示使用 <code>git fetch</code> 和 <code>git merge</code></p>
<h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin --delete &lt;remote-branch&gt;</div></pre></td></tr></table></figure>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>变基是另一种合并方式<br><strong>不要对在你的仓库外有副本的分支执行变基</strong></p>
<p>变基使得提交历史更加整洁，提交历史是一条直线没有分叉</p>
<p><img src="/img/IMG160.png" alt=""><br><img src="/img/IMG161.png" alt=""><br>首先找到这两个分支(即当前分支 experiment、变基操作的目标基底分支 master)的最近共同祖先 C2,然后对比当前分支相对于该祖先的历次提交,提取相应的修改并存为临时文件,然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">git checkout experiment</div><div class="line">git rebase master</div><div class="line">git checkout master </div><div class="line">git merge experiment</div><div class="line"></div><div class="line">git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</div><div class="line">git rebase master server</div><div class="line">git checkout master</div><div class="line">git merge server</div></pre></td></tr></table></figure>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>不同的分支各自都分别有新的提交，当进行合并时就会发生冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件</p>
<p>修改文件中的冲突后可以再次提交</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图产品</p>
<p>git有个最佳实践，master是主分支，用来做正式发布版之后的保留历史，其他分支包括dev用来做正常开发，多个feature用来做某些特性功能，release用来做发布版历史，每次发布都是用release打包，hotfix用来做发布版之后的一些及时迭代修复bug的工作。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</div></pre></td></tr></table></figure></p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">git push origin master</div><div class="line">git push origin dev</div><div class="line"># 推送分支</div><div class="line"></div><div class="line">git clone git@github.com:michaelliao/learngit.git</div><div class="line">git branch</div><div class="line"># 默认是master分支</div><div class="line">git checkout -b dev origin/dev</div><div class="line"># 创建dev分支</div><div class="line"></div><div class="line">git pull</div><div class="line">git branch --set-upstream-to=origin/dev dev</div><div class="line"># 解决冲突</div></pre></td></tr></table></figure>
<!-- ### 分支开发

1. 基于主分支创建个开发分支   `git checkout -b dev1`
2. 在开发分支中拉取下主分支   `git pull origin master`
3. 开发完成后，提交到git服务器     `git add` . / `git commit -m '1' `/ `git push origin dev1`
4. 拉取下主分支，提前解决冲突 `git pull origin master`
5. 切回主分支(切记要提交后切回)     `git checkout master`
6. 拉取下最新代码  `git pull origin master `
7. 合并开发分支   `git merge dev1`(如果失败会提示失败文件，解决掉冲突)
8. 提交到git服务器 -->
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><h3 id="私有小型团队"><a href="#私有小型团队" class="headerlink" title="私有小型团队"></a>私有小型团队</h3><p>有一两个其他开发者的私有项目<br><img src="/img/IMG162.jpg" alt=""></p>
<h3 id="私有管理团队"><a href="#私有管理团队" class="headerlink" title="私有管理团队"></a>私有管理团队</h3><p>独立小组的工作只能被特定的工程师整合,主仓库的master 分支只能被那些工程师更新</p>
<p>假设 John 与 Jessica 在一个特性上工作,同时 Jessica 与 Josie 在第二个特性上工作<br><img src="/img/IMG163.jpg" alt=""></p>
<h3 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h3><p><img src="/img/IMG144.jpg" alt=""></p>
<ul>
<li>master分支，即主分支。任何项目都必须有个这个分支。对项目进行tag或发布版本等操作，都必须在该分支上进行。</li>
<li>develop分支，即开发分支，从master分支上检出。团队成员一般不会直接更改该分支，而是分别从该分支检出自己的feature分支，开发完成后将feature分支上的改动merge回develop分支。同时release分支由此分支检出。</li>
<li>release分支，即发布分支，从develop分支上检出。该分支用作发版前的测试，可进行简单的bug修复。如果bug修复比较复杂，可merge回develop分支后由其他分支进行bug修复。此分支测试完成后，需要同时merge到master和develop分支上。</li>
<li>feature分支，即功能分支，从develop分支上检出。团队成员中每个人都维护一个自己的feature分支，并进行开发工作，开发完成后将此分支merge回develop分支。此分支一般用来开发新功能或进行项目维护等。</li>
<li>fix分支，即补丁分支，由develop分支检出，用作bug修复，bug修复完成需merge回develop分支，并将其删除。所以该分支属于临时性分支。</li>
<li>hotfix分支，即热补丁分支。和fix分支的区别在于，该分支由master分支检出，进行线上版本的bug修复，修复完成后merge回master分支，并merge到develop分支上，merge完成后也可以将其删除，也属于临时性分支。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="external">git-flow 备忘清单</a></li>
<li><a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="external">Git 在团队中的最佳实践–如何正确使用Git Flow</a></li>
<li><a href="https://blog.coding.net/blog/git-workflow" target="_blank" rel="external">大话 Git 工作流</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23478654" target="_blank" rel="external">图文详解如何利用Git+Github进行团队协作开发</a></li>
<li><a href="https://segmentfault.com/a/1190000002918123" target="_blank" rel="external">深入理解学习Git工作流（git-workflow-tutorial）</a></li>
<li><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" target="_blank" rel="external">Learn Version Control with Git</a></li>
</ul>
<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>以下方式为通过ssh协议搭建的Git服务器，添加了公钥的用户可以进行读写操作</p>
<p>1.安装git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install git</div></pre></td></tr></table></figure></p>
<p>2.创建用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat /etc/shells</div><div class="line">which git-shell</div><div class="line">sudo vim /etc/shells</div><div class="line"># 添加git-shell的位置，git-shell可以禁止使用ssh登录shell</div><div class="line"></div><div class="line">sudo adduser git -s /usr/bin/git-shell</div></pre></td></tr></table></figure></p>
<p>3.管理公钥<br>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个<br>人多可以用<code>Gitosis</code>来管理公钥</p>
<p>注意权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">su git</div><div class="line">cd</div><div class="line">mkdir .ssh</div><div class="line">chmod 700 .ssh</div><div class="line">touch .ssh/authorized_keys</div><div class="line">chmod 600 .ssh/authorized_keys</div><div class="line"></div><div class="line">cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys</div><div class="line">cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p>
<p>4.初始化Git仓库<br>选定一个目录作为Git仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd /opt/git</div><div class="line">mkdir project.git</div><div class="line">cd project.git</div><div class="line">git init --bare</div><div class="line"></div><div class="line">chown -R git:git project.git</div></pre></td></tr></table></figure></p>
<p>需要有一个人推送第一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd myproject</div><div class="line">git init</div><div class="line">git add .</div><div class="line">git commit -m &apos;initial commit&apos;</div><div class="line">git remote add origin git@gitserver:/opt/git/project.git</div><div class="line">git push origin master</div></pre></td></tr></table></figure></p>
<p>5.克隆远程仓库<br>在各自的电脑上克隆远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@server:/srv/sample.git</div></pre></td></tr></table></figure></p>
<p>Git不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<code>Gitolite</code>就是这个工具。</p>
<p>还有其他方式，比如适合快速只读访问的Git守护进程，既可以进行授权访问又可以进行无授权访问的Smart HTTP，使用GitWeb搭建网页展示，参考Pro-git</p>
<p><img src="/img/IMG148.png" alt=""></p>
<p>利用工具提升工作效率，而不是去学习工具本身</p>
<ol>
<li>多用客户端和工具，少用命令行，除非在linux服务器上直接开发</li>
<li>每次提交前，diff自己的代码，以免提交错误的代码</li>
<li>下班回家前，整理好自己的工作区</li>
<li>并行的项目，使用分支开发</li>
<li>遇到冲突时，搞明白冲突的原因，千万不要随意丢弃别人的代码</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/entry/586eddf6a22b9d00587829ce" target="_blank" rel="external">比较全面的 Git 学习资料整理</a></li>
<li><a href="http://www.cylong.com/blog/2016/09/26/git-svn/" target="_blank" rel="external">http://www.cylong.com/blog/2016/09/26/git-svn/</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="external">http://rogerdudler.github.io/git-guide/</a></li>
<li><a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="external">https://guides.github.com/activities/hello-world/</a></li>
<li><a href="http://www.uml.org.cn/pzgl/201207264.asp" target="_blank" rel="external">分布式和集中式版本控制工具-svn,git,mercurial</a></li>
<li><a href="https://www.jianshu.com/p/86ef009e5c86" target="_blank" rel="external">Git在工作中的小总结</a></li>
<li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解Git</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本控制系统&quot;&gt;&lt;a href=&quot;#版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;版本控制系统&quot;&gt;&lt;/a&gt;版本控制系统&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;集中式版本控制系统&lt;/strong&gt;（Centralized Version Control Systems,简称 CVCS）：have a single server that contains all the versioned files, and a number of clients that check out files from that central place.&lt;/p&gt;
&lt;p&gt;集中式版本控制系统的缺点是中央服务器的单点故障。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式版本控制系统&lt;/strong&gt;（Distributed Version Control System,简称 DVCS）：clients don’t just check out the latest snapshot of the files; rather, they fully mirror the repository, including its full history.&lt;/p&gt;
&lt;p&gt;分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。&lt;/p&gt;
&lt;p&gt;集中式版本控制：CVS、SVN、ClearCase、VSS&lt;br&gt;分布式版本控制：Git、BitKeeper、Mercurial、Bazaar&lt;/p&gt;
&lt;p&gt;git和其他版本控制工具存储数据的方式不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他版本控制工具存储一组文件以及基于这些文件随时间推移产生的差异&lt;/li&gt;
&lt;li&gt;git存储更像快照，对当时的全部文件制作一个快照并保存这个快照的索引，如果没有修改则只保留一个指向之前存储文件的链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息&lt;br&gt;SVN 中可以修改文件，但是无法向数据库提交修改&lt;/p&gt;
&lt;p&gt;Git 中所有数据在存储前都计算&lt;strong&gt;校验和&lt;/strong&gt;，然后以校验和来引用，&lt;br&gt;校验和由 40 个十六进制字符组成，通过SHA1计算得出。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/post/f7ede91d.html"/>
    <id>http://yoursite.com/post/f7ede91d.html</id>
    <published>2018-06-23T09:23:53.000Z</published>
    <updated>2018-07-09T08:47:01.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="JVM-JRE-JDK"><a href="#JVM-JRE-JDK" class="headerlink" title="JVM JRE JDK"></a>JVM JRE JDK</h3><p>JVM：Java Virtual Machine<br>JDK：Java Development Kit（Java开发工具包）<br>JRE：Java Runtime Environment（Java运行环境）</p>
<p>java文件执行过程</p>
<ol>
<li>源代码文件 .java</li>
<li>编译器编译</li>
<li>字节码文件 .class</li>
<li>解释器解释</li>
<li>执行</li>
</ol>
<p>跨平台通过JVM实现</p>
<p>JRE包含JVM，JDK包含JRE</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>JAVA_HOME    配置JDK安装路径，通常Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。<br>PATH        配置JDK命令文件的位置<br>CLASSPATH    配置类库文件的位置</p>
<p>Java 关键字区分大小写</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符就是用于给 Java 程序中变量、类、方法等命名的符号。类名、变量名、方法名等都是标识符<br>使用标识符时，需要遵守几条规则：</p>
<ol>
<li>标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。</li>
<li>标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Myvoid 可以</li>
<li>标识符是严格区分大小写的。 所以涅，一定要分清楚 imooc 和 IMooc 是两个不同的标识符哦！</li>
<li>标识符的命名最好能反映出其作用，做到见名知意。</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。</p>
<ol>
<li>变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 myAge<br>2.变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName 保存“学生姓名”信息</li>
</ol>
<p><img src="/img/Java001.jpg" alt=""><br>基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址<br>String 是一种常见的引用数据类型，用来表示字符串。<br>char使用两个字节，使用单引号括起来</p>
<ol>
<li>Java 中的变量需要先声明后使用</li>
<li>变量使用时，可以声明变量的同时进行初始化，也可以先声明后赋值</li>
<li>变量中每次只能赋一个值，但可以修改多次</li>
<li>main 方法中定义的变量必须先赋值，然后才能输出</li>
<li>虽然语法中没有提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患，譬如后期跨平台操作时出现乱码等等</li>
</ol>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><ol>
<li>目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型</li>
<li>目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以了</li>
</ol>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(数据类型)数值</div></pre></td></tr></table></figure>
<p>数值上并未进行四舍五入，而是直接将小数位截断。<br>强制类型转换可能会造成数据的丢失</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>它的值被设定后，在程序运行过程中不允许改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final 常量名 = 值;</div></pre></td></tr></table></figure></p>
<p>常量名一般使用大写字符</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。</p>
<p>Java 中注释有三种类型：单行注释、多行注释、文档注释<br>文档注释以<code>/**</code>开头,以<code>*/</code>结尾<br>多行注释以<code>/*</code>开头,以<code>/</code>结尾<br>单行注释以<code>/</code>开头,行未结尾</p>
<p>通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javadoc -d doc Demo03.java</div></pre></td></tr></table></figure></p>
<p>使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@author 	标明开发该类模块的作者</div><div class="line">@version 	标明该类模块的版本</div><div class="line">@see 		参考转向，也就是相关主题</div><div class="line">@param 		对方法中某参数的说明</div><div class="line">@return 	对方法返回值的说明</div><div class="line">@exception 	对方法可能抛出的异常进行说明</div></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Java 语言中常用的运算符可分为如下几种：</p>
<ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>条件运算符</li>
</ul>
<p><img src="/img/Java003.jpg" alt=""></p>
<p>++出现在左边,先执行自增,然后赋值<br>++出现在右边,先赋值,后执行自增</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">double ave = 24/4;</div><div class="line">System.out.println(ave);</div></pre></td></tr></table></figure>
<p>结果是<code>6.0</code></p>
<p><img src="/img/Java004.jpg" alt=""></p>
<p><img src="/img/Java005.jpg" alt=""><br>比较的结果是一个布尔值（ true 或 false ）</p>
<p><code>&gt;</code>、<code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code>只支持左右两边操作数是数值类型</p>
<p><code>==</code> 、 <code>!=</code> 两边的操作数既可以是数值类型，也可以是引用类型</p>
<p><code>equals()</code>用于判断字符串的内容是否相同,相同返回true,反之false</p>
<p><img src="/img/Java006.jpg" alt=""><br>“短路”现象<br>譬如：( one &gt; two ) &amp;&amp; ( one &lt; three ) 中，如果能确定左边 one &gt; two 运行结果为 false , 则系统就认为已经没有必要执行右侧的 one &lt; three 啦。</p>
<p>同理，在( one &gt; two ) || ( one &lt; three ) 中，如果能确定左边表达式的运行结果为 true , 则系统也同样会认为已经没有必要再进行右侧的 one &lt; three 的执行啦！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">布尔表达式 ？ 表达式1 ：表达式2</div></pre></td></tr></table></figure>
<p>如果布尔表达式的值为 true ，则返回 表达式1 的值，否则返回 表达式2 的值</p>
<p><img src="/img/Java007.jpg" alt=""></p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (score&gt;90)&#123;</div><div class="line">	System.out.println(&quot;哟&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (score&gt;90)&#123;</div><div class="line">	System.out.println(&quot;哟&quot;);</div><div class="line">&#125;else&#123;</div><div class="line">	System.out.println(&quot;噢&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (score&gt;90)&#123;</div><div class="line">	System.out.println(&quot;哟&quot;);</div><div class="line">&#125;else if (score &gt;70)&#123;</div><div class="line">	System.out.println(&quot;噢&quot;);</div><div class="line">&#125;else&#123;</div><div class="line">	System.out.println(&quot;喵&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (score&gt;90)&#123;</div><div class="line">	if (sex.equals(&quot;&quot;))&#123;</div><div class="line">		System.out.println(&quot;哟&quot;);</div><div class="line">	&#125;else &#123;</div><div class="line">		System.out.println(&quot;噢&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;else&#123;</div><div class="line">	System.out.println(&quot;喵&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int num =1;</div><div class="line">switch(num)&#123;</div><div class="line">	case 1:</div><div class="line">		System.out.println(&quot;1&quot;);</div><div class="line">		break;</div><div class="line">	case 2:</div><div class="line">		System.out.println(&quot;2&quot;);</div><div class="line">		break;</div><div class="line">	case 3:</div><div class="line">		System.out.println(&quot;3&quot;);</div><div class="line">		break;</div><div class="line">	default:</div><div class="line">		System.out.println(&quot;default&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行过程：当 switch 后表达式的值和 case 语句后的值相同时，从该位置开始向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。</p>
<ul>
<li>switch 后面小括号中表达式的值必须是整型或字符型</li>
<li>case 后面的值可以是常量数值，如 1、2；也可以是一个常量表达式，如 2+2 ；但不能是变量或带有变量的表达式，如 a * 2</li>
<li>case 匹配后，执行匹配块里的程序代码，如果没有遇见 break 会继续执行下一个的 case 块的内容，直到遇到 break 语句或者 switch 语句块结束</li>
<li>default 块可以出现在任意位置，也可以省略</li>
<li>可以把功能相同的 case 语句合并起来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">case 1:</div><div class="line">case 2:</div><div class="line">	System.out.println(&quot;&quot;);</div></pre></td></tr></table></figure>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>先判断，后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int i=1;</div><div class="line">while(i &lt;=1000)&#123;</div><div class="line">	System.out.println(&quot;嗯&quot;);</div><div class="line">	i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><p>先执行，后判断<br>保证循环至少被执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int i=1;</div><div class="line">do&#123;</div><div class="line">	System.out.println(&quot;哦&quot;);</div><div class="line">	i++</div><div class="line">&#125;while (i&lt;=1000);</div></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;=1000;i++)&#123;</div><div class="line">	System.out.println(&quot;咦&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略。</p>
<ul>
<li>省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作</li>
<li>省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象</li>
<li>省略“循环变量变化”，可以在循环体中进行循环变量的变化</li>
</ul>
<p>for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值</p>
<p>循环条件部分可以使用<strong>逻辑运算符</strong>组合的表达式，表示复杂判断条件，但一定注意运算的优先级</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p> break 语句退出指定的循环，直接执行循环后面的代码。</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>跳过循环体中剩余的语句执行下一次循环</p>
<h3 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h3><p><img src="/img/Java008.jpg" alt=""></p>
<p>java.util.Scanner类 ，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import java.util.Scanner;</div><div class="line">Scanner scanner = new Scanner(System.in);</div><div class="line">System.out.println(&quot;Please input score:&quot;);</div><div class="line">int score = scanner.nextInt();</div></pre></td></tr></table></figure></p>
<p>System.out.println 换行输出<br>System.out.print   不换行输出</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># 声明</div><div class="line">int[] scores;</div><div class="line">double height[];</div><div class="line"></div><div class="line"># 分配空间</div><div class="line">scores = new int[5];</div><div class="line">height = new double[5];</div><div class="line"></div><div class="line">int[] scores = new int[5];</div><div class="line"></div><div class="line"># 赋值</div><div class="line">scores[0] = 89;</div><div class="line">scores[1] = 79;</div><div class="line">int[] scores = &#123;87,89&#125;;</div><div class="line"># 造价于 int[] scores = new int[]&#123;87,89&#125;;</div><div class="line"></div><div class="line"># 取值</div><div class="line">scores[1]</div><div class="line"></div><div class="line"># 长度</div><div class="line">scores.lenght;</div><div class="line"></div><div class="line"># 遍历</div><div class="line">for(int i =0;i&lt;scores.length;i++)&#123;</div><div class="line">	System.out.println(scores[i]);</div><div class="line">&#125;</div><div class="line">for(int score:scores)&#123;</div><div class="line">	System.out.println(score);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数组中的元素都可以通过下标来访问，下标从 0 开始。<br>数组下标的范围是 0 至 数组长度-1，如果越界访问，就会报错。</p>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">Arrays.sort(scores);</div><div class="line"># 正序排列</div><div class="line"># 改变原数组</div><div class="line"></div><div class="line">Arrays.toString(scores);</div><div class="line"># 将数组转换为字符串，多个元素之间使用逗号和空格隔开</div></pre></td></tr></table></figure>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># 声明</div><div class="line">int[][] nums = new int[2][3];</div><div class="line"></div><div class="line"># 赋值</div><div class="line">nums[0][0] = 12;</div><div class="line"></div><div class="line"># 取值</div><div class="line">nums[1][1];</div><div class="line"></div><div class="line"># 遍历</div><div class="line">for(int i = 0; i&lt; nums.length; i++)&#123;</div><div class="line">	for(int j =0; j&lt;nums[i].length; j++)&#123;</div><div class="line">		System.out.println(nums[i][j]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">访问修饰符 返回值类型 方法名(参数列表)&#123;</div><div class="line">	方法体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>访问修饰符：方法允许被访问的权限范围， 可以是 public、protected、private 甚至可以省略</li>
<li>返回值类型：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。方法的返回值最多只能有一个，不能返回多个值</li>
<li>方法名：定义的方法的名字，必须使用合法的标识符</li>
<li>参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。定义方法时的参数称为形参，目的是用来定义方法需要传入的参数的个数和类型；把调用方法时的参数称为实参，是传递给方法真正被处理的值。调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应。多个参数间以逗号分隔</li>
</ol>
<ul>
<li>方法体放在一对大括号中，实现特定的操作</li>
<li>方法名主要在调用这个方法时使用，需要注意命名的规范，一般采用第一个单词首字母小写，其它单词首字母大写的形式</li>
</ul>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对象名.方法名();</div></pre></td></tr></table></figure>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的<strong>重载</strong></p>
<p>当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。</p>
<p>判断方法重载的依据：</p>
<ol>
<li>必须是在同一个类中</li>
<li>方法名相同</li>
<li>方法参数的个数、顺序或类型. </li>
<li>与方法的修饰符或返回值没有关系</li>
</ol>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是对象的类型<br>具有相同属性和方法的一组对象的集合</p>
<p>属性：对象具有的各种特征<br>方法：对象执行的操作</p>
<p>所有Java程序都以类class为组织单元</p>
<p>定义类的方法：</p>
<ol>
<li>定义类名</li>
<li>编写类的属性</li>
<li>编写类的方法</li>
</ol>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>使用对象的步骤</p>
<ol>
<li>创建对象<code>类名 对象名 = new 构造方法();</code></li>
<li>使用对象<code>对象名.属性;对象名.方法();</code></li>
</ol>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><p>成员变量：即类的属性<br>局部变量：类的方法中定义的变量</p>
<p>成员变量和局部变量的区别</p>
<ol>
<li>作用域不同：局部变量的作用域仅限于定义它的方法，成员变量的作用域在整个类内部都是可见的。</li>
<li>初始值不同：java会给成员变量一个初始值，java不会给局部变脸赋予初始值。</li>
<li>在同一个方法中，不允许有同名局部变量；在不同的方法中，可以有同名局部变量。</li>
<li>两类变量同名时，局部变量具有更高的优先级（就近原则）。</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且没有返回值</p>
<p>构造方法的语法格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public 类名(参数)&#123;</div><div class="line">//初始化代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>public后面没有返回值类型，构造方法名与类名相同，括号内可以指定参数</p>
<p>构造方法分为无参构造方法和有参构造方法。有参构造方法的目的就是初始化对象中成员变量的值。通过无参或者有参的构造方法都可以创建对象，但是后者不但可以创建对象而且可以给对象中的实例变量赋初值</p>
<ol>
<li>使用<code>new+构造方法</code>创建一个新的对象，当我们创建对象的时候,其实我们执行的是构造方法</li>
<li>当没有指定构造方法时，系统会自动添加无参的构造方法，可以自定义无参的构造方法</li>
<li>当有指定构造方法时，无论是有参无参的构造方法，都不会自动添加无参的构造方法</li>
<li>构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法</li>
<li>构造方法不但可以给对象的属性赋值，还可以通过条件判断保证给对象的属性赋一个合理的值</li>
</ol>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>Java 中被 static 修饰的变量称为静态变量或类变量。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</p>
<p>使用 static 可以修饰变量、方法和代码块。</p>
<p>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>使用 static 修饰方法，称为静态方法或类方法。 main 方法就是静态方法。</p>
<p>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。<br>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。<br>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。</p>
<h4 id="静态数据块"><a href="#静态数据块" class="headerlink" title="静态数据块"></a>静态数据块</h4><p>Java 中可以通过初始化块进行数据赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class HelloWorld&#123;</div><div class="line">	String name;</div><div class="line">	&#123;</div><div class="line">		name = &quot;John&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在类的声明中，可以包含多个初始化块，当<strong>创建类的实例时</strong>，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。<br>静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。</p>
<p><img src="/img/Java009.jpg" alt=""><br><img src="/img/Java010.jpg" alt=""></p>
<p><strong>程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。</strong></p>
<p>面向对象的三大特性：封装、继承、多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。</p>
<p>好处：只能通过规定的方法访问数据；隐藏类的实例细节，方便修改和实现。</p>
<p>封装实现方法：</p>
<ol>
<li>修改属性可见性，设为<code>private</code>。</li>
<li>创建<code>getter\setter</code>方法，用于属性的读写。</li>
<li>在<code>getter\setter</code>中加入属性控制语句(对属性值的合法性进行判断)。</li>
</ol>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>packege，包名间可以用点来区别文件夹<br>且要放在java程序的第一行<br>包名间用<code>.</code>隔开</p>
<p>包的作用：<br>1.管理java文件<br>2.<strong>管理同名文件冲突</strong><br>加上不同的包来区分相同文件名的类<br>例如：音乐类——MyClassMusic<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">com.imooc.music.MyClassMusic</div><div class="line">com.imooc.movie.MyClassMusic</div></pre></td></tr></table></figure></p>
<p>系统中的包<br>java.lang.(类) 放置java语言基础类<br>java.util.(类)放置java语言工具类<br>java.io.(类)包含输入输出相关功能的类</p>
<p>包的使用</p>
<ol>
<li>可以使用import关键字，在某个文件使用其他文件中的类。<code>import com.imooc.music.MyClass</code></li>
<li>java中，包的命名规范是全小写字母拼写</li>
<li>使用的时候不但可以加载某个包下的所有文件<code>com.imooc.*</code>。也可以加载某个具体子包下的所有文件<code>com.imooc.music.*</code></li>
</ol>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>修饰属性和方法的访问范围<br><img src="/img/Java011.jpg" alt=""></p>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>this关键字代表当前对象<br><code>this.属性</code> 操作当前对象的属性<br><code>this.方法</code> 调用当前对象的方法</p>
<p>封装对象的属性的时候，经常会使用this关键字</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。</p>
<p>内部类作用：</p>
<ol>
<li>内部类提供了更好的<strong>封装</strong>，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li>
<li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li>
<li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li>
</ol>
<p>内部类分类</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>方法内部类</li>
<li>匿名内部类</li>
</ul>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>内部类中最常见的就是成员内部类，也称为普通内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Outer&#123;</div><div class="line">	private int a = 99;</div><div class="line">	public class Inner&#123;</div><div class="line">		int b = 2;</div><div class="line">		public void test()&#123;</div><div class="line">			System.out.println(&quot;外部类中的变量a：&quot;+a);</div><div class="line">			System.out.println(&quot;内部类中的变量b：&quot;+b);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Outer outer = new Outer();</div><div class="line">		Inner i = outer.new Inner();</div><div class="line">		i.test();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 <code>public</code> 、 <code>protected</code> 、 <code>private</code> 等。</li>
<li>Inner 类中定义的 test() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a。</li>
<li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：<code>内部类 对象名 = 外部类对象.new 内部类( );</code></li>
<li>编译上面的程序后，会发现产生了两个 .class 文件，成员内部类的 .class 文件总是这样命名：<code>外部类名$内部类名.class</code></li>
</ol>
<p>外部类是不能直接使用内部类的成员和方法<br><img src="/img/Java012.jpg" alt=""></p>
<p>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字（名字不相同的变量或方法可以直接访问）。<br><img src="/img/Java013.jpg" alt=""></p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类是 static 修饰的内部类，这种内部类的特点是：</p>
<ol>
<li>静态内部类不能直接访问外部类的非静态成员，但可以通过 <code>new 外部类().成员</code> 的方式访问 </li>
<li>如果外部类的静态成员与内部类的成员名称相同，可通过<code>类名.静态成员</code>访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过<code>成员名</code>直接调用外部类的静态成员</li>
<li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <code>内部类 对象名= new 内部类();</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SOuter&#123;</div><div class="line">    private int a = 99;</div><div class="line">    static int b = 1;</div><div class="line">    int c = 3;</div><div class="line">    public static class SInner&#123;</div><div class="line">        int b = 2;</div><div class="line">        public void test()&#123;</div><div class="line">            System.out.println(&quot;访问外部类的私有成员a：&quot;+new SOuter().a);</div><div class="line">            System.out.println(&quot;访问外部类的静态成员b：&quot;+SOuter.b);</div><div class="line">            System.out.println(&quot;访问外部类的非静态成员c：&quot;+ new SOuter().c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        SInner  si = new SInner();</div><div class="line">        si.test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h4><p>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。<br>由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类<strong>不能使用访问控制符和 static 修饰符</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class MOuter&#123;</div><div class="line">    public void show()&#123;</div><div class="line">        final int a = 25;</div><div class="line">        int b = 13;</div><div class="line">        class MInner&#123;</div><div class="line">            int c = 2;</div><div class="line">            public void print()&#123;</div><div class="line">                System.out.println(&quot;访问外部类的方法中的常量a：&quot;+a);</div><div class="line">                System.out.println(&quot;访问外部类中的变量b：&quot;+b);</div><div class="line">                System.out.println(&quot;访问内部类中的变量c：&quot;+c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        MInner mi = new MInner();</div><div class="line">        mi.print();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        MOuter mo = new MOuter();</div><div class="line">        mo.show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是类与类的一种关系；Java中的继承是单继承，只有一个父类。</p>
<p>继承的好处：</p>
<ol>
<li>子类拥有父类的所有属性和方法。(private修饰的属性和方法无法继承)</li>
<li>代码可复用</li>
</ol>
<p>语法规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class 子类 extends 父类&#123;</div><div class="line">	……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>如果子类对继承父类的方法不满意，是可以重写父类继承的方法的，当调用方法时会优先调用子类的方法。</p>
<p>语法规则</p>
<ol>
<li>返回值类型 </li>
<li>方法名 </li>
<li>参数类型及个数<br>都要与父类继承的方法相同，才叫方法的重写。</li>
</ol>
<p>重写方法的规则：</p>
<ol>
<li>参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</li>
<li>返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。如果在子类中写了一个只有返回类型不同的函数，将不是重写，且会报错</li>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</li>
</ol>
<p>重载的规则：</p>
<ol>
<li>必须具有不同的参数列表。</li>
<li>可以有不责骂的返回类型，只要参数列表不同就可以了。</li>
<li>可以有不同的访问修饰符。</li>
<li>可以抛出不同的异常。</li>
</ol>
<p>重写与重载的区别在于：</p>
<ol>
<li>重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。</li>
<li>用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般.</li>
<li>重写是除了函数体其他必须完全相同，如果参数不同则是重载，如果参数相同而返回类型不同则会报错</li>
</ol>
<h4 id="继承的初始化顺序"><a href="#继承的初始化顺序" class="headerlink" title="继承的初始化顺序"></a>继承的初始化顺序</h4><ol>
<li>初始化父类再初始化子类。<br>2.先执行初始化对象中属性，再执行构造方法中的初始化。</li>
</ol>
<p>综合以上两点，顺序为：<br>父类属性初始化—》父类构造方法—》子类属性初始化—》子类构造方法。</p>
<p>在一个不存在继承的类中：初始化static变量—》执行static初始化快—》初始化普通成员变量(如果有赋值语句)—》执行普通初始化块—》构造方法</p>
<p>在一个存在继承的类中：初始化父类static成员变量—》运行父类static初始化块—》初始化子类static成员变量—》运行子类static初始化块—》初始化父类实例成员变量(如果有赋值语句)—》执行父类普通初始化块—》父类构造方法—》初始化子类实例成员变量(如果有赋值语句)及普通初始化块—》子类构造方法。</p>
<p>注意：其中变量初始化(赋值)和初始化块的执行与相关语句在源码中的放置顺序一致，不过变量声明会最先执行</p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final关键字表示“最终的”，即不可修改。</p>
<p>final可以修饰类、方法、属性和变量</p>
<ol>
<li>修饰类：不允许被继承</li>
<li>修饰方法：不允许被重写</li>
<li>修饰属性：则该属性不会进行隐式初始化（不会自动初始化），需要手动初始化或者在构造方法中初始化 （但二者只能选一，即只能初始化一次后便不能更改）</li>
<li>修饰变量，只能在声明的时候赋一次值，成为常量。 （static final 会使其成为全局常量）</li>
</ol>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>super关键字在对象内部使用，代表父类对象</p>
<ol>
<li>访问父类的属性<code>super.age</code></li>
<li>访问父类方法<code>super.eat();</code></li>
<li>调用父类的构造方法<code>super([参数]);</code></li>
</ol>
<p>调用父类的构造方法需要注意：<br>1.子类的构造过程中必须调用其父类的构造方法<br>2.如果子类的构造方法没有显式调用父类的构造方法，则系统会默认调用父类的无参构造方法。<br>3.如果显示的调用构造方法，必须在子类的构造方法的第一行，super()。<br>4.如果子类的构造方法中既没有显示调用父类的构造方法，父类又没有无参的构造方法，则编译就会报错</p>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Object类是所有类的父类，如果一个类没有使用<code>extends</code>关键字明确标识继承另外一个类，那么这个类默认继承Object类，且Object类中的方法适用于所有子类</p>
<h5 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h5><p>在Object类中的toString()方法返回对象的哈希code码(对象地址字符串)</p>
<p>如果我们在代码里面直接输出一个对象<code>System.out.println(new TelePhone);</code>，会输出这个对象在内存中的地址，我们把它称为哈希码，哈希码是通过哈希算法生成的一个字符串用来唯一区分对象的</p>
<p>可以通过重写<code>toString()</code>方法表示出对象的属性</p>
<h5 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass()方法"></a>getClass()方法</h5><p>getClass()可以得到一个类对象，当我们new的时候得到的是一个类的对象，如果对象调用getClass()方法我们得到的是类对象，类对象描述的是类的代码信息(类的代码信息:这个类有哪些属性\它是什么类型\变量名是什么\它有哪些方法\方法名是什么\方法里面的代码是什么；而类的对象关注的是对象的属性值的信息或者说这个对象的数据信息)</p>
<h5 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h5><p>Object类中的<code>equals()</code>用于比较对象的引用是否指向同一块内存地址（对象实例化时，即给对象分配内存空间）</p>
<p>在比较引用对象是否相同时，==比较对象是否相等和equals一样于比较对象的引用是否指向同一块内存地址（对象实例化时，即给对象分配内存空间）</p>
<p>在比较引用对象是否相同时，==比较对象是否相等和equals一样</p>
<p>使用方法如：<code>dog.equals(dog2);</code></p>
<p>如果是两个对象，但想判断两个对象的属性是否相同，则重写<code>equals()</code>方法（ecplise和Intellij都提供了自动生成重写equals方法的功能，<code>equals() and hascode()</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">	//地址是否相同，即是否为同一对象</div><div class="line">	if (this == o) return true;</div><div class="line">	//对象是否为空，getClass()可以得到类对象，判断类的属性是否一样</div><div class="line">	if (o == null || getClass() != o.getClass()) return false;</div><div class="line">	Telephone telephone = (Telephone) o;</div><div class="line">	return Float.compare(telephone.cpu, cpu) == 0 &amp;&amp;</div><div class="line">			Float.compare(telephone.screen, screen) == 0 &amp;&amp;</div><div class="line">			Float.compare(telephone.mem, mem) == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态指的是对象的多种形态<br>主要分为引用多态、方法多态<br>继承是多态的实现基础</p>
<h4 id="引用多态"><a href="#引用多态" class="headerlink" title="引用多态"></a>引用多态</h4><ol>
<li>父类引用可以指向本类对象 <code>Animal obj1 = new Animal();</code></li>
<li>父类引用可以指向子类对象 <code>Animal obj2 = new Dog();</code><br>但是我们不能用子类的引用指向父类对象 <code>Dog obj3 = new Animal();//错</code></li>
</ol>
<h4 id="方法多态"><a href="#方法多态" class="headerlink" title="方法多态"></a>方法多态</h4><ol>
<li>父类创建本类对象时，调用的方法为本类方法</li>
<li>父类创建子类对象时候，调用的方法为子类重写的方法或者父类的方法</li>
</ol>
<p>不能父类引用调用子类自己的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Animal obj1 = new Animal();</div><div class="line">Animal obj2 = new Dog();</div><div class="line">Animal obj3 = new Cat();</div><div class="line"></div><div class="line">obj1.eat();//Animal的方法</div><div class="line">obj2.eat();//Dog重写的方法</div><div class="line">obj3.eat();//Cat没有重写，使用继承自Animal中的方法</div><div class="line"></div><div class="line">obj2.watchDoor();//不能父类引用调用子类自己的方法</div></pre></td></tr></table></figure>
<h4 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h4><ol>
<li>向上类型转换（隐式/自动类型转换），小类型到大类型的转换</li>
<li>向下类型转换（强制类型转换），大类型到小类型的转换（存在风险，溢出）</li>
<li>instanceof运算符，用来解决引用对象的类型，避免类型转换的安全性问题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Dog dog=new Dog();</div><div class="line">Animal animal=dog;//正确，自动类型提升，向上类型转换</div><div class="line">Dog dog1=(Dog)animal;//向下类型转换</div><div class="line">Cat cat=(Cat)animal;</div><div class="line">/*编译时不会出错（按Cat类型进行编译），但运行时会报错，</div><div class="line">因为它开辟的是Dog类型的空间，而（无法将引用类型进行转换）</div><div class="line">无法将dog对象转换成Cat类型，并且此方法对程序的安全性有影响。</div><div class="line">此时应该利用instanceof和if语句结合使用，进行验证，</div><div class="line">以保证程序的安全性</div><div class="line">*/</div><div class="line">if(animal instanceof Cat)&#123;</div><div class="line">	//判断animal类中是否包含Cat类型的元素，若包含则进行转换，instanceof返回值为布尔类型</div><div class="line">	Cat cat=(Cat)animal;</div><div class="line">&#125;else&#123;</div><div class="line">System.out.println(&quot;无法进行类型转换&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类钱使用<code>abstract</code>关键字修饰，则该类为抽象类。</p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li>在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法</li>
<li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性</li>
</ol>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>限制规定子类必须实现某些方法，但不关注实现细节</p>
<h5 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h5><ol>
<li>abstract定义抽象类</li>
<li>abstract定义抽象方法，只有声明，不需要实现，没有方法体</li>
<li>包含抽象方法的类是抽象类</li>
<li>抽象类中可以包含普通的方法，也可以没有抽象方法</li>
<li>抽象类不能直接创建，可以使用引用变量</li>
<li>只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape &#123;</div><div class="line">    public abstract float circuit();//周长</div><div class="line">    public abstract float area();//面积</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>接口可以理解为一种特殊的类，由<strong>全局常量</strong>和<strong>公共的抽象方法</strong>所组成。</p>
<p>类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>和类定义不同，定义接口不再使用<code>class</code>关键字，而是使用<code>interface</code>关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[修饰符] [abstract] interface 接口名 [extends 父接口1，父接口2...]</div><div class="line">&#123;</div><div class="line">    零个到多个常量定义...</div><div class="line">    零个到多个抽象方法的定义...(抽象方法的abstract会自动加)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口就是用来被继承、被实现的，修饰符一般建议用public，注意:不能使用private和protected修饰接口<br>接口中的属性是常量，即使定义时不添加<code>public static final</code>修饰符，系统也会自动加上<br>接口中的方法只能是抽象方法，即使定义时不添加<code>public abstract</code>修饰符，系统也会自动加上</p>
<p>一个类可以实现一个或多和接口，实现接口使用implements关键字。java中一个类只能继承一个父类，可以通过实现多个接口作补充</p>
<p>继承父类实现接口的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[修饰符] class 类名 extends 父类 implements 接口1，接口2……&#123;</div><div class="line">类体部分//如果继承的是抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果要继承父类，继承父类必须在实现接口之前<br>接口命名时通常首字母为I，以区分类名</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>实现时可以利用接口的引用指向实现了接口的对象，调用其方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IPlayGame ip1 = new Psp();</div><div class="line">IPlayGame ip2 = new SmartPhone();</div><div class="line">ip1.playGame();</div><div class="line">//Psp和SmartPhone都是实现了IPlayGame接口的playGame方法</div></pre></td></tr></table></figure></p>
<h5 id="配合匿名内部类使用"><a href="#配合匿名内部类使用" class="headerlink" title="配合匿名内部类使用"></a>配合匿名内部类使用</h5><p>接口的使用还经常与匿名内部类配合<br>匿名内部类就是没有名字的内部类，多用于关注实现而不关注实现类的名称</p>
<p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">IPlayGame ip=new IPlayGame()&#123;</div><div class="line">	public void playGame()&#123;</div><div class="line">		System.out.print(&quot;匿名内部类实现接口的方式……&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">ip.playGame();</div></pre></td></tr></table></figure></p>
<p>即通过创建接口的对象，直接写出实现的方法，再调用此方法<br>注意结尾的逗号</p>
<p>还可以直接创建并调用方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new IPlayGame()&#123;</div><div class="line">	public void playGame()&#123;</div><div class="line">		System.out.println(&quot;……&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;.playGame();</div></pre></td></tr></table></figure></p>
<h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><ol>
<li>数据模型分析</li>
<li>业务模型分析</li>
<li>显示和流程分析</li>
</ol>
<h3 id="数据模型分析"><a href="#数据模型分析" class="headerlink" title="数据模型分析"></a>数据模型分析</h3><p>将现实世界的事与物的主要特征 –分析–抽象–&gt; 信息系统数据存取的数据结构以及约束信息，数据结构的组成：操作（方法）、属性</p>
<h3 id="业务模型分析"><a href="#业务模型分析" class="headerlink" title="业务模型分析"></a>业务模型分析</h3><p>在设计应用程序前，应该明确该应用必须执行哪些任务。</p>
<ul>
<li>分析业务需求量是应用程序开发中最重要的步骤之一。</li>
<li>确认业务需求的目的在于创建一个能同时满足零售商和消费者需要的解决方案。</li>
</ul>
<h3 id="显示和流程分析"><a href="#显示和流程分析" class="headerlink" title="显示和流程分析"></a>显示和流程分析</h3><ol>
<li>显示：用户可以看到的信息提示界面</li>
<li>流程：显示信息的执行过程和步骤</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>阻止当前方法或作用域正常运行</p>
<h3 id="异常处理的作用"><a href="#异常处理的作用" class="headerlink" title="异常处理的作用"></a>异常处理的作用</h3><h3 id="Java异常体系结构"><a href="#Java异常体系结构" class="headerlink" title="Java异常体系结构"></a>Java异常体系结构</h3><p>所有异常都继承于<code>Throwable</code>类，其下有两大子类：</p>
<ol>
<li><code>Error</code>类：错误，如虚拟机错误(VirtualMachineError)、线程死锁(ThreadDeath)。会使程序崩溃</li>
<li><code>Exception</code>类：异常，编码、环境、用户输入等问题</li>
</ol>
<p><code>Exception</code>类其子类主要有：</p>
<ul>
<li>非检查异常(运行时异常RuntimeException)，由java虚拟机自动捕获</li>
<li>检查异常CheckException，需要手动添加捕获和处理语句，包括文件异常IOException、SQL异常SQLException等</li>
</ul>
<p><img src="/img/Java014.jpg" alt=""></p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>try-catch（多catch块）-finally</p>
<ol>
<li>try块：负责捕获异常，一旦try中发现异常，程序的控制权将被移交给catch块中的异常处理程序。【try语句块不可以独立存在，必须与 catch 或者 finally 块同存】</li>
<li>catch块：如何处理？比如发出警告：提示、检查配置、网络连接，记录错误等。执行完catch块之后程序跳出catch块，继续执行后面的代码。<br>·编写catch块的注意事项：多个catch块处理的异常类，要按照先catch子类后catch父类的处理方式，因为会【就近处理】异常（由上自下）。</li>
<li>finally：最终执行的代码，用于关闭和释放资源等，无论是否出现异常，finally块中代码都会执行</li>
</ol>
<p><img src="/img/Java015.jpg" alt=""><br>多重异常处理代码块顺序问题：先子类再父类（顺序不对也会提醒错误），finally语句块处理最终将要执行的代码</p>
<p>当try和catch中有return时，finally仍然会执行，顺序如下<br>1）有错误情况下<br>如果finally块中有return语句，try语句 -&gt; catch -&gt; finally -&gt; finally.return<br>如果finally块中没有return语句，try语句 -&gt; catch -&gt; finally -&gt; catch.return<br>2）无错误情况下<br>如果finally{}块中有return语句，try语句 -&gt; finally -&gt; finally.return<br>如果finally{}块中没有return语句，try语句 -&gt; finally -&gt; try.return</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class TryCatchTest &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        TryCatchTest tct = new TryCatchTest();</div><div class="line">        int x = tct.test();</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int test()&#123;</div><div class="line">        try&#123;</div><div class="line">            System.out.println(&quot;try&quot;);</div><div class="line">            throw  new Exception(&quot;xxx&quot;);</div><div class="line">            //return 999;</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            System.out.println(&quot;catch&quot;);</div><div class="line">            return -1;</div><div class="line">			//-1为抛出异常的习惯写法</div><div class="line">        &#125;</div><div class="line">        finally &#123;</div><div class="line">            System.out.println(&quot;finally&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果方法中try,catch,finally中没有return语句，则会调用这三个语句块之外的return结果<br>e.printStackTrace()可以输出异常信息</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>1.throws的异常列表可以是抛出一条异常，也可以是抛出多条异常，每个类型的异常中间用逗号隔开<br>2.方法体中调用会抛出异常的方法或者是先抛出一个异常：用<code>throw new Exception()</code>，<code>throw</code>写在方法体里，表示“抛出异常”这个动作<br>3.如果某个方法调用了抛出异常的方法，那么必须添加<code>try... catch</code>语句去尝试捕获这种异常，或者添加声明，将异常抛出给更上一层的调用者进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void 方法名（参数列表）throws 异常列表&#123;</div><div class="line">	//调用会抛出异常的方法或者：</div><div class="line">	throw new Exception();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>当实际应用中需要用到Java中没有的异常，就需要自定义异常<br>自定义异常需要继承于Java类库中意思相近的异常，或者直接继承Exception<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class 自定义异常类 extends 异常类型｛｝</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class DrunkException  extends Exception &#123;</div><div class="line">	public DrunkException()&#123;&#125;</div><div class="line">	public DrunkException(String message)&#123;super(message);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>异常链指将捕获的异常包装进一个新的异常中，在新异常里添加原始的异常，并重新抛出的异常处理方式。原异常被保存为新异常的一个属性（比如cause）。这个想法是指一个方法应该抛出定义在相同的抽象层次上的异常，但不会丢弃更低层次的信息。</p>
<p>一个方法应该抛出定义在相同的抽象层次上的异常，（将所有捕获到的异常包装为新的异常类，即定义在相同的抽象层次上抛出）但不会丢弃更低层次的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class chainTest &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	* @param args</div><div class="line">	* Test1抛出喝大了异常</div><div class="line">	* Test2调用test1捕获了喝大了异常，并且包装成运行时异常，继续抛出</div><div class="line">	* main方法中调用test2尝试捕获test2方法抛出的异常</div><div class="line">	*/</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		try&#123;	</div><div class="line">			chainTest ct=new chainTest();</div><div class="line">			ct.Test2();&#125;</div><div class="line">		catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void Test1()throws DrunkException&#123;</div><div class="line">		throw new DrunkException(&quot;喝车别开酒&quot;);</div><div class="line">	&#125;</div><div class="line">	public void Test2()&#123;</div><div class="line">		try&#123;</div><div class="line">			Test1();</div><div class="line">		&#125;catch( DrunkException e)&#123;</div><div class="line">			RuntimeException rte=new RuntimeException(e);</div><div class="line">			//运行时异常，是所有java虚拟机正常操作期间可以被抛出异常的父类</div><div class="line">			//rte.initCause(e);</div><div class="line">			//一种对异常的一种包装技巧。initCause()的作用是保存原始的异常，当想要知道底层发生了什么异常的时候调用getCause()就能获得原始异常。</div><div class="line">			e.printStackTrace();</div><div class="line">			throw rte;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/img/Java016.jpg" alt=""></p>
<ol>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理</li>
<li>在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常</li>
<li>对于不确定的代码，也可以加上try-catch，处理潜在的异常</li>
<li>尽量去处理异常，切记只是简单的调用printStackTrace（）去打印</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li>
<li>尽量添加finally语句块去释放占用的资源</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串被作为 String 类型的对象处理。 String 类位于 java.lang 包中。默认情况下，该包被自动导入所有的程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;jj&quot;;</div><div class="line">//s1存放了到字符串对象的引用</div><div class="line">String s2 = new String();</div><div class="line">String s3 = new String(&quot;jj&quot;);</div></pre></td></tr></table></figure></p>
<p>String 对象创建后则不能被修改，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不同。</p>
<p> 一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder</p>
<p>每次 new 一个字符串就是产生一个新的对象，即便两个字符串的内容相同，使用 <code>==</code>比较时也为 ”false” ,如果只需比较内容是否相同，应使用 <code>equals()</code>方法</p>
<p><img src="/img/Java017.jpg" alt=""></p>
<ul>
<li>字符串中字符的索引从0开始，范围为 0 到 str.length()-1</li>
<li>使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1</li>
<li>使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">String str = &quot;学习 JAVA 编程&quot;;</div><div class="line">System.out.println(&quot;字符串长度：&quot;+str.length());</div><div class="line">char c = &apos;编&apos;;</div><div class="line">System.out.println(&quot;字符串‘编’的位置：&quot;+str.indexOf(c));</div><div class="line">System.out.println(&quot;子字符串Java的位置：&quot;+str.indexOf(&quot;JAVA&quot;));</div><div class="line">System.out.println(&quot;子字符串imooc的位置：&quot;+str.indexOf(&quot;java&quot;));</div><div class="line">String[] arr = str.split(&quot; &quot;);</div><div class="line">System.out.println(&quot;按空格拆分成数组：&quot;+Arrays.toString(arr));</div><div class="line">System.out.println(&quot;获取位置[3，7)之间的子字符串：&quot;+str.substring(3,7));</div><div class="line">System.out.println(&quot;转换为小写：&quot;+str.toLowerCase());</div><div class="line">System.out.println(&quot;获取索引位置为3的字符：&quot;+str.charAt(3));</div><div class="line"></div><div class="line">System.out.print(&quot;将字符串转换为byte数组：&quot;);</div><div class="line">byte[] bytes = str.getBytes();</div><div class="line">for(int i=0;i&lt;bytes.length;i++)&#123;</div><div class="line">	System.out.print(&quot;bytes&quot;+i+&quot;:&quot;+bytes[i] + &quot; &quot;);	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">字符串长度：10</div><div class="line">字符串‘编’的位置：8</div><div class="line">子字符串Java的位置：3</div><div class="line">子字符串imooc的位置：-1</div><div class="line">按空格拆分成数组：[学习, JAVA, 编程]</div><div class="line">获取位置[3，7)之间的子字符串：JAVA</div><div class="line">转换为小写：学习 java 编程</div><div class="line">获取索引位置为3的字符：J</div><div class="line">将字符串转换为byte数组：bytes0:-27 bytes1:-83 bytes2:-90 bytes3:-28 bytes4:-71 bytes5:-96 bytes6:32 bytes7:74 bytes8:65 bytes9:86 bytes10:65 bytes11:32 bytes12:-25 bytes13:-68 bytes14:-106 bytes15:-25 bytes16:-88 bytes17:-117</div></pre></td></tr></table></figure>
<p>1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，1 个英文字符存储需要 1 个字节。字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过 127，如果超过就会溢出，以负数的形式显示。</p>
<p>==” 和 equals() 有什么区别: </p>
<ul>
<li>==: 判断两个字符串在内存中首地址是否相同，即判断是否是同一个字符串对象</li>
<li>equals(): 比较存储在两个字符串对象中的内容是否一致</li>
</ul>
<p>比较字符用<code>==</code></p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>String 类具有是不可变性，多个字符串进行拼接了以后产生一个新的临时变量并指向一个新的对象或新的地址。使用 StringBuilder 或 StringBuffer 就可以避免这个问题。</p>
<p>StringBuilder 和StringBuffer ，它们基本相似，不同之处，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuilder str1 = new StringBuilder();</div><div class="line">StringBuilder str2 = new StringBuilder(&quot;imooc&quot;);</div></pre></td></tr></table></figure>
<p><img src="/img/Java018.jpg" alt=""></p>
<p>在需要频繁对字符串进行修改操作时使用 StringBuilder 的效率比 String 要高</p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>为了让基本数据类型也具备对象的特性， Java 为每个基本数据类型都提供了一个包装类，这样我们就可以像操作对象那样来操作基本数据类型。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<p>包装类主要提供了两大类方法：</p>
<ol>
<li>将本类型和其他基本类型进行转换的方法</li>
<li>将字符串和本类型及包装类互相转换的方法</li>
</ol>
<h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int i = 2;</div><div class="line">Integer m = new Integer(8);</div><div class="line">Integer n = new Integer(&quot;8&quot;);</div></pre></td></tr></table></figure>
<p>常用方法</p>
<p>|   返回值   |   方法名     |   解释    |<br>|   byte   |    byteValue()    |   将该Integer转为byte类型    |<br>|   double   |     doubleValue()   |    转为double类型   |<br>|   float   |   floatValue     |   转为float类型    |<br>|   int   |    intValue()    |   转为int类型    |<br>|   long   |    longValue()    |   转为long类型    |<br>| static  int   |   parseInt(String s)     |   将字符串转换为int类型    |<br>|   String   |   toString     |   转为字符串类型    |<br>|  static  Integer  |    valueOf(String s)    |   将字符串转换为Integer类型    |</p>
<h4 id="基本类型和包装类之间的转换"><a href="#基本类型和包装类之间的转换" class="headerlink" title="基本类型和包装类之间的转换"></a>基本类型和包装类之间的转换</h4><p>装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int i = 10</div><div class="line">Integer x = new Integer(i);//手动装箱</div><div class="line">Integer y = i;//自动装箱</div></pre></td></tr></table></figure></p>
<p>拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer j = new Integer(8);</div><div class="line">int m = j.intValue(); //手动拆箱</div><div class="line">int n = j; //自动拆箱</div></pre></td></tr></table></figure>
<h4 id="基本类型和字符串之间的转换"><a href="#基本类型和字符串之间的转换" class="headerlink" title="基本类型和字符串之间的转换"></a>基本类型和字符串之间的转换</h4><p>基本类型转换为字符串有三种方法：</p>
<ol>
<li>使用包装类的 toString() 方法</li>
<li>使用String类的 valueOf() 方法</li>
<li>用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int c = 10;</div><div class="line">String str1 = Integer.toString(c);</div><div class="line">String str2 = String.valueOf(c);</div><div class="line">String str3 = c + &quot;&quot;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>将字符串转换成基本类型有两种方法:</p>
<ol>
<li>调用包装类的 parseXxx 静态方法</li>
<li>调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;8&quot;;</div><div class="line">int a = Integer.parseInt(str);</div><div class="line">int b = Integer.valueOf(str);</div></pre></td></tr></table></figure>
<h3 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h3><p>java.util 包中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Date d = new Date();</div><div class="line">System.out.println(d);</div><div class="line">// 默认输出当前时间</div><div class="line">// Thu Jul 05 11:39:09 CST 2018</div></pre></td></tr></table></figure>
<p>java.text 包中的 SimpleDateFormat 类可以对日期时间进行格式化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用 format() 方法将日期转换为指定格式的文本</div><div class="line">Date d1 = new Date();</div><div class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">String today = sdf.format(d1);</div><div class="line">System.out.println(today);</div><div class="line"></div><div class="line">//使用 parse() 方法将文本转换为日期</div><div class="line">String day = &quot;2014年02月14日 10:30:25&quot;;</div><div class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</div><div class="line">Date date = sdf1.parse(day);</div><div class="line">System.out.println(&quot;当前时间&quot;+date);</div></pre></td></tr></table></figure>
<p>调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行异常处理    </p>
<p>使用 Date 类时需要导入 java.util 包，使用 SimpleDateFormat 时需要导入 java.text 包</p>
<h3 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h3><p>Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用 Calendar 类进行时间和日期的处理。</p>
<p><code>java.util.Calendar</code>类是一个抽象类，可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 <code>Calendar c = Calendar.getInstance();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Calendar c = Calendar.getInstance();</div><div class="line">int year = c.get(Calendar.YEAR);</div><div class="line">int month = c.get(Calendar.MONTH) + 1; //0表示1月份</div><div class="line">int day = c.get(Calendar.DAY_OF_MONTH);</div><div class="line">int hour = c.get(Calendar.HOUR);</div><div class="line">int minute = c.get(Calendar.MINUTE);</div><div class="line">int second = c.get(Calendar.SECOND);</div><div class="line">System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日 &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second);</div><div class="line"></div><div class="line">Date d = c.getTime(); //Calendar 和 Date 的转换</div><div class="line">Long time = c.getTimeInMillis(); //获取此 Calendar 的时间值，以毫秒为单位</div></pre></td></tr></table></figure>
<h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><p>Math 类位于 java.lang 包中，包含用于执行基本数学运算的方法， Math 类的所有方法都是静态方法，所以使用该类中的方法时，可以直接使用<code>类名.方法名</code>，</p>
<p>不需要导入包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int y = (int)(Math.random()*99);</div><div class="line"># 产生[0,99)之间的随机整数</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;JVM-JRE-JDK&quot;&gt;&lt;a href=&quot;#JVM-JRE-JDK&quot; class=&quot;headerlink&quot; title=&quot;JVM
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://yoursite.com/post/7a8ab919.html"/>
    <id>http://yoursite.com/post/7a8ab919.html</id>
    <published>2018-06-23T08:23:53.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件测试概要"><a href="#软件测试概要" class="headerlink" title="软件测试概要"></a>软件测试概要</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>软件测试是对程序能够按预期运行建立起一种信心  ——Bill Hetzel,1973</li>
<li>测试是为发现错误而执行程序的过程            ——Myers,1979</li>
<li>使用人工或自动的<strong>手段</strong>来运行或测量软件系统的过程，以检测软件系统是否满足<strong>规定的要求</strong>，并找出与<strong>预期定义</strong>之间的差异。        ——IOS/IEC/IEEE 29119</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>软件测试覆盖整个软件研发过程</p>
<ul>
<li>软件需求</li>
<li>概要设计</li>
<li>详细设计</li>
<li>源代码</li>
<li>可运行程序</li>
<li>可运行环境</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><img src="/img/IMG142.png" alt=""></p>
<h3 id="五大要素及两大目标"><a href="#五大要素及两大目标" class="headerlink" title="五大要素及两大目标"></a>五大要素及两大目标</h3><p>要素：</p>
<ul>
<li>质量(最为核心)</li>
<li>人员(决定因素)</li>
<li>技术(实现手段)【测试技术，方法，测试工具】</li>
<li>资源【测试所需的硬件，网络环境，测试生命周期，测试时间】</li>
<li>流程(测试标准)【测试计划，测试执行，报告】</li>
</ul>
<p>目标</p>
<ul>
<li>提升测试覆盖率</li>
<li>测试效率</li>
</ul>
<h3 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h3><ol>
<li>测试显示软件的存在，但不能证明系统不存在缺陷</li>
<li>穷极测试是不可能的，应设定及时终止的条件（无穷无尽的测试是不可能的，需很大代价；无论怎样测试，我们不可能发现软件的所有缺陷）</li>
<li>测试应该尽早进行</li>
<li>缺陷具备群集特性（发现越多错误的模块，越应该集中关注，可能该模块的编程人员的水平较低）</li>
<li>测试的杀虫剂悖论（用相同的用例多次测试时发现不了bug的，应该更新测试方法和用例）</li>
<li>测试的二八原则（80%的时间测试20%的重要模块）</li>
<li>测试活动依赖于测试背景（针对不同的软件的测试方法是不同的，比如电信软件看中性能、大批量；银行看中安全性）</li>
</ol>
<p>术语<strong>杀虫剂悖论</strong>（The Pesticide Paradox）用来描述这样一种现象，即你对软件进行越多的测试，那么该软件对你的测试就越具有免疫力。同样的事情发生在对昆虫使用杀虫剂上。如果你持续使用同样的杀虫剂，这些昆虫最终将建立起抵抗力，杀虫剂将不再发挥作用。<br>为了克服“杀虫剂悖论”，软件测试人员必须不断地编写新的不同的测试来检验程序的不同部分从而找出更多的bug。<br>让其他的人来测试你的程序将有助于打破“杀虫剂悖论”。</p>
<p><img src="/img/IMG143.png" alt=""></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;软件测试概要&quot;&gt;&lt;a href=&quot;#软件测试概要&quot; class=&quot;headerlink&quot; title=&quot;软件测试概要&quot;&gt;&lt;/a&gt;软件测试概要&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>nmap使用</title>
    <link href="http://yoursite.com/post/30bf2354.html"/>
    <id>http://yoursite.com/post/30bf2354.html</id>
    <published>2018-06-22T14:00:49.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nmap.org/" target="_blank" rel="external">Nmap</a>(Network Mapper)是一款用于网络发现（Network Discovery）和安全审计（Security Audting）的安全工具，采用C++语言编写，常用于<strong>端口扫描</strong>。<br>Nmap软件包带有一个名为GUI的包zenmap，使用Python编写。</p>
<h2 id="安装nmap"><a href="#安装nmap" class="headerlink" title="安装nmap"></a>安装nmap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nmap</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>最简单的形式是只传递地址或域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmap scanme.nmap.org</div><div class="line">nmap 74.207.244.221</div><div class="line">nmap 192.168.1.200</div></pre></td></tr></table></figure></p>
<h3 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h3><p>扫描结果中显示的商品状态</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>开放，探测报文到达了端口，端口有响应：我有应用程序监听 - SYN/ACK</td>
</tr>
<tr>
<td>closed</td>
<td>关闭，探测报文到达了端口，端口有响应：我没应用程序监听 - RST (复位)</td>
</tr>
<tr>
<td>filtered</td>
<td>被屏蔽，探测报文到不了端口，石沉大海</td>
</tr>
<tr>
<td>unfiltered</td>
<td>没有被屏蔽，还需要确认，探测报文到达了端口，没响应了</td>
</tr>
<tr>
<td>open &#124; filtered</td>
<td>开放或屏蔽，有可能报文过滤器丢弃了探测报文（filtered），或丢弃了端口的响应报文 (open)(原理请往下看 -sN，-sF，-sX)UDP，IP 协议， FIN，Null，和 Xmas 扫描可能把端口归入此类</td>
</tr>
<tr>
<td>closed &#124; unfiltered</td>
<td>关闭或屏蔽，IPID+1，但是 closed 和 unfiltered 都可能导致只 + 1，所以就不确定了。只可能出现在 IP ID Idle 扫描中（看下端口 TCP 空闲扫描的原理就知道为什么了）</td>
</tr>
</tbody>
</table>
<h3 id="扫描类型"><a href="#扫描类型" class="headerlink" title="扫描类型"></a>扫描类型</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sT　　</td>
<td>TCP 连接扫描，会在目标主机中记录大量的链接请求和错误信息</td>
</tr>
<tr>
<td>-sS　　</td>
<td>SYN 扫描，隐蔽扫描，不创建完整连接，只完成三次握手前两次，很少有系统记入日志，默认使用，需要 root(admin) 权限</td>
</tr>
<tr>
<td>-sP　　</td>
<td>Ping 扫描，默认使用，只有能 Ping 得通才会继续扫描</td>
</tr>
<tr>
<td>-P0　　</td>
<td>扫描之前不需要 Ping，用于绕过防火墙禁 Ping 功能</td>
</tr>
<tr>
<td>-sA　　</td>
<td>高级的扫描方式，用来穿过防火墙的规则集</td>
</tr>
<tr>
<td>-sV　　</td>
<td>服务的详细信息　</td>
</tr>
<tr>
<td>-sU　　</td>
<td>UDP 扫描，扫描主机开启的 UDP 的服务，速度慢，结果不可靠　</td>
</tr>
<tr>
<td>-sX -sN 　　</td>
<td>秘密的 FIN 数据包扫描，圣诞树 (Xmas Tree) 和空模式，针对 Unix 和 Linux 主机，系统要求遵循 TCP RFC 文档</td>
</tr>
</tbody>
</table>
<h3 id="扫描参数"><a href="#扫描参数" class="headerlink" title="扫描参数"></a>扫描参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v　　</td>
<td>显示扫描过程，推荐使用</td>
</tr>
<tr>
<td>-h　　</td>
<td>帮助文档</td>
</tr>
<tr>
<td>-p　　</td>
<td>指定端口号，如 [1-65535],[22,135,1433,3306,] 等格式</td>
</tr>
<tr>
<td>-O　　</td>
<td>探测操作系统，存在误报</td>
</tr>
<tr>
<td>-A　　</td>
<td>全面系统监测，使用脚本检测，扫描等</td>
</tr>
<tr>
<td>-T4　</td>
<td>针对 TCP 端口禁止动态扫描延迟超过 10ms</td>
</tr>
<tr>
<td>-iL　</td>
<td>　批量扫描，读取主机列表，如 [-iL C:\ip.txt]</td>
</tr>
<tr>
<td>-F</td>
<td>快速扫描</td>
</tr>
<tr>
<td>-V</td>
<td>确定指定端口对应的服务信息</td>
</tr>
<tr>
<td>-eclude</td>
<td>排除IP，多个IP用逗号分隔</td>
</tr>
<tr>
<td>-p</td>
<td>指定端口，多个端口用逗号分隔</td>
</tr>
</tbody>
</table>
<h3 id="扫描案例"><a href="#扫描案例" class="headerlink" title="扫描案例"></a>扫描案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># 扫描 C 段（局域网）存活主机</div><div class="line">nmap -sP www.XXX.com/24</div><div class="line">nmap -sP 192.168.1.*</div><div class="line"></div><div class="line"># 主机发现，通过ICMP ECHO扫描子网中的在线主机</div><div class="line">nmap -v -sn -PE 192.168.1.1/24</div><div class="line">nmap -v -sn -PE 192.168.1.1-5</div><div class="line"></div><div class="line"># 指定商品扫描</div><div class="line">nmap -v -p 135 192.168.1.1-5</div><div class="line"></div><div class="line"># 扫描指定 IP 开放端口号</div><div class="line"># -p-为全端口扫描，和[1-65535]一样，建议使用，不使用默认Nmap认为危险的100个端口号</div><div class="line">nmap -sS -p- -v 192.168.1.100</div><div class="line"></div><div class="line"># 扫描指定 IP 所开端口及对应的服务</div><div class="line">nmap -sV -v 192.168.1.100</div><div class="line"></div><div class="line"># 探测主机操作系统以及硬件信息，扫描准确度以百分比显示，未必准确</div><div class="line">nmap -O www.XXX.com</div><div class="line"></div><div class="line"># 穿透防火墙扫描</div><div class="line">nmap -P0  www.XXX.com</div><div class="line"></div><div class="line"># 全面探测，-A 包含 OS 探测，版本探测，脚本扫描，traceroute</div><div class="line">nmap -A www.XXX.com</div><div class="line"></div><div class="line"># 使用脚本扫描，脚本放在Nmap安装目录script下，官网可查各个脚本功能</div><div class="line">nmap --script=&quot;脚本名称&quot; www.XXX.com</div><div class="line"></div><div class="line"># 如在局域网上扫找 Conficker 蠕虫病毒</div><div class="line">nmap -PN -T4 -p139,445 -n -v --script=smb-check-vulns --script-args safe=1 192.168.0.1-254</div></pre></td></tr></table></figure>
<p>补充：</p>
<ul>
<li><a href="https://github.com/erasin/notes/blob/master/linux/safe/nmap.md" target="_blank" rel="external">https://github.com/erasin/notes/blob/master/linux/safe/nmap.md</a></li>
<li><a href="https://nmap.org/book/history-future.html" target="_blank" rel="external">https://nmap.org/book/history-future.html</a></li>
<li><a href="https://blog.csdn.net/emaste_r/article/details/17840465" target="_blank" rel="external">https://blog.csdn.net/emaste_r/article/details/17840465</a></li>
<li><a href="http://os.chinaunix.net/a2006/0619/956/000000956765.shtml" target="_blank" rel="external">http://os.chinaunix.net/a2006/0619/956/000000956765.shtml</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26676508" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26676508</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Nmap" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Nmap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://nmap.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Nmap&lt;/a&gt;(Network Mapper)是一款用于网络发现（Network Discovery）和安全审计（Security Audting）的安全
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看IP使用情况</title>
    <link href="http://yoursite.com/post/62edaad4.html"/>
    <id>http://yoursite.com/post/62edaad4.html</id>
    <published>2018-06-22T13:59:14.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt install fping</div><div class="line">fping -g -c 1 192.168.1.0/24</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -nsP 192.168.1.1-254</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Cisco Packet Tracer</title>
    <link href="http://yoursite.com/post/5aea5c58.html"/>
    <id>http://yoursite.com/post/5aea5c58.html</id>
    <published>2018-06-22T02:16:28.000Z</published>
    <updated>2018-06-24T00:54:03.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.netacad.com/courses/packet-tracer" target="_blank" rel="external">https://www.netacad.com/courses/packet-tracer</a></p>
<p>注册下载</p>
<!-- ## 环境
需要java和32位包

```
sudo dpkg --add-architecture i386
sudo apt-get install libc6:i386
sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0
sudo apt-get install libnss3-1d:i386 libqt4-qt3support:i386 libssl1.0.0:i386 libqtwebkit4:i386 libqt4-scripttools:i386
``` -->
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将压缩文件解压缩到一个文件夹并打开一个终端。<br>使用sudo权限运行install.sh并按照说明进行安装<br>安装的默认路径是<code>/opt/pt</code></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在终端中键入<code>packettracer</code>来运行<br>如果没有反应，运行<code>/opt/pt/bin/PacketTracer7</code><br>会提示缺少库文件，安装相应库文件后再次运行</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>调整终端字体</strong><br>点击选项（options），点击首选项（Preferences），然后点击字体（Font），选CLI右侧就有大小的选择了。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.christospanoudis.com/how-to-install-packet-tracer-7-1-in-linux-and-resolve-any-dependency-issues/" target="_blank" rel="external">http://www.christospanoudis.com/how-to-install-packet-tracer-7-1-in-linux-and-resolve-any-dependency-issues/</a></li>
<li><a href="https://linux.cn/article-5576-1.html" target="_blank" rel="external">https://linux.cn/article-5576-1.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.netacad.com/courses/packet-tracer&quot; target=&quot;_blank
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 网络层</title>
    <link href="http://yoursite.com/post/5149561d.html"/>
    <id>http://yoursite.com/post/5149561d.html</id>
    <published>2018-06-21T14:50:39.000Z</published>
    <updated>2018-06-23T09:55:00.580Z</updated>
    
    <content type="html"><![CDATA[<p>TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，则将数据包丢弃。ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的，traceroute正是因为有了TTL才能正常工作</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>抓包工具tcpdump、wireshark</title>
    <link href="http://yoursite.com/post/8a478097.html"/>
    <id>http://yoursite.com/post/8a478097.html</id>
    <published>2018-06-21T06:44:38.000Z</published>
    <updated>2018-06-21T15:34:33.638Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux下，当我们需要<strong>抓取网络数据包分析</strong>时，通常是使用工具<strong>tcpdump</strong>。但是，有时我们需要将抓取的数据包保存在一个文件中，已备以后分析。而tcpdump保存的文件是<strong>二进制文件</strong>，使用cat 和vim 都无法打开查看。此时我们采取的措施是，下载到本地使用<strong>wireshark</strong>界面网络分析工具进行网络包分析。</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>需要管理员权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">tcpdump host www.baidu.com</div><div class="line">tcpdump host www.baidu.com and port 80</div><div class="line">tcpdump host www.baidu.com -w out.cap</div><div class="line"></div><div class="line"># 经过eth1</div><div class="line">tcpdump -i eth1 host 192.168.1.1</div><div class="line"># 指定源地址，抓取主机发送的所有数据</div><div class="line">tcpdump -i eth1 src host 192.168.1.1</div><div class="line"># 指定目的地址，抓取主机接收的所有数据</div><div class="line">tcpdump -i eth1 dst host 192.168.1.1</div><div class="line"></div><div class="line"># 经过eth1</div><div class="line">tcpdump -i eth1 port 25</div><div class="line"># 指定源端口</div><div class="line">tcpdump -i eth1 src port 25</div><div class="line"># 指定目的端口</div><div class="line">tcpdump -i eth1 dst port 25</div><div class="line"></div><div class="line">tcpdump -c100</div><div class="line"></div><div class="line">tcpdump host 10.37.63.255 and (10.37.63.61 or 10.37.63.95)</div><div class="line">tcpdump host 10.37.63.255 and !10.37.63.61</div><div class="line"></div><div class="line"></div><div class="line"># host 主机地址，后面可以带具体的IP或者地址</div><div class="line"># port 端口号</div><div class="line"># -w 保存到文件</div><div class="line"># -r 读取保存的文件</div><div class="line"># src源地址</div><div class="line"># dst目标地址</div><div class="line"># -c 指定捕获的报文数量</div><div class="line"># -i 指定接口 ifconfig -a查看有哪些接口</div></pre></td></tr></table></figure></p>
<h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>wireshark是一个图形化的工具</p>
<p><img src="/img/IMG138.png" alt=""><br><img src="/img/IMG139.png" alt=""><br><img src="/img/IMG140.png" alt=""></p>
<p>补充：</p>
<ul>
<li><a href="https://linuxwiki.github.io/NetTools/tcpdump.html" target="_blank" rel="external">https://linuxwiki.github.io/NetTools/tcpdump.html</a></li>
<li><a href="https://wizardforcel.gitbooks.io/network-basic/content/16.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/network-basic/content/16.html</a></li>
<li><a href="https://www.jianshu.com/p/8d9accf1d2f1" target="_blank" rel="external">https://www.jianshu.com/p/8d9accf1d2f1</a></li>
<li></li>
<li><a href="https://www.wireshark.org/docs/wsug_html_chunked/index.html" target="_blank" rel="external">https://www.wireshark.org/docs/wsug_html_chunked/index.html</a></li>
<li><a href="https://wizardforcel.gitbooks.io/wireshark-manual/content/1.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/wireshark-manual/content/1.html</a></li>
<li></li>
<li><a href="http://blog.51cto.com/zhaoyuqiang/1575315" target="_blank" rel="external">http://blog.51cto.com/zhaoyuqiang/1575315</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux下，当我们需要&lt;strong&gt;抓取网络数据包分析&lt;/strong&gt;时，通常是使用工具&lt;strong&gt;tcpdump&lt;/strong&gt;。但是，有时我们需要将抓取的数据包保存在一个文件中，已备以后分析。而tcpdump保存的文件是&lt;strong&gt;二进制文件&lt;/str
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python网络编程</title>
    <link href="http://yoursite.com/post/d317e8c4.html"/>
    <id>http://yoursite.com/post/d317e8c4.html</id>
    <published>2018-06-20T15:09:46.000Z</published>
    <updated>2018-06-20T23:56:23.097Z</updated>
    
    <content type="html"><![CDATA[<p>网络通信是两台计算机上的两个进程之间的通信</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络通信是两台计算机上的两个进程之间的通信&lt;/p&gt;

    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 数据链路层</title>
    <link href="http://yoursite.com/post/2f41be1.html"/>
    <id>http://yoursite.com/post/2f41be1.html</id>
    <published>2018-06-20T12:52:11.000Z</published>
    <updated>2018-06-22T12:10:03.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实本文中数据链路层讲了两部分，一部分是针对广域网的PPP，另一部分是针对局域网（以太网）的CSMA/CD</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h3><p>数据链路层使用的信道主要有以下两种类型<br><strong>点对点信道</strong>。这种信道使用 <strong>一对一</strong> 的点对点通信方式。用于<strong>广域网</strong>，使用<strong>PPP协议</strong><br><strong>广播信道</strong>。这种信道使用 <strong>一对多</strong> 的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。用于<strong>局域网</strong>，使用<strong>CSMA/CD协议</strong></p>
<a id="more"></a>
<h3 id="链路和数据链路"><a href="#链路和数据链路" class="headerlink" title="链路和数据链路"></a>链路和数据链路</h3><p><strong>链路</strong> (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。（物理层）</p>
<p><strong>数据链路</strong> (data link) 除了物理线路外，还必须有 <strong>通信协议</strong> 来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。（链路+协议）</p>
<p>现在最常用的方法是使用适配器（即<strong>网卡</strong>）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<p><img src="/img/IMG110.png" alt=""></p>
<h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br>确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。<br>帧=帧头+帧尾+物理层地址+校验值<br><img src="/img/IMG111.png" alt=""><br><img src="/img/IMG112.png" alt=""></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地 “找到帧的边界”。</p>
<p><img src="/img/IMG113.png" alt=""></p>
<p><strong>解决方法</strong>：<br><strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)。</p>
<ol>
<li>发送端的数据链路层在数据中出现控制字符 <code>SOH</code> 或<code>EOT</code>的前面插入一个转义字符<code>ESC</code> (其十六进制编码是 1B)。</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前插入一个转义字符，当接收端收到连续的两个转义字符时，就删除其中前面的一个</li>
</ol>
<p>之所以称为透明传输，是因为插入转义和删除转义是无法感受到的<br><img src="/img/IMG114.png" alt=""></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0 而 0 也可能变成 1。<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER (Bit Error Rate)</strong>。</p>
<p>误码率与信噪比有很大关系<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施<br>如果发现错误并<strong>不进行纠错而直接丢弃</strong>，目标发现没有接收到会要求重发，这是传输层的事情</p>
<h4 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a>循环冗余检验 CRC</h4><p>CRC是差错检测中最常见的方法</p>
<p>在发送端，先把数据划分为组。假定每组 k 个比特。<br>假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。<br>冗余码的计算举例<br><img src="/img/IMG115.png" alt=""><br><img src="/img/IMG116.png" alt=""><br>加法没有进位，减法没有借位，等同于异或运算<br>余数的位数等于n，不足补零</p>
<p><strong>FCS</strong><br>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。<br>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法</p>
<p><strong>检验</strong><br><strong>接收端</strong>对收到的每一帧进行CRC检验<br>若得出的余数R=0，则判定这个帧没有差错，就接受<br>若余数R不等于0,则判定这个帧有差错，就丢弃</p>
<p><strong>特点</strong><br>这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错<br>除数P越大，检错能力越强<br>只要经过严格的挑选，并使用位数足够多的除数P，那么出现检测不到的差错的概率就很小</p>
<p>仅用循环冗余检验CRC差错检测技术只能做到<strong>无差错接受</strong>，”无差错接受” 是指：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。<br>要做到“可靠传输”（即发送什么就收到什么）就必须加上<strong>确认</strong>和<strong>重传</strong>机制</p>
<p>在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p>
<h2 id="点对点信道的数据链路层——PPP协议"><a href="#点对点信道的数据链路层——PPP协议" class="headerlink" title="点对点信道的数据链路层——PPP协议"></a>点对点信道的数据链路层——PPP协议</h2><p>PPP协议 点对点协议 Point-to-Point Protocal<br>用于点到点通信<br>现在全世界使用得最多的数据链路层协议<br>用户使用拨号电话线接入因特网时，一般都是使用PPP协议</p>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><p>用户通过拨号连入ISP（电信、联通），点对点的。ISP给用户分配IP地址。PPP协议作用于之间，为用户和ISP提供规则：在连上网线的基础上还需要遵守拨号和利用IP地址才能上网的规则。PPP能够计费，能够显示上网时间和上网流量等等<br><img src="/img/IMG117.png" alt=""></p>
<h3 id="PPP-协议满足的需求："><a href="#PPP-协议满足的需求：" class="headerlink" title="PPP 协议满足的需求："></a>PPP 协议满足的需求：</h3><ul>
<li>简单——这是首要的要求，对帧不需要纠错，不需要流量控制，在接收方收到帧后用CRC检测，正确接收，错误就丢弃</li>
<li>封装成帧：从PPP协议的帧格式可以看出PPP协议封装成帧。在数据链路层以帧为单位进行传输</li>
<li>透明性：为了防止信息部分出现帧定界序列7E，而使网络误以为帧结束</li>
<li>差错检测：能够利用CRC进行差错检测 </li>
<li>多种网络层协议：能够支持多种高层协议的运行，比如IP协议等</li>
<li>多种类型链路：支持在光线等不同物理链路</li>
<li>检测连接状态：当拨号密码错误、连接错误时，PPP协议会提示错误信息</li>
<li>最大传送单元：一般要传输的数据不能超过1500个字节</li>
<li>网络层地址协商：拨号成功后，PPP协议能给用户分配网络层的IP地址</li>
<li>数据压缩协商：比如要传0000000011111111，16个比特。经过压缩算法后，只需要告诉对方要传8个0，8个1。接收方收到后再根据算法将16个0，16个1解压成0000000011111111。这样能够节省带宽</li>
</ul>
<h3 id="PPP-协议不需要的功能："><a href="#PPP-协议不需要的功能：" class="headerlink" title="PPP 协议不需要的功能："></a>PPP 协议不需要的功能：</h3><ul>
<li>纠错 </li>
<li>流量控制 </li>
<li>序号 </li>
<li>多点线路 </li>
<li>半双工或单工链路 </li>
</ul>
<h3 id="PPP-协议的组成："><a href="#PPP-协议的组成：" class="headerlink" title="PPP 协议的组成："></a>PPP 协议的组成：</h3><ol>
<li>数据链路层协议（HDLC）可以用于异步串行或同步串行方法</li>
<li>链路控制协议 LCP (Link Control Protocol)建立并维护数据链路连接，身份验证，流量统计</li>
<li>网络控制协议 NCP (Network Control Protocol)允许在点到点连接上使用多种网络层协议</li>
</ol>
<p><img src="/img/IMG118.png" alt=""></p>
<p>如果拨号身份验证成功了，则LCP负责建立数据链路，当LCP建立好了链路后，那么NCP就可以通了，NCP就分配一个IP给我们上网</p>
<h3 id="PPP-协议的帧格式："><a href="#PPP-协议的帧格式：" class="headerlink" title="PPP 协议的帧格式："></a>PPP 协议的帧格式：</h3><p><img src="/img/IMG119.png" alt=""></p>
<ul>
<li>标志字段<code>F=0x7E</code>(符号<code>0x</code>表示后面的字符是用十六进制表示，十六进制的7E用二进制表示是<code>01111110</code>)</li>
<li>地址字段A只置为<code>0xFF</code>。地址字段实际上并不起作用</li>
<li>控制字段C通常置为<code>0x03</code></li>
<li>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</li>
<li>PPP有一个2字节的协议字段用来表示信息字段的内容类型<ul>
<li>0x0021：PPP帧的信息字段是IP数据段</li>
<li>0xC021：PPP链路控制数据</li>
<li>0x8021：网络控制数据 </li>
<li>0xC023：安全性认证PAP</li>
<li>0xC025：LQR</li>
<li>oxC223：安全性认证CHAP</li>
</ul>
</li>
</ul>
<h3 id="PPP-协议的透明传输问题："><a href="#PPP-协议的透明传输问题：" class="headerlink" title="PPP 协议的透明传输问题："></a>PPP 协议的透明传输问题：</h3><p>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。<br><strong>字节填充</strong><br>以字节为单位，应用于异步网络中</p>
<ul>
<li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)</li>
<li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)</li>
<li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li>
</ul>
<p><strong>零比特填充</strong><br>以比特为单位，应用于同步网络中<br>在同步网络中传的比特流，所以不一定是8的倍数了。需要解决比特流的透明传输<br>PPP 协议用在<code>SONET/SDH</code>链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p>
<ul>
<li>在发送端，只要发现有 <strong>5 个连续 1</strong>，则立即填入一个 0。</li>
<li>接收端对帧中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除。</li>
</ul>
<p><img src="/img/IMG120.png" alt=""></p>
<p>PPP 协议不提供序号和确认的可靠传输。<br>原因：</p>
<ol>
<li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li>
<li>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列 FCS 字段可保证无差错接受。</li>
</ol>
<h3 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h3><ol>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ol>
<p>PPP 是一种<strong>验证方式</strong>，验证成功后会分配给用户一个 IP 地址。<br>PPP 协议<strong>已不是纯粹的数据链路层的协议</strong>，它还包含了物理层和网络层的内容。</p>
<h2 id="广播信道的数据链路层——CSMA-CD协议"><a href="#广播信道的数据链路层——CSMA-CD协议" class="headerlink" title="广播信道的数据链路层——CSMA/CD协议"></a>广播信道的数据链路层——CSMA/CD协议</h2><h3 id="局域网的拓扑"><a href="#局域网的拓扑" class="headerlink" title="局域网的拓扑"></a>局域网的拓扑</h3><p><img src="/img/IMG121.png" alt=""></p>
<ul>
<li><strong>星型拓扑结构</strong>：每个结点都由一条单独的通信线路与中心结点连结<ul>
<li>优点：结构简单、容易实现、便于管理，连接点的故障容易监测和排除</li>
<li>缺点：中心结点出现故障会导致网络的瘫痪</li>
</ul>
</li>
<li><strong>环形拓扑结构</strong>：各结点通过通信线路组成闭合回路，环中数据只能单向传输<ul>
<li>优点：结构简单、容易实现，适合使用光纤，传输距离远，传输延迟确定</li>
<li>缺点：任意结点出现故障都会造成网络瘫痪，另外故障诊断也较困难</li>
</ul>
</li>
<li><strong>总线拓扑结构</strong>：是将网络中的所有设备通过相应的硬件接口直接连接到公共总线上，结点之间按广播方式通信，一个结点发出的信息，总线上的其它结点均可 “收听” 到<ul>
<li>优点：结构简单、布线容易、可靠性较高，易于扩充，是局域网常采用的拓扑结构</li>
<li>缺点：所有的数据都需经过总线传送，出故障诊断较为困难</li>
</ul>
</li>
<li><strong>树型拓扑结构</strong>：一种层次结构，结点按层次连结，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换<ul>
<li>优点：连结简单，维护方便，适用于汇集信息的应用要求</li>
<li>缺点：资源共亨能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行</li>
</ul>
</li>
</ul>
<h3 id="局域网最主要的特点"><a href="#局域网最主要的特点" class="headerlink" title="局域网最主要的特点"></a>局域网最主要的特点</h3><p>网络为一个单位所拥有，且地理范围和站点数目均有限</p>
<h3 id="局域网的优点"><a href="#局域网的优点" class="headerlink" title="局域网的优点"></a>局域网的优点</h3><ol>
<li>具有广播功能，从一个站点可佷方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li>
<li>提高了系统的可靠性、可用性和生存性</li>
</ol>
<h3 id="局域网中的冲突域与广播域"><a href="#局域网中的冲突域与广播域" class="headerlink" title="局域网中的冲突域与广播域"></a>局域网中的冲突域与广播域</h3><p>最初的以太网是将许多计算机都连接到一根总线上，当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（有电源的器件）<br><img src="/img/IMG122.png" alt=""></p>
<p>总线上的每一个工作的计算机都能检测到B发送的数据信号<br>由于只有计算机D的地址（mac地址）与数据帧首部写入的地址一致，因此只有D才接收这个数据帧<br>其他所有的计算机（A，C和E）都检测到一是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来<br>具有广播特性的总线上实现了一对一的通信</p>
<p><strong>广播域</strong>： 一台计算机发送数据，连接在总线上的所有计算机都能收到数据，所有的计算机在同一个广播域中。<br><strong>冲突域</strong>： 当一台计算机发送数据时，总线被占用，此时所有连接在总线上的其他计算机都不能再发送数据了。<br>所有的计算机又处于同一个冲突域中。</p>
<h3 id="局域网各终端共享通信媒体（线路介质）的方法"><a href="#局域网各终端共享通信媒体（线路介质）的方法" class="headerlink" title="局域网各终端共享通信媒体（线路介质）的方法"></a>局域网各终端共享通信媒体（线路介质）的方法</h3><ul>
<li>静态划分信道<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
</li>
<li>动态媒体接入控制（多点接入）<ul>
<li>随机接入：用户想什么时候在线路上发送数据就什么时候发，什么都不用管。如果恰好有多个用户同时刻发送，则在线路上发生碰撞，需要 <strong>CSMA/CD 协议协调</strong>（主要被以太网采用）这是以太网最需要解决的问题。</li>
<li>受控接入，如多点线路探询（polling），或轮询（目前已不被采用）</li>
</ul>
</li>
</ul>
<p>静态划分的主要问题是增加新的计算机不方便，需要重新分配信道</p>
<h3 id="CSMD-CD-载波监听多点接入-碰撞检测"><a href="#CSMD-CD-载波监听多点接入-碰撞检测" class="headerlink" title="CSMD/CD 载波监听多点接入/碰撞检测"></a>CSMD/CD 载波监听多点接入/碰撞检测</h3><p>CSMA/CD 表示Carrier Sense Multiple Access with Collision Detection</p>
<p><strong>多点接入</strong> 表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听</strong> 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么 “载波”。因此， “载波监听” 就是用电子技术检测总线上有没有其他计算机发送的数据信号。<br><strong>碰撞检测</strong> 就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的<strong>信号电压</strong>摆动值超过一定的<strong>门限值</strong>时，就认为总线上至少有两个站同时在发送数据，表明产生了<strong>碰撞</strong>。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。<br><strong>检测到碰撞后</strong>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p>
<h4 id="载波监听后仍然出现碰撞的可能"><a href="#载波监听后仍然出现碰撞的可能" class="headerlink" title="载波监听后仍然出现碰撞的可能"></a>载波监听后仍然出现碰撞的可能</h4><p>电磁波在总线上的有限传播速率的影响当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A 向 B 发出的信息，要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。</p>
<p><img src="/img/IMG123.png" alt=""></p>
<h3 id="CSMA-C的D重要特性"><a href="#CSMA-C的D重要特性" class="headerlink" title="CSMA/C的D重要特性"></a>CSMA/C的D重要特性</h3><p>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信（<strong>半双工通信</strong>）<br>每个站在发送数据之后的一小段时间内，存在遭遇碰撞的可能性。所以不能保证在一定时间内一定能把数据发送出去。<br>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率（因为碰撞会降低效率）</p>
<p>可以看出，如果A到B之间的<strong>线路越长</strong>（传播时延τ受传播媒介长度影响），那么<strong>接受到碰撞信息的时间也会越长</strong>，所以<strong>CSMA/CD协议适合用在线路较短的局域网和以太网</strong>中。这也是局域网范围受限的原因之一。</p>
<h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><p>A能收到碰撞的最长时间为，当数据到达B后，B刚好发送数据，在主机B上发生了碰撞。最先发送数据帧的站，在发送数据帧后至多经过时间 <code>2τ</code>就可知道发送的数据帧是否遭受了碰撞。如果这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<h4 id="以太网的争用期"><a href="#以太网的争用期" class="headerlink" title="以太网的争用期"></a>以太网的争用期</h4><p>以太网的端到端往返时延<strong>2τ</strong>称为争用期，或碰撞窗口。通常，取 51.2 ms 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节未发生冲突，则后续的数据就不会发生冲突。</p>
<h4 id="最短有效帧长"><a href="#最短有效帧长" class="headerlink" title="最短有效帧长"></a>最短有效帧长</h4><p>如果发生冲突，就一定是在发送的前 64 字节之内。<br>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。<br>以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p>
<h3 id="强化碰撞"><a href="#强化碰撞" class="headerlink" title="强化碰撞"></a>强化碰撞</h3><p>当发送数据的站一旦发现发生了碰撞时：</p>
<ol>
<li>立即停止发送数据；</li>
<li>再继续发送若干比特的人为干扰信号 (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。</li>
</ol>
<h3 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h3><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。尽量避免再次发生碰撞</p>
<p>确定基本退避时间，一般是取为争用期 2t。<br>定义参数 k，k = Min[重传次数n, 10]<br>从整数集合[0,1,…, (2的K次方-1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。<br>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网两个标准"><a href="#以太网两个标准" class="headerlink" title="以太网两个标准"></a>以太网两个标准</h3><ol>
<li>DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。</li>
<li>IEEE 的 802.3 标准。</li>
</ol>
<p>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。说白了： <strong>以太网就是局域网</strong>。<br>严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</p>
<p>10M以太网使用CSMA/CD协议</p>
<h3 id="以太网与数据链路层的两个子层"><a href="#以太网与数据链路层的两个子层" class="headerlink" title="以太网与数据链路层的两个子层"></a>以太网与数据链路层的两个子层</h3><p>为了使数据链路层能更好地适应多种局域网标准，802 委员会就将局域网的数据链路层拆成两个子层：</p>
<ol>
<li><strong>逻辑链路控制 LLC</strong> (Logical Link Control)子层</li>
<li><strong>媒体接入控制 MAC</strong> (Medium Access Control)子层</li>
</ol>
<p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的。</p>
<p>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了，即现在LLC子层几乎不提了。</p>
<p>很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。</p>
<h3 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h3><p>以太网提供的服务是<strong>不可靠的交付</strong>，即尽最大努力的交付。<br>当接收站收到<strong>有差错的数据帧时就丢弃</strong>此帧，其他什么也不做。差错的纠正由传输层来决定。<br>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p>
<p><img src="/img/IMG124.jpg" alt=""><br>如图所示，PC1发送数据给PC0，在以太网上，ＲＡ接收到有差错的数据帧时就直接丢弃。如果PC0的高层（网络层以上）发现数据在途中丢失了，就会要求PC1重新发送一份。 </p>
<h3 id="传统以太网的拓扑——使用集线器的星形拓扑结构"><a href="#传统以太网的拓扑——使用集线器的星形拓扑结构" class="headerlink" title="传统以太网的拓扑——使用集线器的星形拓扑结构"></a>传统以太网的拓扑——使用集线器的星形拓扑结构</h3><p>传统以太网最初是使用<strong>粗同轴电缆</strong>，后来演进到使用比较便宜的<strong>细同轴电缆</strong>，最后发展为使用更便宜和更灵活的<strong>双绞线</strong>。不用电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong>(hub) 。</p>
<p>需要注意的是： 现在中间的可靠设备一般不用集线器了，现在组网去市场花个便宜的钱都是用交换机组网的。</p>
<p><img src="/img/IMG125.jpg" alt=""><br>100m以内</p>
<h3 id="集线器（hub）"><a href="#集线器（hub）" class="headerlink" title="集线器（hub）"></a>集线器（hub）</h3><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。<br>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。<br>集线器很像一个多接口的转发器，工作在<strong>物理层</strong>。 集线器是傻瓜式的，它没有智能作用，看不见什么信号。只知道机械的传输，也不管目的地址什么的，反正就是有信号就传。</p>
<p><img src="/img/IMG126.jpg" alt=""></p>
<p>接在工作站网卡上的8根双脚线有两根是发送数据的，有两根是接收数据的。A发送数据数据到集线器后，B和C都能收到，C发送数据到集线器后，A和B也能收到。发送者自己是收不到自己发出去的数据的。</p>
<p>需要注意的是： 这是早期的集线器，在芯片电路还没有出来之前的，集线器里面都是线连接的。现在的集线器都是芯片电路板了。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。</p>
<h3 id="以太网速度标准"><a href="#以太网速度标准" class="headerlink" title="以太网速度标准"></a>以太网速度标准</h3><p>10BASE-T（10Mb/s）的通信距离稍短，每个站到集线器的距离不超过 100 m。这种 10 Mb/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 </p>
<p>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</p>
<p>其他：100Base-FX(百兆快速以太网，使用光纤)、100Base-T和100Base-T4….</p>
<p>10：10M/s<br>BASE：基带信号<br>T：双绞线<br>FX：光纤</p>
<h3 id="以太网信道利用率"><a href="#以太网信道利用率" class="headerlink" title="以太网信道利用率"></a>以太网信道利用率</h3><p>因为每个站点发送数据时可能产生碰撞的可能，所以此时的信道不会被利用，所以利用率就会变低。</p>
<p>以太网的信道被占用的情况：<br>我们知道争用期长度为 2τ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。<br>如果帧长为 L (bit)，数据发送速率为 C (b/s)，因而帧的发送时间为 L/C = T0 (s)。</p>
<p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过τ时间使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p>
<p><img src="/img/IMG127.jpg" alt=""></p>
<p>要提高以太网的信道利用率，就必须减小τ 与 T0 之比。在以太网中定义了参数 a，它是以太网单程端到端时延τ与帧的发送时间 T0 之比： a=τ/T0      </p>
<p>a→0 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。<br>a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。</p>
<p>a并不是信道利用率，只是为了描述信道利用率的一个参数而已<br>从式子可以得出，要想a变小，则τ尽量变小，而T0尽量要大。<br>当数据率C一定时，T0=L（帧长）/C 。所以以太网的帧长L尽量要长些，这样T0会增大，a会变小。<br>当然也不能太长，太长后信道利用率过高会引起信道延迟成倍增加（ 信道利用率越高，数据线路上拥堵的可能性就越大，当高到一定程度后，会增加数据在线路上的延时）。<br>同时，以太网的连线的长度尽量短些，这样端到端的传播时间τ会变小，a会减小。当然也不能太短，太长后信道利用率过高会引起信道延迟成倍增加。</p>
<h4 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h4><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。</p>
<p>发送一帧占用线路的时间是 T0 +τ，而帧本身的发送时间是 T0。于是我们可计算出理想情况下的极限信道利用率 Smax为：  </p>
<p><img src="/img/IMG128.jpg" alt=""></p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>在局域网中，硬件地址又称为<strong>物理地址</strong>，或<strong> MAC 地址</strong>。 （<strong>48位地址</strong>）</p>
<p>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。 其实我们教材中说的地址并不是很确切，但是我们习惯将这种 48 位的“名字”称为“地址”，所以本书也采用这种习惯用法。</p>
<ul>
<li>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即<strong>高位 24 位</strong>)。</li>
<li>地址字段中的后三个字节(即低位 24 位)由厂家自行指派，称为<strong>扩展标识符</strong>，必须保证生产出的适配器<strong>没有重复地址</strong>。</li>
<li>一个地址块可以生成224个不同的地址。这种 48 位地址称为 <strong>MAC-48</strong>，它的通用名称是<strong>EUI-48</strong>。</li>
<li>“MAC地址”实际上就是适配器地址或适配器标识符EUI-48。在出厂前就烧录在了我们的网卡中。</li>
</ul>
<p>如果在一个局域网内（同一个交换机连接下）有相同的MAC地址，则会引起冲突，导致一方不能正常上网。<br>我们说MAC地址是刻在网卡适配器中的，是不可以更改的，但是我们可以指定一个MAC地址，让计算机应用指定的MAC地址，而不用网卡上固定的MAC地址。<br>windows修改mac地址方法：本地连接—更改适配器设置—本地连接属性—配置—-高级—网络地址（本地管理的地址）</p>
<h3 id="适配器检查-MAC-地址"><a href="#适配器检查-MAC-地址" class="headerlink" title="适配器检查 MAC 地址"></a>适配器检查 MAC 地址</h3><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址<br>如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p>
<p>“发往本站的帧”包括以下三种帧： </p>
<ul>
<li>单播(unicast)帧（一对一）</li>
<li>广播(broadcast)帧（一对全体）（源mac地址：FF:FF:FF:FF:FF:FF）</li>
<li>多播(multicast)帧（一对多）</li>
</ul>
<h3 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h3><p>常用的以太网MAC帧格式有两种标准 ：</p>
<ol>
<li>DIX Ethernet V2 标准</li>
<li>IEEE 的 802.3 标准</li>
</ol>
<p>最常用的 MAC 帧是以太网 V2 的格式。</p>
<p>MAC帧V2 格式<br><img src="/img/IMG129.jpg" alt=""><br>最小长度64字节（最短有效帧长，参考争用期）-18字节的首部和尾部（6+6+2+4）=数据字段的最小长度<br>为了达到比特同步在传输媒体上实际传送的要比 MAC 帧还多 8 个字节</p>
<h3 id="无效的-MAC-帧"><a href="#无效的-MAC-帧" class="headerlink" title="无效的 MAC 帧"></a>无效的 MAC 帧</h3><p>当适配器收到MAC帧后，会检查是否是有效的MAC帧。</p>
<ul>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 </p>
<h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><p>帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。<br>一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 </p>
<p>9.6 μs × 10Mb/s = 96bit</p>
<h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><p>扩展可以在物理层上也可在链路层上，但从网络层看依然是一个局域网。<br>以太网主机之间的距离不能太远（10BASE-T规定200米）</p>
<h3 id="在物理层扩展局域网"><a href="#在物理层扩展局域网" class="headerlink" title="在物理层扩展局域网"></a>在物理层扩展局域网</h3><p>主机使用光纤和一对光纤调制解调器连接到集线器<br><img src="/img/IMG130.png" alt=""><br><img src="/img/IMG131.png" alt=""><br>用多个集线器可连成更大的局域网</p>
<p><strong>优点</strong><br>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。<br>扩大了局域网覆盖的地理范围。（使用光纤可以扩大到几千米）<br>数量增加</p>
<p><strong>缺点</strong><br>碰撞域增大了，但总的吞吐量并未提高。<br>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。<br>三个碰撞域连起来后，最大吞吐率仍然是一个系的最大吞吐率。因为其中任何一台主机通信，其他主机都不能通信。</p>
<h3 id="在数据链路层扩展局域网"><a href="#在数据链路层扩展局域网" class="headerlink" title="在数据链路层扩展局域网"></a>在数据链路层扩展局域网</h3><p>在数据链路层扩展局域网是使用<strong>网桥</strong>。<br>网桥工作在数据链路层，它<strong>根据 MAC 帧的目的地址对收到的帧进行转发</strong>。</p>
<p>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。</p>
<h4 id="网桥的内部结构"><a href="#网桥的内部结构" class="headerlink" title="网桥的内部结构"></a>网桥的内部结构</h4><p>网桥具有多个接口<br>每个接口连接一个网段</p>
<p>若网桥从接口1收到从主机1向主机5的帧，则把帧发到接口2转发出去。<br>若网桥从接口1收到从主机2发到主机3的帧，则丢弃。因为主机2和3位于同一桥段，不用转发。<br><img src="/img/IMG132.png" alt=""></p>
<h4 id="使用网桥带来的好处"><a href="#使用网桥带来的好处" class="headerlink" title="使用网桥带来的好处"></a>使用网桥带来的好处</h4><p>过滤通信量，增大吞吐率。<br>扩大了物理范围。主机数量<br>提高了可靠性。只影响个别网段<br>可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。</p>
<p>网桥使各网段成为隔离开的碰撞域</p>
<h4 id="使用网桥带来的缺点"><a href="#使用网桥带来的缺点" class="headerlink" title="使用网桥带来的缺点"></a>使用网桥带来的缺点</h4><p>存储转发增加了时延。存储、查表、碰撞检测<br>在MAC 子层并没有流量控制功能。 网桥的缓存可能溢出，帧丢失。<br>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。<br>路由器可以阻断网络风暴</p>
<h4 id="网桥和集线器（或转发器）不同"><a href="#网桥和集线器（或转发器）不同" class="headerlink" title="网桥和集线器（或转发器）不同"></a>网桥和集线器（或转发器）不同</h4><p>集线器在转发帧时，不对传输媒体进行检测。<br>网桥在转发帧之前必须执行 CSMA/CD 算法。<br>若在发送过程中出现碰撞，就必须停止发送和进行退避。</p>
<h4 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h4><p>目前使用得最多的网桥是透明网桥(transparent bridge)。<br>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。<br>透明网桥是一种即插即用设备，其标准是 IEEE 802.1D。</p>
<h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><p>网桥使用自学习算法处理收到的帧和建立转发表，网桥并不是一开始就知道所连接网络的所有mac地址的，而是通过自学习算法建立转发表</p>
<p><img src="/img/IMG133.png" alt=""><br><img src="/img/IMG134.png" alt=""><br><img src="/img/IMG135.png" alt=""><br><img src="/img/IMG136.png" alt=""></p>
<ol>
<li>若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A。</li>
<li>网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。</li>
<li>在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面</li>
<li>在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li>
</ol>
<p>如果一个接口有多个mac说明，这个接口连接的是网桥或者交换机</p>
<h4 id="网桥在转发表中登记以下三个信息"><a href="#网桥在转发表中登记以下三个信息" class="headerlink" title="网桥在转发表中登记以下三个信息"></a>网桥在转发表中登记以下三个信息</h4><p>网桥转发表中的信息：<strong>地址</strong>、<strong>接口</strong>和<strong>帧进入该网桥的时间</strong>。</p>
<p>这是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。<br>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。 </p>
<h4 id="网桥的自学习和转发帧的步骤归纳"><a href="#网桥的自学习和转发帧的步骤归纳" class="headerlink" title="网桥的自学习和转发帧的步骤归纳"></a>网桥的自学习和转发帧的步骤归纳</h4><p>网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。<br>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<br>如有，则按转发表中给出的接口进行转发。<br>如没有，则通过所有其他接口（但进入网桥的接口除外）进行转发。<br>若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。</p>
<h4 id="透明网桥使用了生成树算法"><a href="#透明网桥使用了生成树算法" class="headerlink" title="透明网桥使用了生成树算法"></a>透明网桥使用了生成树算法</h4><p>这是为了避免产生转发的帧在网络中不断地兜圈子</p>
<p><img src="/img/IMG137.png" alt=""></p>
<p>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。 </p>
<p>为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</p>
<h3 id="多接口网桥——以太网交换机"><a href="#多接口网桥——以太网交换机" class="headerlink" title="多接口网桥——以太网交换机"></a>多接口网桥——以太网交换机</h3><p>1990 年问世的交换式集线器(switching hub)，可明显地提高局域网的性能。交换式集线器常称为<strong>以太网交换机</strong>(switch)或<strong>第二层交换机</strong>（表明此交换机工作在数据链路层）。以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，可见交换机工作在数据链路层。</p>
<h4 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h4><p>以太网交换机的每个接口都直接与主机相连，并且一般都工作在<strong>全双工方式</strong>。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。</p>
<p><strong>独占传输媒体的带宽</strong><br>对于普通 10 Mb/s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽(10 Mb/s)的 N 分之一。使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 对接口的交换机的总容量为 N×10 Mb/s。这正是交换机的最大优点。</p>
<p>对于普通共享式HUB 若N个用户 总带宽：10Mb/s 每个用户占有平均带宽= 10M/N</p>
<h3 id="以太网交换机的交换方式"><a href="#以太网交换机的交换方式" class="headerlink" title="以太网交换机的交换方式"></a>以太网交换机的交换方式</h3><p>存储转发方式<br>把整个数据帧先缓存后再进行处理。<br>直通 (cut-through) 方式<br>接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。<br>缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</p>
<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。<br>在缺省配置的情况下，交换机的所有端口属于同一 VLAN。连接在不同交换机上的、属于同一 VLAN 的数据帧必须通过 Trunk 链路传输。</p>
<p><img src="/img/IMG138.png" alt=""></p>
<h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p>速率达到或超过 100 Mbit/s 的以太网称为高速以太网。100BASE-T 以太网又称为快速以太网 (Fast Ethernet)。</p>
<p>可在全双工方式下工作而无冲突发生。在全双工方式下工作时，不使用 CSMA/CD 协议。<br>MAC 帧格式仍然是 802.3 标准规定的。<br>保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 m。<br>帧间时间间隔从原来的 9.6 μs 改为现在的 0.96 μs。</p>
<h2 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h2><p>允许在 1 Gbit/s 下全双工和半双工两种方式工作。<br>使用 IEEE 802.3 协议规定的帧格式。<br>在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。</p>
<p><a href="http://blog.51cto.com/zhaoyuqiang/1575315" target="_blank" rel="external">http://blog.51cto.com/zhaoyuqiang/1575315</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实本文中数据链路层讲了两部分，一部分是针对广域网的PPP，另一部分是针对局域网（以太网）的CSMA/CD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;信道类型&quot;&gt;&lt;a href=&quot;#信道类型&quot; class=&quot;headerlink&quot; title=&quot;信道类型&quot;&gt;&lt;/a&gt;信道类型&lt;/h3&gt;&lt;p&gt;数据链路层使用的信道主要有以下两种类型&lt;br&gt;&lt;strong&gt;点对点信道&lt;/strong&gt;。这种信道使用 &lt;strong&gt;一对一&lt;/strong&gt; 的点对点通信方式。用于&lt;strong&gt;广域网&lt;/strong&gt;，使用&lt;strong&gt;PPP协议&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;广播信道&lt;/strong&gt;。这种信道使用 &lt;strong&gt;一对多&lt;/strong&gt; 的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的&lt;strong&gt;共享信道协议&lt;/strong&gt;来协调这些主机的数据发送。用于&lt;strong&gt;局域网&lt;/strong&gt;，使用&lt;strong&gt;CSMA/CD协议&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
