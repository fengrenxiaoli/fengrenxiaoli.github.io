<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>太阳落下</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-23T08:49:12.501Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件测试</title>
    <link href="http://yoursite.com/post/7a8ab919.html"/>
    <id>http://yoursite.com/post/7a8ab919.html</id>
    <published>2018-06-23T08:23:53.000Z</published>
    <updated>2018-06-23T08:49:12.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件测试概要"><a href="#软件测试概要" class="headerlink" title="软件测试概要"></a>软件测试概要</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>软件测试是对程序能够按预期运行建立起一种信心  ——Bill Hetzel,1973</li>
<li>测试是为发现错误而执行程序的过程            ——Myers,1979</li>
<li>使用人工或自动的<strong>手段</strong>来运行或测量软件系统的过程，以检测软件系统是否满足<strong>规定的要求</strong>，并找出与<strong>预期定义</strong>之间的差异。        ——IOS/IEC/IEEE 29119</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>软件测试覆盖整个软件研发过程</p>
<ul>
<li>软件需求</li>
<li>概要设计</li>
<li>详细设计</li>
<li>源代码</li>
<li>可运行程序</li>
<li>可运行环境</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><img src="/img/IMG142.png" alt=""></p>
<h3 id="五大要素及两大目标"><a href="#五大要素及两大目标" class="headerlink" title="五大要素及两大目标"></a>五大要素及两大目标</h3><p>要素：</p>
<ul>
<li>质量(最为核心)</li>
<li>人员(决定因素)</li>
<li>技术(实现手段)【测试技术，方法，测试工具】</li>
<li>资源【测试所需的硬件，网络环境，测试生命周期，测试时间】</li>
<li>流程(测试标准)【测试计划，测试执行，报告】</li>
</ul>
<p>目标</p>
<ul>
<li>提升测试覆盖率</li>
<li>测试效率</li>
</ul>
<h3 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h3><ol>
<li>测试显示软件的存在，但不能证明系统不存在缺陷</li>
<li>穷极测试是不可能的，应设定及时终止的条件（无穷无尽的测试是不可能的，需很大代价；无论怎样测试，我们不可能发现软件的所有缺陷）</li>
<li>测试应该尽早进行</li>
<li>缺陷具备群集特性（发现越多错误的模块，越应该集中关注，可能该模块的编程人员的水平较低）</li>
<li>测试的杀虫剂悖论（用相同的用例多次测试时发现不了bug的，应该更新测试方法和用例）</li>
<li>测试的二八原则（80%的时间测试20%的重要模块）</li>
<li>测试活动依赖于测试背景（针对不同的软件的测试方法是不同的，比如电信软件看中性能、大批量；银行看中安全性）</li>
</ol>
<p>术语<strong>杀虫剂悖论</strong>（The Pesticide Paradox）用来描述这样一种现象，即你对软件进行越多的测试，那么该软件对你的测试就越具有免疫力。同样的事情发生在对昆虫使用杀虫剂上。如果你持续使用同样的杀虫剂，这些昆虫最终将建立起抵抗力，杀虫剂将不再发挥作用。<br>为了克服“杀虫剂悖论”，软件测试人员必须不断地编写新的不同的测试来检验程序的不同部分从而找出更多的bug。<br>让其他的人来测试你的程序将有助于打破“杀虫剂悖论”。</p>
<p><img src="/img/IMG143.png" alt=""></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;软件测试概要&quot;&gt;&lt;a href=&quot;#软件测试概要&quot; class=&quot;headerlink&quot; title=&quot;软件测试概要&quot;&gt;&lt;/a&gt;软件测试概要&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>nmap使用</title>
    <link href="http://yoursite.com/post/30bf2354.html"/>
    <id>http://yoursite.com/post/30bf2354.html</id>
    <published>2018-06-22T14:00:49.000Z</published>
    <updated>2018-06-22T15:57:04.297Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nmap.org/" target="_blank" rel="external">Nmap</a>(Network Mapper)是一款用于网络发现（Network Discovery）和安全审计（Security Audting）的安全工具，采用C++语言编写，常用于<strong>端口扫描</strong>。<br>Nmap软件包带有一个名为GUI的包zenmap，使用Python编写。</p>
<h2 id="安装nmap"><a href="#安装nmap" class="headerlink" title="安装nmap"></a>安装nmap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nmap</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>最简单的形式是只传递地址或域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmap scanme.nmap.org</div><div class="line">nmap 74.207.244.221</div><div class="line">nmap 192.168.1.200</div></pre></td></tr></table></figure></p>
<h3 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h3><p>扫描结果中显示的商品状态</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>开放，探测报文到达了端口，端口有响应：我有应用程序监听 - SYN/ACK</td>
</tr>
<tr>
<td>closed</td>
<td>关闭，探测报文到达了端口，端口有响应：我没应用程序监听 - RST (复位)</td>
</tr>
<tr>
<td>filtered</td>
<td>被屏蔽，探测报文到不了端口，石沉大海</td>
</tr>
<tr>
<td>unfiltered</td>
<td>没有被屏蔽，还需要确认，探测报文到达了端口，没响应了</td>
</tr>
<tr>
<td>open &#124; filtered</td>
<td>开放或屏蔽，有可能报文过滤器丢弃了探测报文（filtered），或丢弃了端口的响应报文 (open)(原理请往下看 -sN，-sF，-sX)UDP，IP 协议， FIN，Null，和 Xmas 扫描可能把端口归入此类</td>
</tr>
<tr>
<td>closed &#124; unfiltered</td>
<td>关闭或屏蔽，IPID+1，但是 closed 和 unfiltered 都可能导致只 + 1，所以就不确定了。只可能出现在 IP ID Idle 扫描中（看下端口 TCP 空闲扫描的原理就知道为什么了）</td>
</tr>
</tbody>
</table>
<h3 id="扫描类型"><a href="#扫描类型" class="headerlink" title="扫描类型"></a>扫描类型</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sT　　</td>
<td>TCP 连接扫描，会在目标主机中记录大量的链接请求和错误信息</td>
</tr>
<tr>
<td>-sS　　</td>
<td>SYN 扫描，隐蔽扫描，不创建完整连接，只完成三次握手前两次，很少有系统记入日志，默认使用，需要 root(admin) 权限</td>
</tr>
<tr>
<td>-sP　　</td>
<td>Ping 扫描，默认使用，只有能 Ping 得通才会继续扫描</td>
</tr>
<tr>
<td>-P0　　</td>
<td>扫描之前不需要 Ping，用于绕过防火墙禁 Ping 功能</td>
</tr>
<tr>
<td>-sA　　</td>
<td>高级的扫描方式，用来穿过防火墙的规则集</td>
</tr>
<tr>
<td>-sV　　</td>
<td>服务的详细信息　</td>
</tr>
<tr>
<td>-sU　　</td>
<td>UDP 扫描，扫描主机开启的 UDP 的服务，速度慢，结果不可靠　</td>
</tr>
<tr>
<td>-sX -sN 　　</td>
<td>秘密的 FIN 数据包扫描，圣诞树 (Xmas Tree) 和空模式，针对 Unix 和 Linux 主机，系统要求遵循 TCP RFC 文档</td>
</tr>
</tbody>
</table>
<h3 id="扫描参数"><a href="#扫描参数" class="headerlink" title="扫描参数"></a>扫描参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v　　</td>
<td>显示扫描过程，推荐使用</td>
</tr>
<tr>
<td>-h　　</td>
<td>帮助文档</td>
</tr>
<tr>
<td>-p　　</td>
<td>指定端口号，如 [1-65535],[22,135,1433,3306,] 等格式</td>
</tr>
<tr>
<td>-O　　</td>
<td>探测操作系统，存在误报</td>
</tr>
<tr>
<td>-A　　</td>
<td>全面系统监测，使用脚本检测，扫描等</td>
</tr>
<tr>
<td>-T4　</td>
<td>针对 TCP 端口禁止动态扫描延迟超过 10ms</td>
</tr>
<tr>
<td>-iL　</td>
<td>　批量扫描，读取主机列表，如 [-iL C:\ip.txt]</td>
</tr>
<tr>
<td>-F</td>
<td>快速扫描</td>
</tr>
<tr>
<td>-V</td>
<td>确定指定端口对应的服务信息</td>
</tr>
<tr>
<td>-eclude</td>
<td>排除IP，多个IP用逗号分隔</td>
</tr>
<tr>
<td>-p</td>
<td>指定端口，多个端口用逗号分隔</td>
</tr>
</tbody>
</table>
<h3 id="扫描案例"><a href="#扫描案例" class="headerlink" title="扫描案例"></a>扫描案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># 扫描 C 段（局域网）存活主机</div><div class="line">nmap -sP www.XXX.com/24</div><div class="line">nmap -sP 192.168.1.*</div><div class="line"></div><div class="line"># 主机发现，通过ICMP ECHO扫描子网中的在线主机</div><div class="line">nmap -v -sn -PE 192.168.1.1/24</div><div class="line">nmap -v -sn -PE 192.168.1.1-5</div><div class="line"></div><div class="line"># 指定商品扫描</div><div class="line">nmap -v -p 135 192.168.1.1-5</div><div class="line"></div><div class="line"># 扫描指定 IP 开放端口号</div><div class="line"># -p-为全端口扫描，和[1-65535]一样，建议使用，不使用默认Nmap认为危险的100个端口号</div><div class="line">nmap -sS -p- -v 192.168.1.100</div><div class="line"></div><div class="line"># 扫描指定 IP 所开端口及对应的服务</div><div class="line">nmap -sV -v 192.168.1.100</div><div class="line"></div><div class="line"># 探测主机操作系统以及硬件信息，扫描准确度以百分比显示，未必准确</div><div class="line">nmap -O www.XXX.com</div><div class="line"></div><div class="line"># 穿透防火墙扫描</div><div class="line">nmap -P0  www.XXX.com</div><div class="line"></div><div class="line"># 全面探测，-A 包含 OS 探测，版本探测，脚本扫描，traceroute</div><div class="line">nmap -A www.XXX.com</div><div class="line"></div><div class="line"># 使用脚本扫描，脚本放在Nmap安装目录script下，官网可查各个脚本功能</div><div class="line">nmap --script=&quot;脚本名称&quot; www.XXX.com</div><div class="line"></div><div class="line"># 如在局域网上扫找 Conficker 蠕虫病毒</div><div class="line">nmap -PN -T4 -p139,445 -n -v --script=smb-check-vulns --script-args safe=1 192.168.0.1-254</div></pre></td></tr></table></figure>
<p>补充：</p>
<ul>
<li><a href="https://github.com/erasin/notes/blob/master/linux/safe/nmap.md" target="_blank" rel="external">https://github.com/erasin/notes/blob/master/linux/safe/nmap.md</a></li>
<li><a href="https://nmap.org/book/history-future.html" target="_blank" rel="external">https://nmap.org/book/history-future.html</a></li>
<li><a href="https://blog.csdn.net/emaste_r/article/details/17840465" target="_blank" rel="external">https://blog.csdn.net/emaste_r/article/details/17840465</a></li>
<li><a href="http://os.chinaunix.net/a2006/0619/956/000000956765.shtml" target="_blank" rel="external">http://os.chinaunix.net/a2006/0619/956/000000956765.shtml</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26676508" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26676508</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Nmap" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Nmap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://nmap.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Nmap&lt;/a&gt;(Network Mapper)是一款用于网络发现（Network Discovery）和安全审计（Security Audting）的安全
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看IP使用情况</title>
    <link href="http://yoursite.com/post/62edaad4.html"/>
    <id>http://yoursite.com/post/62edaad4.html</id>
    <published>2018-06-22T13:59:14.000Z</published>
    <updated>2018-06-22T14:00:17.792Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt install fping</div><div class="line">fping -g -c 1 192.168.1.0/24</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -nsP 192.168.1.1-254</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Cisco Packet Tracer</title>
    <link href="http://yoursite.com/post/5aea5c58.html"/>
    <id>http://yoursite.com/post/5aea5c58.html</id>
    <published>2018-06-22T02:16:28.000Z</published>
    <updated>2018-06-22T02:28:51.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.netacad.com/courses/packet-tracer" target="_blank" rel="external">https://www.netacad.com/courses/packet-tracer</a></p>
<p>注册下载</p>
<!-- ## 环境
需要java和32位包

```
sudo dpkg --add-architecture i386
sudo apt-get install libc6:i386
sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0
sudo apt-get install libnss3-1d:i386 libqt4-qt3support:i386 libssl1.0.0:i386 libqtwebkit4:i386 libqt4-scripttools:i386
``` -->
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将压缩文件解压缩到一个文件夹并打开一个终端。<br>使用sudo权限运行install.sh并按照说明进行安装<br>安装的默认路径是<code>/opt/pt</code></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在终端中键入<code>packettracer</code>来运行<br>如果没有反应，运行<code>/opt/pt/bin/PacketTracer7</code><br>会提示缺少库文件，安装相应库文件后再次运行</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>调整终端字体</strong><br>点击选项（options），点击首选项（Preferences），然后点击字体（Font），选CLI右侧就有大小的选择了。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.christospanoudis.com/how-to-install-packet-tracer-7-1-in-linux-and-resolve-any-dependency-issues/" target="_blank" rel="external">http://www.christospanoudis.com/how-to-install-packet-tracer-7-1-in-linux-and-resolve-any-dependency-issues/</a></li>
<li><a href="https://linux.cn/article-5576-1.html" target="_blank" rel="external">https://linux.cn/article-5576-1.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.netacad.com/courses/packet-tracer&quot; target=&quot;_blank
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 网络层</title>
    <link href="http://yoursite.com/post/5149561d.html"/>
    <id>http://yoursite.com/post/5149561d.html</id>
    <published>2018-06-21T14:50:39.000Z</published>
    <updated>2018-06-23T09:55:00.580Z</updated>
    
    <content type="html"><![CDATA[<p>TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，则将数据包丢弃。ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的，traceroute正是因为有了TTL才能正常工作</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，由于有了TTL，最终TTL为0后，
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>抓包工具tcpdump、wireshark</title>
    <link href="http://yoursite.com/post/8a478097.html"/>
    <id>http://yoursite.com/post/8a478097.html</id>
    <published>2018-06-21T06:44:38.000Z</published>
    <updated>2018-06-21T15:34:33.638Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux下，当我们需要<strong>抓取网络数据包分析</strong>时，通常是使用工具<strong>tcpdump</strong>。但是，有时我们需要将抓取的数据包保存在一个文件中，已备以后分析。而tcpdump保存的文件是<strong>二进制文件</strong>，使用cat 和vim 都无法打开查看。此时我们采取的措施是，下载到本地使用<strong>wireshark</strong>界面网络分析工具进行网络包分析。</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>需要管理员权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">tcpdump host www.baidu.com</div><div class="line">tcpdump host www.baidu.com and port 80</div><div class="line">tcpdump host www.baidu.com -w out.cap</div><div class="line"></div><div class="line"># 经过eth1</div><div class="line">tcpdump -i eth1 host 192.168.1.1</div><div class="line"># 指定源地址，抓取主机发送的所有数据</div><div class="line">tcpdump -i eth1 src host 192.168.1.1</div><div class="line"># 指定目的地址，抓取主机接收的所有数据</div><div class="line">tcpdump -i eth1 dst host 192.168.1.1</div><div class="line"></div><div class="line"># 经过eth1</div><div class="line">tcpdump -i eth1 port 25</div><div class="line"># 指定源端口</div><div class="line">tcpdump -i eth1 src port 25</div><div class="line"># 指定目的端口</div><div class="line">tcpdump -i eth1 dst port 25</div><div class="line"></div><div class="line">tcpdump -c100</div><div class="line"></div><div class="line">tcpdump host 10.37.63.255 and (10.37.63.61 or 10.37.63.95)</div><div class="line">tcpdump host 10.37.63.255 and !10.37.63.61</div><div class="line"></div><div class="line"></div><div class="line"># host 主机地址，后面可以带具体的IP或者地址</div><div class="line"># port 端口号</div><div class="line"># -w 保存到文件</div><div class="line"># -r 读取保存的文件</div><div class="line"># src源地址</div><div class="line"># dst目标地址</div><div class="line"># -c 指定捕获的报文数量</div><div class="line"># -i 指定接口 ifconfig -a查看有哪些接口</div></pre></td></tr></table></figure></p>
<h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>wireshark是一个图形化的工具</p>
<p><img src="/img/IMG138.png" alt=""><br><img src="/img/IMG139.png" alt=""><br><img src="/img/IMG140.png" alt=""></p>
<p>补充：</p>
<ul>
<li><a href="https://linuxwiki.github.io/NetTools/tcpdump.html" target="_blank" rel="external">https://linuxwiki.github.io/NetTools/tcpdump.html</a></li>
<li><a href="https://wizardforcel.gitbooks.io/network-basic/content/16.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/network-basic/content/16.html</a></li>
<li><a href="https://www.jianshu.com/p/8d9accf1d2f1" target="_blank" rel="external">https://www.jianshu.com/p/8d9accf1d2f1</a></li>
<li></li>
<li><a href="https://www.wireshark.org/docs/wsug_html_chunked/index.html" target="_blank" rel="external">https://www.wireshark.org/docs/wsug_html_chunked/index.html</a></li>
<li><a href="https://wizardforcel.gitbooks.io/wireshark-manual/content/1.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/wireshark-manual/content/1.html</a></li>
<li></li>
<li><a href="http://blog.51cto.com/zhaoyuqiang/1575315" target="_blank" rel="external">http://blog.51cto.com/zhaoyuqiang/1575315</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux下，当我们需要&lt;strong&gt;抓取网络数据包分析&lt;/strong&gt;时，通常是使用工具&lt;strong&gt;tcpdump&lt;/strong&gt;。但是，有时我们需要将抓取的数据包保存在一个文件中，已备以后分析。而tcpdump保存的文件是&lt;strong&gt;二进制文件&lt;/str
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python网络编程</title>
    <link href="http://yoursite.com/post/d317e8c4.html"/>
    <id>http://yoursite.com/post/d317e8c4.html</id>
    <published>2018-06-20T15:09:46.000Z</published>
    <updated>2018-06-20T23:56:23.097Z</updated>
    
    <content type="html"><![CDATA[<p>网络通信是两台计算机上的两个进程之间的通信</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络通信是两台计算机上的两个进程之间的通信&lt;/p&gt;

    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 数据链路层</title>
    <link href="http://yoursite.com/post/2f41be1.html"/>
    <id>http://yoursite.com/post/2f41be1.html</id>
    <published>2018-06-20T12:52:11.000Z</published>
    <updated>2018-06-22T12:10:03.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实本文中数据链路层讲了两部分，一部分是针对广域网的PPP，另一部分是针对局域网（以太网）的CSMA/CD</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h3><p>数据链路层使用的信道主要有以下两种类型<br><strong>点对点信道</strong>。这种信道使用 <strong>一对一</strong> 的点对点通信方式。用于<strong>广域网</strong>，使用<strong>PPP协议</strong><br><strong>广播信道</strong>。这种信道使用 <strong>一对多</strong> 的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。用于<strong>局域网</strong>，使用<strong>CSMA/CD协议</strong></p>
<a id="more"></a>
<h3 id="链路和数据链路"><a href="#链路和数据链路" class="headerlink" title="链路和数据链路"></a>链路和数据链路</h3><p><strong>链路</strong> (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。（物理层）</p>
<p><strong>数据链路</strong> (data link) 除了物理线路外，还必须有 <strong>通信协议</strong> 来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。（链路+协议）</p>
<p>现在最常用的方法是使用适配器（即<strong>网卡</strong>）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<p><img src="/img/IMG110.png" alt=""></p>
<h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br>确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。<br>帧=帧头+帧尾+物理层地址+校验值<br><img src="/img/IMG111.png" alt=""><br><img src="/img/IMG112.png" alt=""></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地 “找到帧的边界”。</p>
<p><img src="/img/IMG113.png" alt=""></p>
<p><strong>解决方法</strong>：<br><strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)。</p>
<ol>
<li>发送端的数据链路层在数据中出现控制字符 <code>SOH</code> 或<code>EOT</code>的前面插入一个转义字符<code>ESC</code> (其十六进制编码是 1B)。</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前插入一个转义字符，当接收端收到连续的两个转义字符时，就删除其中前面的一个</li>
</ol>
<p>之所以称为透明传输，是因为插入转义和删除转义是无法感受到的<br><img src="/img/IMG114.png" alt=""></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0 而 0 也可能变成 1。<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER (Bit Error Rate)</strong>。</p>
<p>误码率与信噪比有很大关系<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施<br>如果发现错误并<strong>不进行纠错而直接丢弃</strong>，目标发现没有接收到会要求重发，这是传输层的事情</p>
<h4 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a>循环冗余检验 CRC</h4><p>CRC是差错检测中最常见的方法</p>
<p>在发送端，先把数据划分为组。假定每组 k 个比特。<br>假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。<br>冗余码的计算举例<br><img src="/img/IMG115.png" alt=""><br><img src="/img/IMG116.png" alt=""><br>加法没有进位，减法没有借位，等同于异或运算<br>余数的位数等于n，不足补零</p>
<p><strong>FCS</strong><br>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。<br>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法</p>
<p><strong>检验</strong><br><strong>接收端</strong>对收到的每一帧进行CRC检验<br>若得出的余数R=0，则判定这个帧没有差错，就接受<br>若余数R不等于0,则判定这个帧有差错，就丢弃</p>
<p><strong>特点</strong><br>这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错<br>除数P越大，检错能力越强<br>只要经过严格的挑选，并使用位数足够多的除数P，那么出现检测不到的差错的概率就很小</p>
<p>仅用循环冗余检验CRC差错检测技术只能做到<strong>无差错接受</strong>，”无差错接受” 是指：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。<br>要做到“可靠传输”（即发送什么就收到什么）就必须加上<strong>确认</strong>和<strong>重传</strong>机制</p>
<p>在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p>
<h2 id="点对点信道的数据链路层——PPP协议"><a href="#点对点信道的数据链路层——PPP协议" class="headerlink" title="点对点信道的数据链路层——PPP协议"></a>点对点信道的数据链路层——PPP协议</h2><p>PPP协议 点对点协议 Point-to-Point Protocal<br>用于点到点通信<br>现在全世界使用得最多的数据链路层协议<br>用户使用拨号电话线接入因特网时，一般都是使用PPP协议</p>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><p>用户通过拨号连入ISP（电信、联通），点对点的。ISP给用户分配IP地址。PPP协议作用于之间，为用户和ISP提供规则：在连上网线的基础上还需要遵守拨号和利用IP地址才能上网的规则。PPP能够计费，能够显示上网时间和上网流量等等<br><img src="/img/IMG117.png" alt=""></p>
<h3 id="PPP-协议满足的需求："><a href="#PPP-协议满足的需求：" class="headerlink" title="PPP 协议满足的需求："></a>PPP 协议满足的需求：</h3><ul>
<li>简单——这是首要的要求，对帧不需要纠错，不需要流量控制，在接收方收到帧后用CRC检测，正确接收，错误就丢弃</li>
<li>封装成帧：从PPP协议的帧格式可以看出PPP协议封装成帧。在数据链路层以帧为单位进行传输</li>
<li>透明性：为了防止信息部分出现帧定界序列7E，而使网络误以为帧结束</li>
<li>差错检测：能够利用CRC进行差错检测 </li>
<li>多种网络层协议：能够支持多种高层协议的运行，比如IP协议等</li>
<li>多种类型链路：支持在光线等不同物理链路</li>
<li>检测连接状态：当拨号密码错误、连接错误时，PPP协议会提示错误信息</li>
<li>最大传送单元：一般要传输的数据不能超过1500个字节</li>
<li>网络层地址协商：拨号成功后，PPP协议能给用户分配网络层的IP地址</li>
<li>数据压缩协商：比如要传0000000011111111，16个比特。经过压缩算法后，只需要告诉对方要传8个0，8个1。接收方收到后再根据算法将16个0，16个1解压成0000000011111111。这样能够节省带宽</li>
</ul>
<h3 id="PPP-协议不需要的功能："><a href="#PPP-协议不需要的功能：" class="headerlink" title="PPP 协议不需要的功能："></a>PPP 协议不需要的功能：</h3><ul>
<li>纠错 </li>
<li>流量控制 </li>
<li>序号 </li>
<li>多点线路 </li>
<li>半双工或单工链路 </li>
</ul>
<h3 id="PPP-协议的组成："><a href="#PPP-协议的组成：" class="headerlink" title="PPP 协议的组成："></a>PPP 协议的组成：</h3><ol>
<li>数据链路层协议（HDLC）可以用于异步串行或同步串行方法</li>
<li>链路控制协议 LCP (Link Control Protocol)建立并维护数据链路连接，身份验证，流量统计</li>
<li>网络控制协议 NCP (Network Control Protocol)允许在点到点连接上使用多种网络层协议</li>
</ol>
<p><img src="/img/IMG118.png" alt=""></p>
<p>如果拨号身份验证成功了，则LCP负责建立数据链路，当LCP建立好了链路后，那么NCP就可以通了，NCP就分配一个IP给我们上网</p>
<h3 id="PPP-协议的帧格式："><a href="#PPP-协议的帧格式：" class="headerlink" title="PPP 协议的帧格式："></a>PPP 协议的帧格式：</h3><p><img src="/img/IMG119.png" alt=""></p>
<ul>
<li>标志字段<code>F=0x7E</code>(符号<code>0x</code>表示后面的字符是用十六进制表示，十六进制的7E用二进制表示是<code>01111110</code>)</li>
<li>地址字段A只置为<code>0xFF</code>。地址字段实际上并不起作用</li>
<li>控制字段C通常置为<code>0x03</code></li>
<li>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</li>
<li>PPP有一个2字节的协议字段用来表示信息字段的内容类型<ul>
<li>0x0021：PPP帧的信息字段是IP数据段</li>
<li>0xC021：PPP链路控制数据</li>
<li>0x8021：网络控制数据 </li>
<li>0xC023：安全性认证PAP</li>
<li>0xC025：LQR</li>
<li>oxC223：安全性认证CHAP</li>
</ul>
</li>
</ul>
<h3 id="PPP-协议的透明传输问题："><a href="#PPP-协议的透明传输问题：" class="headerlink" title="PPP 协议的透明传输问题："></a>PPP 协议的透明传输问题：</h3><p>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。<br><strong>字节填充</strong><br>以字节为单位，应用于异步网络中</p>
<ul>
<li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)</li>
<li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)</li>
<li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li>
</ul>
<p><strong>零比特填充</strong><br>以比特为单位，应用于同步网络中<br>在同步网络中传的比特流，所以不一定是8的倍数了。需要解决比特流的透明传输<br>PPP 协议用在<code>SONET/SDH</code>链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p>
<ul>
<li>在发送端，只要发现有 <strong>5 个连续 1</strong>，则立即填入一个 0。</li>
<li>接收端对帧中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除。</li>
</ul>
<p><img src="/img/IMG120.png" alt=""></p>
<p>PPP 协议不提供序号和确认的可靠传输。<br>原因：</p>
<ol>
<li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li>
<li>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列 FCS 字段可保证无差错接受。</li>
</ol>
<h3 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h3><ol>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ol>
<p>PPP 是一种<strong>验证方式</strong>，验证成功后会分配给用户一个 IP 地址。<br>PPP 协议<strong>已不是纯粹的数据链路层的协议</strong>，它还包含了物理层和网络层的内容。</p>
<h2 id="广播信道的数据链路层——CSMA-CD协议"><a href="#广播信道的数据链路层——CSMA-CD协议" class="headerlink" title="广播信道的数据链路层——CSMA/CD协议"></a>广播信道的数据链路层——CSMA/CD协议</h2><h3 id="局域网的拓扑"><a href="#局域网的拓扑" class="headerlink" title="局域网的拓扑"></a>局域网的拓扑</h3><p><img src="/img/IMG121.png" alt=""></p>
<ul>
<li><strong>星型拓扑结构</strong>：每个结点都由一条单独的通信线路与中心结点连结<ul>
<li>优点：结构简单、容易实现、便于管理，连接点的故障容易监测和排除</li>
<li>缺点：中心结点出现故障会导致网络的瘫痪</li>
</ul>
</li>
<li><strong>环形拓扑结构</strong>：各结点通过通信线路组成闭合回路，环中数据只能单向传输<ul>
<li>优点：结构简单、容易实现，适合使用光纤，传输距离远，传输延迟确定</li>
<li>缺点：任意结点出现故障都会造成网络瘫痪，另外故障诊断也较困难</li>
</ul>
</li>
<li><strong>总线拓扑结构</strong>：是将网络中的所有设备通过相应的硬件接口直接连接到公共总线上，结点之间按广播方式通信，一个结点发出的信息，总线上的其它结点均可 “收听” 到<ul>
<li>优点：结构简单、布线容易、可靠性较高，易于扩充，是局域网常采用的拓扑结构</li>
<li>缺点：所有的数据都需经过总线传送，出故障诊断较为困难</li>
</ul>
</li>
<li><strong>树型拓扑结构</strong>：一种层次结构，结点按层次连结，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换<ul>
<li>优点：连结简单，维护方便，适用于汇集信息的应用要求</li>
<li>缺点：资源共亨能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行</li>
</ul>
</li>
</ul>
<h3 id="局域网最主要的特点"><a href="#局域网最主要的特点" class="headerlink" title="局域网最主要的特点"></a>局域网最主要的特点</h3><p>网络为一个单位所拥有，且地理范围和站点数目均有限</p>
<h3 id="局域网的优点"><a href="#局域网的优点" class="headerlink" title="局域网的优点"></a>局域网的优点</h3><ol>
<li>具有广播功能，从一个站点可佷方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li>
<li>提高了系统的可靠性、可用性和生存性</li>
</ol>
<h3 id="局域网中的冲突域与广播域"><a href="#局域网中的冲突域与广播域" class="headerlink" title="局域网中的冲突域与广播域"></a>局域网中的冲突域与广播域</h3><p>最初的以太网是将许多计算机都连接到一根总线上，当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件（有电源的器件）<br><img src="/img/IMG122.png" alt=""></p>
<p>总线上的每一个工作的计算机都能检测到B发送的数据信号<br>由于只有计算机D的地址（mac地址）与数据帧首部写入的地址一致，因此只有D才接收这个数据帧<br>其他所有的计算机（A，C和E）都检测到一是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来<br>具有广播特性的总线上实现了一对一的通信</p>
<p><strong>广播域</strong>： 一台计算机发送数据，连接在总线上的所有计算机都能收到数据，所有的计算机在同一个广播域中。<br><strong>冲突域</strong>： 当一台计算机发送数据时，总线被占用，此时所有连接在总线上的其他计算机都不能再发送数据了。<br>所有的计算机又处于同一个冲突域中。</p>
<h3 id="局域网各终端共享通信媒体（线路介质）的方法"><a href="#局域网各终端共享通信媒体（线路介质）的方法" class="headerlink" title="局域网各终端共享通信媒体（线路介质）的方法"></a>局域网各终端共享通信媒体（线路介质）的方法</h3><ul>
<li>静态划分信道<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
</li>
<li>动态媒体接入控制（多点接入）<ul>
<li>随机接入：用户想什么时候在线路上发送数据就什么时候发，什么都不用管。如果恰好有多个用户同时刻发送，则在线路上发生碰撞，需要 <strong>CSMA/CD 协议协调</strong>（主要被以太网采用）这是以太网最需要解决的问题。</li>
<li>受控接入，如多点线路探询（polling），或轮询（目前已不被采用）</li>
</ul>
</li>
</ul>
<p>静态划分的主要问题是增加新的计算机不方便，需要重新分配信道</p>
<h3 id="CSMD-CD-载波监听多点接入-碰撞检测"><a href="#CSMD-CD-载波监听多点接入-碰撞检测" class="headerlink" title="CSMD/CD 载波监听多点接入/碰撞检测"></a>CSMD/CD 载波监听多点接入/碰撞检测</h3><p>CSMA/CD 表示Carrier Sense Multiple Access with Collision Detection</p>
<p><strong>多点接入</strong> 表示许多计算机以多点接入的方式连接在一根总线上。<br><strong>载波监听</strong> 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么 “载波”。因此， “载波监听” 就是用电子技术检测总线上有没有其他计算机发送的数据信号。<br><strong>碰撞检测</strong> 就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的<strong>信号电压</strong>摆动值超过一定的<strong>门限值</strong>时，就认为总线上至少有两个站同时在发送数据，表明产生了<strong>碰撞</strong>。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。<br><strong>检测到碰撞后</strong>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p>
<h4 id="载波监听后仍然出现碰撞的可能"><a href="#载波监听后仍然出现碰撞的可能" class="headerlink" title="载波监听后仍然出现碰撞的可能"></a>载波监听后仍然出现碰撞的可能</h4><p>电磁波在总线上的有限传播速率的影响当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A 向 B 发出的信息，要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。</p>
<p><img src="/img/IMG123.png" alt=""></p>
<h3 id="CSMA-C的D重要特性"><a href="#CSMA-C的D重要特性" class="headerlink" title="CSMA/C的D重要特性"></a>CSMA/C的D重要特性</h3><p>使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信（<strong>半双工通信</strong>）<br>每个站在发送数据之后的一小段时间内，存在遭遇碰撞的可能性。所以不能保证在一定时间内一定能把数据发送出去。<br>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率（因为碰撞会降低效率）</p>
<p>可以看出，如果A到B之间的<strong>线路越长</strong>（传播时延τ受传播媒介长度影响），那么<strong>接受到碰撞信息的时间也会越长</strong>，所以<strong>CSMA/CD协议适合用在线路较短的局域网和以太网</strong>中。这也是局域网范围受限的原因之一。</p>
<h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><p>A能收到碰撞的最长时间为，当数据到达B后，B刚好发送数据，在主机B上发生了碰撞。最先发送数据帧的站，在发送数据帧后至多经过时间 <code>2τ</code>就可知道发送的数据帧是否遭受了碰撞。如果这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<h4 id="以太网的争用期"><a href="#以太网的争用期" class="headerlink" title="以太网的争用期"></a>以太网的争用期</h4><p>以太网的端到端往返时延<strong>2τ</strong>称为争用期，或碰撞窗口。通常，取 51.2 ms 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节未发生冲突，则后续的数据就不会发生冲突。</p>
<h4 id="最短有效帧长"><a href="#最短有效帧长" class="headerlink" title="最短有效帧长"></a>最短有效帧长</h4><p>如果发生冲突，就一定是在发送的前 64 字节之内。<br>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。<br>以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p>
<h3 id="强化碰撞"><a href="#强化碰撞" class="headerlink" title="强化碰撞"></a>强化碰撞</h3><p>当发送数据的站一旦发现发生了碰撞时：</p>
<ol>
<li>立即停止发送数据；</li>
<li>再继续发送若干比特的人为干扰信号 (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。</li>
</ol>
<h3 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h3><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。尽量避免再次发生碰撞</p>
<p>确定基本退避时间，一般是取为争用期 2t。<br>定义参数 k，k = Min[重传次数n, 10]<br>从整数集合[0,1,…, (2的K次方-1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。<br>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网两个标准"><a href="#以太网两个标准" class="headerlink" title="以太网两个标准"></a>以太网两个标准</h3><ol>
<li>DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。</li>
<li>IEEE 的 802.3 标准。</li>
</ol>
<p>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。说白了： <strong>以太网就是局域网</strong>。<br>严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</p>
<p>10M以太网使用CSMA/CD协议</p>
<h3 id="以太网与数据链路层的两个子层"><a href="#以太网与数据链路层的两个子层" class="headerlink" title="以太网与数据链路层的两个子层"></a>以太网与数据链路层的两个子层</h3><p>为了使数据链路层能更好地适应多种局域网标准，802 委员会就将局域网的数据链路层拆成两个子层：</p>
<ol>
<li><strong>逻辑链路控制 LLC</strong> (Logical Link Control)子层</li>
<li><strong>媒体接入控制 MAC</strong> (Medium Access Control)子层</li>
</ol>
<p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的。</p>
<p>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了，即现在LLC子层几乎不提了。</p>
<p>很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。</p>
<h3 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h3><p>以太网提供的服务是<strong>不可靠的交付</strong>，即尽最大努力的交付。<br>当接收站收到<strong>有差错的数据帧时就丢弃</strong>此帧，其他什么也不做。差错的纠正由传输层来决定。<br>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p>
<p><img src="/img/IMG124.jpg" alt=""><br>如图所示，PC1发送数据给PC0，在以太网上，ＲＡ接收到有差错的数据帧时就直接丢弃。如果PC0的高层（网络层以上）发现数据在途中丢失了，就会要求PC1重新发送一份。 </p>
<h3 id="传统以太网的拓扑——使用集线器的星形拓扑结构"><a href="#传统以太网的拓扑——使用集线器的星形拓扑结构" class="headerlink" title="传统以太网的拓扑——使用集线器的星形拓扑结构"></a>传统以太网的拓扑——使用集线器的星形拓扑结构</h3><p>传统以太网最初是使用<strong>粗同轴电缆</strong>，后来演进到使用比较便宜的<strong>细同轴电缆</strong>，最后发展为使用更便宜和更灵活的<strong>双绞线</strong>。不用电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong>(hub) 。</p>
<p>需要注意的是： 现在中间的可靠设备一般不用集线器了，现在组网去市场花个便宜的钱都是用交换机组网的。</p>
<p><img src="/img/IMG125.jpg" alt=""><br>100m以内</p>
<h3 id="集线器（hub）"><a href="#集线器（hub）" class="headerlink" title="集线器（hub）"></a>集线器（hub）</h3><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。<br>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。<br>集线器很像一个多接口的转发器，工作在<strong>物理层</strong>。 集线器是傻瓜式的，它没有智能作用，看不见什么信号。只知道机械的传输，也不管目的地址什么的，反正就是有信号就传。</p>
<p><img src="/img/IMG126.jpg" alt=""></p>
<p>接在工作站网卡上的8根双脚线有两根是发送数据的，有两根是接收数据的。A发送数据数据到集线器后，B和C都能收到，C发送数据到集线器后，A和B也能收到。发送者自己是收不到自己发出去的数据的。</p>
<p>需要注意的是： 这是早期的集线器，在芯片电路还没有出来之前的，集线器里面都是线连接的。现在的集线器都是芯片电路板了。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。</p>
<h3 id="以太网速度标准"><a href="#以太网速度标准" class="headerlink" title="以太网速度标准"></a>以太网速度标准</h3><p>10BASE-T（10Mb/s）的通信距离稍短，每个站到集线器的距离不超过 100 m。这种 10 Mb/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 </p>
<p>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</p>
<p>其他：100Base-FX(百兆快速以太网，使用光纤)、100Base-T和100Base-T4….</p>
<p>10：10M/s<br>BASE：基带信号<br>T：双绞线<br>FX：光纤</p>
<h3 id="以太网信道利用率"><a href="#以太网信道利用率" class="headerlink" title="以太网信道利用率"></a>以太网信道利用率</h3><p>因为每个站点发送数据时可能产生碰撞的可能，所以此时的信道不会被利用，所以利用率就会变低。</p>
<p>以太网的信道被占用的情况：<br>我们知道争用期长度为 2τ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。<br>如果帧长为 L (bit)，数据发送速率为 C (b/s)，因而帧的发送时间为 L/C = T0 (s)。</p>
<p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过τ时间使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p>
<p><img src="/img/IMG127.jpg" alt=""></p>
<p>要提高以太网的信道利用率，就必须减小τ 与 T0 之比。在以太网中定义了参数 a，它是以太网单程端到端时延τ与帧的发送时间 T0 之比： a=τ/T0      </p>
<p>a→0 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。<br>a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。</p>
<p>a并不是信道利用率，只是为了描述信道利用率的一个参数而已<br>从式子可以得出，要想a变小，则τ尽量变小，而T0尽量要大。<br>当数据率C一定时，T0=L（帧长）/C 。所以以太网的帧长L尽量要长些，这样T0会增大，a会变小。<br>当然也不能太长，太长后信道利用率过高会引起信道延迟成倍增加（ 信道利用率越高，数据线路上拥堵的可能性就越大，当高到一定程度后，会增加数据在线路上的延时）。<br>同时，以太网的连线的长度尽量短些，这样端到端的传播时间τ会变小，a会减小。当然也不能太短，太长后信道利用率过高会引起信道延迟成倍增加。</p>
<h4 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h4><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。</p>
<p>发送一帧占用线路的时间是 T0 +τ，而帧本身的发送时间是 T0。于是我们可计算出理想情况下的极限信道利用率 Smax为：  </p>
<p><img src="/img/IMG128.jpg" alt=""></p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>在局域网中，硬件地址又称为<strong>物理地址</strong>，或<strong> MAC 地址</strong>。 （<strong>48位地址</strong>）</p>
<p>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。 其实我们教材中说的地址并不是很确切，但是我们习惯将这种 48 位的“名字”称为“地址”，所以本书也采用这种习惯用法。</p>
<ul>
<li>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即<strong>高位 24 位</strong>)。</li>
<li>地址字段中的后三个字节(即低位 24 位)由厂家自行指派，称为<strong>扩展标识符</strong>，必须保证生产出的适配器<strong>没有重复地址</strong>。</li>
<li>一个地址块可以生成224个不同的地址。这种 48 位地址称为 <strong>MAC-48</strong>，它的通用名称是<strong>EUI-48</strong>。</li>
<li>“MAC地址”实际上就是适配器地址或适配器标识符EUI-48。在出厂前就烧录在了我们的网卡中。</li>
</ul>
<p>如果在一个局域网内（同一个交换机连接下）有相同的MAC地址，则会引起冲突，导致一方不能正常上网。<br>我们说MAC地址是刻在网卡适配器中的，是不可以更改的，但是我们可以指定一个MAC地址，让计算机应用指定的MAC地址，而不用网卡上固定的MAC地址。<br>windows修改mac地址方法：本地连接—更改适配器设置—本地连接属性—配置—-高级—网络地址（本地管理的地址）</p>
<h3 id="适配器检查-MAC-地址"><a href="#适配器检查-MAC-地址" class="headerlink" title="适配器检查 MAC 地址"></a>适配器检查 MAC 地址</h3><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址<br>如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p>
<p>“发往本站的帧”包括以下三种帧： </p>
<ul>
<li>单播(unicast)帧（一对一）</li>
<li>广播(broadcast)帧（一对全体）（源mac地址：FF:FF:FF:FF:FF:FF）</li>
<li>多播(multicast)帧（一对多）</li>
</ul>
<h3 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h3><p>常用的以太网MAC帧格式有两种标准 ：</p>
<ol>
<li>DIX Ethernet V2 标准</li>
<li>IEEE 的 802.3 标准</li>
</ol>
<p>最常用的 MAC 帧是以太网 V2 的格式。</p>
<p>MAC帧V2 格式<br><img src="/img/IMG129.jpg" alt=""><br>最小长度64字节（最短有效帧长，参考争用期）-18字节的首部和尾部（6+6+2+4）=数据字段的最小长度<br>为了达到比特同步在传输媒体上实际传送的要比 MAC 帧还多 8 个字节</p>
<h3 id="无效的-MAC-帧"><a href="#无效的-MAC-帧" class="headerlink" title="无效的 MAC 帧"></a>无效的 MAC 帧</h3><p>当适配器收到MAC帧后，会检查是否是有效的MAC帧。</p>
<ul>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 </p>
<h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><p>帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。<br>一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 </p>
<p>9.6 μs × 10Mb/s = 96bit</p>
<h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><p>扩展可以在物理层上也可在链路层上，但从网络层看依然是一个局域网。<br>以太网主机之间的距离不能太远（10BASE-T规定200米）</p>
<h3 id="在物理层扩展局域网"><a href="#在物理层扩展局域网" class="headerlink" title="在物理层扩展局域网"></a>在物理层扩展局域网</h3><p>主机使用光纤和一对光纤调制解调器连接到集线器<br><img src="/img/IMG130.png" alt=""><br><img src="/img/IMG131.png" alt=""><br>用多个集线器可连成更大的局域网</p>
<p><strong>优点</strong><br>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。<br>扩大了局域网覆盖的地理范围。（使用光纤可以扩大到几千米）<br>数量增加</p>
<p><strong>缺点</strong><br>碰撞域增大了，但总的吞吐量并未提高。<br>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。<br>三个碰撞域连起来后，最大吞吐率仍然是一个系的最大吞吐率。因为其中任何一台主机通信，其他主机都不能通信。</p>
<h3 id="在数据链路层扩展局域网"><a href="#在数据链路层扩展局域网" class="headerlink" title="在数据链路层扩展局域网"></a>在数据链路层扩展局域网</h3><p>在数据链路层扩展局域网是使用<strong>网桥</strong>。<br>网桥工作在数据链路层，它<strong>根据 MAC 帧的目的地址对收到的帧进行转发</strong>。</p>
<p>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。</p>
<h4 id="网桥的内部结构"><a href="#网桥的内部结构" class="headerlink" title="网桥的内部结构"></a>网桥的内部结构</h4><p>网桥具有多个接口<br>每个接口连接一个网段</p>
<p>若网桥从接口1收到从主机1向主机5的帧，则把帧发到接口2转发出去。<br>若网桥从接口1收到从主机2发到主机3的帧，则丢弃。因为主机2和3位于同一桥段，不用转发。<br><img src="/img/IMG132.png" alt=""></p>
<h4 id="使用网桥带来的好处"><a href="#使用网桥带来的好处" class="headerlink" title="使用网桥带来的好处"></a>使用网桥带来的好处</h4><p>过滤通信量，增大吞吐率。<br>扩大了物理范围。主机数量<br>提高了可靠性。只影响个别网段<br>可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。</p>
<p>网桥使各网段成为隔离开的碰撞域</p>
<h4 id="使用网桥带来的缺点"><a href="#使用网桥带来的缺点" class="headerlink" title="使用网桥带来的缺点"></a>使用网桥带来的缺点</h4><p>存储转发增加了时延。存储、查表、碰撞检测<br>在MAC 子层并没有流量控制功能。 网桥的缓存可能溢出，帧丢失。<br>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。<br>路由器可以阻断网络风暴</p>
<h4 id="网桥和集线器（或转发器）不同"><a href="#网桥和集线器（或转发器）不同" class="headerlink" title="网桥和集线器（或转发器）不同"></a>网桥和集线器（或转发器）不同</h4><p>集线器在转发帧时，不对传输媒体进行检测。<br>网桥在转发帧之前必须执行 CSMA/CD 算法。<br>若在发送过程中出现碰撞，就必须停止发送和进行退避。</p>
<h4 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h4><p>目前使用得最多的网桥是透明网桥(transparent bridge)。<br>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。<br>透明网桥是一种即插即用设备，其标准是 IEEE 802.1D。</p>
<h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><p>网桥使用自学习算法处理收到的帧和建立转发表，网桥并不是一开始就知道所连接网络的所有mac地址的，而是通过自学习算法建立转发表</p>
<p><img src="/img/IMG133.png" alt=""><br><img src="/img/IMG134.png" alt=""><br><img src="/img/IMG135.png" alt=""><br><img src="/img/IMG136.png" alt=""></p>
<ol>
<li>若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A。</li>
<li>网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。</li>
<li>在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面</li>
<li>在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li>
</ol>
<p>如果一个接口有多个mac说明，这个接口连接的是网桥或者交换机</p>
<h4 id="网桥在转发表中登记以下三个信息"><a href="#网桥在转发表中登记以下三个信息" class="headerlink" title="网桥在转发表中登记以下三个信息"></a>网桥在转发表中登记以下三个信息</h4><p>网桥转发表中的信息：<strong>地址</strong>、<strong>接口</strong>和<strong>帧进入该网桥的时间</strong>。</p>
<p>这是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。<br>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。 </p>
<h4 id="网桥的自学习和转发帧的步骤归纳"><a href="#网桥的自学习和转发帧的步骤归纳" class="headerlink" title="网桥的自学习和转发帧的步骤归纳"></a>网桥的自学习和转发帧的步骤归纳</h4><p>网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。<br>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<br>如有，则按转发表中给出的接口进行转发。<br>如没有，则通过所有其他接口（但进入网桥的接口除外）进行转发。<br>若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。</p>
<h4 id="透明网桥使用了生成树算法"><a href="#透明网桥使用了生成树算法" class="headerlink" title="透明网桥使用了生成树算法"></a>透明网桥使用了生成树算法</h4><p>这是为了避免产生转发的帧在网络中不断地兜圈子</p>
<p><img src="/img/IMG137.png" alt=""></p>
<p>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。 </p>
<p>为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</p>
<h3 id="多接口网桥——以太网交换机"><a href="#多接口网桥——以太网交换机" class="headerlink" title="多接口网桥——以太网交换机"></a>多接口网桥——以太网交换机</h3><p>1990 年问世的交换式集线器(switching hub)，可明显地提高局域网的性能。交换式集线器常称为<strong>以太网交换机</strong>(switch)或<strong>第二层交换机</strong>（表明此交换机工作在数据链路层）。以太网交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，可见交换机工作在数据链路层。</p>
<h4 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h4><p>以太网交换机的每个接口都直接与主机相连，并且一般都工作在<strong>全双工方式</strong>。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。</p>
<p><strong>独占传输媒体的带宽</strong><br>对于普通 10 Mb/s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽(10 Mb/s)的 N 分之一。使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 对接口的交换机的总容量为 N×10 Mb/s。这正是交换机的最大优点。</p>
<p>对于普通共享式HUB 若N个用户 总带宽：10Mb/s 每个用户占有平均带宽= 10M/N</p>
<h3 id="以太网交换机的交换方式"><a href="#以太网交换机的交换方式" class="headerlink" title="以太网交换机的交换方式"></a>以太网交换机的交换方式</h3><p>存储转发方式<br>把整个数据帧先缓存后再进行处理。<br>直通 (cut-through) 方式<br>接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。<br>缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</p>
<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。<br>在缺省配置的情况下，交换机的所有端口属于同一 VLAN。连接在不同交换机上的、属于同一 VLAN 的数据帧必须通过 Trunk 链路传输。</p>
<p><img src="/img/IMG138.png" alt=""></p>
<h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p>速率达到或超过 100 Mbit/s 的以太网称为高速以太网。100BASE-T 以太网又称为快速以太网 (Fast Ethernet)。</p>
<p>可在全双工方式下工作而无冲突发生。在全双工方式下工作时，不使用 CSMA/CD 协议。<br>MAC 帧格式仍然是 802.3 标准规定的。<br>保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 m。<br>帧间时间间隔从原来的 9.6 μs 改为现在的 0.96 μs。</p>
<h2 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h2><p>允许在 1 Gbit/s 下全双工和半双工两种方式工作。<br>使用 IEEE 802.3 协议规定的帧格式。<br>在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。</p>
<p><a href="http://blog.51cto.com/zhaoyuqiang/1575315" target="_blank" rel="external">http://blog.51cto.com/zhaoyuqiang/1575315</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实本文中数据链路层讲了两部分，一部分是针对广域网的PPP，另一部分是针对局域网（以太网）的CSMA/CD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;信道类型&quot;&gt;&lt;a href=&quot;#信道类型&quot; class=&quot;headerlink&quot; title=&quot;信道类型&quot;&gt;&lt;/a&gt;信道类型&lt;/h3&gt;&lt;p&gt;数据链路层使用的信道主要有以下两种类型&lt;br&gt;&lt;strong&gt;点对点信道&lt;/strong&gt;。这种信道使用 &lt;strong&gt;一对一&lt;/strong&gt; 的点对点通信方式。用于&lt;strong&gt;广域网&lt;/strong&gt;，使用&lt;strong&gt;PPP协议&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;广播信道&lt;/strong&gt;。这种信道使用 &lt;strong&gt;一对多&lt;/strong&gt; 的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的&lt;strong&gt;共享信道协议&lt;/strong&gt;来协调这些主机的数据发送。用于&lt;strong&gt;局域网&lt;/strong&gt;，使用&lt;strong&gt;CSMA/CD协议&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-物理层</title>
    <link href="http://yoursite.com/post/b709c2f1.html"/>
    <id>http://yoursite.com/post/b709c2f1.html</id>
    <published>2018-06-19T13:09:35.000Z</published>
    <updated>2018-06-20T23:59:15.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各种计算机的 <strong>传输媒体</strong>（光纤、无线等）上传输 <strong>数据比特流</strong>，而不是指具体的传输媒体<br>物理层的主要任务描述为：确定传输媒体的接口的一些特性，即：</p>
<ol>
<li><strong>机械特性</strong>：例如接口形状，大小，引线数目</li>
<li><strong>电气特性</strong>：例如规定电压范围（-5V到+5V）</li>
<li><strong>功能特性</strong>：例如规定-5V表示0，+5V表示1</li>
<li><strong>过程特性</strong>：也称为规程特性，规定建立连接时各个相关部件的工作步骤</li>
</ol>
<a id="more"></a>
<p><br></p>
<h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><p><img src="/img/IMG72.png" alt=""><br>广域网：公共电话网<br>局域网：通过交换机直接使用数字比特流</p>
<p>数据通信不只包括计算机通信，也包括电视、电话、传真等通信方式</p>
<p>通信的目的是传送消息</p>
<ul>
<li>数据data：运送消息的实体</li>
<li>信号signal：数据的电气或电磁表现<ul>
<li>模拟信号：代表消息的参数的取值是连续的</li>
<li>数字信号：代表消息的参数的聚会是离散的</li>
</ul>
</li>
<li>码元code：在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元(在波形中单个0和1就代表码元)，在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度，1码元可以携带nbit的信息量</li>
</ul>
<p><img src="/img/IMG73.png" alt=""><br>右图表示一码元可以携带3bit的信息，可以通过不同的电压表示 </p>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道一般表示向一个方向传送信息的媒体（A到B是一条，B到A是一条），所以平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道</p>
<ul>
<li><strong>单向通信</strong>（单工通信）：只能有一个方向的通信而没有反方向的交互，电视、收音机</li>
<li><strong>双向交替通信</strong>（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送（当然也不能同时接收），对讲机</li>
<li><strong>双向同时通信</strong>（全双工通信）：通信的双方可以同时发送和接收信息</li>
</ul>
<h3 id="基带信号和带通信号、调制"><a href="#基带信号和带通信号、调制" class="headerlink" title="基带信号和带通信号、调制"></a>基带信号和带通信号、调制</h3><ul>
<li>基带信号/baseband/基本频带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号</li>
<li>带通信号/band pass：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）</li>
</ul>
<p>基带信号传播衰减太严重，这就是为什么需要带通信号的原因，带通信号能够在空气中传播较远的范围</p>
<p>由于在传输距离较近时，基带信号的衰减不大，信号内容不会发生变化，当在较近范围内传输时计算机网络会采用基带传输方式。如从计算机到监视器、打印机等外设的信号就是基带信号</p>
<p>把基带信号调制为带通信号的常见方式有三种：</p>
<ol>
<li><strong>调幅</strong>（AM）：载波的振幅随基带数字信号而变化</li>
<li><strong>调频</strong>（FM）：载波的频率随基带数字信号而变化</li>
<li><strong>调相</strong>（PM）：载波的初始相位随基带数字信号而变化</li>
</ol>
<p><img src="/img/IMG74.png" alt=""></p>
<h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><ol>
<li>单极性不归零码：只使用一个电压值，用高电平表示1，没电压表示0</li>
<li>双极性不归零码：用正电平和负电平分别表示二进制数据的1和0，正负幅值相等</li>
<li>单极性归零码（RZ）：即是高电平和零电平分别表示二进制码1和0，而且在发送码1时高电平在整个码元期间T只持续一段时间t，其余时间返回零电平</li>
<li>双极性归零码：正负零三个电平，信号本身携带同步信号</li>
<li>曼彻斯特编码</li>
<li>差分曼彻斯特编码</li>
</ol>
<p>单极性和双极性：区别在于0用没电压表示还量用负电平表示<br>归零和不归零：每一bit结束时是否归零，不归零这种方式无法区分到底是0还是没有信号<br><img src="/img/IMG75.png" alt=""></p>
<p><strong>曼彻斯特编码</strong></p>
<p><img src="/img/IMG76.png" alt=""><br>采样两次是指每bit开始一次，结束一次，比较开始和结束是从高电平转低电平还是从低电平转高电平</p>
<p><strong>差分曼彻斯特编码</strong><br><img src="/img/IMG77.png" alt=""><br>注意，看的是bit与bit之间是否有跳变，不是bit内<br><img src="/img/IMG78.png" alt=""></p>
<h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p>有失真，但可以识别<br><img src="/img/IMG79.png" alt=""></p>
<p>失真大，无法识别<br><img src="/img/IMG80.png" alt=""></p>
<p><strong>奈氏准则</strong><br>1924年，奈奎斯特（Nyquist)就推导出了著名的奈氏准则，他给出了在 <strong>假定的理想条件</strong>下，为了避免码间串扰，码元的传输速率的上限值。<br>在任何信道中，<strong>码元传输的速率是有上限的</strong>，否则就会出现 <strong>码间串扰</strong>的问题，使接收端对码元的识别成为不可能。<br>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以使用更高的速率传送码元而不出现码间串扰。</p>
<p><strong>香农理论</strong><br>在奈氏准则的基础上，香农用信息论的理论推导出了 <strong>带宽受限</strong>且有 <strong>噪声干扰</strong>的信道的极限、<strong>无差错的信息传输速率</strong>。</p>
<p>信道的极限信息传输速率C可表达为：<code>C=W lg(1+S/N)/lg2 b/s</code></p>
<ul>
<li>W为信道的带宽（以Hz为单位）</li>
<li>S为信道内所传信号的平均功率</li>
<li>N为信道内部的高斯噪声功率</li>
<li>S/N为信噪比</li>
</ul>
<ol>
<li>信道的带宽或信道中的<strong>信噪比越大</strong>，则信息的<strong>极限传输速率就越高</strong></li>
<li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输</li>
<li>若信道带宽 W 或信噪比<code>S/N</code>没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率C也就没有上限</li>
<li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少</li>
</ol>
<p><img src="/img/IMG81.png" alt=""></p>
<p><br></p>
<h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><h3 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h3><p>导向传输媒体中，电磁波沿着固体媒体传播</p>
<ul>
<li>双绞线<ul>
<li>屏蔽双绞线STP：屏蔽网线，优点屏蔽性好，抗干扰能力强。缺点价格昂贵，与UTP相比，直径较大，更重以及不易安装</li>
<li>无屏蔽双绞线UTP：非屏蔽网线，优点是价格便宜，直径较小，易安装。缺点是抗干扰能力较弱</li>
</ul>
</li>
<li>同轴电缆<ul>
<li>50Ω 同轴电缆用于数字传输，由于多用于基带传输，也叫基带同轴电缆</li>
<li>75Ω 同轴电缆用于模拟传输，即宽带同轴电缆</li>
</ul>
</li>
<li>光缆</li>
</ul>
<p><img src="/img/IMG82.png" alt=""></p>
<h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>LAN网络中最常见的数据传输铜介质是双绞线。铜介质优点是可以非常好的传导电信号，缺点是易受外界干扰而产生畸形和信号衰减，导致长距离传输过程中能量损失。为解决上述不足，提高数据传输稳定性，IEEE制定了LAN线缆标准，主要有两种：屏蔽双绞线(STP)和非屏蔽双绞线(UTP)。</p>
<p>所谓双绞线，实际上是将线缆中细铜缆成对出现。之所以这样设计，原因是在数据传输过程中，电线中电流流过时产生电磁场，干扰线缆中其它细铜缆。为解决这个问题，将电缆中细铜线 <strong>两两配对</strong>，使得传输过程中两两配对的细铜缆产生的 <strong>电磁场互相抵消</strong>，减少串扰。</p>
<p>随着UTP单位长度中的双绞次数的增多，抗干扰能力也得到加强,是目前使用最广泛的双绞线，而STP因需要接地，安装不易反而没有得到大范围应用。在实际工作中可以察看双绞线的双绞频率判断双绞线的伪劣。</p>
<h5 id="双绞线线缆引脚顺序"><a href="#双绞线线缆引脚顺序" class="headerlink" title="双绞线线缆引脚顺序"></a>双绞线线缆引脚顺序</h5><p>双绞线要正常稳定工作，需要在两端将细铜缆按一定的顺序接在连接器中。双绞线使用的连接器标准是 <strong>RJ-45连接器</strong>。要理解线缆的引脚顺序本质，实际上需要理解硬件设备接收发送电信号的规则：</p>
<ol>
<li>以太网设备使用一对铜细缆来传输数据</li>
<li>以太网设备使用一对铜细缆来接收数据</li>
<li>以太网设备不能使用同一对铜细缆来同时传输和接收数据。</li>
</ol>
<p>结论：<strong>在以太网中，以太网设备需要使用两对细铜缆分别用来进行数据的接收和发送</strong>。</p>
<p>理解了以上规则后，我们再来了解下不同的硬件设备用于发送和接收数据的工作规则：</p>
<ol>
<li>网卡NIC：1、2引脚发送数据，3、6引脚接收数据</li>
<li>集线器：3、6引脚发送数据，1，2引脚接收数据</li>
<li>交换机：3、6引脚发送数据，1，2引脚接收数据</li>
<li>网桥：3、6引脚发送数据，1，2引脚接收数据</li>
<li>路由器：1，2引脚发送数据，3，6引脚接收数据</li>
</ol>
<p>了解了不同硬件设备的接收发送信号的引脚编号后，再看来直通线和交叉线的使用场景就会清晰很多。</p>
<p>以最常见的PC机与交换机通信为例</p>
<ol>
<li>PC机网卡发送信号给交换机，对于NIC端是发送数据，NIC的发送引脚是1，2引脚，对于交换机是接收数据，参照上述规则，交换机接收数据使用的是1，2引脚。</li>
<li>交换机发送信号到PC机网卡，对于交换机是发送数据，使用3，6引脚，对于NIC端是接收数据，同样使用3，6引脚。</li>
</ol>
<p>所以PC机与交换机通过网线相连，用于通信的线缆1、2、3、6引脚两端顺序保持一致，简称直通线。<br>同理，PC机与集线器、网桥相连，也使用直通线。</p>
<p>结论：<br><strong>互相通信的网络设备使用的传输引脚规则一致时，使用交叉线</strong><br><strong>互相通信的网络设备使用的传输引脚规则不同时，使用直通线</strong></p>
<h5 id="TIA-EIA-586A与TIA-EIA-586B引脚顺序"><a href="#TIA-EIA-586A与TIA-EIA-586B引脚顺序" class="headerlink" title="TIA/EIA-586A与TIA/EIA-586B引脚顺序"></a>TIA/EIA-586A与TIA/EIA-586B引脚顺序</h5><p>从上述双绞线线缆引脚顺序的描述中，可以看出两台设备要能正常通信，只需要根据具体设备发送和接收数据的工作规则来排列正确的引脚次序。比如说PC机与交换机通信，只要将网线两端的引脚顺序保持一致就可以，那么可以通信的引脚顺序组合有：8<em>7</em>6<em>5</em>4<em>3</em>2*1种可能性。为避免不同人员随意性的引脚顺序排列，TIA/EIA制定了两个网线引脚顺序标准，分别是<code>TIA/EIA-586A</code>与<code>TIA/EIA-586B</code>，强制要求所有的网线引脚顺序必须遵循以上两种标准之一。</p>
<p>TIA/EIA-586A引脚顺序：1-绿白 2-绿 3-橙白 4-蓝 5-蓝白 6-橙 7棕白 8棕<br>TIA/EIA-586B引脚顺序：1-橙白 2-橙 3-绿白 4-蓝 5-蓝白 6-绿 7棕白 8棕</p>
<p>观察586A和586B引脚顺序，实质上就是 <strong>1，2引脚和3，6引脚互换了位置</strong>，其它位置的引脚保持不变。<br>1、2、3、6是10M和100M网线使用的线路，1000M使用全部8根线</p>
<p>根据标准的586A和586B标准，再来明确一下直通线和交叉线的定义：</p>
<ul>
<li>直通线：两端使用相同引脚顺序，同时使用586A标准或同时使用586B标准。用于不同类的网络设备连接，如电脑与交换机、交换机与路由器等。</li>
<li>交叉线：两端使用不同的引脚顺序，一端使用586A顺序，一端使用586B顺序，主要用于同类网络设备的连接，如交换机与交换机、电脑与电脑等。</li>
</ul>
<p>当前大部分网络设备、网络终端的网线接口均支持 <strong>自动翻转</strong>功能。</p>
<h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="/img/IMG83.png" alt=""><br><img src="/img/IMG84.png" alt=""><br><img src="/img/IMG85.png" alt=""></p>
<h3 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h3><p>非导向传输媒体就是指 <strong>自由空间</strong>，其中的电磁波传输被称为无线传输<br>无线传输所使用的频段很广<br>短波通信主要是靠电离层的反射，但短波信道的通信质量较差<br>微波在空间主要是直线传播<br>    地面微波接力通信<br>    卫星通信</p>
<p><img src="/img/IMG86.png" alt=""></p>
<h3 id="物理层设备———集线器"><a href="#物理层设备———集线器" class="headerlink" title="物理层设备———集线器"></a>物理层设备———集线器</h3><p>工作范围：它在网络中只起信号放大和重发作用，其目的是扩大网络的传输范围，而 <strong>不具备信号的定向传送能力</strong>（不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点）<br>最大传输距离：100m<br>集线器是一个大的冲突域（带宽共用）</p>
<p><br></p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p><img src="/img/IMG87.png" alt=""></p>
<h3 id="频分复用FDM-Frequency-Division-Multiplexing"><a href="#频分复用FDM-Frequency-Division-Multiplexing" class="headerlink" title="频分复用FDM Frequency Division Multiplexing"></a>频分复用FDM Frequency Division Multiplexing</h3><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带<br>频分复用的所有用户在同样的时间占用不同的频率</p>
<p><img src="/img/IMG88.png" alt=""><br><img src="/img/IMG89.png" alt=""><br><img src="/img/IMG90.png" alt=""><br><img src="/img/IMG91.png" alt=""></p>
<h3 id="时分利用TDM-Time-Division-Multiplexing"><a href="#时分利用TDM-Time-Division-Multiplexing" class="headerlink" title="时分利用TDM Time Division Multiplexing"></a>时分利用TDM Time Division Multiplexing</h3><p>时分复用是将时间划分为一段段等长的时分复用帧（TDM帧），每一个时分复用的用户在每个TDM帧中占用固定序号的时隙<br>每个用户所占用的时隙是周期性（其周期性就是TDM帧的长度对应的时间）<br>TDM信号也称为等时（isochronous)信号</p>
<p>时分复用的所有用户是在不同的时间占用同样的频带宽度</p>
<p><img src="/img/IMG92.png" alt=""><br><img src="/img/IMG93.png" alt=""><br><img src="/img/IMG94.png" alt=""></p>
<h4 id="统计时分复用STDM-Statistic-TDM"><a href="#统计时分复用STDM-Statistic-TDM" class="headerlink" title="统计时分复用STDM Statistic TDM"></a>统计时分复用STDM Statistic TDM</h4><p>时分复用可能会造成线路资源的浪费<br>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的，所以出现了统计时分复用</p>
<p><img src="/img/IMG95.png" alt=""><br><img src="/img/IMG96.png" alt=""></p>
<h3 id="波分复用WDM-Wavelength-Division-Multiplexing"><a href="#波分复用WDM-Wavelength-Division-Multiplexing" class="headerlink" title="波分复用WDM Wavelength Division Multiplexing"></a>波分复用WDM Wavelength Division Multiplexing</h3><p>波分复用就是光的频分复用</p>
<p><img src="/img/IMG97.png" alt=""><br><img src="/img/IMG98.png" alt=""></p>
<p><br></p>
<h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>脉冲编码调制PCM最初是为了在电话局之间的中继线上传送多路的电话。由于历史的原因，PCM有两个互一兼容的标准，即北美24路PCM（简称为T1）和欧洲的30路PCM（简称为E1）。我国采用的是欧洲的E1标准。<br>E1的速率是 2.048Mb/s，而T1的速率是 1.544Mb/s<br>当需要有更高的数据率时，可采用复用的方法</p>
<p>PCM 是要把声音从 <strong>模拟转换成数字信号</strong>的一种技术，他的原理简单地说就是利用一个固定的频率对模拟信号进行采样，采样后的信号在波形上看就像一串连续的幅值不一的脉冲，把这些脉冲的幅值按一定的精度进行量化，这些量化后的数值被连续地输出、传输、处理或记录到存储介质中，所有这些组成了数字音频的产生过程。</p>
<p><img src="/img/IMG99.png" alt=""></p>
<p>电话的采样采样频率通常为8000次/s，量化精度是 8bit（每一个波形/码元用8位二进制表示）<br>8000×8 = 64Kb/s<br>PCM产生的数字信号称为 <strong>数字基带信号</strong></p>
<p><img src="/img/IMG100.png" alt=""><br><img src="/img/IMG101.png" alt=""></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/hanmengaidudu/article/details/78854264" target="_blank" rel="external">https://blog.csdn.net/hanmengaidudu/article/details/78854264</a></li>
<li><a href="https://baike.baidu.com/item/PCM/1568054" target="_blank" rel="external">https://baike.baidu.com/item/PCM/1568054</a></li>
</ul>
<p><br></p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>究其本质，没有太多区别，它们都是接入网络（Access Network），先认证用户合法，分配 IP 地址等上网必备的参数，将用户电脑接入互联网 Internet。运营商在将用户接入网络的同时，启动用户流量统计/用户在线时长统计，以生成用户账单，用户掏钱。</p>
<p>但由于采用的传输介质（physical media）大不同，有模拟电话线、数字铜线、光纤，以及成帧方式的不同，有 PPP，PPPoE +PPP，IPoE，在上网速率上体现出数量级的差别，从模拟电话线 56Kbps，ISDN 144Kbps，ADSL 512Kbps-10Mbps，FTTH 2-1000Mbps。</p>
<h3 id="拨号上网"><a href="#拨号上网" class="headerlink" title="拨号上网"></a>拨号上网</h3><h4 id="模拟线电话拨号"><a href="#模拟线电话拨号" class="headerlink" title="模拟线电话拨号"></a>模拟线电话拨号</h4><p>使用电话线，用户可以在自己的电脑上安装一个内置（插在电脑 PCI 插槽）modem，或外置（插在 RS-232 接口）modem官方的名字：调制解调器，民间的名字：猫！它负责将电脑的数字信号转换为可以在电话线上传输的模拟信号。在局端，也有对应的 modem，再将模拟信号转换为数字信号。</p>
<h4 id="数字线电话拨号-ISDN"><a href="#数字线电话拨号-ISDN" class="headerlink" title="数字线电话拨号 ISDN"></a>数字线电话拨号 ISDN</h4><p>此为数字线，所以不需要模数转换的 modem，提供 B +2D 接入方式，即一条 16Kbps 信令通道 B，两条各 64 Kbps 数据通道 D，可以一条线路打电话，同时另一条上网；也可以两条 D 通道都用于上网，即 64 + 64=128 Kbps 的上网带宽。</p>
<h3 id="xDSL方式"><a href="#xDSL方式" class="headerlink" title="xDSL方式"></a>xDSL方式</h3><p>xDSL：用数字技术对现有的模拟电话用户线进行改造。标准模拟电话信号的频带限制在300～3400Hz的范围内，但用户线本身实际可通过的信号频率超过1MHz。xDSL就把0～4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱给用户上网使用。</p>
<ul>
<li>DSL：数字用户线路</li>
<li>ADSL：不对称数字用户线路</li>
<li>VDSL：甚高比特率数字用户线路</li>
<li>R-ADSL：速率适应数字用户线</li>
<li>IDSL：ISDN DSL</li>
<li>HDSL：高速数字用户线</li>
<li>SDSL：单线用户数字线</li>
</ul>
<p><img src="/img/IMG102.png" alt=""><br><img src="/img/IMG103.png" alt=""></p>
<p>中间还是一根电话线，你这头是一个ADSL宽带猫，运营商机房那头是对应的宽带设备。</p>
<p>ADSL的特点</p>
<ol>
<li>上行和下行带宽做成不对称的</li>
<li>ADSL在用户线的两端各安装一个ADSL调制解调器</li>
<li>我国目前采用的方案是离散多间调DMT（Discrete Multi-Tone）调制技术</li>
</ol>
<p><strong>DMT技术</strong><br>DMT调制技术采用频分复用的方法，把40kHz以上一直到1.1MHz的高端频谱划分为许多的子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道<br>每个子信道占据4kHz带宽，并使用不同的载波（即不同的音调）进行数字调制，这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据</p>
<p><img src="/img/IMG104.png" alt=""></p>
<p>Serial/parallel converter 串/并行转换</p>
<p><img src="/img/IMG105.png" alt=""><br><img src="/img/IMG106.png" alt=""></p>
<h3 id="HFC"><a href="#HFC" class="headerlink" title="HFC"></a>HFC</h3><p>光纤同轴混合网，Hybrid Fiber Coax</p>
<p>HFC网是在目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。<br>HFC网除可传送CATV外，还提供电话、数据和其他宽带交互型业务。<br>现有的CATV网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而HFC网则需要对CATV进行改造。</p>
<p>HFC的主要特点：</p>
<ul>
<li>HFC网的主干线路采用光纤。HFC网将原CATV网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。在模拟光纤中采用光的振幅调制AM，这比使用数字光纤更为经济。模拟光纤从头端连接到光纤结点（fiber node），即光分配结点OND（Optical Distribution Node）。在光纤结点光信号被转换为电信号，在光纤结点以下就是同轴电缆。</li>
<li>HFC网具有比CATV网更宽的频谱，且具有双向传输功能</li>
<li>每个家庭要安装一个用户接口盒</li>
</ul>
<p><img src="/img/IMG107.png" alt=""><br><img src="/img/IMG108.png" alt=""><br><img src="/img/IMG109.png" alt=""></p>
<p>HFC的优点<br>具有很宽的频带<br>能够利用已经有相当大的覆盖面的有线电视网</p>
<h3 id="FTTx"><a href="#FTTx" class="headerlink" title="FTTx"></a>FTTx</h3><p>FTTx（光纤到……），这里字母x可代表不同意思</p>
<ul>
<li>光纤到家FTTH（Fiber To The Home）：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法（155Mb/s）</li>
<li>光纤到大楼FTTB（Fiber To The Building）：光纤进入大楼后就接入交换机，然后用电缆或双绞线分配到各用户</li>
<li>光纤到路边FTTC（Fiber To The Curb）：从路边到各用户可使用星形结构双绞线作为传输媒体（155Mb/s）</li>
</ul>
<p><br></p>
<p>参考：</p>
<ul>
<li><a href="http://blog.51cto.com/alligator/910667" target="_blank" rel="external">http://blog.51cto.com/alligator/910667</a></li>
<li><a href="http://www.admin10000.com/document/3946.html" target="_blank" rel="external">http://www.admin10000.com/document/3946.html</a></li>
<li><a href="https://www.zhihu.com/question/48988005" target="_blank" rel="external">https://www.zhihu.com/question/48988005</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;物理层的基本概念&quot;&gt;&lt;a href=&quot;#物理层的基本概念&quot; class=&quot;headerlink&quot; title=&quot;物理层的基本概念&quot;&gt;&lt;/a&gt;物理层的基本概念&lt;/h2&gt;&lt;p&gt;物理层解决如何在连接各种计算机的 &lt;strong&gt;传输媒体&lt;/strong&gt;（光纤、无线等）上传输 &lt;strong&gt;数据比特流&lt;/strong&gt;，而不是指具体的传输媒体&lt;br&gt;物理层的主要任务描述为：确定传输媒体的接口的一些特性，即：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;机械特性&lt;/strong&gt;：例如接口形状，大小，引线数目&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;电气特性&lt;/strong&gt;：例如规定电压范围（-5V到+5V）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能特性&lt;/strong&gt;：例如规定-5V表示0，+5V表示1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过程特性&lt;/strong&gt;：也称为规程特性，规定建立连接时各个相关部件的工作步骤&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络性能指标</title>
    <link href="http://yoursite.com/post/da722289.html"/>
    <id>http://yoursite.com/post/da722289.html</id>
    <published>2018-06-19T08:35:24.000Z</published>
    <updated>2018-06-20T23:56:53.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>连接在计算机网络上的主机在 <strong>数字信道</strong> 上传送 <strong>数据位数</strong> 的速率，也称为 <code>data rate</code> 或 <code>bit rate</code><br>单位：<code>b/s</code>、<code>kb/s</code>、<code>Mb/s</code>、<code>Gb/s</code></p>
<p>注意两点：</p>
<ol>
<li>速率是指一个信道</li>
<li>计算的是<code>bit</code>，而不是<code>byte</code>，实际网速多用<code>K/s</code>、<code>M/s</code>都是计算<code>byte</code>，而我们说的带宽有100M指的是<code>bit</code>，故而实际网速是带宽除以8</li>
</ol>
<p><br></p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>数据通信领域中，数字信道所能传送的最高数据率，单位是<code>b/s</code>、<code>kb/s</code>、<code>Mb/s</code>、<code>Gb/s</code><br>所有信道传输和的最大值</p>
<p><br></p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>在单位时间内通过某个网络的数据量，单位是<code>b/s</code>、<code>kb/s</code>、<code>Mb/s</code>、<code>Gb/s</code><br>单位时间内所有信道传输的和</p>
<p><br></p>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>又叫延迟。<br>时延是指一个报文或分组从一个网络的一端传送到另一个端所需要的时间。它包括了发送时延，传播时延，处理时延，排队时延。主要时延是发送时延和传播时延</p>
<ul>
<li>发送时延：数据块长度(bit)/信道带宽(b/s)。主机或路由器发送数据帧所需要的时间，也就是从发送数据的第一个比特算起，到该帧的最后一个比特发送（到网线上）完毕所需的时间。发送时延也称为传输时延。</li>
<li>传播时延：数据在网络上传输开始到接收端完全接收数据结束。电磁波在信道中传播一定的距离需要花费的时间</li>
<li>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，就这产生了处理时延。</li>
<li>排队时延：分组在经过网络传输时，会经过许多路由器。分组在进入路由器之前要先在输入队列中排队等待处理（因为可能无法一次处理完成）。在路由器确定了转发接口后，还要在输出队列中排队等待转发（因为可能无法一次发送完成）。这就产生了排队时延。</li>
</ul>
<p>带宽决定了发送时延，带宽越大，时延越低，但是不能无限增大，数据太密集后，可能无法识别高电压和低电压，也就无法识别数据，这时就要考虑传播介质，传播介质决定传播时延，铜介质因为信号太密集就无法识别，而光纤可以</p>
<p><br></p>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 = 带宽×传播时延</p>
<p><br></p>
<h2 id="往返时间-RTT-Round-Trip-Time"><a href="#往返时间-RTT-Round-Trip-Time" class="headerlink" title="往返时间 RTT Round-Trip Time"></a>往返时间 RTT Round-Trip Time</h2><p>从发送方发送数据开始，到发送方收到接收方确认<br><code>ping</code>命令查看的时间就是往返时间</p>
<p><br></p>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：有数据通过时间/(有+无)数据通过时间<br>网络利用率：信道利用率加权平均值</p>
<p><img src="/img/IMG71.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;速率&quot;&gt;&lt;a href=&quot;#速率&quot; class=&quot;headerlink&quot; title=&quot;速率&quot;&gt;&lt;/a&gt;速率&lt;/h2&gt;&lt;p&gt;连接在计算机网络上的主机在 &lt;strong&gt;数字信道&lt;/strong&gt; 上传送 &lt;strong&gt;数据位数&lt;/strong&gt; 的速率，也称为 
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>gns3使用</title>
    <link href="http://yoursite.com/post/1f37d955.html"/>
    <id>http://yoursite.com/post/1f37d955.html</id>
    <published>2018-06-19T04:43:47.000Z</published>
    <updated>2018-06-19T08:35:53.966Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://gns3.com/" target="_blank" rel="external">https://gns3.com/</a></p>
<p>ubuntu下安装gns3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:gns3/ppa</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install gns3-gui</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官网：&lt;a href=&quot;https://gns3.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gns3.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ubuntu下安装gns3&lt;br&gt;&lt;figure class=&quot;highlight plai
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python播放视频</title>
    <link href="http://yoursite.com/post/fb7a8e23.html"/>
    <id>http://yoursite.com/post/fb7a8e23.html</id>
    <published>2018-06-18T14:14:32.000Z</published>
    <updated>2018-06-19T08:32:40.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装opencv"><a href="#安装opencv" class="headerlink" title="安装opencv"></a>安装opencv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install opencv-python</div></pre></td></tr></table></figure>
<p>如果使用以下方式安装，则安装opencv2，只能在python2.7下使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-opencv</div></pre></td></tr></table></figure></p>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">&gt;&gt;&gt; cv2.__version__</div><div class="line">&apos;3.4.1&apos;</div></pre></td></tr></table></figure>
<h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><p>这样只有声音<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import pyglet</div><div class="line">import os</div><div class="line"></div><div class="line">window=pyglet.window.Window(caption=&apos;my player&apos;)</div><div class="line"></div><div class="line">player=pyglet.media.Player()</div><div class="line"></div><div class="line">source=pyglet.media.load(&apos;./sound/movie.flv&apos;,streaming=False)</div><div class="line">player.play()</div><div class="line"></div><div class="line">@window.event</div><div class="line">def on_draw():</div><div class="line">    window.clear()</div><div class="line">    player.get_texture().blit(0,0)</div><div class="line"></div><div class="line">pyglet.app.run()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装opencv&quot;&gt;&lt;a href=&quot;#安装opencv&quot; class=&quot;headerlink&quot; title=&quot;安装opencv&quot;&gt;&lt;/a&gt;安装opencv&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python变量和常量</title>
    <link href="http://yoursite.com/post/7f049186.html"/>
    <id>http://yoursite.com/post/7f049186.html</id>
    <published>2018-06-16T23:16:15.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>命名</strong></p>
<ol>
<li>第一个字符必须是字母表中的字母(大写ASCII字符或小写ASCII字符或Unicode字符)或下划线(<code>_</code>)。</li>
<li>标识符的其它部分可以由字符(大写 ASCII 字符或小写 ASCII 字符或 Unicode字符)、下划线(<code>_</code>)、数字(0~9)组成。</li>
<li>标识符名称区分大小写</li>
</ol>
<p>实际上是把变量b指向变量a所指向的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">ABC</div><div class="line">&gt;&gt;&gt; b=a</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">ABC</div><div class="line">&gt;&gt;&gt; a=&apos;XYZ&apos;</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">XYZ</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">ABC</div></pre></td></tr></table></figure></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>通常用全部大写的变量名表示常量，但无法保证不会被改变，<strong>本质还是变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PI = 3.14159265359</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一个字符必须是字母表中的字母(大写ASCII字符或小写ASCII字符或U
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型</title>
    <link href="http://yoursite.com/post/9f07ae5c.html"/>
    <id>http://yoursite.com/post/9f07ae5c.html</id>
    <published>2018-06-15T12:12:21.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据类型</strong></p>
<ul>
<li>整数：<code>-1</code>，<code>100</code>，<code>0</code>，<code>0xff00</code>（十六进制整数）</li>
<li>浮点数：<code>1.23</code>，<code>-9.01</code>，<code>1.23e9</code>，<code>1.23-5</code></li>
<li>字符串：<code>&#39;12c&#39;</code>，<code>&quot;ab&quot;</code>，<code>&quot;I&#39;m OK&quot;</code>，<code>&#39;I\&#39;m OK&#39;</code></li>
<li>布尔值：<code>True</code>，<code>False</code>（首字母大写）</li>
<li>空值：<code>None</code></li>
</ul>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的），而浮点数运算则可能会有四舍五入的误差。</p>
<ul>
<li>转义字符：<code>\n</code>，<code>\\</code>，<code>\t</code>，<code>\&#39;</code>，<code>\&quot;</code></li>
<li>用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</li>
<li>用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(r&apos;&apos;&apos;hello,\n</div><div class="line">... world&apos;&apos;&apos;)</div><div class="line">hello,\n</div><div class="line">world</div></pre></td></tr></table></figure>
<p><code>and</code>，<code>or</code>，<code>not</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; True and True</div><div class="line">True</div><div class="line">&gt;&gt;&gt; True and False</div><div class="line">False</div><div class="line">&gt;&gt;&gt; True or True</div><div class="line">True</div><div class="line">&gt;&gt;&gt; True or False</div><div class="line">True</div><div class="line">&gt;&gt;&gt; not True</div><div class="line">False</div><div class="line">&gt;&gt;&gt; not False</div><div class="line">True</div><div class="line">&gt;&gt;&gt; not 1&gt;2</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p><strong>数据类型转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s=&apos;123&apos;</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&apos;123&apos;</div><div class="line">&gt;&gt;&gt; int(s)</div><div class="line">123</div><div class="line">&gt;&gt;&gt; a=123</div><div class="line">&gt;&gt;&gt; a</div><div class="line">123</div><div class="line">&gt;&gt;&gt; str(a)</div><div class="line">&apos;123&apos;</div><div class="line">&gt;&gt;&gt; bool(1)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; bool(&apos;&apos;)</div><div class="line">False</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数：&lt;code&gt;-1&lt;/code&gt;，&lt;code&gt;100&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;0xff00&lt;/code&gt;（十六进制整数）&lt;/li&gt;
&lt;li&gt;浮点数：&lt;code&gt;1.23
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python输入输出及基础</title>
    <link href="http://yoursite.com/post/32cf0123.html"/>
    <id>http://yoursite.com/post/32cf0123.html</id>
    <published>2018-06-15T12:12:09.000Z</published>
    <updated>2018-06-19T08:32:40.788Z</updated>
    
    <content type="html"><![CDATA[<p><strong>输出</strong><br>自动添加空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;print(&apos;hello world&apos;)</div><div class="line">hello world</div><div class="line">&gt;&gt;&gt;print(&apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;)</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">&gt;&gt;&gt;print(&apos;1024 * 768 =&apos;,1024*768)</div><div class="line">1024 * 768 = 786432</div></pre></td></tr></table></figure>
<p><strong>输入</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;name=input(&apos;please input your name:&apos;)</div><div class="line">&gt;&gt;&gt;print(&apos;name:&apos;,name)</div></pre></td></tr></table></figure></p>
<p>采用缩进方式<br>当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块<br>Python程序是大小写敏感的<br>使用4个空格的缩进<br>以<code>#</code>开头的语句是注释</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;br&gt;自动添加空格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python编码</title>
    <link href="http://yoursite.com/post/d6d2cac9.html"/>
    <id>http://yoursite.com/post/d6d2cac9.html</id>
    <published>2018-06-15T00:44:39.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul>
<li>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</li>
<li>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件</li>
<li>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</li>
<li>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</div><div class="line">65</div><div class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</div><div class="line">20013</div><div class="line">&gt;&gt;&gt; chr(66)</div><div class="line">&apos;B&apos;</div><div class="line">&gt;&gt;&gt; chr(25991)</div><div class="line">&apos;文&apos;</div><div class="line">&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;</div><div class="line">&apos;中文&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="str和bytes"><a href="#str和bytes" class="headerlink" title="str和bytes"></a>str和bytes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x=b&apos;ABC&apos;</div><div class="line">y=&apos;ABC&apos;</div></pre></td></tr></table></figure>
<p>y是<code>str</code>，x是<code>bytes</code>，内容显示一样，但<code>bytes</code>每个字符都只占用一个字节</p>
<ul>
<li>Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>(各个平台的编码不一定都相同，socket 传递的数据都是<code>bytes</code>类型的，避免乱码)</li>
<li>Python 3 不会以任意隐式的方式混用<code>str</code>和<code>bytes</code></li>
<li>Bytes 对象是由单个字节作为基本元素（8 位，取值范围 0-255）组成的序列，为不可变对象。</li>
<li><code>Bytes</code>对象只负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。我们可以通过调用<code>bytes()</code> 类（没错，它是类，不是函数）生成<code>bytes</code>实例，其值形式为<code>b&#39;xxxxx&#39;</code>，其中<code>&#39;xxxxx&#39;</code>为一至多个转义的十六进制字符串（单个 x 的形式为：<code>\xHH</code>，其中 <code>\x</code> 为小写的十六进制转义字符，HH 为二位十六进制数）组成的序列，每个十六进制数代表一个字节（八位二进制数，取值范围 0-255），对于同一个字符串如果采用不同的编码方式生成 <code>bytes</code> 对象，就会形成不同的值</li>
</ul>
<p><code>str</code>编码为指定的<code>bytes</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</div><div class="line">b&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf8&apos;)</div><div class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</div><div class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</div></pre></td></tr></table></figure></p>
<p>纯英文的<code>str</code>可以用ASCII编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p>
<p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p>
<p><code>bytes</code>编码为<code>str</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</div><div class="line">&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf8&apos;)</div><div class="line">&apos;中文&apos;</div><div class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;ascii&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 0: ordinal not in range(128)</div></pre></td></tr></table></figure></p>
<h3 id="len函数"><a href="#len函数" class="headerlink" title="len函数"></a>len函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; len(&apos;中文&apos;)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; len(b&apos;abc&apos;)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf8&apos;))                          </div><div class="line">6</div></pre></td></tr></table></figure>
<h3 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># encoding=utf-8</div></pre></td></tr></table></figure>
<p>第一行会告诉系统使用的python路径，不建议使用<code>#!/usr/bin/python</code>，灵活性降低</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">sys.getdefaultencoding()</div><div class="line"></div><div class="line">&apos;utf-8&apos;</div></pre></td></tr></table></figure>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello,%s&apos;%&apos;world&apos;</div><div class="line">&apos;Hello,world&apos;</div><div class="line">&gt;&gt;&gt; &apos;Hi,%s,you have $%d.&apos;%(&apos;Michael&apos;,10000)</div><div class="line">&apos;Hi,Michael,you have $10000.&apos;</div><div class="line">&gt;&gt;&gt; print(&apos;$%2d-$%02d&apos; % (3,1))</div><div class="line">$ 3-$01</div><div class="line">&gt;&gt;&gt; print(&apos;%.2f&apos; % 3.1415926)</div><div class="line">3.14</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;growth rate:%d %%&apos; % 7</div><div class="line">&apos;growth rate:7 %&apos;</div></pre></td></tr></table></figure>
<p>%d 整数<br>%f 浮点数<br>%s 字符串<br>%x 十六进制整数</p>
<p>如果不太确定应该用什么，%s永远起作用</p>
<h3 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello,&#123;0&#125;,成绩提升了&#123;1:.1f&#125;&apos;.format(&apos;小明&apos;,17.125)</div><div class="line">&apos;Hello,小明,成绩提升了17.1&apos;</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="http://www.ituring.com.cn/article/1116" target="_blank" rel="external">http://www.ituring.com.cn/article/1116</a></li>
<li><a href="https://www.kancloud.cn/lanyulei/python/357700" target="_blank" rel="external">https://www.kancloud.cn/lanyulei/python/357700</a></li>
<li><a href="https://segmentfault.com/a/1190000004450876" target="_blank" rel="external">https://segmentfault.com/a/1190000004450876</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;/li&gt;
&lt;li&gt;用记
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Anaconda</title>
    <link href="http://yoursite.com/post/634c672f.html"/>
    <id>http://yoursite.com/post/634c672f.html</id>
    <published>2018-06-14T01:38:50.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda 是一种Python语言的包管理工具，用于进行大规模数据处理, 预测分析, 和科学计算, 致力于简化包的管理和部署。 Anaconda使用软件包管理系统Conda进行包管理。</p>
<p>实际上我使用Anaconda是为了避免Python2和Python3的冲突，我既想使用Python3又不想改变Python2原来的东西</p>
<p>官网：<a href="https://anaconda.org/" target="_blank" rel="external">https://anaconda.org/</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>选择对应的Python版本和系统进行下载安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bash Anaconda3-5.2.0-Linux-x86_64.sh</div><div class="line">conda upgrade --all</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装包管理"><a href="#安装包管理" class="headerlink" title="安装包管理"></a>安装包管理</h2><p>列出已经安装的包：<code>pip list</code>或<code>conda list</code><br>安装新包：<code>pip install 包名</code>或<code>conda install 包名</code><br>更新包： <code>conda update package_name</code><br>升级所有包：<code>conda upgrade --all</code><br>卸载包：<code>conda remove package_names</code><br>搜索包：<code>conda search search_term</code></p>
<h2 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h2><p>安装nb_conda，用于notebook自动关联nb_conda的环境<code>conda install cb_conda</code><br>创建环境：<code>conda create -n env_name package_names[=ver]</code><br>指定Python版本：<code>conda create -n py3 python=3.6</code><br>可以切换不同的Python版本<br>使用环境：<code>activate env_name</code><br>离开环境：<code>deactivate</code><br>导出环境设置：<code>conda env export &gt; environmentName.yaml</code> 或 <code>pip freeze &gt; environmentName.txt</code><br>导入环境设置：<code>conda env update -f=/path/environmentName.yaml</code> 或 <code>pip install -r /path/environmentName.txt</code><br>导出和导入可以用于共享环境，在 GitHub 上共享代码时，最好同样创建环境文件并将其包括在代码库中。这能让其他人更轻松地安装你的代码的所有依赖项。<br>列出环境清单：<code>conda env list</code><br>删除环境： <code>conda env remove -n env_name</code></p>
<p>参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88</a>)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Anaconda 是一种Python语言的包管理工具，用于进行大规模数据处理, 预测分析, 和科学计算, 致力于简化包的管理和部署。 Anaconda使用软件包管理系统Conda进行包管理。&lt;/p&gt;
&lt;p&gt;实际上我使用Anaconda是为了避免Python2和Python3的冲突，我既想使用Python3又不想改变Python2原来的东西&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://anaconda.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://anaconda.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;下载：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&lt;/a&gt;&lt;br&gt;选择对应的Python版本和系统进行下载安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;bash Anaconda3-5.2.0-Linux-x86_64.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;conda upgrade --all&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Vim中Python相关插件</title>
    <link href="http://yoursite.com/post/d52f3c59.html"/>
    <id>http://yoursite.com/post/d52f3c59.html</id>
    <published>2018-06-14T00:09:01.000Z</published>
    <updated>2018-06-19T08:32:40.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tell-k-vim-autopep8"><a href="#tell-k-vim-autopep8" class="headerlink" title="tell-k/vim-autopep8"></a><a href="https://github.com/tell-k/vim-autopep8" target="_blank" rel="external">tell-k/vim-autopep8</a></h2><p>依照pep8的标准自动格式化代码<br>插件依赖autopep8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install --upgrade autopep8</div></pre></td></tr></table></figure></p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plug &apos;tell-k/vim-autopep8&apos;</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:Autopep8</div><div class="line">:Autopep8 --range 1 5               # with arguments</div><div class="line">:call Autopep8(&quot; --range 1 5&quot;)      # with arguments</div><div class="line">:&apos;&lt;,&apos;&gt;Autopep8              # range selection</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">autocmd FileType python noremap &lt;buffer&gt; &lt;F8&gt; :call Autopep8()&lt;CR&gt;</div><div class="line">let g:autopep8_max_line_length=119</div></pre></td></tr></table></figure>
<h2 id="Yggdroot-indentLine"><a href="#Yggdroot-indentLine" class="headerlink" title="Yggdroot/indentLine"></a><a href="https://github.com/Yggdroot/indentLine" target="_blank" rel="external">Yggdroot/indentLine</a></h2><p>显示缩进指示线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plug &apos;Yggdroot/indentLine&apos;</div></pre></td></tr></table></figure></p>
<h2 id="Valloric-YouCompleteMe"><a href="#Valloric-YouCompleteMe" class="headerlink" title="Valloric/YouCompleteMe"></a><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">Valloric/YouCompleteMe</a></h2><p>YouCompleteMe不支持Anaconda，所以要指定原生Python路径</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential cmake</div><div class="line">sudo apt-get install python-dev python3-dev</div></pre></td></tr></table></figure>
<h3 id="配置-安装"><a href="#配置-安装" class="headerlink" title="配置/安装"></a>配置/安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Plug &apos;Valloric/YouCompleteMe&apos;</div><div class="line">let g:ycm_server_python_interpreter=&apos;/usr/bin/python3.5&apos;</div></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.vim/bundle/YouCompleteMe</div><div class="line">/usr/bin/python3.5 ./install.py</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/f0513d18742a" target="_blank" rel="external">https://www.jianshu.com/p/f0513d18742a</a></li>
<li><a href="https://github.com/Valloric/YouCompleteMe/issues/2876" target="_blank" rel="external">https://github.com/Valloric/YouCompleteMe/issues/2876</a></li>
<li><a href="https://github.com/JeffyLu/JeffyLu.github.io/issues/15" target="_blank" rel="external">https://github.com/JeffyLu/JeffyLu.github.io/issues/15</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tell-k-vim-autopep8&quot;&gt;&lt;a href=&quot;#tell-k-vim-autopep8&quot; class=&quot;headerlink&quot; title=&quot;tell-k/vim-autopep8&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/t
    
    </summary>
    
    
      <category term="VIM" scheme="http://yoursite.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>VIM模版</title>
    <link href="http://yoursite.com/post/22b97e54.html"/>
    <id>http://yoursite.com/post/22b97e54.html</id>
    <published>2018-06-11T09:27:23.000Z</published>
    <updated>2018-06-12T23:35:43.110Z</updated>
    
    <content type="html"><![CDATA[<p>用Vim写Python的时候，每次都要在开头写路径和编码，索性直接用模版<br>直接使用插件方式配置模版</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>使用vim-plug配置，<code>vim .vimrc</code>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plug &apos;aperezdc/vim-template&apos;</div></pre></td></tr></table></figure></p>
<p>保存，重新打开<code>.vimrc</code>，进行安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:PlugInstall</div></pre></td></tr></table></figure></p>
<h2 id="配置模版"><a href="#配置模版" class="headerlink" title="配置模版"></a>配置模版</h2><p>模版文件在<code>.vim/plugged/vim-template/templates</code>下</p>
<a id="more"></a>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/996afb9e4086" target="_blank" rel="external">https://www.jianshu.com/p/996afb9e4086</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Vim写Python的时候，每次都要在开头写路径和编码，索性直接用模版&lt;br&gt;直接使用插件方式配置模版&lt;/p&gt;
&lt;h2 id=&quot;安装插件&quot;&gt;&lt;a href=&quot;#安装插件&quot; class=&quot;headerlink&quot; title=&quot;安装插件&quot;&gt;&lt;/a&gt;安装插件&lt;/h2&gt;&lt;p&gt;使用vim-plug配置，&lt;code&gt;vim .vimrc&lt;/code&gt;添加&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Plug &amp;apos;aperezdc/vim-template&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;保存，重新打开&lt;code&gt;.vimrc&lt;/code&gt;，进行安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;:PlugInstall&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置模版&quot;&gt;&lt;a href=&quot;#配置模版&quot; class=&quot;headerlink&quot; title=&quot;配置模版&quot;&gt;&lt;/a&gt;配置模版&lt;/h2&gt;&lt;p&gt;模版文件在&lt;code&gt;.vim/plugged/vim-template/templates&lt;/code&gt;下&lt;/p&gt;
    
    </summary>
    
    
      <category term="VIM" scheme="http://yoursite.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>Pygame相关</title>
    <link href="http://yoursite.com/post/7e3c85d2.html"/>
    <id>http://yoursite.com/post/7e3c85d2.html</id>
    <published>2018-06-11T08:09:50.000Z</published>
    <updated>2018-06-19T07:38:50.397Z</updated>
    
    <content type="html"><![CDATA[<p>pygame是主要构筑在SDL库基础上的一组Python模块的集合，它使我们能够用Python语言来创建功能完整的游戏和多媒体程序。pygame是高度括平台可移植的，在任何SDL支持的平台上都可以运行（几乎可以在任何平台和操作系统上运行）。</p>
<p>注：SDL(Simple DirectMedia Layer)是一个跨平台的多媒体库，可以用来访问底层的音频、键盘、鼠标、摇杆、3D硬件（通过OpenGL）以及2D视频缓冲。它被用在MPEG播放软件、模拟器和很多流行的游戏中，包括获得大奖的Linux版的”Civilization: Call To Power”。</p>
<h2 id="安装Pygame"><a href="#安装Pygame" class="headerlink" title="安装Pygame"></a>安装Pygame</h2><p><a href="https://www.pygame.org/wiki/GettingStarted" target="_blank" rel="external">https://www.pygame.org/wiki/GettingStarted</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pip install pygame</div><div class="line"></div><div class="line">#检验是否安装成功</div><div class="line">python3 -m pygame.examples.aliens</div></pre></td></tr></table></figure></p>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line"># 引入 pygame 中的所有常量</div><div class="line">from pygame.locals import *</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cdrom</td>
<td>访问光驱</td>
</tr>
<tr>
<td>cursors</td>
<td>加载光标图像，包含标准光标</td>
</tr>
<tr>
<td>display</td>
<td>控制显示窗口或屏幕</td>
</tr>
<tr>
<td>draw</td>
<td>在Surface上绘制简单的图形</td>
</tr>
<tr>
<td>event</td>
<td>管理事件和事件队列</td>
</tr>
<tr>
<td>font</td>
<td>创建并呈现TrueType字体</td>
</tr>
<tr>
<td>image</td>
<td>保存并加载图像</td>
</tr>
<tr>
<td>joystick</td>
<td>管理游戏手柄设备</td>
</tr>
<tr>
<td>key</td>
<td>管理键盘</td>
</tr>
<tr>
<td>pygame.mixer</td>
<td>音效</td>
</tr>
<tr>
<td>mouse</td>
<td>管理鼠标</td>
</tr>
<tr>
<td>pygame.movie</td>
<td>播放视频</td>
</tr>
<tr>
<td>pygame.music</td>
<td>播放音频</td>
</tr>
<tr>
<td>pygame.rect</td>
<td>管理矩形区域</td>
</tr>
<tr>
<td>pygame.sprite</td>
<td>操作移动图像</td>
</tr>
<tr>
<td>sndarray</td>
<td>用numpy操纵声音</td>
</tr>
<tr>
<td>surfarray</td>
<td>用numpy处理图像</td>
</tr>
<tr>
<td>time</td>
<td>控制时间</td>
</tr>
<tr>
<td>transform</td>
<td>缩放，旋转和翻转图像</td>
</tr>
</tbody>
</table>
<h2 id="初始化和退出"><a href="#初始化和退出" class="headerlink" title="初始化和退出"></a>初始化和退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 导入并初始化所有 pygame 模块，使用其他模块之前，必须先调用 init 方法</div><div class="line">pygame.init()</div><div class="line"></div><div class="line"># 卸载所有 pygame 模块，在游戏结束之前调用，没有必要显式的调用这个函数，因为pygame会在python退出的时候自动清理所有已经初始化的模块</div><div class="line">pygame.quit()</div></pre></td></tr></table></figure>
<h2 id="窗口-suiface-pygame-display"><a href="#窗口-suiface-pygame-display" class="headerlink" title="窗口/suiface pygame.display"></a><a href="https://www.pygame.org/docs/ref/display.html" target="_blank" rel="external">窗口/suiface pygame.display</a></h2><p><code>pygame.display</code>模块用于创建、管理游戏窗口<br>需要先创建一个窗口。其他的活动都是基于窗口的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pygame.display.set_mode(resolution=(0,0),flags=0,depth=0)</div></pre></td></tr></table></figure>
<ul>
<li>resolution：指定屏幕的宽和高，默认创建的窗口大小和屏幕大小一致</li>
<li>flags：标志位<ul>
<li>FULLSCREEN 创建一个全屏窗口</li>
<li>DOUBLEBUF 创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用</li>
<li>HWSURFACE 创建一个硬件加速的窗口，必须和FULLSCREEN同时使用</li>
<li>OPENGL 创建一个OPENGL渲染的窗口</li>
<li>RESIZABLE 创建一个可以改变大小的窗口</li>
<li>NOFRAME 创建一个没有边框的窗口</li>
</ul>
</li>
<li>depth：颜色的位深，默认自动匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 指定窗口的宽和高</div><div class="line"># 只能有一个</div><div class="line">screen = pygame.display.set_mode((600,500))</div><div class="line">screen = pygame.display.set_mode((1024, 768), pygame.FULLSCREEN)</div><div class="line"></div><div class="line"># 设置窗口的标题</div><div class="line">pygame.display.set_caption(&apos;Hello World!&apos;)</div><div class="line"></div><div class="line"># 填充背景颜色</div><div class="line">screen.fill((255,255,255))</div><div class="line"></div><div class="line"># 刷新屏幕内容显示，把内容显示到屏幕上</div><div class="line">pygame.display.update()</div><div class="line"></div><div class="line"># 如果使用DOUBLEBUF，需要用flip函数把内容显示到屏幕上</div><div class="line">pygame.display.flip()</div><div class="line"></div><div class="line"># 可以查看当前设备支持的分辨率</div><div class="line">pygame.display.list_modes()</div></pre></td></tr></table></figure>
<h2 id="游戏循环"><a href="#游戏循环" class="headerlink" title="游戏循环"></a>游戏循环</h2><p>如果没有循环，窗口无法保持，只能看到一闪而过</p>
<p>一个游戏循环（也可以称为主循环）就做下面这三件事：</p>
<ol>
<li>处理事件</li>
<li>更新游戏状态</li>
<li>绘制游戏状态到屏幕上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while True:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line">from pygame.locals import *</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">screen = pygame.display.set_mode((600,500))</div><div class="line"></div><div class="line">pygame.display.set_caption(&apos;Hello World&apos;)</div><div class="line"></div><div class="line">while True:</div><div class="line">    pass</div><div class="line"></div><div class="line">pygame.quit()</div></pre></td></tr></table></figure>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>以左上角为（0，0）点，往右方向为X轴，往下方向为Y轴，单位为像素</p>
<h2 id="矩形区域-pygame-Rect"><a href="#矩形区域-pygame-Rect" class="headerlink" title="矩形区域 pygame.Rect"></a><a href="https://www.pygame.org/docs/ref/rect.html" target="_blank" rel="external">矩形区域 pygame.Rect</a></h2><p><code>pygame.Rect</code>是用于存储直角坐标的pygame对象，在游戏中所有可见的元素都是以矩形区域来描述位置的（区别于绘制图形中的矩形）</p>
<p><strong>对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Rect(left, top, width, height)</div><div class="line">Rect((left, top), (width, height))</div></pre></td></tr></table></figure></p>
<p>前两项描述位置，后两项描述大小</p>
<p><strong>属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x,y</div><div class="line">top, left, bottom, right</div><div class="line">topleft, bottomleft, topright, bottomright</div><div class="line">midtop, midleft, midbottom, midright</div><div class="line">center, centerx, centery</div><div class="line">size, width, height</div></pre></td></tr></table></figure></p>
<h2 id="绘制图形-pygame-draw"><a href="#绘制图形-pygame-draw" class="headerlink" title="绘制图形 pygame.draw"></a><a href="https://www.pygame.org/docs/ref/draw.html#pygame.draw.rect" target="_blank" rel="external">绘制图形 pygame.draw</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">pygame.draw.rect(Surface, color, Rect, width=0)</div><div class="line"># 绘制一个矩形形状</div><div class="line"></div><div class="line">pygame.draw.polygon(Surface, color, pointlist, width=0) 	    </div><div class="line"># 绘制多边形</div><div class="line"></div><div class="line">pygame.draw.circle(Surface, color, pos, radius, width=0) 	    </div><div class="line"># 围绕一个点画一个圆</div><div class="line"></div><div class="line">pygame.draw.ellipse(Surface, color, Rect, width=0)</div><div class="line"># 在矩形内绘制圆形</div><div class="line"></div><div class="line">pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1) 	        </div><div class="line"># 绘制一个椭圆的局部部分</div><div class="line"></div><div class="line">pygame.draw.line(Surface, color, start_pos, end_pos, width=1)	    </div><div class="line"># 画出一条直线段</div><div class="line"></div><div class="line">pygame.draw.lines(Surface, color, closed, pointlist, width=1)</div><div class="line"># 绘制多个连续的线段</div><div class="line"></div><div class="line">pygame.draw.aaline(Surface, color, startpos, endpos, blend=1)	    </div><div class="line"># 画精美的抗锯齿线</div><div class="line"></div><div class="line">pygame.draw.aalines(Surface, color, closed, pointlist, blend=1)	    </div><div class="line"># 绘制抗锯齿线的连接序列</div></pre></td></tr></table></figure>
<p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line">from pygame.locals import *</div><div class="line">from math import pi </div><div class="line"></div><div class="line"># 定义颜色</div><div class="line">RED = (255,0,0)</div><div class="line">GREEN = (0,255,0)</div><div class="line">BLUE = (0,0,255)</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">screen = pygame.display.set_mode((600,600))</div><div class="line">pygame.display.set_caption(&apos;绘制图形&apos;)</div><div class="line"># screen.fill((255,255,255))</div><div class="line"></div><div class="line">pygame.draw.rect(screen,BLUE,(400,400,100,100))</div><div class="line">pygame.draw.polygon(screen,GREEN,[[400,0],[500,70],[450,100]],5)</div><div class="line">pygame.draw.circle(screen,BLUE,[10,500],40)</div><div class="line">pygame.draw.ellipse(screen,BLUE,(300,200,50,40))</div><div class="line">pygame.draw.ellipse(screen,RED,(200,200,50,40),5)</div><div class="line"></div><div class="line">pygame.draw.arc(screen,GREEN,(300,500,40,40),0,pi/2,2)</div><div class="line">pygame.draw.arc(screen,RED,(300,500,40,40),pi/2,pi,2)</div><div class="line">pygame.draw.arc(screen,BLUE,(300,500,40,40),pi,3*pi/2,2)</div><div class="line">pygame.draw.arc(screen,(255,255,255),(300,500,40,40),3*pi/2,2*pi,2)</div><div class="line"></div><div class="line">pygame.draw.line(screen,RED,[1,1],[50,50],5)</div><div class="line">pygame.draw.lines(screen,RED,True,</div><div class="line">        [[0,80],[50,90],[200,80],[220,30]],5)</div><div class="line">pygame.draw.aaline(screen,RED,[80,80],[40,90],True)</div><div class="line"></div><div class="line">while 1:</div><div class="line">    pass</div><div class="line">    pygame.display.update()</div></pre></td></tr></table></figure></p>
<p><img src="/img/IMG65.png" alt=""></p>
<h2 id="字体-文本-pygame-font"><a href="#字体-文本-pygame-font" class="headerlink" title="字体/文本 pygame.font"></a><a href="https://www.pygame.org/docs/ref/font.html" target="_blank" rel="external">字体/文本 pygame.font</a></h2><p><code>pygame.font</code>模块将文本打印到窗口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">pygame.font.Font(filename, size)</div><div class="line"># filename：字体文件的文件名</div><div class="line"># size：字体的高 height，单位为像素</div><div class="line"></div><div class="line">pygame.font.Font.render(text, antialias, color, background=None)</div><div class="line"># text：要显示的文字，文字只能包含一行，换行符不会被画出来</div><div class="line"># antialias： 是否抗锯齿</div><div class="line"># color：字体颜色</div><div class="line"># background：背景颜色（可选参数），如果没有指定background，背景是透明的</div><div class="line"># 返回一个surgace</div><div class="line"></div><div class="line">pygame.font.get_fonts()</div><div class="line"># 获取可用的字体的列表</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">screen = pygame.display.set_mode((300,300))</div><div class="line">pygame.display.set_caption(&apos;Font&apos;)</div><div class="line"></div><div class="line"># 1.字体对象，指定字体和大小</div><div class="line">myfont = pygame.font.Font(None,60)</div><div class="line"># myfont = pygame.font.Font(&apos;./font/楷体_GB2312.ttf&apos;,60)</div><div class="line"># 2.指定文本内容，文本颜色，文本背景色</div><div class="line">textSufaceObj = myfont.render(&apos;Hello world&apos;,True,(255,255,255),(0,255,0))</div><div class="line"># 3.指定文本位置</div><div class="line">screen.blit(textSufaceObj,(50,100))</div><div class="line"></div><div class="line">while 1:</div><div class="line">    # 4.显示文本</div><div class="line">    pygame.display.update()</div><div class="line"></div><div class="line">pygame.quit()</div></pre></td></tr></table></figure>
<p><img src="/img/IMG66.png" alt=""></p>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">img = pygame.image.load(filename)</div><div class="line"># 加载一张图片</div><div class="line"># 返回一个包含图像的Surface，Surface的格式和原来的文件相同（包括颜色格式、透明色和alpha透明）</div><div class="line"></div><div class="line">pygame.Surface.blit(img, dest, area=None, special_flags = 0)</div><div class="line"># 将图片绘制到屏幕相应坐标上（后面两个参数默认，可以不传）</div><div class="line"></div><div class="line">pygame.image.save(img, filename)</div><div class="line"># 把img这个Surface的内容保存为filename指定的图像文件</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line">from pygame.locals import *</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">screen = pygame.display.set_mode((100,100))</div><div class="line">pygame.display.set_caption(&apos;Image&apos;)</div><div class="line"></div><div class="line">image = pygame.image.load(&apos;./Ball.png&apos;)</div><div class="line"># 获得图像位置</div><div class="line">imageRect = image.get_rect()</div><div class="line"># 指定图片居中</div><div class="line">imageRect.center = (50,50)</div><div class="line">screen.fill((156,178,166))</div><div class="line"># screen.blit(image,(50,50))</div><div class="line">screen.blit(image,imageRect)</div><div class="line"></div><div class="line">while 1:</div><div class="line">    pygame.display.update()</div><div class="line"></div><div class="line">pygame.quit()</div></pre></td></tr></table></figure>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><h3 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pygame.mixer.music.load(filename)</div></pre></td></tr></table></figure>
<p>filename：音频文件的文件名<br>该方法用来加载背景音乐，之后调用 pygame.mixer.music.play( ) 方法就可以播放背景音乐（Pygame 只允许加载一个背景音乐在同一个时刻）<br>音乐文件可以很大，系统以流的形式播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">pygame.init() #进行全部模块的初始化， </div><div class="line">pygame.mixer.init() #或者只初始化音频部分 </div><div class="line">pygame.mixer.music.load(&apos;xx.mp3&apos;) #使用文件名作为参数载入音乐 ,音乐可以是ogg、mp3等格式。载入的音乐不会全部放到内容中，而是以流的形式播放的，即在播放的时候才会一点点从文件中读取。 </div><div class="line">pygame.mixer.music.play() #播放载入的音乐。该函数立即返回，音乐播放在后台进行。</div><div class="line"></div><div class="line">#play方法还可以使用两个参数 </div><div class="line">pygame.mixer.music.play(loops=0, start=0.0) #loops和start分别代表重复的次数和开始播放的位置 </div><div class="line">pygame.mixer.music.stop() #停止播放 </div><div class="line">pygame.mixer.music.pause() #暂停播放</div><div class="line">pygame.mixer.music.unpause() #取消暂停</div><div class="line">pygame.mixer.music.fadeout(time) #用来进行淡出，在time毫秒的时间内音量由初始值渐变为0，最后停止播放</div><div class="line">pygame.mixer.music.set_volume(value) #来设置播放的音量，音量value的范围为0.0到1.0</div><div class="line">pygame.mixer.music.get_busy() #判断是否在播放音乐,返回1为正在播放</div><div class="line">pygame.mixer.music.set_endevent(pygame.USEREVENT + 1) #在音乐播放完成时，用事件的方式通知用户程序，设置当音乐播放完成时发送</div><div class="line">pygame.USEREVENT+1 #事件给用户程序</div><div class="line">pygame.mixer.music.queue(filename) #使用指定下一个要播放的音乐文件，当前的音乐播放完成后自动开始播放指定的下一个。一次只能指定一个等待播放的音乐文件</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">pygame.mixer.music.load(&apos;./sound/background.mp3&apos;)</div><div class="line">pygame.mixer.music.play()</div><div class="line"></div><div class="line">while 1:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>循环播放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">pygame.mixer.music.load(&apos;./sound/曲锦楠 - 霞光.mp3&apos;)</div><div class="line">pygame.mixer.music.play()</div><div class="line"></div><div class="line">clock = pygame.time.Clock()</div><div class="line"></div><div class="line">while 1:</div><div class="line">    clock.tick(1)</div><div class="line">    isbusy = pygame.mixer.music.get_busy()</div><div class="line">    print(isbusy)</div><div class="line">    if isbusy == 0:</div><div class="line">        pygame.mixer.music.play()</div></pre></td></tr></table></figure></p>
<h3 id="特效声音"><a href="#特效声音" class="headerlink" title="特效声音"></a>特效声音</h3><p>要在游戏中播放碰撞、爆炸、语音等音效，需要使用pygame.mixer模块。这个模块支持同时播放多个音效文件，多个文件在多个不同的通道Channel中播放，一个通道一次只能播放一个音效文件。</p>
<p>音效和音乐的区别是：音效要整个文件载入到Sound对象中才能播放，而音乐不用完全载入，而以流的方式播放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">pygame.mixer.get_num_channels()</div><div class="line"># 查看总共有多少个通道</div><div class="line"></div><div class="line">channel = pygame.mixer.Channel(i)</div><div class="line"># 取得第i个通道</div><div class="line"></div><div class="line">channel = pygame.mixer.find_channel()</div><div class="line"># 自动取得一个空闲的通道（没有音效正在播放的通道）</div><div class="line"></div><div class="line">sound = pygame.mixer.Sound(&apos;./sound/enemy1_down.wav&apos;)</div><div class="line"></div><div class="line">channel.play(sound)</div><div class="line"># 在一个通道中播放一个音效</div><div class="line">sound.play()</div><div class="line"># 自动找一个空闲的通道播放音效</div><div class="line"></div><div class="line">sound.stop()</div><div class="line"># 停止音效sound的播放</div><div class="line">channel.stop()</div><div class="line"># 停止在通道channel中播放的音效</div><div class="line"></div><div class="line">channel.pause()</div><div class="line"># 暂停通道中的音效</div><div class="line">channel.unpause()</div><div class="line"># 暂停的音效继续播放</div><div class="line"></div><div class="line">channel.get_busy()</div><div class="line"># 检查通道是否正在播放音效</div><div class="line"></div><div class="line">channel.fadeout(time)</div><div class="line"># 淡出，在time毫秒的时间内音量由初始值渐变为0，最后停止播放</div><div class="line"></div><div class="line">channel.queue(soundfile)</div><div class="line"># 为正在播放音效的通道指定下一个要播放的音效。当前的音效播放完成后，下一个音效会自动播放。一个通道只能有一个等待播放的音效。</div><div class="line"></div><div class="line">channel.set_volume(value)</div><div class="line"># 设置通道中播放的音效的音量</div><div class="line">sound.set_volume(value)</div><div class="line"># 设置单个音效的音量</div><div class="line"># 两者的取值范围都是0.0到1.0。音效播放的实际音量是通道音量和音效音量的乘积，比如通道音量0.5，音效音量0.6，则实际播放的音量为0.3</div></pre></td></tr></table></figure></p>
<p>说了这么多，实际上只需要两句就足够了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sound = pygame.mixer.Sound(&apos;./sound/enemy1_down.wav&apos;)</div><div class="line">sound.play()</div></pre></td></tr></table></figure></p>
<h2 id="视频-pygame-movie"><a href="#视频-pygame-movie" class="headerlink" title="视频 pygame.movie"></a><a href="https://pygame.bitbucket.io/docs/pygame/ref/movie.html" target="_blank" rel="external">视频 pygame.movie</a></h2><p><a href="https://stackoverflow.com/questions/37775635/pygame-movie-missing" target="_blank" rel="external">https://stackoverflow.com/questions/37775635/pygame-movie-missing</a></p>
<p>该模块已经过时</p>
<p><del>要在游戏中播放片头动画、过场动画等视频画面，可以使用<code>pygame.movie</code>模块</del></p>
<p>要播放视频中的音乐，<code>pygame.movie</code>模块需要对音频接口的完全控制，不能初始化mixer模块。因此要这样完成初始化~~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pygame.init()</div><div class="line">pygame.mixer.quit()</div></pre></td></tr></table></figure></p>
<p>或者只初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pygame.display.init()</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">movie = pygame.movie.Movie(’filename’)</div><div class="line"># 指定文件名载入视频。视频的格式可以为mpeg1。视频文件不会马上全部载入内存，而是在播放的时候一点一点的载入内存。</div><div class="line"></div><div class="line">movie.set_display(pygame.display.set_mode((640,480)))</div><div class="line"># 指定播放的surface。</div><div class="line"></div><div class="line">movie.set_volume(value)</div><div class="line"># 指定播放的音量。音量的值value的取值范围为0.0到1.0。</div><div class="line"></div><div class="line">movie.play() </div><div class="line"># 播放视频。这个函数会立即返回，视频在后台播放。这个函数可以带一个参数loops，指定重复次数。</div><div class="line"></div><div class="line">movie.stop()</div><div class="line"># 停止播放</div><div class="line"></div><div class="line">movie.pause()</div><div class="line"># 暂停播放</div><div class="line"></div><div class="line">movie.skip(seconds)</div><div class="line"># 使视频前进seconds秒钟。</div><div class="line"></div><div class="line">如有不懂的可以参考Pygame的官方例子，在Python安装目录下的\lib\site-packages\pygame\examples\movieplayer.py文件。</div></pre></td></tr></table></figure>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><strong>帧率（Frame rate）</strong>：每秒钟能够刷新的次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pygame.time.Clock()</div><div class="line"># 获得 pygame 的时钟对象</div><div class="line"></div><div class="line">pygame.time.Clock.tick(FPS)</div><div class="line"># 设置 pygame 时钟的间隔时间</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line">from pygame.locals import *</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">screen = pygame.display.set_mode((100,100))</div><div class="line">pygame.display.set_caption(&apos;Image&apos;)</div><div class="line"></div><div class="line">image = pygame.image.load(&apos;./Ball.png&apos;)</div><div class="line">imageRect = image.get_rect()</div><div class="line">imageRect.center = (50,50)</div><div class="line"># screen.blit(image,(50,50))</div><div class="line"></div><div class="line">fps = pygame.time.Clock()</div><div class="line"></div><div class="line">while 1:</div><div class="line">    fps.tick(10)</div><div class="line">    </div><div class="line">    imageRect.x += 1</div><div class="line">    # 需要重新绘制背景</div><div class="line">    screen.fill((156,178,166))</div><div class="line">    screen.blit(image,imageRect)</div><div class="line"></div><div class="line">    # pygame.display.flip()</div><div class="line">    pygame.display.update()</div><div class="line"></div><div class="line">pygame.quit()</div></pre></td></tr></table></figure>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a><a href="https://www.pygame.org/docs/ref/event.html" target="_blank" rel="external">事件</a></h2><p>Pygame通过一个事件系统与用户进行交互，以及处理一些系统发生的事件。事件系统包括一个事件队列，其中每一项都是一个Event对象。所有的用户输入和一些系统事件，都会形成一个Event对象被添加到事件队列中。<br>Event对象有各种不同的类型，通过<code>Event.type</code>属性来区分。不同的类型的Event对象还有不同的其它属性。通过<code>Event.dict</code>属性来查看。</p>
<p>详细：<a href="http://www.xefan.com/archives/83586.html" target="_blank" rel="external">http://www.xefan.com/archives/83586.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">import pygame</div><div class="line">from pygame.locals import *</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">screen = pygame.display.set_mode((600,600))</div><div class="line">pygame.display.set_caption(&apos;Event&apos;)</div><div class="line"></div><div class="line">while 1:</div><div class="line">    # 获取事件列表</div><div class="line">    for event in pygame.event.get():</div><div class="line">        # 点击关闭</div><div class="line">        if event.type == QUIT:</div><div class="line">            pygame.quit()</div><div class="line">            exit()</div><div class="line">        </div><div class="line">        # 鼠标移动</div><div class="line">        if event.type == MOUSEMOTION:</div><div class="line">            print(event.pos)</div><div class="line"></div><div class="line">        if event.type == MOUSEBUTTONDOWN:</div><div class="line">            print(&apos;鼠标按下&apos;,event.pos)</div><div class="line">        if event.type == MOUSEBUTTONUP:</div><div class="line">            print(&apos;鼠标抬起&apos;,event.pos)</div><div class="line"></div><div class="line">        # 方向键</div><div class="line">        if event.type == KEYDOWN:</div><div class="line">            if (event.key == K_UP or event.key == K_w):</div><div class="line">                print(&apos;上&apos;)</div><div class="line">            if (event.key == K_DOWN or event.key == K_s):</div><div class="line">                print(&apos;下&apos;)</div><div class="line">            if (event.key == K_LEFT or event.key == K_a):</div><div class="line">                print(&apos;左&apos;)</div><div class="line">            if (event.key == K_RIGHT or event.key == K_d):</div><div class="line">                print(&apos;右&apos;)</div><div class="line">            if event.key == K_ESCAPE:</div><div class="line">                pygame.quit()</div><div class="line">                exit()</div></pre></td></tr></table></figure>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>每隔多少时间触发一次事件<br>pygame中的时间是以毫秒（千分之一秒）表示的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 自定义计时事件</div><div class="line">COUNT = pygame.USEREVENT +1</div><div class="line"></div><div class="line"># 每隔1秒发送一次自定义事件</div><div class="line">pygame.time.set_timer(COUNT,1000)</div><div class="line"></div><div class="line"># 获取事件</div><div class="line">for event in pygame.event.get():</div><div class="line">    # 判断事件是否为计时事件</div><div class="line">    if event.type == COUNT: </div><div class="line">        pass</div></pre></td></tr></table></figure></p>
<p>计时器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import pygame,time</div><div class="line">from pygame.locals import *</div><div class="line"></div><div class="line">SCREEN_RECT = pygame.Rect(0,0,700,200)</div><div class="line">COUNT = pygame.USEREVENT+1</div><div class="line"></div><div class="line">pygame.init()</div><div class="line"></div><div class="line">screen = pygame.display.set_mode(SCREEN_RECT.size)</div><div class="line">pygame.display.set_caption(&apos;time&apos;)</div><div class="line"></div><div class="line">font = pygame.font.Font(None,60)</div><div class="line">pygame.time.set_timer(COUNT,1000)</div><div class="line">while 1:</div><div class="line">    for event in pygame.event.get():</div><div class="line">        if event.type == QUIT:</div><div class="line">            pygame.quit()</div><div class="line">            exit()</div><div class="line">        if event.type == COUNT:</div><div class="line">            now = time.ctime()</div><div class="line">            clock = now[11:19]</div><div class="line">            timeObj = font.render(clock,True,(255,255,255))</div><div class="line">            # timeObj = font.render(now,True,(255,255,255))</div><div class="line">            timeRect = timeObj.get_rect()</div><div class="line">            timeRect.center = SCREEN_RECT.center</div><div class="line">            screen.fill((0,0,0))</div><div class="line">            screen.blit(timeObj,timeRect)</div><div class="line"></div><div class="line">    pygame.display.update()</div></pre></td></tr></table></figure></p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>while True: # 程序主循环<br>    for event in pygame.event.get():# 获取事件<br>        if event.type == QUIT:# 判断事件是否为退出事件<br>            pygame.quit()# 退出pygame<br>            sys.exit()# 退出系统<br>    pygame.display.update()# 绘制屏幕内容</p>
<p>参考：</p>
<ul>
<li><a href="http://www.xefan.com/archives/83574.html" target="_blank" rel="external">http://www.xefan.com/archives/83574.html</a></li>
<li><a href="https://www.jianshu.com/u/e46ded17a290" target="_blank" rel="external">https://www.jianshu.com/u/e46ded17a290</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pygame是主要构筑在SDL库基础上的一组Python模块的集合，它使我们能够用Python语言来创建功能完整的游戏和多媒体程序。pygame是高度括平台可移植的，在任何SDL支持的平台上都可以运行（几乎可以在任何平台和操作系统上运行）。&lt;/p&gt;
&lt;p&gt;注：SDL(Simple DirectMedia Layer)是一个跨平台的多媒体库，可以用来访问底层的音频、键盘、鼠标、摇杆、3D硬件（通过OpenGL）以及2D视频缓冲。它被用在MPEG播放软件、模拟器和很多流行的游戏中，包括获得大奖的Linux版的”Civilization: Call To Power”。&lt;/p&gt;
&lt;h2 id=&quot;安装Pygame&quot;&gt;&lt;a href=&quot;#安装Pygame&quot; class=&quot;headerlink&quot; title=&quot;安装Pygame&quot;&gt;&lt;/a&gt;安装Pygame&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.pygame.org/wiki/GettingStarted&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.pygame.org/wiki/GettingStarted&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pip install pygame&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#检验是否安装成功&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;python3 -m pygame.examples.aliens&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;导入&quot;&gt;&lt;a href=&quot;#导入&quot; class=&quot;headerlink&quot; title=&quot;导入&quot;&gt;&lt;/a&gt;导入&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;import pygame&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 引入 pygame 中的所有常量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;from pygame.locals import *&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
