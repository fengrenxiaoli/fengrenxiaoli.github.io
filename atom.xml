<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>太阳落下</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-04T12:24:16.820Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 虚拟机网络配置详解(NAT、桥接、Hostonly)</title>
    <link href="http://yoursite.com/2018/05/04/Linux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3-NAT%E3%80%81%E6%A1%A5%E6%8E%A5%E3%80%81Hostonly/"/>
    <id>http://yoursite.com/2018/05/04/Linux-虚拟机网络配置详解-NAT、桥接、Hostonly/</id>
    <published>2018-05-04T08:56:23.000Z</published>
    <updated>2018-05-04T12:24:16.820Z</updated>
    
    <content type="html"><![CDATA[<p>无论是vmware还是virtual box虚拟机软件，一般来说，虚拟机有三种网络模式:</p>
<ol>
<li>Bridged Adapter（桥接模式）</li>
<li>NAT（网络地址转换模式）</li>
<li>Host-only Adapter（主机模式）</li>
</ol>
<p>virtual box中还有lInternal</p>
<p>虚拟网卡在虚拟机安装好之后，会自动添加两张网卡(VMnet1和VMnet8)，VMnet1用Host-only网络连接，VMnet8用NAT方式的网络连接，原先的VMnet0用桥接网络连接。</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG23.png" alt=""></p>
<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><p>桥接网络是指宿主物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于<strong>同等地位</strong>，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机，所以两个网卡的IP地址也要设置为同一网段。会占用内网IP</p>
<p>vmnet0实际上就是一个虚拟的网桥(2层交换机)，这个网桥有若干个接口，一个端口用于连接你的Host主机，其余端口可以用于连接虚拟机，他们的位置是对等的，谁也不是谁的网关。<br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG24.png" alt=""></p>
<p>主机A上的两个虚拟机1和虚拟机2，和主机A、B同处于一个网段，能够相互通信<br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG25.png" alt=""></p>
<p>虚拟机网卡配置，虚拟机上网需要IP/子网掩码/DNS/网关</p>
<pre><code>DEVICE=&quot;eth0&quot;
BOOTPROTO=“static&quot; #设置静态ip,动态为dhcp
IPADDR=&quot;192.168.1.3&quot;
GATEWAY=&quot;192.168.1.1&quot;
HWADDR=&quot;08:00:27:C7:1B:22&quot;
DNS1=&quot;8.8.8.8&quot;
NETMASK=&quot;255.255.255.0&quot;
ONBOOT=&quot;yes&quot;
</code></pre><p>CentOS 7中ONBOOT默认为NO，需要打开</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>虚拟机要求可以上网，且虚拟机完全模拟一台实体机</p>
<p><br></p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。宿主能够联网，虚拟机也能联网(其他主机)。宿主没有联网，虚拟机也不能联网</p>
<p>vmnet1也是一个虚拟的交换机，交换机的一个 端口连接到你的Host上，另外一个端口连接到虚拟的DHCP服务器上（实际上是vmware的一个组件），另外剩下的端口就是连虚拟机了，主机A和虚拟机1和2能相互通信，虚拟机1和2能访问主机B和外网，主机B不能访问虚拟机1和2，虚拟机1和2能相互通信<br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG27.png" alt=""></p>
<p>虚拟机的配置:</p>
<pre><code>DEVICE=&quot;eth0&quot;
BOOTPROTO=“static&quot; #设置静态ip,动态为dhcp
IPADDR=&quot;10.0.2.5&quot;
GATEWAY=&quot;10.0.2.1&quot;
HWADDR=&quot;08:00:27:C7:1B:22&quot;
DNS1=&quot;10.0.2.1&quot;
NETMASK=&quot;255.255.255.0&quot;
ONBOOT=&quot;yes&quot;
</code></pre><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><p>虚拟机只要求可以上网，无其它特殊要求，满足最一般需求</p>
<p><br></p>
<h2 id="Host-Only"><a href="#Host-Only" class="headerlink" title="Host-Only"></a>Host-Only</h2><p><strong>所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的</strong></p>
<p>虚拟系统和宿主机器系统是可以相互通信的。<br>虚拟系统的TCP/IP配置信息(如IP地址、网关地址、DNS服务器等)，都是由VMnet1(host-only)虚拟网络的DHCP服务器来动态分配的。</p>
<p>主机和虚拟机之间的通信是通过 VMnet1虚拟网卡来实现的。虚拟机连接到VMnet1上，系统并不为其提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到真正的网络上。</p>
<p>Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p>
<p>虚拟机1和2之间可以相互通信，主机A能和虚拟机1和2通信，虚拟机1和2不能和主机通信(需要设置)，虚拟机不能和B主机以及外网通信<br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG26.png" alt=""></p>
<h4 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h4><p>如果你想利用VMWare创建一个与网内其他机器相隔离的虚拟系统，进行某些特殊的网络调试工作，可以选择host-only模式。</p>
<p><br></p>
<h2 id="内网模式"><a href="#内网模式" class="headerlink" title="内网模式"></a>内网模式</h2><p>内网模式，顾名思义就是内部网络模式：虚拟机与外网完全断开，只实现虚拟机于虚拟机之间的内部网络模式。</p>
<p>虚拟机与主机的关系：不能相互访问，彼此不属于同一个网络，无法相互访问。<br>虚拟机与网络中其他主机的关系：不能相互访问，理由同上。<br>虚拟机与虚拟机的关系：可以相互访问，前提是在设置网络时，两台虚拟机设置同一网络名称。如上配置图中，名称为intnet。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html</a></li>
<li><a href="https://www.jianshu.com/p/305f7384cfe9" target="_blank" rel="external">https://www.jianshu.com/p/305f7384cfe9</a></li>
<li><a href="https://blog.csdn.net/bytxl/article/details/35569217" target="_blank" rel="external">https://blog.csdn.net/bytxl/article/details/35569217</a></li>
<li><a href="https://blog.csdn.net/clevercode/article/details/45934233" target="_blank" rel="external">https://blog.csdn.net/clevercode/article/details/45934233</a></li>
<li><a href="http://blog.51cto.com/wangchunhai/381225" target="_blank" rel="external">http://blog.51cto.com/wangchunhai/381225</a></li>
<li><a href="https://github.com/waltcow/blog/issues/21" target="_blank" rel="external">https://github.com/waltcow/blog/issues/21</a></li>
<li><a href="https://blog.csdn.net/guizaijianchic/article/details/72190394" target="_blank" rel="external">https://blog.csdn.net/guizaijianchic/article/details/72190394</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是vmware还是virtual box虚拟机软件，一般来说，虚拟机有三种网络模式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bridged Adapter（桥接模式）&lt;/li&gt;
&lt;li&gt;NAT（网络地址转换模式）&lt;/li&gt;
&lt;li&gt;Host-only Adapter（主机模式）&lt;/
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 挂载命令mount</title>
    <link href="http://yoursite.com/2018/05/03/Linux-%E6%8C%82%E8%BD%BD%E5%91%BD%E4%BB%A4mount/"/>
    <id>http://yoursite.com/2018/05/03/Linux-挂载命令mount/</id>
    <published>2018-05-03T07:13:09.000Z</published>
    <updated>2018-05-03T07:21:35.392Z</updated>
    
    <content type="html"><![CDATA[<pre><code>sudo fdisk -l
#查看系统的硬盘和硬盘分区情况，了解需要的设备，比如移动硬盘/U盘/windows下的分区/光盘
sudo mkdir -p /media/usb
#创建挂载点
sudo mount /dev/sdb /media/usb
#挂载

sudo umount /dev/sdb
#退出
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;sudo fdisk -l
#查看系统的硬盘和硬盘分区情况，了解需要的设备，比如移动硬盘/U盘/windows下的分区/光盘
sudo mkdir -p /media/usb
#创建挂载点
sudo mount /dev/sdb /media/usb
#挂载
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装ssh</title>
    <link href="http://yoursite.com/2018/05/02/Linux-%E5%AE%89%E8%A3%85ssh/"/>
    <id>http://yoursite.com/2018/05/02/Linux-安装ssh/</id>
    <published>2018-05-02T10:46:32.000Z</published>
    <updated>2018-05-02T12:42:08.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h2><pre><code>#查看ssh服务是否开启
ps -e |grep ssh

#安装ssh服务
sudo apt install openssh-server

#配置ssh
sudo vi /etc/ssh/sshd_config
#PermitRootLogin，RSAAuthentication，PubkeyAuthentication的设置打开

#开启ssh服务
sudo systemctl restart sshd.service
#开机启动SSH服务
sudo systemctl enable sshd.service

#连接
ssh -p 22 userName@192.168.1.100
</code></pre><h2 id="复杂版"><a href="#复杂版" class="headerlink" title="复杂版"></a>复杂版</h2><p>参考<a href="https://wiki.centos.org/HowTos/Network/SecuringSSH" target="_blank" rel="external">https://wiki.centos.org/HowTos/Network/SecuringSSH</a></p>
<pre><code>sudo firewall-cmd --reload
#重新载入防火墙设定
</code></pre><h2 id="设置SSH免密码登录"><a href="#设置SSH免密码登录" class="headerlink" title="设置SSH免密码登录"></a>设置SSH免密码登录</h2><pre><code>ssh-keygen -t rsa
# ～/.ssh目录中创建两个名为id_rsa和id_rsa.pub的文件，id_rsa是私钥，id_rsa.pub是公钥

#设置权限
chmod 700〜/ .ssh
chmod 600〜/ .ssh / id_rsa 

# 复制公钥到服务器然后写入到~/.ssh/authorized_keys 方法一
# 使用SSH远程登陆到服务器,发现家目录中还没有.ssh目录,使用mkdir创建
mkdir .ssh
# 发送公钥
scp -P 端口号 ./id_rsa.pub alice@192.168.0.10:/home/alice/.ssh
# 将公钥追加写入~/.ssh/authorized_keys中,若authorized_keys不存在,则会创建并写入
cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
#修改authorized_keys的权限为600,并删除公钥文件
rm id_rsa.pub

# 复制公钥到服务器然后写入到~/.ssh/authorized_keys 方法二
# ssh-copy-id 命令可以把本地主机的公钥复制到远程主机的 authorized_keys 文件上
ssh-copy-id -i ~/.ssh/id_rsa.pub user@server
chmod 700 ~/.ssh 
chmod 600 ~/.ssh/authorized_keys
</code></pre><h2 id="清除SSH的私钥密码"><a href="#清除SSH的私钥密码" class="headerlink" title="清除SSH的私钥密码"></a>清除SSH的私钥密码</h2><pre><code>ssh-keygen -p
# 选择需要修改的私钥，默认是/home/username/.ssh/id_rsa。
# 选好文件后按回车，会提示你输入旧密码。
#输入好后会提示输入新密码。
#直接回车，提示确认新密码再直接回车，此时指定的私钥的密码就被清除了
</code></pre><p>参考：</p>
<ul>
<li><a href="https://wiki.centos.org/HowTos/Network/SecuringSSH" target="_blank" rel="external">https://wiki.centos.org/HowTos/Network/SecuringSSH</a></li>
<li><a href="http://www.iosugar.com/2017/02/14/CentOS-remote-login-SSH-configuration/#SSH%E7%99%BB%E9%99%86" target="_blank" rel="external">http://www.iosugar.com/2017/02/14/CentOS-remote-login-SSH-configuration/#SSH%E7%99%BB%E9%99%86</a></li>
<li><a href="http://einverne.github.io/post/2016/06/ssh-copy-id.html" target="_blank" rel="external">http://einverne.github.io/post/2016/06/ssh-copy-id.html</a></li>
<li><a href="https://www.ssh.com/ssh/copy-id" target="_blank" rel="external">https://www.ssh.com/ssh/copy-id</a></li>
<li><a href="https://linux.cn/article-6901-1.html" target="_blank" rel="external">https://linux.cn/article-6901-1.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简易版&quot;&gt;&lt;a href=&quot;#简易版&quot; class=&quot;headerlink&quot; title=&quot;简易版&quot;&gt;&lt;/a&gt;简易版&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#查看ssh服务是否开启
ps -e |grep ssh

#安装ssh服务
sudo apt install op
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络管理 网络基础</title>
    <link href="http://yoursite.com/2018/05/01/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/05/01/Linux网络管理-网络基础/</id>
    <published>2018-05-01T11:06:32.000Z</published>
    <updated>2018-05-02T14:11:57.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>开放系统互联模型，由ISO(国际标准化组织) 组织开发的</p>
<p>该模型为基础模型, 而实际中常用的TCP/IP模型是由七层模型演变的</p>
<p>上三层(应用层、表示层、会话层)是对用户提供服务, 下四层(传输层、网络层、数据链路层、物理层)对数据传输提供服务</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>作用</th>
<th>传输单元</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>用户接口</td>
<td>APDU，应用协议数据单元</td>
</tr>
<tr>
<td>表示层</td>
<td>数据的表现形式（ASCII、GB2312、jpg）、 特定功能的实现如加密、压缩</td>
<td>PPDU，表示协议数据单元</td>
</tr>
<tr>
<td>会话层</td>
<td>对应用会话的管理、同步。 确定网络数据是否要经过远程会话</td>
<td>SPDU，会话协议数据单元</td>
</tr>
<tr>
<td>传输层</td>
<td>确定可靠与不可靠的传输（ TCP传输控制协议可靠不会丢、UDP用户数据报协议更快但可能会丢）、传输前的错误检测、 流量控制、 确立端口号, 便于通过IP确定主机后, 通过端口确定交互的服务</td>
<td>TPDU，传输协议数据单元</td>
</tr>
<tr>
<td>网络层</td>
<td>负责提供逻辑地址(IP地址, 需要写入发件人IP与收件人IP）、 选择通路。 （确定IP地址，原IP、目地IP）</td>
<td>报文</td>
</tr>
<tr>
<td>数据链路层</td>
<td>负责组成帧(组入MAC信息)，用MAC地址访问媒介（源地址&amp;目的地址）、错误的检测与修正。物理地址，就是计算机MAC地址，也就是计算机网卡地址。每一台电脑都有一个网卡地址，MAC地址负责局域网通信，IP地址负责外网通信。</td>
<td>帧</td>
</tr>
<tr>
<td>物理层</td>
<td>设备之间比特流的传输（ 最基本的数据传递）、物理接口（ 网线口、视频口、音频口）、电气特性（ 网线8根线中的1、3、2、6四根线传输数据）</td>
<td>比特流</td>
</tr>
</tbody>
</table>
<p>举例场景 用户A需要给用户B发送一份邮件</p>
<ol>
<li>应用层 : 浏览器进入邮箱, 写邮件, 点击发送, 数据将传递至 表示层</li>
<li>表示层 : 进行的数据的编码, 而后数据传递至会话层</li>
<li>会话层 : 判断数据的发送类型, 是进行网络传输还是进行本地保存, 若是进行传输 传递至传输层</li>
<li>传输层 : 确立协议TCP或UDP, 写入邮件的发送及目标端口号, 传递至网络层</li>
<li>网络层 : 写入自身及目标IP地址, 传递至数据链路层</li>
<li>数据链路层 : 写入源MAC地址与目标MAC地址, 由于IP地址找到局域网, 再通过MAC地址在局域网中找到目标, 传递至物理层</li>
<li>物理层 : 数据传输</li>
</ol>
<p><br></p>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><h4 id="TCP-IP-四层模型与-OSI-七层模型对应关系"><a href="#TCP-IP-四层模型与-OSI-七层模型对应关系" class="headerlink" title="TCP/IP 四层模型与 OSI 七层模型对应关系"></a>TCP/IP 四层模型与 OSI 七层模型对应关系</h4><ul>
<li>应用层 : 应用层、表示层、会话层<br>为用户提供所需的各种服务, 例如 <strong>FTP</strong>、<strong>Telnet</strong>、<strong>DNS</strong>、<strong>SMTP</strong>等</li>
</ul>
<ul>
<li>传输层 : 传输层<br>负责为应用层实体提供端到端的通信功能, 保证了数据包的顺序传送及数据的完整性, 该层定义了两个主要的协议 : 传输控制协议(<strong>TCP</strong>)可靠的面向连接，不会丢失，类似打电话，网页、邮件 和  用户数据报协议(<strong>UDP</strong>)不可靠的面向无连接,有可能丢失, 类似发短信、QQ</li>
</ul>
<ul>
<li>网际互联层 : 网络层<br>主要解决主机到主机的通信问题, 它所包含的协议涉及数据包在整个网络上的逻辑传输, 该层有三个主要协议 : 网际协议(<strong>IP</strong>), 互联网组管理协议(<strong>IGMP</strong>), 互联网控制报文协议(<strong>ICMP</strong>)</li>
</ul>
<ul>
<li>网络接口层 : 数据链路层、物理层<br>负责监视数据在主机和网络之间的交换, 事实上, TCP/IP本身并未定义该层的协议, 而由参与互连的各网络使用自己的物理层和数据链路层协议, 然后与TCP/IP的网络接入层进行连接. 地址解析协议(<strong>ARP</strong>) 工作在此层, 即OSI参考模型的数据链路层.<br>地址解析协议(ARP) : 将IP地址 翻译成物理地址</li>
</ul>
<h4 id="数据封装过程"><a href="#数据封装过程" class="headerlink" title="数据封装过程"></a>数据封装过程</h4><p>发送是由上至下进行打包, 接收是由下至上进行拆包<br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG10.jpg" alt=""></p>
<h4 id="TCP-IP-模型与OSI-模型的比较"><a href="#TCP-IP-模型与OSI-模型的比较" class="headerlink" title="TCP/IP  模型与OSI 模型的比较"></a>TCP/IP  模型与OSI 模型的比较</h4><p>共同点</p>
<ol>
<li>OSI 参考模型和 TCP/IP参考模型都采用了层次结构的概念</li>
<li>都能够提供面向连接和无连接两种通信服务机制</li>
</ol>
<p>不同点</p>
<ol>
<li>OSI 七层, TCP/IP 四层</li>
<li>对可靠性要求不同(TCP/IP 更高)</li>
<li>OSI 模型是在协议开发前设计的, 具有通用性. TCP/IP 是先有协议集, 然后建立模型, 不适用与非TCP/IP网络</li>
<li>实际市场应用不同( OSI 模型只是理论上的模型, 并没有成熟的产品, 而TCP/IP已经成为”实际上的国际标准”)</li>
</ol>
<p><br></p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="IP包头-如图"><a href="#IP包头-如图" class="headerlink" title="IP包头(如图)"></a>IP包头(如图)</h4><p>横32位, 竖5行, 固定的共160位, 20字节, 另外有其他选项存在, 导致包头不固定, 因此每接收到包头, 需要进行检测包头长度才能够取出包头, 也是为何IPv4没有IPv6快的原因</p>
<p>包头中包含的IP地址只有32位, 即2的32次幂, 42亿9千万左右的IP</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG11.jpg" alt=""></p>
<h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p>IP分为A、B、C、D、E 五大类, 其中DE不对民用组织开放, 不可使用, 因此有效类只有ABC<br>可根据第一位数值判断类别, 1-126 为A类, 128-172 为B类, 192-223 为C类</p>
<p>127.0.0.1 为本机</p>
<p> 第一位表示不同网段, 不同网络, 不同网络之间的通信需要使用路由器，路由器是用来实现跨网络通信的, 同一网络下通信使用交换机即可. 第一位不变情况下, 后三位的变化都代表同一网络下的不同主机</p>
<ol>
<li>A 类 : 每个网络中的第一个地址(X.0.0.0)代表网络本身,最后一个地址(X.255.255.255)代表当前网络的广播地址, 不能分配, 最大主机数 : 后三位的次幂, 减 第一和最后一个 , 2^24 -2</li>
<li>B 类 : 前两位代表网段, 后两位代表网段中的不同主机</li>
<li>C 类 : 前三位代表网段, 最后一位代表不同主机</li>
</ol>
<p>私有IP :  不需要花钱买, 用来做内网IP, 可有效保护公网IP, 不能直接访问公网, 需要与公网之间进行转换才可访问互联网</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG12.jpg" alt=""></p>
<p><br></p>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>ABC类可以用不同的网段个数和主机个数, 是由子网掩码决定<br>子网掩码用连续1的表示，例如255.0.0.0，255.255.0.0，255。255.255.255.0</p>
<p>子网掩码的作用：用来区分不同网段的IP—-子网掩码与IP相与，得到的结果相同则在同一网段。否则不在，需要经过路由器转发。</p>
<p>合理的子网掩码 : 所有的1必须连续, A 类地址可匹配B类子网掩码</p>
<p>IP和子网掩码必须一起配合使用。<br>网络号=IP&amp;&amp;子网掩码</p>
<p>广播地址：主机号全为1,广播地址是专门用于同时向网络中所有工作站进行发送的一个地址</p>
<p>合理的子网掩码 : 所有的1必须连续, A 类地址可匹配B类子网掩码</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG13.jpg" alt=""></p>
<p><br></p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG14.jpg" alt=""><br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG15.jpg" alt=""></p>
<pre><code>netstat -an
# 查看本机启用的端口
#-a:查看所有连接和监听端口
#-n:显示IP地址和端口号，而不显示域名和服务名
</code></pre><p>TCP因为3次握手的机制所以需要监听，而UDP不需要监听</p>
<h4 id="常见端口号"><a href="#常见端口号" class="headerlink" title="常见端口号"></a>常见端口号</h4><ul>
<li>FTP（文件传输协议）：20、21；</li>
<li>SSH（安全shell协议）：22；</li>
<li>telnet（远程登录协议）：23；</li>
<li>DNS（域名系统）：53；</li>
<li>http（超文本传输协议）：80；</li>
<li>SMTP（简单邮件传输协议）：25；</li>
<li>POP3（邮局协议）：110；</li>
</ul>
<p><br></p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="hosts和DNS"><a href="#hosts和DNS" class="headerlink" title="hosts和DNS"></a>hosts和DNS</h4><p>hosts文件：做静态IP和域名对应，优先于DNS.<br>位置：<br>C：\Windows\System32\drivers\etc\hosts<br>hosts文件只可做临时解析用，名称解析效能下降，主机维护困难</p>
<p>DNS全称为——&gt;domain name system——&gt;域名系统</p>
<ul>
<li>不配置DNS是不能联网的。</li>
<li>在互联网中，通过IP地址来进行通信。</li>
<li>IP地址是用数字来表示的，记忆起来太困难了(如116.213.120.232)</li>
<li>人对域名更加敏感，:<a href="http://www.imooc.com/" target="_blank" rel="external">http://www.imooc.com/</a></li>
</ul>
<p>DNS服务的作用:将域名解析为IP地址<br>过程：客户机向DNS服务器发送查询IP请求<br>DNS服务器查询到web服务器的ip，告知用户<br>用户访问web服务器</p>
<h4 id="域名空间结构"><a href="#域名空间结构" class="headerlink" title="域名空间结构"></a>域名空间结构</h4><p>根域：.（13台服务器）<br>——&gt;顶级域/一级域：包括组织域和地区域<br>（组织域：gov政府/edu教育部门/com商业部门/org民间团体/net网络服务机构/mil军事部门 地区域：cn 中国 hk 香港 jp 日本 Uk 英国 au 澳大利亚）<br>——&gt;二级域：企业或个人自行购买的（imooc /microsoft/ibm/sina）<br>——&gt;主机名/3级域：申请完二级域后自己定义的（www/news）</p>
<p>三级域（www）+二级域（baidu）+顶级域（.com）组成完整域名空间</p>
<p>为什么要进行域名分级划分<br>便于IP地址解析</p>
<h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>DNS客户机——&gt;本地域名服务器——&gt;根DNS服务器——&gt;cn服务器——&gt;com.cn服务器——&gt;imooc.com.cn——&gt;本地域名服务器——&gt;DNS客户机——&gt;web服务器www.imooc.com.cn</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG16.PNG" alt=""></p>
<h4 id="DNS查询类型"><a href="#DNS查询类型" class="headerlink" title="DNS查询类型"></a>DNS查询类型</h4><p>从查询方式上分</p>
<ul>
<li>递归查询：客户机将请求发送给DNS服务器，服务器通过缓存或者询问其他服务器最后将一个准确的结果或者失败回复给客户机，客户机只负责问，所有事情都是服务器做。客户机对本地域名服务器查询的机制，必须反馈准确值（要么成功要么失败）</li>
<li>迭代查询：客户机像DNS服务器发送请求后，服务器向客户机返回另一个服务器的地址，客户机不停地向不同DNS服务器发送请求，所有事情都自己做。本地域名服务器分别对各级域名服务器的查询机制，不一定反馈准确值</li>
</ul>
<p>从查询内容上分</p>
<ul>
<li>正向：域名到IP ARP </li>
<li>反向：IP到域名 RARP</li>
</ul>
<p><br></p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><ul>
<li>网关（Gateway）又称网间连接器、协议转换器</li>
<li>网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层不同的网络互连</li>
<li>网关既可以用于广域网互连，也可以用于局域网互连</li>
<li>网关是一种充当转换重任的服务器或路由器</li>
<li>交换机不能识别ip，只能记录客户机的MAC地址。即只能在局域网中进行通信</li>
<li>访问不同网段，则需要引入网关。</li>
<li>网关：一个具有路由功能的设备，一般为路由器。</li>
</ul>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG17.jpg" alt=""></p>
<h4 id="网关作用"><a href="#网关作用" class="headerlink" title="网关作用"></a>网关作用</h4><ul>
<li>网关在所有内网计算机访问的不是本网段的数据包时使用</li>
<li>把内网Ip转公网Ip，公网Ip转内网Ip</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OSI模型&quot;&gt;&lt;a href=&quot;#OSI模型&quot; class=&quot;headerlink&quot; title=&quot;OSI模型&quot;&gt;&lt;/a&gt;OSI模型&lt;/h3&gt;&lt;p&gt;开放系统互联模型，由ISO(国际标准化组织) 组织开发的&lt;/p&gt;
&lt;p&gt;该模型为基础模型, 而实际中常用的TCP/I
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络管理 远程登录</title>
    <link href="http://yoursite.com/2018/05/01/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2018/05/01/Linux网络管理-远程登录/</id>
    <published>2018-05-01T11:03:54.000Z</published>
    <updated>2018-05-02T07:34:20.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH协议原理"><a href="#SSH协议原理" class="headerlink" title="SSH协议原理"></a>SSH协议原理</h2><h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h4><p>采用单钥密码系统的加密方法, 同一个秘钥可以同时用作信息的加密和解密, 这种加密方法称为对称加密, 也称为单秘钥加密.</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG22.png" alt=""></p>
<p>缺点 : 加密解密使用相同密码, 需要告知对方密码, 等同于将自身多方习惯密码告知对方. 例如邮箱等密码, 造成威胁</p>
<h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h4><p>asymmetric cryptographic algorithm，又名 “公开秘钥加密算法” ,  需要公开秘钥(publickey) 和私有秘钥(privatekey)<br>linux 中为 gpg工具, windows 中为 pgp工具</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG21.jpg" alt=""></p>
<p>过程原理, A 需要发送数据包给 B</p>
<ol>
<li>A 根据自己密码A 生成 公钥A 和私钥A</li>
<li>B 根据自己密码B 生成 公钥B 和私钥B</li>
<li>A 向 B 寻要 公钥B, 再结合自身的公钥A 对数据包进行加密, 并发送给B</li>
<li>B 收到数据包之后, 可根据自身密码B 和 私钥B 对数据包进行解密且成功</li>
<li>此时, A 也可以根据自身密码A 结合 私钥A 对已加密的数据包进行解密</li>
<li>至此, 避免了泄露 A 自身的密码</li>
</ol>
<h4 id="SSH安全外壳协议"><a href="#SSH安全外壳协议" class="headerlink" title="SSH安全外壳协议"></a>SSH安全外壳协议</h4><p>在非对称加密算法之上演变而来<br>密码足够复杂强壮可降低暴力破解的成功性<br>SSH 保护数据传递过程中的安全, 但若在传递之前中病毒则不可避免<br>通用的远程管理协议</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG23.jpg" alt=""></p>
<p>过程原理, A 需要发送数据包给 B</p>
<ol>
<li>A 持有 公钥A 和 私钥A</li>
<li>B 持有 公钥B 和 私钥B</li>
<li>A 向 B 寻要 公钥B, 再结合自身的 公钥A 对数据包进行加密, 并发送给B</li>
<li>B 收到数据包之后, 可根据自身 私钥B 对数据包进行解密</li>
</ol>
<h4 id="SSH-命令"><a href="#SSH-命令" class="headerlink" title="SSH 命令"></a>SSH 命令</h4><pre><code>ssh 用户名@ip
# 远程管理制定Linux服务器
# 经过远程之后, 在家目录中的 .ssh 文件夹 know_hosts文件中保存着 连接成功的目标信息
# 地址 加密算法 公钥
#若目计算机进行了重装系统, 或地址被另一台机器占用, 此时 已下载的公钥无法使用, 使用vi 对改行进行删除, 当再次连接时, 会再次提示是否进行下载公钥


scp [-r] 用户名@ip:文件路径 本地路径
# 网络复制命令, 下载文件 或加-r 下载文件夹

scp [-r] 本地文件 用户名@ip:上传路径
# 网络复制命令, 上传文件 或加-r 上传文件夹
# 此为linux 与 linux之间进行文件传输的最简单方式
</code></pre><h2 id="远程管理工具"><a href="#远程管理工具" class="headerlink" title="远程管理工具"></a>远程管理工具</h2><p>SecureCRT、Xshell</p>
<p>WinSCP文件传输工具</p>
<p>FileZilla</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SSH协议原理&quot;&gt;&lt;a href=&quot;#SSH协议原理&quot; class=&quot;headerlink&quot; title=&quot;SSH协议原理&quot;&gt;&lt;/a&gt;SSH协议原理&lt;/h2&gt;&lt;h4 id=&quot;对称加密算法&quot;&gt;&lt;a href=&quot;#对称加密算法&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络管理 网络命令</title>
    <link href="http://yoursite.com/2018/05/01/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/05/01/Linux网络管理-网络命令/</id>
    <published>2018-05-01T11:03:44.000Z</published>
    <updated>2018-05-02T06:50:00.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络环境查看命令"><a href="#网络环境查看命令" class="headerlink" title="网络环境查看命令"></a>网络环境查看命令</h2><pre><code>ifconfig
# 查看与临时配置网络状态，但无法查看网关和DNS


#关闭与启动网卡
ifdown 网卡设备名 
#禁用该网卡设备
ifup 网卡设备名 
#启用该网卡设备


#查询网络状态
netstat 选项
选项：一般为tuln或an
-t：列出TCP协议端口
-u：列出UDP协议端口
-n：不使用域名与服务名，而使用IP地址和端口号
-l：仅列出在监听状态的网络服务
-a：列出所有的网络连接

#统计计算机建立的远程连接数
netstat -an | grep ESTABLISHED | wc -l

#查看网关
netstat -rn 
选项：
-r：列出路由表，功能和route命令一致。


route -n 
#查看路由列表(可以看到网关)
route add default gw 192.168.1.1
#临时测定网关


#域名解析命令
nslookup [主机名或IP] 
#进行域名与IP地址解析，域名对应哪个IP

nslookup
&gt;server #本地设定的DNS的地址
&gt;exit #退出
</code></pre><p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG19.png" alt=""><br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG20.png" alt=""></p>
<p>在一台服务器里，连接内网的网卡是不能设置网关的，只有连接外网的网卡才能设置，而且这个网关是由运营商设置好 它告诉我们的下一级网络地址。</p>
<p>随便设置一个网关是不行的，因为与外网通信时，要把消息转发到网关，网关负责把内网IP转换成功公网IP，随便设置则将找不到这个网关，导致呈现网络连接失败状态。</p>
<h2 id="网络测试命令"><a href="#网络测试命令" class="headerlink" title="网络测试命令"></a>网络测试命令</h2><pre><code>ping [选项] ip或域名 
#探测指定IP或域名的网络状况
选项：
-c 次数：指定ping包的次数


telnet [域名或IP] [端口] 
#远程管理与端口探测命令，明文传递
telnet 192.168.0.252 80
#如果连接成功，将会进入连接状态，按ctrl+]退出到telnet，再键入quit返回命令行状态


traceroute [选项] IP或域名 
#路由跟踪命令，查看中间所经过的节点，故障定位。
选项：
-n 使用IP，不使用域名，速度更快
#和ping一样都是利用的ICMP协议（Internet Control Message Protocol）Internet控制报文协议
#家用网络大多数结点都禁止ping，就是*，可以根据路由来分析哪些结点出现了问题


wget http://soft.vpser.net/lnmp/lnmp1.1-full.tar.gz     #下载命令


tcpdump -i eth0 -nnX port 21
抓取eth0网卡上的数据包，以16进制拆分数据包(用port 21可以只拆分21端口)
选项：
-i：指定网卡接口
-nn：将数据包中的域名与服务转为IP和端口
-X：以十六进制和ASCII码显示数据包内容
port：指定监听的端口
</code></pre><ul>
<li>ftp也是明文：用来上传下载文件，默认是不允许用户登陆的</li>
<li>http都是明文，一旦截获了数据包，就能直接获取里面的数据</li>
<li>https才是加密的</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络环境查看命令&quot;&gt;&lt;a href=&quot;#网络环境查看命令&quot; class=&quot;headerlink&quot; title=&quot;网络环境查看命令&quot;&gt;&lt;/a&gt;网络环境查看命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ifconfig
# 查看与临时配置网络状态，但无法查看网关和DNS


#
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络管理 网络配置</title>
    <link href="http://yoursite.com/2018/05/01/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/01/Linux网络管理-网络配置/</id>
    <published>2018-05-01T11:03:33.000Z</published>
    <updated>2018-05-02T06:32:27.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IP地址配置"><a href="#IP地址配置" class="headerlink" title="IP地址配置"></a>IP地址配置</h2><p>DHCP服务器可以自动分配IP</p>
<h4 id="ifconfig命令临时配置IP地址"><a href="#ifconfig命令临时配置IP地址" class="headerlink" title="ifconfig命令临时配置IP地址"></a>ifconfig命令临时配置IP地址</h4><pre><code>ifconfig
查看当前网络状态
ifconfig eth0 192.168.254.200 netmask 255.255.255.0
临时设置eth0网卡的IP地址与子网掩码
</code></pre><h4 id="setup工具永久配置IP地址"><a href="#setup工具永久配置IP地址" class="headerlink" title="setup工具永久配置IP地址"></a>setup工具永久配置IP地址</h4><ul>
<li>红帽专有图形化工具setup设置IP地址</li>
<li>CentOS系统中默认就没有setup命令，需要安装</li>
</ul>
<pre><code>yum -y install setuptool   
安装setup命令工具
yum -y install ntsysv   
安装setup工具配套的系统服务组件
yum -y install system-config-securitylevel-tui
安装setup工具配套的防火墙配置组件
yum -y install system-config-network-tui 
安装setup工具配套的网络配置组件
yum -y install authconfig-gtk
安装setup工具配套的验证配置组件
</code></pre><p>system-config-network-tui 无法安装，是因为网络设置改到<code>nmtui</code>命令中</p>
<p>####修改网络配置文件</p>
<p>因为配置文件不光可以配置IP，所以单独开一节</p>
<p>####图形界面配置IP地址</p>
<p><br></p>
<h2 id="修改网络配置文件"><a href="#修改网络配置文件" class="headerlink" title="修改网络配置文件"></a>修改网络配置文件</h2><h4 id="网卡信息文件"><a href="#网卡信息文件" class="headerlink" title="网卡信息文件"></a>网卡信息文件</h4><p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG18.png" alt=""></p>
<h4 id="主机名文件"><a href="#主机名文件" class="headerlink" title="主机名文件"></a>主机名文件</h4><pre><code>vi /etc/sysconfig/network

hostname [主机名]
# 查看与临时设置主机名命令
</code></pre><h4 id="DNS配置文件"><a href="#DNS配置文件" class="headerlink" title="DNS配置文件"></a>DNS配置文件</h4><pre><code>vi /etc/resolv.conf
# nameserver 名称服务器/DNS
</code></pre><p><br></p>
<h2 id="虚拟机网络参数配置"><a href="#虚拟机网络参数配置" class="headerlink" title="虚拟机网络参数配置"></a>虚拟机网络参数配置</h2><p>1.配置LinuxIP地址</p>
<pre><code>setup
#修改并配置IP地址
</code></pre><p>2.启动网卡</p>
<pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0
#把 ONBOOT = no改为 ONBOOT = yes
service network restart
#重启网络服务 
</code></pre><p>3.修改UUID(如果这是一台克隆/复制出来的机子则必须进行这个步骤，否则可以省去)</p>
<pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0
#删除MAC地址行
rm -rf /etc/udev/rules.d/70-persistent-net.rules
#删除网卡和MAC地址绑定文件
#重启动系统
</code></pre><p>4.设置虚拟机网络连接方式</p>
<ul>
<li><strong>桥接模式</strong>：通过物理机的真实网卡进行通信，若选此项，则虚拟机需要配置与物理机相同的网关，缺点是需要占用真实网段的一个IP地址。这种模式更适用于实验，因为这种模式不仅可以与你的物理机可以通信还可以与同一局域网的其他主机通信，还可以访问公网。</li>
<li><strong>NAT模式</strong>：在windows中（物理机中）是以VMware8虚拟网卡进行通信。这种模式只能与你自己的主机通信，不能与局域网的其他主机通信，但是可以通过物理的网卡访问公网。</li>
<li>仅主机模式：在windows中（物理机中）是以VMware1虚拟网卡进行通信。这种模式只能与你自己的主机通信，不能与局域网的其他主机通信，只能与自己的物理机通信，并且不能上公网。</li>
</ul>
<p>切记：在选择桥接模式之后，需要选择桥接的网卡（即需要确定虚拟机需要通过哪个真实网卡连接网络），一般的虚拟机都是自动桥接，但是这种方式真的跟不靠谱**，所以你需要自己选择，如果你是通过有线接入网络，则选择有线桥接，若是通过无线接入网络，则通过无线接入。</p>
<p>5.修改桥接网卡</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IP地址配置&quot;&gt;&lt;a href=&quot;#IP地址配置&quot; class=&quot;headerlink&quot; title=&quot;IP地址配置&quot;&gt;&lt;/a&gt;IP地址配置&lt;/h2&gt;&lt;p&gt;DHCP服务器可以自动分配IP&lt;/p&gt;
&lt;h4 id=&quot;ifconfig命令临时配置IP地址&quot;&gt;&lt;a hre
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装、卸载wine</title>
    <link href="http://yoursite.com/2018/05/01/Ubuntu-%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BDwine/"/>
    <id>http://yoursite.com/2018/05/01/Ubuntu-安装、卸载wine/</id>
    <published>2018-05-01T08:17:58.000Z</published>
    <updated>2018-05-01T08:39:07.491Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>sudo add-apt-repository ppa:wine/wine-builds
sudo apt-get update
sudo apt-get install --install-recommends wine-staging
sudo apt-get install winehq-staging
</code></pre><p><br></p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre><code>sudo apt purge wine
rm -r ~/.wine
sudo apt-get autoremove
#清理wine模拟运行的windows程序:
sudo rm -r /home/username/.local/share/applications
#清理残余的windows程序:
sudo rm -r /home/username/.config/menus/applications-merged/wine*
</code></pre><ul>
<li>apt-get remove 会删除软件包而保留软件的配置文件</li>
<li>apt-get purge 会同时清除软件包和软件的配置文件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:wine/wine-builds
sudo apt-get upda
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用配置目录</title>
    <link href="http://yoursite.com/2018/05/01/Linux-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2018/05/01/Linux-常用配置目录/</id>
    <published>2018-05-01T08:06:02.000Z</published>
    <updated>2018-05-01T08:13:19.114Z</updated>
    
    <content type="html"><![CDATA[<p>apt 源相关文件、目录</p>
<pre><code>/var/lib/apt/lists 
#ubuntu软件更新的源服务器的地址
/etc/apt/sources.list
#*.list文件在单独文件中写入源的地址，通常用来安装第三方的软件
/etc/apt/sources.list.d
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;apt 源相关文件、目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/var/lib/apt/lists 
#ubuntu软件更新的源服务器的地址
/etc/apt/sources.list
#*.list文件在单独文件中写入源的地址，通常用来安装第三方的软件
/etc/apt/sou
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下无法使用add-apt-repository命令</title>
    <link href="http://yoursite.com/2018/05/01/Linux%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8add-apt-repository%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/05/01/Linux下无法使用add-apt-repository命令/</id>
    <published>2018-05-01T07:59:11.000Z</published>
    <updated>2018-05-01T08:39:43.799Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下无法使用add-apt-repository命令报错：<br><code>add-apt-repository command not found</code></p>
<p>解决办法：</p>
<pre><code>sudo apt-get install python-software-properties
sudo apt-get update
sudo apt install software-properties-common 
sudo apt-get update
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux下无法使用add-apt-repository命令报错：&lt;br&gt;&lt;code&gt;add-apt-repository command not found&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install p
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装JDK的两种方式</title>
    <link href="http://yoursite.com/2018/05/01/Linux-%E5%AE%89%E8%A3%85JDK%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/05/01/Linux-安装JDK的两种方式/</id>
    <published>2018-05-01T07:13:07.000Z</published>
    <updated>2018-05-01T07:59:55.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用PPA源安装"><a href="#使用PPA源安装" class="headerlink" title="使用PPA源安装"></a>使用PPA源安装</h3><pre><code>sudo add-apt-repository ppa:webupd8team/java
sudo apt-get update
sudo apt-get install oracle-java8-installer
sudo apt-get install oracle-java8-set-default
</code></pre><p>oracle-java8-set-default：将jdk8设置为默认的Java运行版本</p>
<p>默认的安装路径是在<code>/usr/lib/jvm/java-8-oracle</code>中</p>
<pre><code>echo $JAVA_HOME
</code></pre><p><br></p>
<h3 id="使用源码包安装"><a href="#使用源码包安装" class="headerlink" title="使用源码包安装"></a>使用源码包安装</h3><p>在<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>找需要的包下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sudo tar zxvf ./jdk-8u171-linux-x64.tar.gz -C /usr/lib/jvm/jdk1.8.0_171</div><div class="line">sudo vim〜/ .bashrc</div><div class="line"></div><div class="line"><span class="meta">#</span>在文件的末尾追加下面行</div><div class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_171  </div><div class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</div><div class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</div><div class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</div><div class="line"></div><div class="line"><span class="meta">#</span>使环境变量马上生效</div><div class="line">source ~/.bashrc</div><div class="line"></div><div class="line"><span class="meta">#</span>设置系统默认jdk 版本</div><div class="line">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/ jdk1.8.0_144/bin/java 300</div><div class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/ jdk1.8.0_144/bin/javac 300</div><div class="line">sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/ jdk1.8.0_144/bin/jar 300</div><div class="line">sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/ jdk1.8.0_144/bin/javah 300</div><div class="line">sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/ jdk1.8.0_144/bin/javap 300</div><div class="line"></div><div class="line">sudo update-alternatives --config java</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用PPA源安装&quot;&gt;&lt;a href=&quot;#使用PPA源安装&quot; class=&quot;headerlink&quot; title=&quot;使用PPA源安装&quot;&gt;&lt;/a&gt;使用PPA源安装&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:webupd8tea
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/05/01/hello-world/"/>
    <id>http://yoursite.com/2018/05/01/hello-world/</id>
    <published>2018-05-01T06:30:57.929Z</published>
    <updated>2018-05-01T06:30:57.929Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux安装管理 脚本安装包</title>
    <link href="http://yoursite.com/2018/04/29/Linux%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86-%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85/"/>
    <id>http://yoursite.com/2018/04/29/Linux安装管理-脚本安装包/</id>
    <published>2018-04-29T10:40:21.000Z</published>
    <updated>2018-04-29T11:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="脚本安装包：准备工作"><a href="#脚本安装包：准备工作" class="headerlink" title="脚本安装包：准备工作"></a>脚本安装包：准备工作</h3><p>1、本节以安装LNMP（<a href="http://lnmp.org/download.html）为例，所以需要先停止之前安装的apache和mysql服务（最好也将源码包安装的apache" target="_blank" rel="external">http://lnmp.org/download.html）为例，所以需要先停止之前安装的apache和mysql服务（最好也将源码包安装的apache</a> <code>/usr/local/apache2</code>删除） </p>
<p>2、保证yum源正常使用：可以使用<code>yum list</code>命令测试。（若是光盘yum源，记得挂载光盘）</p>
<p>3、关闭SELinux和防火墙：</p>
<ul>
<li>永久关闭SELinux的方法：编辑文件<code>/etc/selinux/config</code>，将<code>SELINUX=enforcing</code>改为<code>SELINUX=disabled</code>，然后重启系统即可。</li>
<li>永久关闭防火墙的方法：<code>chkconfig iptables off</code>，开启为：<code>chkconfig iptables on</code>；临时关闭防火墙的方法：<code>service iptables stop</code>，开启为：<code>service iptables start</code>。</li>
</ul>
<p><br></p>
<h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><pre><code>wget -c http://soft.vpser.net/lnmp.lnmp1.0-full.tar.gz &amp;&amp; tar zxvf lnmp1.0-full.tar.gz &amp;&amp; cd lnmp1.0-full &amp;&amp; ./centos.sh
</code></pre><p>脚本安装过程中，会将系统中已有的apache、mysql、php等卸载掉。</p>
<p>虚拟机中安装lnmp常常会卡在 starting php-fpm,真实环境中很少出现。其实安装已经完成，只需要杀掉php-fpm进程，再重新启动这个进程就好了 pkill -9 php-fpm : -9是强制杀死的意思，然后重新启动该进程【/etc/rc.d/init.d/php-fpm start】即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;脚本安装包：准备工作&quot;&gt;&lt;a href=&quot;#脚本安装包：准备工作&quot; class=&quot;headerlink&quot; title=&quot;脚本安装包：准备工作&quot;&gt;&lt;/a&gt;脚本安装包：准备工作&lt;/h3&gt;&lt;p&gt;1、本节以安装LNMP（&lt;a href=&quot;http://lnmp.org/d
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装管理 源码包</title>
    <link href="http://yoursite.com/2018/04/29/Linux%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86-%E6%BA%90%E7%A0%81%E5%8C%85/"/>
    <id>http://yoursite.com/2018/04/29/Linux安装管理-源码包/</id>
    <published>2018-04-29T10:39:26.000Z</published>
    <updated>2018-04-29T13:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码包和RPM包安装位置的不同："><a href="#源码包和RPM包安装位置的不同：" class="headerlink" title="源码包和RPM包安装位置的不同："></a>源码包和RPM包安装位置的不同：</h3><h4 id="RPM包安装位置"><a href="#RPM包安装位置" class="headerlink" title="RPM包安装位置"></a>RPM包安装位置</h4><p>rpm包有安装的默认位置：</p>
<ul>
<li>/etc/ 配置文件安装目录 </li>
<li>/usr/bin/ 可执行的命令安装目录 </li>
<li>/usr/lib/ 程序所使用的函数库保存位置</li>
<li>/usr/share/doc/ 基本的软件使用手册保存位置 </li>
<li>/usr/share/man/ 帮助文件保存位置</li>
</ul>
<p>当然RPM包可以指定安装位置，但是建议不要指定安装位置，就让它安装到默认位置，这样系统可以找到它，利用service XXX start的方式启动它，而且rpm提供-e选项来自动卸载，摆明了就是推荐你让它默认安装</p>
<pre><code>rpm -ivh --profix=&lt;dir&gt;
</code></pre><h4 id="源码包安装位置"><a href="#源码包安装位置" class="headerlink" title="源码包安装位置"></a>源码包安装位置</h4><p>安装在指定位置当中，一般是<code>/usr/local/软件名</code>，源码包没有卸载命令</p>
<h4 id="安装位置不同带来的影响"><a href="#安装位置不同带来的影响" class="headerlink" title="安装位置不同带来的影响"></a>安装位置不同带来的影响</h4><p>rpm包安装的服务可以使用系统服务管理命令（service）来管理，例如： RPM包安装的apache的启动方法是：</p>
<pre><code>/etc/rc.d/init.d/httpd start 
service httpd start
</code></pre><p>源码包安装的服务不能被服务管理命令管理，因为没有安装到默认路径中，所以只能用绝对路径进行服务的管理，不同软件请参考INSTALL或README，如：</p>
<pre><code>/usr/local/apache2/bin/apachectl start
</code></pre><p>使用绝对路径启动程序的方法是通用的，通常软件包中会写上启动程序的方法的。</p>
<p>如果将源码包安装后的启动程序复制到<code>/etc/rc.d/init.d</code>目录中，则也是可以使用<code>service</code>命令执行的</p>
<p>源码包是不能使用<code>service</code>命令来启动服务，因为源码包的安装位置由用户指定，放在哪并不统一；rpm包安装后，通常都是放在<code>/etc/rc.d/init.d</code>目录中的，而<code>service</code>命令执行时，会自动搜索该目录，所以rpm包安装的服务可以使用<code>service</code>命令</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h4><ul>
<li>由于源码都是c语言写的，所以要先安装c语言编译器：gcc</li>
<li>从官方网站下载源码包，若是下载到了windows上面，可以使用ftp传到linux上</li>
</ul>
<p>注：若已安装了二进制包，则源码包也是可以继续安装的，因为两者安装目录不一样。但是，并不建议这样做，因为端口会冲突。</p>
<p>对于要求效率的软件，要安装源码包版本，因为是本机编译，更具有兼容性和效率，而rpm包是软件开发者提供的大众版本，可用于不注重效率的应用。</p>
<p><code>netstat -tlun</code>查找网络连接信息和系统开启的端口号<br>使用 -t 选项列出 TCP 协议的连接<br>使用 -l 选项列出正在监听的套接字<br>使用 -u 选项列出 UDP 协议的连接<br>使用 -n 选项禁用域名解析功能</p>
<h4 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h4><ol>
<li>源代码一般保存位置：<code>/usr/local/src</code></li>
<li>软件安装位置：``</li>
<li>如何确定安装过程报错<ul>
<li>安装过程停止</li>
<li>并出现error、warning、no的提示</li>
</ul>
</li>
</ol>
<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><pre><code>#下载源码包
wget http://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.33.tar.gz
#解压缩
tar -zxvf httpd-2.4.33.tar.gz
#进入解压缩目录
cd httpd-2.4.33
#软件配置与检查，指定安装位置
./configure --prefix=/usr/local/apache2
#编译，根据当前目录下的Makefile内部信息编译
make
#编译安装，根据当前目录下的Makefile内部信息安装
make install
</code></pre><p>./configure作用</p>
<ul>
<li>定义需要的功能选项； </li>
<li>检测系统环境是否符合安装要求 </li>
<li>把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。 </li>
<li>其中的<code>apache2</code>目录不需要提前创建，<code>make install</code>命令执行时会自动创建</li>
</ul>
<p><br></p>
<p>解压的文件夹中有一个INSTALL或README文件，vi打开之就可以看到详细的安装说明了。 </p>
<p>如果<code>make</code>环节出错，只需要<code>make clean</code>即可。如果<code>make install</code>安装环节出错，我们就得删除configure时制定的安装目录，因为其中生成的文件失效了。 </p>
<h3 id="源码包的卸载"><a href="#源码包的卸载" class="headerlink" title="源码包的卸载"></a>源码包的卸载</h3><p>只需要把安装目录删除即可。因为安装过程中生成的所有文件都是存放在安装目录中的，所以将安装目录删除就不会留下任何垃圾。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;源码包和RPM包安装位置的不同：&quot;&gt;&lt;a href=&quot;#源码包和RPM包安装位置的不同：&quot; class=&quot;headerlink&quot; title=&quot;源码包和RPM包安装位置的不同：&quot;&gt;&lt;/a&gt;源码包和RPM包安装位置的不同：&lt;/h3&gt;&lt;h4 id=&quot;RPM包安装位置&quot;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装管理 yum在线安装</title>
    <link href="http://yoursite.com/2018/04/29/Linux%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86-yum%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/04/29/Linux安装管理-yum在线安装/</id>
    <published>2018-04-29T08:36:58.000Z</published>
    <updated>2018-04-29T10:50:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="yum源文件"><a href="#yum源文件" class="headerlink" title="yum源文件"></a>yum源文件</h3><p>将所有软件包放到官方服务器上，当进行yum在线安装时，可以自动解决依赖性问题。（rpm缺点：安装过程中，rpm包依赖性太强）</p>
<p>RedHat的yum是收费服务，而CentOS的yum是免费服务。</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG007.png" alt=""></p>
<ul>
<li>在<code>/etc/yum.repos.d/</code>目录中，默认有4个yum源文件，其中<code>CentOS-Base.repo</code>是基本yum源文件，如果我们能上网，那它是默认生效的，而其他的都是默认不生效的。</li>
<li>mirrorlist和baseurl一个是主站点，一个是辅助站点，代表内容一样，只写一个就行，可以修改为国内的源</li>
<li>gpgcheck：一般都要开启，开启后安装时会验证rpm包是否是官方的，以保证系统安全。</li>
<li>gpgkey：默认系统安装后，在目录<code>/etc/pki/rpm-gpg</code>下都会存在数字证书。</li>
</ul>
<p>注：前面的<code>file://</code>表示文件协议，后面的<code>/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</code>是数字证书的位置。</p>
<pre><code>[root@CentOS6 ~]# cd /etc/pki/rpm-gpg
[root@CentOS6 rpm-gpg]# ll
总用量 16
-rw-r--r--. 1 root root 1706 11月 27 2013 RPM-GPG-KEY-CentOS-6
-rw-r--r--. 1 root root 1730 11月 27 2013 RPM-GPG-KEY-CentOS-Debug-6
-rw-r--r--. 1 root root 1730 11月 27 2013 RPM-GPG-KEY-CentOS-Security-6
-rw-r--r--. 1 root root 1734 11月 27 2013 RPM-GPG-KEY-CentOS-Testing-6
</code></pre><p><br></p>
<h3 id="光盘搭建yum源"><a href="#光盘搭建yum源" class="headerlink" title="光盘搭建yum源"></a>光盘搭建yum源</h3><p>如果没有网络，可以使用光盘</p>
<ol>
<li>挂载光盘 <ul>
<li><code>mkdir /media</code>或<code>mkdir mnt/cdrom</code>：建立挂载点</li>
<li><code>mount /dev/cdrom /media</code>或<code>mount mnt/cdrom</code>：挂载光盘； </li>
</ul>
</li>
<li>使网络yum源失效 <ul>
<li><code>cd/etc/yum.repos.d/</code>：进入yum源目录； </li>
<li><code>mv CentOS-Base.repo CentOS-Base.repo.bak</code>：修改Yum源文件后缀名，使其失效；（判断yum源是根据后缀名repo来实现的，修改后缀名则可以使该yum源失效）</li>
</ul>
</li>
<li>使光盘yum源生效<br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG008.png" alt=""></li>
</ol>
<p><br></p>
<h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>yum list
# 查询所有可用软件包列表
yum search 关键字
# 搜索服务器上所有和关键字相关的包
</code></pre><p><br></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>yum -y install 包名（只用包名即可）
# -y 自动回答yes
</code></pre><p><br></p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><pre><code>yum -y update 包名
# -y 自动回答yes
</code></pre><p><br></p>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><pre><code>yum -y remove 包名
# -y 自动回答yes
# 服务器使用最小化安装，用什么软件安装什么，尽量不卸载
</code></pre><p><br></p>
<h3 id="yum软件组管理命令"><a href="#yum软件组管理命令" class="headerlink" title="yum软件组管理命令"></a>yum软件组管理命令</h3><pre><code>yum grouplist 
#列出所有可用的软件组列表 

yum groupinstall 软件组名 
#安装指定软件组，组名可以由grouplist查询出来 

yum groupremove 软件组名 
#卸载指定软件组 

软件组名必须是英文
LANG=en_US 临时更改语系为英文 
LANG=zh_CN.utf8 临时生效 
/etc/sysconfig/i18n中 修改配置文件永久生效
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;yum源文件&quot;&gt;&lt;a href=&quot;#yum源文件&quot; class=&quot;headerlink&quot; title=&quot;yum源文件&quot;&gt;&lt;/a&gt;yum源文件&lt;/h3&gt;&lt;p&gt;将所有软件包放到官方服务器上，当进行yum在线安装时，可以自动解决依赖性问题。（rpm缺点：安装过程中，rp
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装管理 RPM包管理</title>
    <link href="http://yoursite.com/2018/04/29/Linux%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86-RPM%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/29/Linux安装管理-RPM包管理/</id>
    <published>2018-04-29T07:54:32.000Z</published>
    <updated>2018-04-29T10:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RPM包的来源"><a href="#RPM包的来源" class="headerlink" title="RPM包的来源"></a>RPM包的来源</h3><p>所有RPM包都来自安装系统光盘的Packages目录中</p>
<p><br></p>
<h3 id="RPM包命名规则"><a href="#RPM包命名规则" class="headerlink" title="RPM包命名规则"></a>RPM包命名规则</h3><p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG004.png" alt="img"></p>
<ul>
<li>包全名：操作的包是没有安装的软件包时，使用包全名，而且要注意路径</li>
<li>包名：操作已安装的软件包时，使用包名，是搜索<code>/var/lib/rpm/</code>中的数据库</li>
</ul>
<p><br></p>
<h3 id="RPM包依赖性"><a href="#RPM包依赖性" class="headerlink" title="RPM包依赖性"></a>RPM包依赖性</h3><ol>
<li>树形依赖：a-&gt;b-&gt;c 解决方法：从后往前安装</li>
<li>环形依赖：a-&gt;b-&gt;c-&gt;a 解决方法：放在一条命令中安装即可</li>
<li>模块依赖：库文件依赖，库也叫模块，就是linux当中的函数，它有一个典型的特征，就是以<code>.so.数字</code>结尾，它依赖的其实是一个文件，而不是软件包。该文件藏身在某一个软件包当中。我们只要将该文件所在的软件包安装上，该文件也就安装了。解决方法：登录www.rpmfind.net 网站，输入库文件名称查询到对应的rpm包，然后安装即可。</li>
</ol>
<p><br></p>
<h3 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h3><pre><code>rpm -ivh 包全名
# -i （install）安装
# -v（verbose）显示详细信息
# -h（hash）显示进度
# --nodeps不检测依赖性（一般不用）
</code></pre><p><br></p>
<h3 id="RPM-升级"><a href="#RPM-升级" class="headerlink" title="RPM 升级"></a>RPM 升级</h3><pre><code>rpm -Uvh 包全名
# -U（update）升级
</code></pre><ul>
<li>需要包全名，而不是包名。可以如此理解：升级时的新包对于系统是新的，因此要包全名</li>
<li>如果这个包从来没有安装过，那么效果等同于rpm -ivh 包全名</li>
</ul>
<p><br></p>
<h3 id="RPM卸载"><a href="#RPM卸载" class="headerlink" title="RPM卸载"></a>RPM卸载</h3><pre><code>rpm -e 包名
# -e（erase）卸载
#  --nodeps 不检查依赖性
</code></pre><ul>
<li>rpm准备了这个卸载命令的原因是，我们安装时根本不知道这个包装了在哪里（要知道linux下的安装的软件的文件散布多个地方的，很难一一找），而rpm知道，所以干脆就为我们准备了这条便利的命令。</li>
<li>window下卸载软件，往往容易留很多垃圾数据难以除完，例如注册表等等。而linux中不会出现这个问题，只要把软件的安装目录所有都删除掉，就不会有残留。</li>
</ul>
<p><br></p>
<h3 id="RPM包查询"><a href="#RPM包查询" class="headerlink" title="RPM包查询"></a>RPM包查询</h3><pre><code>rpm -q 包名
# 查询包是否安装
# -q 查询（query）

rpm -qa 包名
# 查询所有已经安装的RPM包
# -a 所有（all）
# rpm -qa | grep httpd

rpm -qi 包名
# 查询软件包详细信息
# -i (infomation) : 查询软件信息

rpm -qip 包全名
# -p (package) : 查询未安装报信息
# 有时遇到问题, 可根据未安装包信息中所提供的网站进行查询资料

rpm -ql 包名
# 查询包中文件安装位置
# -l (list) : 列表
# -p (package) : 查询未安装包信息
# 可查看包作者欲将包安装的位置

rpm -qf 系统文件名
# -f (file) : 查询系统文件属于哪个软件包
# 查询系统文件属于哪个 RPM 包
# 该文件必须是通过 RPM 包安装的

rpm -qR 包名
# 查询软件包的依赖性
# -R (requires) : 查询软件包的依赖性 
# -p (package) : 查询未安装包的信息
</code></pre><p>RPM包默认安装位置<br><img src="http://ow3dy62zt.bkt.clouddn.com/IMG005.png" alt=""></p>
<p><br></p>
<h3 id="RPM包校验"><a href="#RPM包校验" class="headerlink" title="RPM包校验"></a>RPM包校验</h3><pre><code>rpm -V 已安装的包名
# -V (verify) : 校验指定RPM包中的文件
# 执行后, 无任何提示, 代表该文件没有被做任何修改
# 判断本地的安装包与官方给出的是否一致, 从而判断是否被人修改
</code></pre><h4 id="验证内容中的8个信息"><a href="#验证内容中的8个信息" class="headerlink" title="验证内容中的8个信息"></a>验证内容中的8个信息</h4><ul>
<li>S : 文件大小是否改变</li>
<li>M : 文件的类型或文件的权限( rwx )是否被改变</li>
<li>5 : 文件MD5 校验和是否改变( 可以看成文件内容是否改变 )</li>
<li>D : 设备的主从代码是否改变</li>
<li>L : 文件路径是否改变</li>
<li>U : 文件的属主( 所有者 ) 是否改变</li>
<li>G : 文件的属组是否改变</li>
<li>T : 文件的修改时间是否改变</li>
</ul>
<h4 id="验证内容中的文件类型"><a href="#验证内容中的文件类型" class="headerlink" title="验证内容中的文件类型"></a>验证内容中的文件类型</h4><ul>
<li>c (config file) : 配置文件</li>
<li>d (documentation) : 普通文档</li>
<li>g (ghost file) : “鬼”文件, 很少见, 就是该文件不应该被这个RPM包包含</li>
<li>L (license file) : 授权文件</li>
<li>r (read me) : 描述文件</li>
</ul>
<h4 id="MD5校验"><a href="#MD5校验" class="headerlink" title="MD5校验"></a>MD5校验</h4><p>用来校验文件的完整性(文件内容是否被改变)</p>
<p>例如, 在官网下载的游戏, 官方会给出MD5校验码, 将下载的游戏通过专用的MD5校验工具校验后生成一份MD5校验码, 对比两份校验码是否一致, 不一致则说明，下载的文件可能丢包, 可能文件损坏, 可能被其他人动过手脚一直木马等</p>
<p><br></p>
<h3 id="RPM包中的文件提取"><a href="#RPM包中的文件提取" class="headerlink" title="RPM包中的文件提取"></a>RPM包中的文件提取</h3><pre><code>rpm2cpio 包全名 | cpio -idv .文件绝对路径 
</code></pre><ul>
<li>前面的<code>.</code>代表当前路径，不能省略。</li>
<li><code>文件绝对路径</code>和包里文件的绝对路径对应，也就是告诉了cpio要去包里提取哪个文件。</li>
<li>cpio只知道提取文件，并不知道要从什么地方提取文件，因此我们通常要使用<code>|</code>管道符或<code>&lt;</code>输入重定向告诉cpio我们应该从什么设备去取出文件。</li>
</ul>
<pre><code>cpio 选项 &lt; [文件|设备]
# 使用输入重定向的cpio
# -i：copy-in模式，还原
# -d：还原时自动新建目录
# -v：显示还原过程
</code></pre><p><img src="http://ow3dy62zt.bkt.clouddn.com/IMG006.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RPM包的来源&quot;&gt;&lt;a href=&quot;#RPM包的来源&quot; class=&quot;headerlink&quot; title=&quot;RPM包的来源&quot;&gt;&lt;/a&gt;RPM包的来源&lt;/h3&gt;&lt;p&gt;所有RPM包都来自安装系统光盘的Packages目录中&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装管理 软件包分类</title>
    <link href="http://yoursite.com/2018/04/29/Linux%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86-%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/04/29/Linux安装管理-软件包分类/</id>
    <published>2018-04-29T07:42:28.000Z</published>
    <updated>2018-04-29T11:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>二进制包是经过源码包编译过的安装包，编译就是将源码解释为机器可以认识的二进制语言的过程，安装源码包比二进制包复杂，因为要经过一个编译的过程，这个过程容易出错，一旦出错，就要对源码进行修改。</p>
<p>在redhat中二进制包后缀是rpm，在debian系列里如ubuntu二进制包的后缀是deb，但是它们都是二进制包。Linux下安装软件只有俩种格式：二进制包和源代码包</p>
<h3 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>开源，如果有足够的能力，可以修改源代码</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装，所以更加适合自己的系统，更加稳定、效率更高</li>
<li>卸载方便（直接删除）</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误</li>
<li>编译过程时间较长，安装比二进制安装时间长</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决</li>
</ul>
<p><br></p>
<h3 id="二进制包（RPM包、Deb包）"><a href="#二进制包（RPM包、Deb包）" class="headerlink" title="二进制包（RPM包、Deb包）"></a>二进制包（RPM包、Deb包）</h3><p>二进制包安装速度快是它的优点，但是二进制包不是系统自己编译的，效率不如源码包。如果是生产环境，就要源码包安装，因为效率高。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>经过编译，不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性</li>
</ul>
<p><br></p>
<h3 id="脚本安装包"><a href="#脚本安装包" class="headerlink" title="脚本安装包"></a>脚本安装包</h3><p>把复杂的软件包安装过程写成了程序脚本，初学者可以执行脚本实现一键安装。但实际安装的还是源码包和二进制包,例如LAMP一键安装包</p>
<ul>
<li>优点：安装简单、快捷</li>
<li>缺点：完全丧失了自定义性，不能定义安装软件的版本，不能定义所需要的软件功能，源码包的优势几乎完全丧失</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制包是经过源码包编译过的安装包，编译就是将源码解释为机器可以认识的二进制语言的过程，安装源码包比二进制包复杂，因为要经过一个编译的过程，这个过程容易出错，一旦出错，就要对源码进行修改。&lt;/p&gt;
&lt;p&gt;在redhat中二进制包后缀是rpm，在debian系列里如ubunt
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux权限 chattr、lsattr</title>
    <link href="http://yoursite.com/2018/04/27/Linux%E6%9D%83%E9%99%90-chattr%E3%80%81lsattr/"/>
    <id>http://yoursite.com/2018/04/27/Linux权限-chattr、lsattr/</id>
    <published>2018-04-27T07:54:28.000Z</published>
    <updated>2018-04-27T08:59:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在Linux中，有一些系统文件，对系统的运行有着至关重要的作用，如/etc/fstab等，一般不允许修改，这个时候，我们可以赋予文件/目录<code>r--------</code>的权限；然而，还有一个更为简单有效的命令<code>chattr</code>可以实现该功能！</p>
<p><br>  </p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul>
<li>所支持的文件系统包括：ext2、ext3、ext4和xfs</li>
<li>一般要求内核版本不低于2.2(查看版本的命令如下：<code>uname -a</code>、<code>lsb_release -a</code></li>
<li>不能保护 <code>/</code>、<code>/tmp</code> 、<code>/dev</code>、<code>/var</code>目录</li>
<li><code>chattr</code>只能由root用户使用</li>
</ul>
<p><br></p>
<h3 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h3><p>类似于<code>chmod</code>, <code>chmod</code>只是改变文件的读写、执行权限，更底层的属性控制是由<code>chattr</code>来改变的.</p>
<pre><code>chattr [+-=] [选项] 文件或目录名
</code></pre><ul>
<li>+：增加权限</li>
<li>-：减少权限 </li>
<li>=：等于某权限</li>
<li>a：即append<ul>
<li>如果对文件设置a属性，那么只能在文件中增加数据，不能删除也不能修改数据（不能使用vi，因为不能判断是增加还是修改，可以使用echo）</li>
<li>如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除</li>
</ul>
</li>
<li>i：即insert<ul>
<li>如果对文件设置i属性，那么不允许对文件进行删除、改名、设定链接关系，同时不能写入或新增内容</li>
<li>如果对目录设置i属性，那么只能修改目录下文件的数据，不允许建立和删除文件</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h3><p>查看文件系统属性</p>
<pre><code>lsattr [选项] [文件名]
</code></pre><ul>
<li>-a：列出目录下的所有文件，包括隐藏文件</li>
<li>-d：查看本目录自身的权限</li>
</ul>
<p><br></p>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>首先，我使用root身份新建一个文件：</p>
<pre><code>[root@niesh test]# ll
总用量 0
-rw-rw-r--. 1 root niesh 0 7月  31 20:27 abc
</code></pre><p>然后，我给该文件增加 i 权限：</p>
<pre><code>[root@niesh test]# chattr +i abc
[root@niesh test]# lsattr abc
----i----------- abc
</code></pre><p>然后，我尝试增加内容、删除文件和修改文件名：</p>
<pre><code>[root@niesh test]# echo 1234 &gt;&gt; abc
bash: abc: 权限不够
[root@niesh test]# rm -f abc
rm: 无法删除&quot;abc&quot;: 不允许的操作
[root@niesh test]# mv abc bcd
mv: 无法将&quot;abc&quot; 移动至&quot;bcd&quot;: 不允许的操作
</code></pre><p>以上均失败，由此验证！</p>
<p>修改以上文件的权限为 a :</p>
<pre><code>[root@niesh test]# chattr +a abc
[root@niesh test]# lsattr abc
-----a---------- abc
</code></pre><p>对 abc文件进行操作：</p>
<pre><code>[root@niesh test]# echo 1111 &gt;&gt; abc
[root@niesh test]# cat abc
1111
[root@niesh test]# rm -f abc
rm: 无法删除&quot;abc&quot;: 不允许的操作
[root@niesh test]# mv abc bcd
mv: 无法将&quot;abc&quot; 移动至&quot;bcd&quot;: 不允许的操作
</code></pre><p>由以上可以看出，只能增加文件内容，不能进行其他的操作！</p>
<p><br></p>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/Jimmy1988/p/7265816.html" target="_blank" rel="external">http://www.cnblogs.com/Jimmy1988/p/7265816.html</a></li>
<li><a href="https://www.imooc.com/video/9667" target="_blank" rel="external">https://www.imooc.com/video/9667</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;p&gt;在Linux中，有一些系统文件，对系统的运行有着至关重要的作用，如/etc/fstab等，一般不允许修改，这个时候，我们可以赋予文件/目录&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux权限 SUID、SGID、SBIT</title>
    <link href="http://yoursite.com/2018/04/27/Linux%E6%9D%83%E9%99%90-SUID%E3%80%81SGID%E3%80%81SBIT/"/>
    <id>http://yoursite.com/2018/04/27/Linux权限-SUID、SGID、SBIT/</id>
    <published>2018-04-27T07:54:05.000Z</published>
    <updated>2018-04-27T11:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SUID-SetUID"><a href="#SUID-SetUID" class="headerlink" title="SUID(SetUID)"></a>SUID(SetUID)</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>使用户临时具有程序所有者（比如root）的权限来执行该程序</p>
<p>试想一个场景：</p>
<p>Linux普通用户可以修改自己的密码，这个是一个合情合理的设置；修改密码其实修改的是 /etc/shadow 这个文件；然而不知道你有没看过这个文件的属性：</p>
<pre><code>[niesh@niesh ~]$ ll /etc/shadow
----------. 1 root root 1476 7月  30 16:15 /etc/shadow
</code></pre><p>我去，bug啊？很明显普通用户对 /etc/shadow 文件没有任何权限啊，那怎么可能修改该文件呢？</p>
<p>一方面我们需要修改自己的密码（就是修改/etc/shadow)，另一方面这个文件对普通用户没任何权限，自相矛盾啊？这么办呢？<br>其实，这里就牵扯到了 SetUID 权限：修改密码的流程其实就是通过 <code>/usr/bin/passwd</code> 命令对 <code>/etc/passwd</code>进行修改，那么先让我们看一下这个可执行文件的属性：</p>
<pre><code>[niesh@niesh ~]$ ll /usr/bin/passwd
-rwsr-xr-x. 1 root root 27832 6月  10 2014 /usr/bin/passwd
</code></pre><p>发现/usr/bin/passwd的权限为：-rwsr-xr-x. 在此“文件所有者”的第三位是s权限，也就是咱们即将要详细讲解的的setUID权限，也就是它在作怪了！<br>不相信，那行，我现在验证一下（和cat命令对比）：</p>
<pre><code>[niesh@niesh ~]$ passwd
更改用户 niesh 的密码 。
为 niesh 更改 STRESS 密码。
（当前）UNIX 密码：
新的 密码：

[niesh@niesh ~]$ ll /usr/bin/cat
-rwxr-xr-x. 1 root root 54048 11月 20 2015 /usr/bin/cat

[niesh@niesh ~]$ cat /etc/shadow
cat: /etc/shadow: 权限不够
</code></pre><p>SetUID(或者 s 权限）：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然 “灵魂附体” 了，实际在以passwd命令所有者root的身份在执行，root当然可以将密码写入/etc/shadow文件（root是一个bug的存在，在Linux中就没有它不能干的事），命令执行完成后该身份也随之消失。<br>当然用户的passwd命令不能修改其他用户的密码，只能输入<code>passwd</code>来修改自己的密码</p>
<h4 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h4><ul>
<li>只有可执行的二进制程序才可以设置SetUID</li>
<li>命令执行者必须对欲设置SetUID的文件具备可执行(x) 权限，没有x的文件会成为S，S不能正确使用，只有s可以正确使用</li>
<li>命令执行过程中，其它用户获取所有者的身份（灵魂附体）</li>
<li>SetUID具有时间限制，即完成该程序执行后就消失</li>
<li>不能对目录使用</li>
</ul>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>4代表SUID，s出现在文件所有者的x权限上<br>设置SetUID</p>
<pre><code>chmod 4755 文件名
chmod u+s 文件名（推荐，不影响其他权限）
</code></pre><p>取消SetUID</p>
<pre><code>chmod 0755 文件名
chmod u-s 文件名（推荐，不影响其他权限）
</code></pre><h4 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h4><p>首先，查看一下touch命令的属性：</p>
<pre><code>[niesh@niesh tmp]$ ll /usr/bin/touch
-rwxr-xr-x. 1 root root 62432 11月 20 2015 /usr/bin/touch
</code></pre><p>然后，用普通用户创建一个文件：</p>
<pre><code>[niesh@niesh tmp]$ touch test1
[niesh@niesh tmp]$ ll test1
-rw-rw-r--. 1 niesh niesh 0 7月  30 17:40 test1
</code></pre><p>接着，更改touch的属性，增加SetUID属性：</p>
<pre><code>[niesh@niesh tmp]$ sudo chmod u+s /usr/bin/touch
[sudo] password for niesh:
[niesh@niesh tmp]$ ll /usr/bin/touch
-rwsr-xr-x. 1 root root 62432 11月 20 2015 /usr/bin/touch
</code></pre><p>而后，用普通用户再新建一个文件：</p>
<pre><code>[niesh@niesh tmp]$ touch test2
</code></pre><p>最后，查看两个新建文件的属性：</p>
<pre><code>[niesh@niesh tmp]$ ll test1 test2
-rw-rw-r--. 1 niesh niesh 0 7月  30 17:40 test1
-rw-rw-r--. 1 root  niesh 0 7月  30 17:42 test2
[niesh@niesh tmp]$
</code></pre><p>可以看到，在设置了SetUID之后，新建文件的所有者为root了，说明在执行touch的时候，用户自动升级为了所有者，灵魂附体了！</p>
<h4 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h4><p>设置SetUID是具备很大危险性的，例如赋予 vim 这个权限：</p>
<p>首先，查找vim在哪里<br>    [root@niesh ~]# whereis vim<br>    vim: /usr/bin/vim /usr/bin/vim.tiny /usr/local/bin/vim /usr/local/vim /usr/share/vim</p>
<p>然后，查看vim的属性<br>    [root@niesh ~]# ll /usr/bin/vim<br>    lrwxrwxrwx. 1 root root 18 5月   1 21:02 /usr/bin/vim -&gt; /usr/local/bin/vim</p>
<p>再次，给vim增加SetUID权限<br>    [root@niesh ~]# chmod u+s /usr/bin/vim<br>    [root@niesh ~]# ll /usr/bin/vim<br>    lrwxrwxrwx. 1 root root 18 5月   1 21:02 /usr/bin/vim -&gt; /usr/local/bin/vim</p>
<p>最后，使用vim编辑/etc/shadow<br>    [niesh@niesh ~]# vim /etc/shadow</p>
<p>明显，我可以打开并进行编辑了，那万一，一个不懂的人或者而已破坏的人将自己的权限提升到了root或者干脆删除这里的内容，那后果将是灾难性的！<br>所以，我们需要定时查看系统中有哪些设置了SetUID权限</p>
<ul>
<li>关键目录应严格控制写权限。比如 <code>/</code>、<code>/usr</code></li>
<li>用户的密码设置要严格遵循密码三原则(#复杂性，易记忆性，时效性）</li>
<li>对系统中默认应该具有SetUID权限的文件做一个列表，然后定期检查有没有这之外的执行程序的命令文件被设置了SetUID</li>
</ul>
<p>使用shell定期检查SetUID</p>
<pre><code>#!/bin/bash

find / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.check
for i in $(cat /tmp/setuid.check)

do   
        grep $i /root/suid.log &gt; /dev/null
              if [ &quot;S?&quot; !=&quot;0&quot;]
              then
                  echo &quot;$i isn&apos;t in listfile!&quot; &gt;&gt; /root/suid_log_$(date+%F)
              fi
done
rm -rf /tmp/setuid.check
</code></pre><p><br></p>
<h3 id="SGID-SetGID"><a href="#SGID-SetGID" class="headerlink" title="SGID(SetGID)"></a>SGID(SetGID)</h3><p>SetGID基本与SetUID相同，SetUID是设置所有者的权限，GID为设置所属组的权限<br>区别点在于：SetGID也可以设置目录的相关SetGID权限！</p>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>将用户所在组临时升级为某一个组，以执行只有该组才有相应权限进行的操作</p>
<h4 id="使用要求-1"><a href="#使用要求-1" class="headerlink" title="使用要求"></a>使用要求</h4><ul>
<li>针对文件：<ul>
<li>可执行的二进制文件</li>
<li>命令执行者（即所属组）对该文件具备 x 权限</li>
<li>命令执行者在执行程序的时候，组身份升级为该程序文件的属组</li>
<li>权限只在执行过程中有效</li>
</ul>
</li>
<li>针对目录：<ul>
<li>普通用户对目录具备r和x权限，才可以进入到该目录</li>
<li>普通用户在此目录中的有效组会变成此目录的所属组</li>
<li>如普通用户对该目录具备w权限，新建文件的所属组为该目录的所属组</li>
</ul>
</li>
</ul>
<h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p>2代表SGID，s出现在文件所属群组的x权限上<br>设置SetGID</p>
<pre><code>chmod 2xxx &lt;file/dir-name&gt;
chmod g+s &lt;file/dir-name&gt; （推荐）
</code></pre><p>取消SetGID</p>
<pre><code>chmod xxx &lt;file/dir-name&gt;
chmod g-s &lt;file/dir-name&gt;
</code></pre><h4 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h4><p>我们此处以locate命令进行讨论：<br>locate查询命令，比find要快很多，为什么？因为其实搜索的数据库而非整个硬盘：</p>
<pre><code>[root@niesh ~]# ll /usr/bin/locate
-rwx--s--x. 1 root slocate 40496 6月  10 2014 /usr/bin/locate

[root@niesh ~]# ll /var/lib/mlocate/mlocate.db
-rw-r-----. 1 root slocate 6306909 7月  30 19:15 /var/lib/mlocate/mlocate.db
</code></pre><p>我用普通用户进行locate查看：</p>
<pre><code>[niesh@niesh root]$ locate mlocate.db
/usr/share/man/man5/mlocate.db.5.gz
</code></pre><p>去掉locate的s权限：<br>    [root@niesh ~]# chmod g-s /usr/bin/locate<br>    [root@niesh ~]# ll /usr/bin/locate<br>    -rwx–x–x. 1 root slocate 40496 6月 10 2014 /usr/bin/locate</p>
<pre><code>[niesh@niesh root]$ locate mlocate.db
locate: 无法执行 stat () `/var/lib/mlocate/mlocate.db&apos;: 权限不够
</code></pre><p>也就是：当执行locate命令时，普通用户niesh自动升级为slocate的组成员。</p>
<ul>
<li>/usr/bin/locate是可执行二进制程序，可以赋予SGID</li>
<li>执行用户niesh对/usr/bin/locate命令拥有执行权限</li>
<li>执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate命令查询mlocate.db数据库</li>
<li>命令结束，niesh用户的组身份返回为niesh组</li>
</ul>
<p><br></p>
<h3 id="SBIT-Sticky-BIT"><a href="#SBIT-Sticky-BIT" class="headerlink" title="SBIT(Sticky BIT)"></a>SBIT(Sticky BIT)</h3><p>粘滞位</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>防止其他用户删除自己的文件，使用者在该目录下，仅自己与root才有权力删除新建的目录或文件</p>
<h4 id="使用要求-2"><a href="#使用要求-2" class="headerlink" title="使用要求"></a>使用要求</h4><p>只对目录有效<br>普通用户对该目录有w和x权限<br>若没有粘滞位，则普通用户可以对目录下的文件/子目录进行删除操作（因为普通用户对目录具有w权限），包括其它用户建立的目录/文件；但若赋了SBIT,则普通用户只能删除自己创建的文件/目录，而不能删除不属于自己的文件/目录！</p>
<h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p>1代表SBIT，t出现在文件其他用户的x权限上<br>设置SBIT</p>
<pre><code>chmod 1xxx &lt; dir-name &gt;
chmod o+t &lt; dir-name &gt;
</code></pre><p>取消SBIT</p>
<pre><code>chmod xxx &lt; dir-name &gt;
chmod o-t &lt; dir-name &gt;
</code></pre><h4 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h4><p>以/tmp为例：<br>查看/tmp的权限：<br>    [niesh@niesh tmp]$ ll -d /tmp/<br>    drwxrwxrwt. 8 root root 4096 7月 30 19:40 /tmp/<br>会看到，/tmp目录的权限other部分为rwt,这个t就是我们设置的粘滞位<br>接下来，我们用其它用户创建两个文件：</p>
<pre><code>[Jimmy@niesh tmp]$ touch test-file
[Jimmy@niesh tmp]$ mkdir test-dir
[Jimmy@niesh tmp]$ ll
总用量 0
drwxrwxr-x. 2 Jimmy Jimmy 6 7月  30 19:44 test-dir
-rw-rw-r--. 1 root  Jimmy 0 7月  30 19:44 test-file
</code></pre><p>切换到另外一个用户niesh:</p>
<pre><code>[niesh@niesh tmp]$ ll
总用量 0
drwxrwxr-x. 2 Jimmy Jimmy 6 7月  30 19:44 test-dir
-rw-rw-r--. 1 root  Jimmy 0 7月  30 19:44 test-file
在 niesh用户下，删除/tmp目录下的文件：

[niesh@niesh tmp]$ rm -rf test-dir/ test-file
rm: 无法删除&quot;test-dir/&quot;: 不允许的操作  
无法删除！
</code></pre><p>然后，我们切换到root，去掉/tmp的粘滞位：</p>
<pre><code>[niesh@niesh tmp]$ su -
密码：
上一次登录：日 7月 30 19:43:21 CST 2017pts/0 上
[root@niesh ~]# chmod o-t /tmp/
[root@niesh ~]# ll -d /tmp/
drwxrwxrwx. 9 root root 4096 7月  30 19:48 /tmp/
</code></pre><p>最后，切换到普通用户niesh，再次删除/tmp下的文件：</p>
<pre><code>[niesh@niesh root]$ rm -rf /tmp/test-dir/ /tmp/test-file
[niesh@niesh root]$ ll /tmp/
总用量 0
</code></pre><p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/Jimmy1988/p/7260215.html" target="_blank" rel="external">http://www.cnblogs.com/Jimmy1988/p/7260215.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SUID-SetUID&quot;&gt;&lt;a href=&quot;#SUID-SetUID&quot; class=&quot;headerlink&quot; title=&quot;SUID(SetUID)&quot;&gt;&lt;/a&gt;SUID(SetUID)&lt;/h3&gt;&lt;h4 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>清华同方x46h开启Intel VT</title>
    <link href="http://yoursite.com/2017/09/11/%E6%B8%85%E5%8D%8E%E5%90%8C%E6%96%B9x46h%E5%BC%80%E5%90%AFIntel-VT/"/>
    <id>http://yoursite.com/2017/09/11/清华同方x46h开启Intel-VT/</id>
    <published>2017-09-11T00:37:46.000Z</published>
    <updated>2017-09-11T01:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>清华同方x46h是我在12年买的，在网上搜索的资料是说原本Intel VT技术是开启的，但是如果多次重装系统就会把它关闭，而且官方的BIOS是没有开启选项的，官方也没有提供BIOS更新，所以需要自己刷，结果我刷的代价就是主板被刷坏，花了350把主板修了，总之刷BIOS还是<strong>有风险</strong>的，这里只是提供具体方法</p>
<h2 id="1、查看是否支持Intel-VT技术以及是否开启"><a href="#1、查看是否支持Intel-VT技术以及是否开启" class="headerlink" title="1、查看是否支持Intel VT技术以及是否开启"></a>1、查看是否支持Intel VT技术以及是否开启</h2><p>下载leomoon-cpu-v（<a href="https://leomoon.com/downloads/desktop-apps/leomoon-cpu-v/），并安装" target="_blank" rel="external">https://leomoon.com/downloads/desktop-apps/leomoon-cpu-v/），并安装</a></p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/2017-09-11_084754.png" alt="leomoon-cpv"></p>
<p>左边的对勾表示主板支持Intel VT<br>右边的对勾表示主板已经开启Intel VT<br>这张图片是已经开启的状态<br>清华同方x46h的实际状态应该是左边对勾，右边叉</p>
<h2 id="2、制作纯DOS启动U盘"><a href="#2、制作纯DOS启动U盘" class="headerlink" title="2、制作纯DOS启动U盘"></a>2、制作纯DOS启动U盘</h2><ul>
<li><p>下载MSDOS7.1<br><a href="http://www.cn-dos.net/newdos/dosart32.htm" target="_blank" rel="external">http://www.cn-dos.net/newdos/dosart32.htm</a><br>解压</p>
</li>
<li><p>格式化U盘为FAT32分区格式</p>
</li>
<li><p>使用UltraIOS制作U盘启动盘<br>和制作win7的启动U盘一样<br>插入不用的U盘（因为需要格式化）<br>在UltraIOS中文件》打开，选择解压后的MSDOS文件夹中的IOS镜像文件；<br>点击启动》写入硬盘映像<br>选择U盘，写入方式为USB-HDD+，点击写入</p>
</li>
</ul>
<p>可以参考<a href="http://blog.sina.com.cn/s/blog_4ad042e50102eclt.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4ad042e50102eclt.html</a></p>
<h2 id="3、下载需要刷的BIOS"><a href="#3、下载需要刷的BIOS" class="headerlink" title="3、下载需要刷的BIOS"></a>3、下载需要刷的BIOS</h2><ul>
<li>在步骤2中制作好的U盘启动盘里新建文件夹，文件夹名叫12</li>
<li>下载<a href="https://getpocket.com/a/read/1885690768中的X46H_BIOS" target="_blank" rel="external">https://getpocket.com/a/read/1885690768中的X46H_BIOS</a> ，解压，将文件夹中的四个文件复制到12文件夹中</li>
</ul>
<h2 id="4、刷BIOS"><a href="#4、刷BIOS" class="headerlink" title="4、刷BIOS"></a>4、刷BIOS</h2><ul>
<li>重启电脑，按F2打开BIOS</li>
<li>将U盘设为电脑开启的第一启动项，保存，退出</li>
<li>插入U盘，重启电脑</li>
<li>会进入MSDOS界面，会先让你设置MSDOS，选择cancel取消设置</li>
<li><p>接下来输入以下命令</p>
<p>命令1： “C:” 回车       —将当前盘符切换到C:<br>命令2： “CD 12” 回车    —将当前操作文件夹切换到C:\12下<br>命令3： “fpt -bios -f GT_122.h09” 回车    —执行刷新命令 图4</p>
</li>
</ul>
<p>刷新成功后<br><img src="http://ow3dy62zt.bkt.clouddn.com/2017-09-11_091756.jpg" alt=""></p>
<ul>
<li>按开关机键 关机 ，将电池拔掉 ，电源线 移除 ，1分钟后安装好。</li>
</ul>
<h2 id="5、开启Intel-VT"><a href="#5、开启Intel-VT" class="headerlink" title="5、开启Intel VT"></a>5、开启Intel VT</h2><p>开机，按F2进 BIOS  选择高级 Advanced  选项  会出现 虚拟化选项。打开后按F10保存并退出即可。</p>
<p><img src="http://ow3dy62zt.bkt.clouddn.com/2017-09-11_091956.jpg" alt=""></p>
<p>运行leomoon-cpu-v工具可以看到看到Intel VT已经开启</p>
<p>参考：<a href="http://benyouhui.it168.com/thread-1896445-1-1.html" target="_blank" rel="external">http://benyouhui.it168.com/thread-1896445-1-1.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;清华同方x46h是我在12年买的，在网上搜索的资料是说原本Intel VT技术是开启的，但是如果多次重装系统就会把它关闭，而且官方的BIOS是没有开启选项的，官方也没有提供BIOS更新，所以需要自己刷，结果我刷的代价就是主板被刷坏，花了350把主板修了，总之刷BIOS还是&lt;
    
    </summary>
    
    
  </entry>
  
</feed>
